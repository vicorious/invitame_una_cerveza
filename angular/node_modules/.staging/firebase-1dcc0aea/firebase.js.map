{"version":3,"file":"firebase.js","sources":["../../node_modules/whatwg-fetch/fetch.js","../../node_modules/core-js/internals/global.js","../../node_modules/core-js/internals/fails.js","../../node_modules/core-js/internals/is-object.js","../../node_modules/core-js/internals/document-create-element.js","../../node_modules/core-js/internals/an-object.js","../../node_modules/core-js/internals/to-primitive.js","../../node_modules/core-js/internals/create-property-descriptor.js","../../node_modules/core-js/internals/set-global.js","../../node_modules/core-js/internals/has.js","../../node_modules/core-js/internals/uid.js","../../node_modules/core-js/internals/shared-key.js","../../node_modules/core-js/internals/internal-state.js","../../node_modules/core-js/internals/descriptors.js","../../node_modules/core-js/internals/ie8-dom-define.js","../../node_modules/core-js/internals/object-define-property.js","../../node_modules/core-js/internals/create-non-enumerable-property.js","../../node_modules/core-js/internals/shared-store.js","../../node_modules/core-js/internals/shared.js","../../node_modules/core-js/internals/function-to-string.js","../../node_modules/core-js/internals/native-weak-map.js","../../node_modules/core-js/internals/hidden-keys.js","../../node_modules/core-js/internals/classof-raw.js","../../node_modules/core-js/internals/well-known-symbol.js","../../node_modules/core-js/internals/classof.js","../../node_modules/core-js/internals/redefine.js","../../node_modules/core-js/internals/native-symbol.js","../../node_modules/core-js/internals/object-to-string.js","../../node_modules/core-js/modules/es.object.to-string.js","../../node_modules/core-js/internals/to-integer.js","../../node_modules/core-js/internals/require-object-coercible.js","../../node_modules/core-js/internals/string-multibyte.js","../../node_modules/core-js/internals/to-indexed-object.js","../../node_modules/core-js/internals/get-built-in.js","../../node_modules/core-js/internals/to-length.js","../../node_modules/core-js/internals/array-includes.js","../../node_modules/core-js/internals/to-absolute-index.js","../../node_modules/core-js/internals/object-keys-internal.js","../../node_modules/core-js/internals/copy-constructor-properties.js","../../node_modules/core-js/internals/is-forced.js","../../node_modules/core-js/internals/export.js","../../node_modules/core-js/internals/to-object.js","../../node_modules/core-js/internals/iterators-core.js","../../node_modules/core-js/internals/object-property-is-enumerable.js","../../node_modules/core-js/internals/indexed-object.js","../../node_modules/core-js/internals/object-get-own-property-descriptor.js","../../node_modules/core-js/internals/path.js","../../node_modules/core-js/internals/enum-bug-keys.js","../../node_modules/core-js/internals/object-get-own-property-names.js","../../node_modules/core-js/internals/object-get-own-property-symbols.js","../../node_modules/core-js/internals/own-keys.js","../../node_modules/core-js/internals/correct-prototype-getter.js","../../node_modules/core-js/internals/object-get-prototype-of.js","../../node_modules/core-js/internals/object-create.js","../../node_modules/core-js/internals/object-keys.js","../../node_modules/core-js/internals/object-define-properties.js","../../node_modules/core-js/internals/html.js","../../node_modules/core-js/internals/set-to-string-tag.js","../../node_modules/core-js/internals/create-iterator-constructor.js","../../node_modules/core-js/internals/define-iterator.js","../../node_modules/core-js/internals/iterators.js","../../node_modules/core-js/internals/object-set-prototype-of.js","../../node_modules/core-js/internals/a-possible-prototype.js","../../node_modules/core-js/modules/es.string.iterator.js","../../node_modules/core-js/internals/dom-iterables.js","../../node_modules/core-js/internals/add-to-unscopables.js","../../node_modules/core-js/modules/es.array.iterator.js","../../node_modules/core-js/modules/web.dom-collections.iterator.js","../../node_modules/core-js/internals/redefine-all.js","../../node_modules/core-js/internals/set-species.js","../../node_modules/core-js/internals/a-function.js","../../node_modules/core-js/internals/an-instance.js","../../node_modules/core-js/internals/is-array-iterator-method.js","../../node_modules/core-js/internals/bind-context.js","../../node_modules/core-js/internals/get-iterator-method.js","../../node_modules/core-js/internals/call-with-safe-iteration-closing.js","../../node_modules/core-js/internals/native-promise-constructor.js","../../node_modules/core-js/internals/iterate.js","../../node_modules/core-js/internals/check-correctness-of-iteration.js","../../node_modules/core-js/internals/species-constructor.js","../../node_modules/core-js/internals/task.js","../../node_modules/core-js/internals/user-agent.js","../../node_modules/core-js/internals/microtask.js","../../node_modules/core-js/internals/new-promise-capability.js","../../node_modules/core-js/internals/promise-resolve.js","../../node_modules/core-js/internals/perform.js","../../node_modules/core-js/modules/es.promise.js","../../node_modules/core-js/internals/host-report-errors.js","../../node_modules/core-js/modules/es.promise.all-settled.js","../../node_modules/core-js/modules/es.promise.finally.js","../../node_modules/core-js/es/promise/index.js","../../node_modules/core-js/modules/esnext.aggregate-error.js","../../node_modules/core-js/modules/esnext.promise.try.js","../../node_modules/core-js/modules/esnext.promise.any.js","../../node_modules/core-js/internals/array-species-create.js","../../node_modules/core-js/internals/array-iteration.js","../../node_modules/core-js/internals/is-array.js","../../node_modules/core-js/modules/es.array.find.js","../../node_modules/core-js/internals/entry-unbind.js","../../node_modules/core-js/modules/es.array.find-index.js","../../node_modules/core-js/es/array/find.js","../../node_modules/core-js/internals/create-property.js","../../node_modules/core-js/es/array/find-index.js","../../node_modules/core-js/modules/es.array.from.js","../../node_modules/core-js/internals/array-from.js","../../node_modules/core-js/es/array/from.js","../../node_modules/core-js/internals/sloppy-array-method.js","../../node_modules/core-js/modules/es.array.some.js","../../node_modules/core-js/es/array/some.js","../../node_modules/core-js/internals/array-buffer-view-core.js","../../node_modules/core-js/modules/es.typed-array.iterator.js","../../node_modules/core-js/internals/object-assign.js","../../node_modules/core-js/modules/es.object.assign.js","../../node_modules/core-js/es/object/assign.js","../../node_modules/core-js/internals/object-to-array.js","../../node_modules/core-js/modules/es.object.entries.js","../../node_modules/core-js/es/object/entries.js","../../node_modules/core-js/modules/es.object.values.js","../../node_modules/core-js/es/object/values.js","../../node_modules/core-js/internals/not-a-regexp.js","../../node_modules/core-js/internals/is-regexp.js","../../node_modules/core-js/internals/correct-is-regexp-logic.js","../../node_modules/core-js/modules/es.string.includes.js","../../node_modules/core-js/es/string/includes.js","../../node_modules/core-js/modules/es.string.starts-with.js","../../node_modules/core-js/es/string/starts-with.js","../../node_modules/core-js/modules/es.string.repeat.js","../../node_modules/core-js/internals/string-repeat.js","../../node_modules/core-js/es/string/repeat.js","../../node_modules/core-js/modules/es.array.concat.js","../../node_modules/core-js/internals/array-method-has-species-support.js","../../node_modules/core-js/internals/define-well-known-symbol.js","../../node_modules/core-js/modules/es.symbol.js","../../node_modules/core-js/internals/object-get-own-property-names-external.js","../../node_modules/core-js/internals/wrapped-well-known-symbol.js","../../node_modules/core-js/modules/es.symbol.async-iterator.js","../../node_modules/core-js/modules/es.symbol.description.js","../../node_modules/core-js/modules/es.symbol.has-instance.js","../../node_modules/core-js/modules/es.symbol.is-concat-spreadable.js","../../node_modules/core-js/modules/es.symbol.iterator.js","../../node_modules/core-js/modules/es.symbol.match.js","../../node_modules/core-js/modules/es.symbol.match-all.js","../../node_modules/core-js/modules/es.symbol.replace.js","../../node_modules/core-js/modules/es.symbol.search.js","../../node_modules/core-js/modules/es.symbol.species.js","../../node_modules/core-js/modules/es.symbol.split.js","../../node_modules/core-js/modules/es.symbol.to-primitive.js","../../node_modules/core-js/modules/es.symbol.to-string-tag.js","../../node_modules/core-js/modules/es.symbol.unscopables.js","../../node_modules/core-js/modules/es.math.to-string-tag.js","../../node_modules/core-js/modules/es.json.to-string-tag.js","../../node_modules/core-js/es/symbol/index.js","../../node_modules/core-js/modules/esnext.symbol.async-dispose.js","../../node_modules/core-js/modules/esnext.symbol.dispose.js","../../node_modules/core-js/modules/esnext.symbol.observable.js","../../node_modules/core-js/modules/esnext.symbol.pattern-match.js","../../node_modules/core-js/modules/esnext.symbol.replace-all.js","../../node_modules/core-js/es/symbol/iterator.js","../../node_modules/core-js/internals/collection.js","../../node_modules/core-js/internals/inherit-if-required.js","../../node_modules/core-js/internals/collection-from.js","../../node_modules/core-js/internals/freezing.js","../../node_modules/core-js/internals/internal-metadata.js","../../node_modules/core-js/internals/collection-strong.js","../../node_modules/core-js/modules/es.map.js","../../node_modules/core-js/es/map/index.js","../../node_modules/core-js/modules/esnext.map.from.js","../../node_modules/core-js/internals/collection-of.js","../../node_modules/core-js/modules/esnext.map.of.js","../../node_modules/core-js/internals/collection-delete-all.js","../../node_modules/core-js/modules/esnext.map.delete-all.js","../../node_modules/core-js/internals/is-pure.js","../../node_modules/core-js/internals/get-map-iterator.js","../../node_modules/core-js/modules/esnext.map.every.js","../../node_modules/core-js/modules/esnext.map.filter.js","../../node_modules/core-js/modules/esnext.map.find.js","../../node_modules/core-js/modules/esnext.map.find-key.js","../../node_modules/core-js/modules/esnext.map.group-by.js","../../node_modules/core-js/modules/esnext.map.includes.js","../../node_modules/core-js/internals/same-value-zero.js","../../node_modules/core-js/modules/esnext.map.key-by.js","../../node_modules/core-js/modules/esnext.map.key-of.js","../../node_modules/core-js/modules/esnext.map.map-keys.js","../../node_modules/core-js/modules/esnext.map.map-values.js","../../node_modules/core-js/modules/esnext.map.merge.js","../../node_modules/core-js/modules/esnext.map.reduce.js","../../node_modules/core-js/modules/esnext.map.some.js","../../node_modules/core-js/modules/esnext.map.update.js","../../node_modules/core-js/internals/map-upsert.js","../../node_modules/core-js/modules/esnext.map.update-or-insert.js","../../node_modules/core-js/modules/esnext.map.upsert.js","../../node_modules/core-js/modules/es.set.js","../../node_modules/core-js/es/set/index.js","../../node_modules/core-js/modules/esnext.set.from.js","../../node_modules/core-js/modules/esnext.set.of.js","../../node_modules/core-js/modules/esnext.set.add-all.js","../../node_modules/core-js/internals/collection-add-all.js","../../node_modules/core-js/modules/esnext.set.delete-all.js","../../node_modules/core-js/internals/get-set-iterator.js","../../node_modules/core-js/modules/esnext.set.every.js","../../node_modules/core-js/modules/esnext.set.difference.js","../../node_modules/core-js/modules/esnext.set.filter.js","../../node_modules/core-js/modules/esnext.set.find.js","../../node_modules/core-js/modules/esnext.set.intersection.js","../../node_modules/core-js/modules/esnext.set.is-disjoint-from.js","../../node_modules/core-js/modules/esnext.set.is-subset-of.js","../../node_modules/core-js/internals/get-iterator.js","../../node_modules/core-js/modules/esnext.set.is-superset-of.js","../../node_modules/core-js/modules/esnext.set.join.js","../../node_modules/core-js/modules/esnext.set.map.js","../../node_modules/core-js/modules/esnext.set.reduce.js","../../node_modules/core-js/modules/esnext.set.some.js","../../node_modules/core-js/modules/esnext.set.symmetric-difference.js","../../node_modules/core-js/modules/esnext.set.union.js","../../node_modules/core-js/internals/is-integer.js","../../node_modules/core-js/modules/es.number.is-integer.js","../../node_modules/core-js/es/number/is-integer.js","../../node_modules/tslib/tslib.es6.js","../util/src/crypt.ts","../util/src/constants.ts","../util/src/assert.ts","../util/src/deepCopy.ts","../util/src/deferred.ts","../util/src/environment.ts","../util/src/errors.ts","../util/src/json.ts","../util/src/jwt.ts","../util/src/obj.ts","../util/src/sha1.ts","../util/src/subscribe.ts","../util/src/validation.ts","../util/src/utf8.ts","../logger/src/logger.ts","../app/src/errors.ts","../app/src/constants.ts","../app/src/firebaseApp.ts","../app/src/logger.ts","../app/src/firebaseNamespaceCore.ts","../app/index.ts","../app/src/firebaseNamespace.ts","../node_modules/google-closure-library/closure/goog/base.js","../auth/dist/ [synthetic:util/defineproperty] ","../auth/dist/ [synthetic:util/global] ","../auth/dist/ [synthetic:es6/util/makeiterator] ","../auth/dist/ [synthetic:es6/util/arrayiterator] ","../auth/dist/ [synthetic:util/polyfill] ","../auth/dist/ [synthetic:es6/promise/promise] ","../node_modules/google-closure-library/closure/goog/promise/thenable.js","../node_modules/google-closure-library/closure/goog/debug/error.js","../node_modules/google-closure-library/closure/goog/asserts/asserts.js","../node_modules/google-closure-library/closure/goog/async/freelist.js","../node_modules/google-closure-library/closure/goog/async/workqueue.js","../node_modules/google-closure-library/closure/goog/dom/asserts.js","../node_modules/google-closure-library/closure/goog/array/array.js","../node_modules/google-closure-library/closure/goog/object/object.js","../node_modules/google-closure-library/closure/goog/string/const.js","../node_modules/google-closure-library/closure/goog/html/trustedresourceurl.js","../node_modules/google-closure-library/closure/goog/string/internal.js","../node_modules/google-closure-library/closure/goog/html/safeurl.js","../node_modules/google-closure-library/closure/goog/labs/useragent/util.js","../node_modules/google-closure-library/closure/goog/html/safehtml.js","../node_modules/google-closure-library/closure/goog/async/nexttick.js","../node_modules/google-closure-library/closure/goog/async/run.js","../node_modules/google-closure-library/closure/goog/string/string.js","../node_modules/google-closure-library/closure/goog/labs/useragent/engine.js","../node_modules/google-closure-library/closure/goog/dom/safe.js","../node_modules/google-closure-library/closure/goog/labs/useragent/browser.js","../node_modules/google-closure-library/closure/goog/promise/promise.js","../node_modules/google-closure-library/closure/goog/disposable/disposable.js","../node_modules/google-closure-library/closure/goog/reflect/reflect.js","../node_modules/google-closure-library/closure/goog/useragent/useragent.js","../node_modules/google-closure-library/closure/goog/debug/debug.js","../node_modules/google-closure-library/closure/goog/events/browserfeature.js","../node_modules/google-closure-library/closure/goog/events/event.js","../node_modules/google-closure-library/closure/goog/events/browserevent.js","../node_modules/google-closure-library/closure/goog/events/eventtype.js","../node_modules/google-closure-library/closure/goog/events/listenable.js","../node_modules/google-closure-library/closure/goog/events/listener.js","../node_modules/google-closure-library/closure/goog/events/listenermap.js","../node_modules/google-closure-library/closure/goog/events/events.js","../node_modules/google-closure-library/closure/goog/events/eventtarget.js","../node_modules/google-closure-library/closure/goog/timer/timer.js","../node_modules/google-closure-library/closure/goog/structs/structs.js","../node_modules/google-closure-library/closure/goog/structs/map.js","../node_modules/google-closure-library/closure/goog/uri/utils.js","../node_modules/google-closure-library/closure/goog/uri/uri.js","../auth/dist/src/iframeclient/ifchandler.js","../node_modules/google-closure-library/closure/goog/dom/browserfeature.js","../node_modules/google-closure-library/closure/goog/dom/dom.js","../node_modules/google-closure-library/closure/goog/json/json.js","../auth/dist/src/utils.js","../node_modules/google-closure-library/closure/goog/window/window.js","../node_modules/google-closure-library/closure/goog/labs/useragent/platform.js","../auth/dist/src/object.js","../auth/dist/src/deprecation.js","../auth/dist/src/actioncodeinfo.js","../auth/dist/src/error_auth.js","../auth/dist/src/actioncodeurl.js","../auth/dist/src/actioncodesettings.js","../node_modules/google-closure-library/closure/goog/crypt/base64.js","../auth/dist/src/idtoken.js","../auth/dist/src/defines.js","../auth/dist/src/idp.js","../auth/dist/src/additionaluserinfo.js","../auth/dist/src/dynamiclink.js","../auth/dist/src/authcredential.js","../auth/dist/src/authevent.js","../auth/dist/src/universallinksubscriber.js","../auth/dist/src/rpchandler.js","../node_modules/google-closure-library/closure/goog/net/xmlhttp.js","../auth/dist/src/error_invalidorigin.js","../auth/dist/src/error_withcredential.js","../node_modules/google-closure-library/closure/goog/net/xmlhttpfactory.js","../node_modules/google-closure-library/closure/goog/net/corsxmlhttpfactory.js","../node_modules/google-closure-library/closure/goog/debug/logrecord.js","../node_modules/google-closure-library/closure/goog/debug/logger.js","../node_modules/google-closure-library/closure/goog/net/httpstatus.js","../node_modules/google-closure-library/closure/goog/functions/functions.js","../node_modules/google-closure-library/closure/goog/log/log.js","../node_modules/google-closure-library/closure/goog/net/fetchxmlhttpfactory.js","../node_modules/google-closure-library/closure/goog/net/xhrio.js","../node_modules/google-closure-library/closure/goog/net/eventtype.js","../node_modules/google-closure-library/third_party/closure/goog/mochikit/async/deferred.js","../node_modules/google-closure-library/closure/goog/net/jsloader.js","../node_modules/google-closure-library/closure/goog/net/errorcode.js","../auth/dist/src/iframeclient/iframewrapper.js","../auth/dist/src/storage/asyncstorage.js","../auth/dist/src/storage/storage.js","../auth/dist/src/messagechannel/receiver.js","../auth/dist/src/storage/indexeddb.js","../auth/dist/src/messagechannel/postmessager.js","../auth/dist/src/messagechannel/sender.js","../auth/dist/src/messagechannel/defines.js","../auth/dist/src/storage/hybridindexeddb.js","../auth/dist/src/storage/inmemorystorage.js","../auth/dist/src/storage/localstorage.js","../auth/dist/src/storage/nullstorage.js","../auth/dist/src/storage/sessionstorage.js","../auth/dist/src/storage/factory.js","../auth/dist/src/authstorage.js","../auth/dist/src/storageautheventmanager.js","../node_modules/google-closure-library/closure/goog/crypt/sha2.js","../auth/dist/src/storageoauthhandlermanager.js","../node_modules/google-closure-library/closure/goog/crypt/hash.js","../node_modules/google-closure-library/closure/goog/crypt/sha256.js","../auth/dist/src/cordovahandler.js","../node_modules/google-closure-library/closure/goog/crypt/crypt.js","../auth/dist/src/storagependingredirectmanager.js","../auth/dist/src/autheventmanager.js","../auth/dist/src/authsettings.js","../auth/dist/src/confirmationresult.js","../auth/dist/src/idtokenresult.js","../auth/dist/src/proactiverefresh.js","../auth/dist/src/authuser.js","../auth/dist/src/token.js","../auth/dist/src/storageredirectusermanager.js","../auth/dist/src/storageusermanager.js","../auth/dist/src/auth.js","../auth/dist/src/recaptchaverifier/grecaptcha.js","../auth/dist/src/recaptchaverifier/grecaptchamock.js","../auth/dist/src/recaptchaverifier/mockloader.js","../auth/dist/src/recaptchaverifier/realloader.js","../auth/dist/src/recaptchaverifier/recaptchaverifier.js","../auth/dist/src/args.js","../auth/dist/src/exports_lib.js","../auth/dist/src/exports_auth.js","../database/src/core/storage/DOMStorageWrapper.ts","../database/src/core/storage/MemoryStorage.ts","../database/src/core/storage/storage.ts","../database/src/core/util/util.ts","../database/src/core/util/Path.ts","../database/src/realtime/Constants.ts","../database/src/core/RepoInfo.ts","../database/src/core/util/libs/parser.ts","../database/src/core/util/validation.ts","../database/src/api/onDisconnect.ts","../database/src/api/TransactionResult.ts","../database/src/core/util/NextPushId.ts","../database/src/core/snap/Node.ts","../database/src/core/snap/indexes/Index.ts","../database/src/core/snap/indexes/KeyIndex.ts","../database/src/core/snap/snap.ts","../database/src/core/snap/LeafNode.ts","../database/src/core/snap/indexes/PriorityIndex.ts","../database/src/core/util/SortedMap.ts","../database/src/core/snap/childSet.ts","../database/src/core/snap/IndexMap.ts","../database/src/core/snap/ChildrenNode.ts","../database/src/core/snap/comparators.ts","../database/src/core/snap/nodeFromJSON.ts","../database/src/core/snap/indexes/ValueIndex.ts","../database/src/core/snap/indexes/PathIndex.ts","../database/src/api/DataSnapshot.ts","../database/src/core/view/Event.ts","../database/src/core/view/EventRegistration.ts","../database/src/api/Query.ts","../database/src/core/SparseSnapshotTree.ts","../database/src/core/util/ServerValues.ts","../database/src/core/operation/Operation.ts","../database/src/core/operation/AckUserWrite.ts","../database/src/core/util/ImmutableTree.ts","../database/src/core/operation/ListenComplete.ts","../database/src/core/operation/Overwrite.ts","../database/src/core/operation/Merge.ts","../database/src/core/view/CacheNode.ts","../database/src/core/view/ViewCache.ts","../database/src/core/view/Change.ts","../database/src/core/view/filter/IndexedFilter.ts","../database/src/core/view/ChildChangeAccumulator.ts","../database/src/core/view/CompleteChildSource.ts","../database/src/core/view/ViewProcessor.ts","../database/src/core/view/EventGenerator.ts","../database/src/core/view/View.ts","../database/src/core/SyncPoint.ts","../database/src/core/CompoundWrite.ts","../database/src/core/WriteTree.ts","../database/src/core/SyncTree.ts","../database/src/core/SnapshotHolder.ts","../database/src/core/AuthTokenProvider.ts","../database/src/core/EmulatorAuthTokenProvider.ts","../database/src/core/stats/StatsCollection.ts","../database/src/core/stats/StatsManager.ts","../database/src/core/stats/StatsListener.ts","../database/src/core/stats/StatsReporter.ts","../database/src/core/view/EventQueue.ts","../database/src/core/util/EventEmitter.ts","../database/src/core/util/VisibilityMonitor.ts","../database/src/core/util/OnlineMonitor.ts","../database/src/realtime/polling/PacketReceiver.ts","../database/src/realtime/BrowserPollConnection.ts","../database/src/core/version.ts","../database/src/realtime/WebSocketConnection.ts","../database/src/realtime/TransportManager.ts","../database/src/realtime/Connection.ts","../database/src/core/ServerActions.ts","../database/src/core/PersistentConnection.ts","../database/src/core/ReadonlyRestClient.ts","../util/src/query.ts","../database/src/core/Repo.ts","../database/src/core/view/filter/RangedFilter.ts","../database/src/core/view/filter/LimitedFilter.ts","../database/src/core/view/QueryParams.ts","../database/src/api/Reference.ts","../database/src/core/util/Tree.ts","../database/src/core/Repo_transaction.ts","../database/src/core/RepoManager.ts","../database/src/api/Database.ts","../database/src/api/internal.ts","../database/src/api/test_access.ts","../database/index.ts","../../node_modules/closure-builder/third_party/closure-library/closure/goog/base.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/disposable/disposable.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/array/array.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/string/internal.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/useragent/util.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/object/object.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/reflect/reflect.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/useragent/useragent.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/useragent/browser.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/useragent/engine.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/browserfeature.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/event.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/browserevent.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/eventtype.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/listenable.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/listener.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/listenermap.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/events.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/eventtarget.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/json/json.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/async/freelist.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/async/workqueue.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/async/run.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/async/nexttick.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/timer/timer.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/async/throttle.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/events/eventhandler.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/webchanneldebug.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/requeststats.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/errorcode.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/eventtype.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/xmlhttpfactory.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/xmlhttp.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/channelrequest.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/environment.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/webchannelbase.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/structs/structs.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/structs/map.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/string/string.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/uri/utils.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/uri/uri.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/basetestchannel.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/connectionstate.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/structs/set.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/wire.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/forwardchannelrequestpool.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/debug/formatter.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/json/nativejsonprocessor.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/wirev8.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/netutils.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/json/hybrid.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/xhrio.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/httpstatus.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/net/rpc/httpcors.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchannel/webchannelbasetransport.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/string/path.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchanneltransport.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/labs/net/webchanneltransportfactory.js","../../node_modules/closure-builder/third_party/closure-library/closure/goog/functions/functions.js","../webchannel-wrapper/src/index.js","../firestore/src/util/log.ts","../firestore/src/core/version.ts","../firestore/src/util/assert.ts","../firestore/src/platform/platform.ts","../firestore/src/util/error.ts","../firestore/src/util/api.ts","../firestore/src/util/obj.ts","../firestore/src/util/input_validation.ts","../firestore/src/util/misc.ts","../firestore/src/api/blob.ts","../firestore/src/core/database_info.ts","../firestore/src/core/listen_sequence.ts","../firestore/src/model/path.ts","../firestore/src/model/document_key.ts","../firestore/src/util/promise.ts","../firestore/src/util/async_queue.ts","../firestore/src/local/encoded_resource_path.ts","../firestore/src/api/timestamp.ts","../firestore/src/core/snapshot_version.ts","../firestore/src/util/sorted_map.ts","../firestore/src/util/sorted_set.ts","../firestore/src/model/collections.ts","../firestore/src/model/mutation_batch.ts","../firestore/src/local/persistence_promise.ts","../firestore/src/local/simple_db.ts","../firestore/src/local/indexeddb_mutation_queue.ts","../firestore/src/core/target_id_generator.ts","../firestore/src/local/indexeddb_query_cache.ts","../firestore/src/model/mutation.ts","../firestore/src/model/field_value.ts","../firestore/src/model/document.ts","../firestore/src/util/obj_map.ts","../firestore/src/local/remote_document_change_buffer.ts","../firestore/src/local/indexeddb_remote_document_cache.ts","../firestore/src/local/memory_index_manager.ts","../firestore/src/local/indexeddb_schema.ts","../firestore/src/local/query_data.ts","../firestore/src/local/indexeddb_index_manager.ts","../firestore/src/local/local_serializer.ts","../firestore/src/local/lru_garbage_collector.ts","../firestore/src/local/persistence.ts","../firestore/src/local/indexeddb_persistence.ts","../firestore/src/local/local_documents_view.ts","../firestore/src/local/reference_set.ts","../firestore/src/local/local_store.ts","../firestore/src/local/memory_mutation_queue.ts","../firestore/src/local/memory_query_cache.ts","../firestore/src/local/memory_remote_document_cache.ts","../firestore/src/local/memory_persistence.ts","../firestore/src/local/simple_query_engine.ts","../firestore/src/util/types.ts","../firestore/src/remote/backoff.ts","../firestore/src/remote/persistent_stream.ts","../firestore/src/remote/datastore.ts","../firestore/src/core/transaction.ts","../firestore/src/core/types.ts","../firestore/src/remote/online_state_tracker.ts","../firestore/src/remote/rpc_error.ts","../firestore/src/model/document_set.ts","../firestore/src/core/view_snapshot.ts","../firestore/src/remote/remote_event.ts","../firestore/src/remote/watch_change.ts","../firestore/src/remote/remote_store.ts","../firestore/src/api/geo_point.ts","../firestore/src/core/query.ts","../firestore/src/model/transform_operation.ts","../firestore/src/remote/existence_filter.ts","../firestore/src/remote/serializer.ts","../firestore/src/core/event_manager.ts","../firestore/src/local/local_view_changes.ts","../firestore/src/core/view.ts","../firestore/src/core/transaction_runner.ts","../firestore/src/core/sync_engine.ts","../firestore/src/auth/user.ts","../firestore/src/local/shared_client_state.ts","../firestore/src/core/firestore_client.ts","../firestore/src/util/async_observer.ts","../firestore/src/api/field_path.ts","../firestore/src/api/credentials.ts","../firestore/src/api/observer.ts","../firestore/src/api/field_value.ts","../firestore/src/api/user_data_converter.ts","../firestore/src/api/database.ts","../firestore/src/platform/config.ts","../firestore/src/remote/connectivity_monitor_noop.ts","../firestore/src/platform_browser/browser_connectivity_monitor.ts","../firestore/src/remote/stream_bridge.ts","../firestore/src/platform_browser/webchannel_connection.ts","../firestore/src/platform_browser/browser_platform.ts","../firestore/src/platform_browser/browser_init.ts","../firestore/index.ts","../functions/src/api/error.ts","../functions/src/context.ts","../functions/src/serializer.ts","../functions/src/api/service.ts","../functions/index.ts","../../node_modules/idb/lib/idb.mjs","../installations/src/util/constants.ts","../installations/src/util/errors.ts","../installations/src/helpers/extract-app-config.ts","../installations/src/api/common.ts","../installations/src/util/sleep.ts","../installations/src/helpers/generate-fid.ts","../installations/src/helpers/buffer-to-base64-url-safe.ts","../installations/src/helpers/idb-manager.ts","../installations/src/helpers/get-installation-entry.ts","../installations/src/api/create-installation.ts","../installations/src/api/generate-auth-token.ts","../installations/src/helpers/refresh-auth-token.ts","../installations/src/functions/get-token.ts","../installations/src/api/delete-installation.ts","../installations/src/index.ts","../installations/src/functions/get-id.ts","../installations/src/functions/delete-installation.ts","../messaging/src/models/errors.ts","../messaging/src/models/worker-page-message.ts","../messaging/src/models/fcm-details.ts","../messaging/src/helpers/is-array-buffer-equal.ts","../messaging/src/helpers/array-buffer-to-base64.ts","../messaging/src/models/subscription-manager.ts","../messaging/src/helpers/base64-to-array-buffer.ts","../messaging/src/models/clean-v1-undefined.ts","../messaging/src/models/db-interface.ts","../messaging/src/models/token-details-model.ts","../messaging/src/models/vapid-details-model.ts","../messaging/src/controllers/base-controller.ts","../messaging/src/controllers/sw-controller.ts","../messaging/src/models/default-sw.ts","../messaging/index.ts","../messaging/src/controllers/window-controller.ts","../storage/src/implementation/constants.ts","../storage/src/implementation/error.ts","../storage/src/implementation/string.ts","../storage/src/implementation/taskenums.ts","../storage/src/implementation/xhrio.ts","../storage/src/implementation/type.ts","../storage/src/implementation/xhrio_network.ts","../storage/src/implementation/xhriopool.ts","../storage/src/implementation/fs.ts","../storage/src/implementation/blob.ts","../storage/src/implementation/location.ts","../storage/src/implementation/json.ts","../storage/src/implementation/path.ts","../storage/src/implementation/url.ts","../storage/src/implementation/metadata.ts","../storage/src/implementation/list.ts","../storage/src/implementation/requestinfo.ts","../storage/src/implementation/requests.ts","../storage/src/implementation/observer.ts","../storage/src/tasksnapshot.ts","../storage/src/implementation/args.ts","../storage/src/implementation/async.ts","../storage/src/task.ts","../storage/src/reference.ts","../storage/src/implementation/failrequest.ts","../storage/src/implementation/requestmap.ts","../storage/src/implementation/authwrapper.ts","../storage/src/implementation/request.ts","../storage/src/implementation/backoff.ts","../storage/src/service.ts","../storage/index.ts","../performance/src/services/api_service.ts","../performance/src/services/settings_service.ts","../performance/src/constants.ts","../performance/src/utils/errors.ts","../performance/src/services/iid_service.ts","../performance/src/utils/attributes_utils.ts","../performance/src/utils/console_logger.ts","../performance/src/services/remote_config_service.ts","../performance/src/services/initialization_service.ts","../performance/src/services/cc_service.ts","../performance/src/services/perf_logger.ts","../performance/src/utils/metric_utils.ts","../performance/src/resources/trace.ts","../performance/src/resources/network_request.ts","../performance/src/services/oob_resources_service.ts","../performance/src/controllers/perf.ts","../performance/index.ts","../analytics/src/constants.ts","../analytics/src/helpers.ts","../analytics/src/errors.ts","../analytics/src/factory.ts","../analytics/src/functions.ts","../analytics/index.ts","../remote-config/src/client/caching_client.ts","../remote-config/src/errors.ts","../remote-config/src/client/rest_client.ts","../remote-config/src/language.ts","../remote-config/src/client/remote_config_fetch_client.ts","../remote-config/src/value.ts","../remote-config/src/remote_config.ts","../remote-config/src/storage/storage.ts","../remote-config/src/storage/storage_cache.ts","../remote-config/src/client/retrying_client.ts","../remote-config/src/client/exponential_backoff.ts","../remote-config/index.ts","src/index.cdn.ts"],"sourcesContent":["(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n","var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line no-undef\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func\n  Function('return this')();\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var isObject = require('../internals/is-object');\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n","var isObject = require('../internals/is-object');\n\n// `ToPrimitive` abstract operation\n// https://tc39.github.io/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var global = require('../internals/global');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nmodule.exports = function (key, value) {\n  try {\n    createNonEnumerableProperty(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar objectHas = require('../internals/has');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","var fails = require('../internals/fails');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPrimitive = require('../internals/to-primitive');\n\nvar nativeDefineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.3.3',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n","var shared = require('../internals/shared');\n\nmodule.exports = shared('native-function-to-string', Function.toString);\n","var global = require('../internals/global');\nvar nativeFunctionToString = require('../internals/function-to-string');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));\n","module.exports = {};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nvar Symbol = global.Symbol;\nvar store = shared('wks');\n\nmodule.exports = function (name) {\n  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]\n    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n","var classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n};\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar has = require('../internals/has');\nvar setGlobal = require('../internals/set-global');\nvar nativeFunctionToString = require('../internals/function-to-string');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(nativeFunctionToString).split('toString');\n\nshared('inspectSource', function (it) {\n  return nativeFunctionToString.call(it);\n});\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);\n});\n","var fails = require('../internals/fails');\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n","'use strict';\nvar classof = require('../internals/classof');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\n// `Object.prototype.toString` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\nmodule.exports = String(test) !== '[object z]' ? function toString() {\n  return '[object ' + classof(this) + ']';\n} : test.toString;\n","var redefine = require('../internals/redefine');\nvar toString = require('../internals/object-to-string');\n\nvar ObjectPrototype = Object.prototype;\n\n// `Object.prototype.toString` method\n// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\nif (toString !== ObjectPrototype.toString) {\n  redefine(ObjectPrototype, 'toString', toString, { unsafe: true });\n}\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var toInteger = require('../internals/to-integer');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `String.prototype.{ codePointAt, at }` methods implementation\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING ? S.charAt(position) : first\n        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","var path = require('../internals/path');\nvar global = require('../internals/global');\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n","var toInteger = require('../internals/to-integer');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","var toInteger = require('../internals/to-integer');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","var has = require('../internals/has');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","var has = require('../internals/has');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var fails = require('../internals/fails');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `ToObject` abstract operation\n// https://tc39.github.io/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","'use strict';\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar has = require('../internals/has');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar IS_PURE = require('../internals/is-pure');\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {\n  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n","'use strict';\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n","var fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPrimitive = require('../internals/to-primitive');\nvar has = require('../internals/has');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","module.exports = require('../internals/global');\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n","var has = require('../internals/has');\nvar toObject = require('../internals/to-object');\nvar sharedKey = require('../internals/shared-key');\nvar CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n","var anObject = require('../internals/an-object');\nvar defineProperties = require('../internals/object-define-properties');\nvar enumBugKeys = require('../internals/enum-bug-keys');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar html = require('../internals/html');\nvar documentCreateElement = require('../internals/document-create-element');\nvar sharedKey = require('../internals/shared-key');\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar PROTOTYPE = 'prototype';\nvar Empty = function () { /* empty */ };\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var length = enumBugKeys.length;\n  var lt = '<';\n  var script = 'script';\n  var gt = '>';\n  var js = 'java' + script + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  iframe.src = String(js);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n  return createDict();\n};\n\n// `Object.create` method\n// https://tc39.github.io/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\nhiddenKeys[IE_PROTO] = true;\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.github.io/ecma262/#sec-object.keys\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar anObject = require('../internals/an-object');\nvar objectKeys = require('../internals/object-keys');\n\n// `Object.defineProperties` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperties\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n","var defineProperty = require('../internals/object-define-property').f;\nvar has = require('../internals/has');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n","'use strict';\nvar IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;\nvar create = require('../internals/object-create');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar setToStringTag = require('../internals/set-to-string-tag');\nvar Iterators = require('../internals/iterators');\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar createIteratorConstructor = require('../internals/create-iterator-constructor');\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\nvar setToStringTag = require('../internals/set-to-string-tag');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar IS_PURE = require('../internals/is-pure');\nvar Iterators = require('../internals/iterators');\nvar IteratorsCore = require('../internals/iterators-core');\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n","module.exports = {};\n","var anObject = require('../internals/an-object');\nvar aPossiblePrototype = require('../internals/a-possible-prototype');\n\n// `Object.setPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n","var isObject = require('../internals/is-object');\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n","'use strict';\nvar charAt = require('../internals/string-multibyte').charAt;\nvar InternalStateModule = require('../internals/internal-state');\nvar defineIterator = require('../internals/define-iterator');\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n","// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\nvar create = require('../internals/object-create');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, create(null));\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n","'use strict';\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar addToUnscopables = require('../internals/add-to-unscopables');\nvar Iterators = require('../internals/iterators');\nvar InternalStateModule = require('../internals/internal-state');\nvar defineIterator = require('../internals/define-iterator');\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.github.io/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\nIterators.Arguments = Iterators.Array;\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","var global = require('../internals/global');\nvar DOMIterables = require('../internals/dom-iterables');\nvar ArrayIteratorMethods = require('../modules/es.array.iterator');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n}\n","var redefine = require('../internals/redefine');\n\nmodule.exports = function (target, src, options) {\n  for (var key in src) redefine(target, key, src[key], options);\n  return target;\n};\n","'use strict';\nvar getBuiltIn = require('../internals/get-built-in');\nvar definePropertyModule = require('../internals/object-define-property');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar DESCRIPTORS = require('../internals/descriptors');\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n    defineProperty(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n","module.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n","module.exports = function (it, Constructor, name) {\n  if (!(it instanceof Constructor)) {\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n  } return it;\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\nvar Iterators = require('../internals/iterators');\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n","var aFunction = require('../internals/a-function');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var classof = require('../internals/classof');\nvar Iterators = require('../internals/iterators');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar ITERATOR = wellKnownSymbol('iterator');\n\nmodule.exports = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","var anObject = require('../internals/an-object');\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    var returnMethod = iterator['return'];\n    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n    throw error;\n  }\n};\n","var global = require('../internals/global');\n\nmodule.exports = global.Promise;\n","var anObject = require('../internals/an-object');\nvar isArrayIteratorMethod = require('../internals/is-array-iterator-method');\nvar toLength = require('../internals/to-length');\nvar bind = require('../internals/bind-context');\nvar getIteratorMethod = require('../internals/get-iterator-method');\nvar callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {\n  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);\n  var iterator, iterFn, index, length, result, next, step;\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n        result = AS_ENTRIES\n          ? boundFunction(anObject(step = iterable[index])[0], step[1])\n          : boundFunction(iterable[index]);\n        if (result && result instanceof Result) return result;\n      } return new Result(false);\n    }\n    iterator = iterFn.call(iterable);\n  }\n\n  next = iterator.next;\n  while (!(step = next.call(iterator)).done) {\n    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);\n    if (typeof result == 'object' && result && result instanceof Result) return result;\n  } return new Result(false);\n};\n\niterate.stop = function (result) {\n  return new Result(true, result);\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n","var anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.github.io/ecma262/#sec-speciesconstructor\nmodule.exports = function (O, defaultConstructor) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\n};\n","var global = require('../internals/global');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\nvar bind = require('../internals/bind-context');\nvar html = require('../internals/html');\nvar createElement = require('../internals/document-create-element');\nvar userAgent = require('../internals/user-agent');\n\nvar location = global.location;\nvar set = global.setImmediate;\nvar clear = global.clearImmediate;\nvar process = global.process;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\n\nvar run = function (id) {\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global.postMessage(id + '', location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n  set = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (classof(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !/(iphone|ipod|ipad).*applewebkit/i.test(userAgent)) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {\n    defer = post;\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nmodule.exports = {\n  set: set,\n  clear: clear\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar classof = require('../internals/classof-raw');\nvar macrotask = require('../internals/task').set;\nvar userAgent = require('../internals/user-agent');\n\nvar MutationObserver = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar IS_NODE = classof(process) == 'process';\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (IS_NODE) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  } else if (MutationObserver && !/(iphone|ipod|ipad).*applewebkit/i.test(userAgent)) {\n    toggle = true;\n    node = document.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise.resolve(undefined);\n    then = promise.then;\n    notify = function () {\n      then.call(promise, flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n}\n\nmodule.exports = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify();\n  } last = task;\n};\n","'use strict';\nvar aFunction = require('../internals/a-function');\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n};\n\n// 25.4.1.5 NewPromiseCapability(C)\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","var anObject = require('../internals/an-object');\nvar isObject = require('../internals/is-object');\nvar newPromiseCapability = require('../internals/new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar global = require('../internals/global');\nvar path = require('../internals/path');\nvar NativePromise = require('../internals/native-promise-constructor');\nvar redefine = require('../internals/redefine');\nvar redefineAll = require('../internals/redefine-all');\nvar setToStringTag = require('../internals/set-to-string-tag');\nvar setSpecies = require('../internals/set-species');\nvar isObject = require('../internals/is-object');\nvar aFunction = require('../internals/a-function');\nvar anInstance = require('../internals/an-instance');\nvar classof = require('../internals/classof-raw');\nvar iterate = require('../internals/iterate');\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\nvar speciesConstructor = require('../internals/species-constructor');\nvar task = require('../internals/task').set;\nvar microtask = require('../internals/microtask');\nvar promiseResolve = require('../internals/promise-resolve');\nvar hostReportErrors = require('../internals/host-report-errors');\nvar newPromiseCapabilityModule = require('../internals/new-promise-capability');\nvar perform = require('../internals/perform');\nvar userAgent = require('../internals/user-agent');\nvar InternalStateModule = require('../internals/internal-state');\nvar isForced = require('../internals/is-forced');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\nvar PROMISE = 'Promise';\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar PromiseConstructor = NativePromise;\nvar TypeError = global.TypeError;\nvar document = global.document;\nvar process = global.process;\nvar $fetch = global.fetch;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar newPromiseCapability = newPromiseCapabilityModule.f;\nvar newGenericPromiseCapability = newPromiseCapability;\nvar IS_NODE = classof(process) == 'process';\nvar DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\nvar FORCED = isForced(PROMISE, function () {\n  // correct subclassing with @@species support\n  var promise = PromiseConstructor.resolve(1);\n  var empty = function () { /* empty */ };\n  var FakePromise = (promise.constructor = {})[SPECIES] = function (exec) {\n    exec(empty, empty);\n  };\n  // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !((IS_NODE || typeof PromiseRejectionEvent == 'function')\n    && (!IS_PURE || promise['finally'])\n    && promise.then(empty) instanceof FakePromise\n    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n    // we can't detect it synchronously, so just check versions\n    && v8.indexOf('6.6') !== 0\n    && userAgent.indexOf('Chrome/66') === -1);\n});\n\nvar INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {\n  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });\n});\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\n\nvar notify = function (promise, state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  var chain = state.reactions;\n  microtask(function () {\n    var value = state.value;\n    var ok = state.state == FULFILLED;\n    var index = 0;\n    // variable length - can't use forEach\n    while (chain.length > index) {\n      var reaction = chain[index++];\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);\n            state.rejection = HANDLED;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // can throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (error) {\n        if (domain && !exited) domain.exit();\n        reject(error);\n      }\n    }\n    state.reactions = [];\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(promise, state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (handler = global['on' + name]) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (promise, state) {\n  task.call(global, function () {\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform(function () {\n        if (IS_NODE) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (promise, state) {\n  task.call(global, function () {\n    if (IS_NODE) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind = function (fn, promise, state, unwrap) {\n  return function (value) {\n    fn(promise, state, value, unwrap);\n  };\n};\n\nvar internalReject = function (promise, state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(promise, state, true);\n};\n\nvar internalResolve = function (promise, state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          then.call(value,\n            bind(internalResolve, promise, wrapper, state),\n            bind(internalReject, promise, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(promise, wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(promise, state, false);\n    }\n  } catch (error) {\n    internalReject(promise, { done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance(this, PromiseConstructor, PROMISE);\n    aFunction(executor);\n    Internal.call(this);\n    var state = getInternalState(this);\n    try {\n      executor(bind(internalResolve, this, state), bind(internalReject, this, state));\n    } catch (error) {\n      internalReject(this, state, error);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    setInternalState(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: [],\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n  Internal.prototype = redefineAll(PromiseConstructor.prototype, {\n    // `Promise.prototype.then` method\n    // https://tc39.github.io/ecma262/#sec-promise.prototype.then\n    then: function then(onFulfilled, onRejected) {\n      var state = getInternalPromiseState(this);\n      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = IS_NODE ? process.domain : undefined;\n      state.parent = true;\n      state.reactions.push(reaction);\n      if (state.state != PENDING) notify(this, state, false);\n      return reaction.promise;\n    },\n    // `Promise.prototype.catch` method\n    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalState(promise);\n    this.promise = promise;\n    this.resolve = bind(internalResolve, promise, state);\n    this.reject = bind(internalReject, promise, state);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (!IS_PURE && typeof NativePromise == 'function') {\n    nativeThen = NativePromise.prototype.then;\n\n    // wrap native Promise#then for native async functions\n    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {\n      var that = this;\n      return new PromiseConstructor(function (resolve, reject) {\n        nativeThen.call(that, resolve, reject);\n      }).then(onFulfilled, onRejected);\n    // https://github.com/zloirock/core-js/issues/640\n    }, { unsafe: true });\n\n    // wrap fetch result\n    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {\n      // eslint-disable-next-line no-unused-vars\n      fetch: function fetch(input) {\n        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));\n      }\n    });\n  }\n}\n\n$({ global: true, wrap: true, forced: FORCED }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag(PromiseConstructor, PROMISE, false, true);\nsetSpecies(PROMISE);\n\nPromiseWrapper = path[PROMISE];\n\n// statics\n$({ target: PROMISE, stat: true, forced: FORCED }, {\n  // `Promise.reject` method\n  // https://tc39.github.io/ecma262/#sec-promise.reject\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    capability.reject.call(undefined, r);\n    return capability.promise;\n  }\n});\n\n$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {\n  // `Promise.resolve` method\n  // https://tc39.github.io/ecma262/#sec-promise.resolve\n  resolve: function resolve(x) {\n    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);\n  }\n});\n\n$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {\n  // `Promise.all` method\n  // https://tc39.github.io/ecma262/#sec-promise.all\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aFunction(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        $promiseResolve.call(C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  },\n  // `Promise.race` method\n  // https://tc39.github.io/ecma262/#sec-promise.race\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aFunction(C.resolve);\n      iterate(iterable, function (promise) {\n        $promiseResolve.call(C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n","var global = require('../internals/global');\n\nmodule.exports = function (a, b) {\n  var console = global.console;\n  if (console && console.error) {\n    arguments.length === 1 ? console.error(a) : console.error(a, b);\n  }\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar aFunction = require('../internals/a-function');\nvar newPromiseCapabilityModule = require('../internals/new-promise-capability');\nvar perform = require('../internals/perform');\nvar iterate = require('../internals/iterate');\n\n// `Promise.allSettled` method\n// https://github.com/tc39/proposal-promise-allSettled\n$({ target: 'Promise', stat: true }, {\n  allSettled: function allSettled(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var promiseResolve = aFunction(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        promiseResolve.call(C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = { status: 'fulfilled', value: value };\n          --remaining || resolve(values);\n        }, function (e) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = { status: 'rejected', reason: e };\n          --remaining || resolve(values);\n        });\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar NativePromise = require('../internals/native-promise-constructor');\nvar getBuiltIn = require('../internals/get-built-in');\nvar speciesConstructor = require('../internals/species-constructor');\nvar promiseResolve = require('../internals/promise-resolve');\nvar redefine = require('../internals/redefine');\n\n// `Promise.prototype.finally` method\n// https://tc39.github.io/ecma262/#sec-promise.prototype.finally\n$({ target: 'Promise', proto: true, real: true }, {\n  'finally': function (onFinally) {\n    var C = speciesConstructor(this, getBuiltIn('Promise'));\n    var isFunction = typeof onFinally == 'function';\n    return this.then(\n      isFunction ? function (x) {\n        return promiseResolve(C, onFinally()).then(function () { return x; });\n      } : onFinally,\n      isFunction ? function (e) {\n        return promiseResolve(C, onFinally()).then(function () { throw e; });\n      } : onFinally\n    );\n  }\n});\n\n// patch native Promise.prototype for native async functions\nif (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {\n  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);\n}\n","require('../../modules/es.object.to-string');\nrequire('../../modules/es.string.iterator');\nrequire('../../modules/web.dom-collections.iterator');\nrequire('../../modules/es.promise');\nrequire('../../modules/es.promise.all-settled');\nrequire('../../modules/es.promise.finally');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Promise;\n","'use strict';\nvar $ = require('../internals/export');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\nvar create = require('../internals/object-create');\nvar defineProperty = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar iterate = require('../internals/iterate');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar anObject = require('../internals/an-object');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar setInternalState = InternalStateModule.set;\nvar getInternalAggregateErrorState = InternalStateModule.getterFor('AggregateError');\n\nvar $AggregateError = function AggregateError(errors, message) {\n  var that = this;\n  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);\n  if (setPrototypeOf) {\n    that = setPrototypeOf(new Error(message), getPrototypeOf(that));\n  }\n  var errorsArray = [];\n  iterate(errors, errorsArray.push, errorsArray);\n  if (DESCRIPTORS) setInternalState(that, { errors: errorsArray, type: 'AggregateError' });\n  else that.errors = errorsArray;\n  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));\n  return that;\n};\n\n$AggregateError.prototype = create(Error.prototype, {\n  constructor: createPropertyDescriptor(5, $AggregateError),\n  message: createPropertyDescriptor(5, ''),\n  name: createPropertyDescriptor(5, 'AggregateError'),\n  toString: createPropertyDescriptor(5, function toString() {\n    var name = anObject(this).name;\n    name = name === undefined ? 'AggregateError' : String(name);\n    var message = this.message;\n    message = message === undefined ? '' : String(message);\n    return name + ': ' + message;\n  })\n});\n\nif (DESCRIPTORS) defineProperty.f($AggregateError.prototype, 'errors', {\n  get: function () {\n    return getInternalAggregateErrorState(this).errors;\n  },\n  configurable: true\n});\n\n$({ global: true }, {\n  AggregateError: $AggregateError\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar newPromiseCapabilityModule = require('../internals/new-promise-capability');\nvar perform = require('../internals/perform');\n\n// `Promise.try` method\n// https://github.com/tc39/proposal-promise-try\n$({ target: 'Promise', stat: true }, {\n  'try': function (callbackfn) {\n    var promiseCapability = newPromiseCapabilityModule.f(this);\n    var result = perform(callbackfn);\n    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);\n    return promiseCapability.promise;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar aFunction = require('../internals/a-function');\nvar getBuiltIn = require('../internals/get-built-in');\nvar newPromiseCapabilityModule = require('../internals/new-promise-capability');\nvar perform = require('../internals/perform');\nvar iterate = require('../internals/iterate');\n\nvar PROMISE_ANY_ERROR = 'No one promise resolved';\n\n// `Promise.any` method\n// https://github.com/tc39/proposal-promise-any\n$({ target: 'Promise', stat: true }, {\n  any: function any(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var promiseResolve = aFunction(C.resolve);\n      var errors = [];\n      var counter = 0;\n      var remaining = 1;\n      var alreadyResolved = false;\n      iterate(iterable, function (promise) {\n        var index = counter++;\n        var alreadyRejected = false;\n        errors.push(undefined);\n        remaining++;\n        promiseResolve.call(C, promise).then(function (value) {\n          if (alreadyRejected || alreadyResolved) return;\n          alreadyResolved = true;\n          resolve(value);\n        }, function (e) {\n          if (alreadyRejected || alreadyResolved) return;\n          alreadyRejected = true;\n          errors[index] = e;\n          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));\n        });\n      });\n      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n","var isObject = require('../internals/is-object');\nvar isArray = require('../internals/is-array');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n","var bind = require('../internals/bind-context');\nvar IndexedObject = require('../internals/indexed-object');\nvar toObject = require('../internals/to-object');\nvar toLength = require('../internals/to-length');\nvar arraySpeciesCreate = require('../internals/array-species-create');\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else if (IS_EVERY) return false;  // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6)\n};\n","var classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.github.io/ecma262/#sec-isarray\nmodule.exports = Array.isArray || function isArray(arg) {\n  return classof(arg) == 'Array';\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $find = require('../internals/array-iteration').find;\nvar addToUnscopables = require('../internals/add-to-unscopables');\n\nvar FIND = 'find';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });\n\n// `Array.prototype.find` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\n$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND);\n","var global = require('../internals/global');\nvar bind = require('../internals/bind-context');\n\nvar call = Function.call;\n\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $findIndex = require('../internals/array-iteration').findIndex;\nvar addToUnscopables = require('../internals/add-to-unscopables');\n\nvar FIND_INDEX = 'findIndex';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });\n\n// `Array.prototype.findIndex` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.findindex\n$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND_INDEX);\n","require('../../modules/es.array.find');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'find');\n","'use strict';\nvar toPrimitive = require('../internals/to-primitive');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","require('../../modules/es.array.find-index');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'findIndex');\n","var $ = require('../internals/export');\nvar from = require('../internals/array-from');\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n","'use strict';\nvar bind = require('../internals/bind-context');\nvar toObject = require('../internals/to-object');\nvar callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');\nvar isArrayIteratorMethod = require('../internals/is-array-iterator-method');\nvar toLength = require('../internals/to-length');\nvar createProperty = require('../internals/create-property');\nvar getIteratorMethod = require('../internals/get-iterator-method');\n\n// `Array.from` method implementation\n// https://tc39.github.io/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var C = typeof this == 'function' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var index = 0;\n  var iteratorMethod = getIteratorMethod(O);\n  var length, result, step, iterator, next;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    result = new C();\n    for (;!(step = next.call(iterator)).done; index++) {\n      createProperty(result, index, mapping\n        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)\n        : step.value\n      );\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n    for (;length > index; index++) {\n      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n    }\n  }\n  result.length = index;\n  return result;\n};\n","require('../../modules/es.string.iterator');\nrequire('../../modules/es.array.from');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Array.from;\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !method || !fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $some = require('../internals/array-iteration').some;\nvar sloppyArrayMethod = require('../internals/sloppy-array-method');\n\n// `Array.prototype.some` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.some\n$({ target: 'Array', proto: true, forced: sloppyArrayMethod('some') }, {\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","require('../../modules/es.array.some');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'some');\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar has = require('../internals/has');\nvar classof = require('../internals/classof');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar defineProperty = require('../internals/object-define-property').f;\nvar getPrototypeOf = require('../internals/object-get-prototype-of');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar uid = require('../internals/uid');\n\nvar DataView = global.DataView;\nvar DataViewPrototype = DataView && DataView.prototype;\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar Uint8ClampedArray = global.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\nvar ObjectPrototype = Object.prototype;\nvar isPrototypeOf = ObjectPrototype.isPrototypeOf;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\nvar NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && DataView);\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQIRED = false;\nvar NAME;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar isView = function isView(it) {\n  var klass = classof(it);\n  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);\n};\n\nvar isTypedArray = function (it) {\n  return isObject(it) && has(TypedArrayConstructorsList, classof(it));\n};\n\nvar aTypedArray = function (it) {\n  if (isTypedArray(it)) return it;\n  throw TypeError('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor = function (C) {\n  if (setPrototypeOf) {\n    if (isPrototypeOf.call(TypedArray, C)) return C;\n  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {\n      return C;\n    }\n  } throw TypeError('Target is not a typed array constructor');\n};\n\nvar exportProto = function (KEY, property, forced) {\n  if (!DESCRIPTORS) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {\n      delete TypedArrayConstructor.prototype[KEY];\n    }\n  }\n  if (!TypedArrayPrototype[KEY] || forced) {\n    redefine(TypedArrayPrototype, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);\n  }\n};\n\nvar exportStatic = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS) return;\n  if (setPrototypeOf) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global[ARRAY];\n      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {\n        delete TypedArrayConstructor[KEY];\n      }\n    }\n    if (!TypedArray[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      redefine(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {\n  // eslint-disable-next-line no-shadow\n  TypedArray = function TypedArray() {\n    throw TypeError('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n  TypedArrayPrototype = TypedArray.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n}\n\nif (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQIRED = true;\n  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {\n    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {\n    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\n  }\n}\n\n// WebKit bug - the same parent prototype for typed arrays and data view\nif (NATIVE_ARRAY_BUFFER && setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {\n  setPrototypeOf(DataViewPrototype, ObjectPrototype);\n}\n\nmodule.exports = {\n  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,\n  aTypedArray: aTypedArray,\n  aTypedArrayConstructor: aTypedArrayConstructor,\n  exportProto: exportProto,\n  exportStatic: exportStatic,\n  isView: isView,\n  isTypedArray: isTypedArray,\n  TypedArray: TypedArray,\n  TypedArrayPrototype: TypedArrayPrototype\n};\n","'use strict';\nvar global = require('../internals/global');\nvar ArrayBufferViewCore = require('../internals/array-buffer-view-core');\nvar ArrayIterators = require('../modules/es.array.iterator');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar Uint8Array = global.Uint8Array;\nvar arrayValues = ArrayIterators.values;\nvar arrayKeys = ArrayIterators.keys;\nvar arrayEntries = ArrayIterators.entries;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportProto = ArrayBufferViewCore.exportProto;\nvar nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];\n\nvar CORRECT_ITER_NAME = !!nativeTypedArrayIterator\n  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);\n\nvar typedArrayValues = function values() {\n  return arrayValues.call(aTypedArray(this));\n};\n\n// `%TypedArray%.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries\nexportProto('entries', function entries() {\n  return arrayEntries.call(aTypedArray(this));\n});\n// `%TypedArray%.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys\nexportProto('keys', function keys() {\n  return arrayKeys.call(aTypedArray(this));\n});\n// `%TypedArray%.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values\nexportProto('values', typedArrayValues, !CORRECT_ITER_NAME);\n// `%TypedArray%.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator\nexportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar objectKeys = require('../internals/object-keys');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\n\nvar nativeAssign = Object.assign;\n\n// `Object.assign` method\n// https://tc39.github.io/ecma262/#sec-object.assign\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !nativeAssign || fails(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : nativeAssign;\n","var $ = require('../internals/export');\nvar assign = require('../internals/object-assign');\n\n// `Object.assign` method\n// https://tc39.github.io/ecma262/#sec-object.assign\n$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n","require('../../modules/es.object.assign');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.assign;\n","var DESCRIPTORS = require('../internals/descriptors');\nvar objectKeys = require('../internals/object-keys');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;\n\n// `Object.{ entries, values }` methods implementation\nvar createMethod = function (TO_ENTRIES) {\n  return function (it) {\n    var O = toIndexedObject(it);\n    var keys = objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {\n        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n\nmodule.exports = {\n  // `Object.entries` method\n  // https://tc39.github.io/ecma262/#sec-object.entries\n  entries: createMethod(true),\n  // `Object.values` method\n  // https://tc39.github.io/ecma262/#sec-object.values\n  values: createMethod(false)\n};\n","var $ = require('../internals/export');\nvar $entries = require('../internals/object-to-array').entries;\n\n// `Object.entries` method\n// https://tc39.github.io/ecma262/#sec-object.entries\n$({ target: 'Object', stat: true }, {\n  entries: function entries(O) {\n    return $entries(O);\n  }\n});\n","require('../../modules/es.object.entries');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.entries;\n","var $ = require('../internals/export');\nvar $values = require('../internals/object-to-array').values;\n\n// `Object.values` method\n// https://tc39.github.io/ecma262/#sec-object.values\n$({ target: 'Object', stat: true }, {\n  values: function values(O) {\n    return $values(O);\n  }\n});\n","require('../../modules/es.object.values');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.values;\n","var isRegExp = require('../internals/is-regexp');\n\nmodule.exports = function (it) {\n  if (isRegExp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n","var isObject = require('../internals/is-object');\nvar classof = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.github.io/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar MATCH = wellKnownSymbol('match');\n\nmodule.exports = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (e) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (f) { /* empty */ }\n  } return false;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar notARegExp = require('../internals/not-a-regexp');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');\n\n// `String.prototype.includes` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.includes\n$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~String(requireObjectCoercible(this))\n      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","require('../../modules/es.string.includes');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('String', 'includes');\n","'use strict';\nvar $ = require('../internals/export');\nvar toLength = require('../internals/to-length');\nvar notARegExp = require('../internals/not-a-regexp');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');\n\nvar nativeStartsWith = ''.startsWith;\nvar min = Math.min;\n\n// `String.prototype.startsWith` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.startswith\n$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('startsWith') }, {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = String(requireObjectCoercible(this));\n    notARegExp(searchString);\n    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return nativeStartsWith\n      ? nativeStartsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n","require('../../modules/es.string.starts-with');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('String', 'startsWith');\n","var $ = require('../internals/export');\nvar repeat = require('../internals/string-repeat');\n\n// `String.prototype.repeat` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.repeat\n$({ target: 'String', proto: true }, {\n  repeat: repeat\n});\n","'use strict';\nvar toInteger = require('../internals/to-integer');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `String.prototype.repeat` method implementation\n// https://tc39.github.io/ecma262/#sec-string.prototype.repeat\nmodule.exports = ''.repeat || function repeat(count) {\n  var str = String(requireObjectCoercible(this));\n  var result = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;\n  return result;\n};\n","require('../../modules/es.string.repeat');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('String', 'repeat');\n","'use strict';\nvar $ = require('../internals/export');\nvar fails = require('../internals/fails');\nvar isArray = require('../internals/is-array');\nvar isObject = require('../internals/is-object');\nvar toObject = require('../internals/to-object');\nvar toLength = require('../internals/to-length');\nvar createProperty = require('../internals/create-property');\nvar arraySpeciesCreate = require('../internals/array-species-create');\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';\n\nvar IS_CONCAT_SPREADABLE_SUPPORT = !fails(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\n\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray(O);\n};\n\nvar FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n\n// `Array.prototype.concat` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  concat: function concat(arg) { // eslint-disable-line no-unused-vars\n    var O = toObject(this);\n    var A = arraySpeciesCreate(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = toLength(E.length);\n        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty(A, n++, E);\n      }\n    }\n    A.length = n;\n    return A;\n  }\n});\n","var fails = require('../internals/fails');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  return !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n","var path = require('../internals/path');\nvar has = require('../internals/has');\nvar wrappedWellKnownSymbolModule = require('../internals/wrapped-well-known-symbol');\nvar defineProperty = require('../internals/object-define-property').f;\n\nmodule.exports = function (NAME) {\n  var Symbol = path.Symbol || (path.Symbol = {});\n  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {\n    value: wrappedWellKnownSymbolModule.f(NAME)\n  });\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar global = require('../internals/global');\nvar IS_PURE = require('../internals/is-pure');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar fails = require('../internals/fails');\nvar has = require('../internals/has');\nvar isArray = require('../internals/is-array');\nvar isObject = require('../internals/is-object');\nvar anObject = require('../internals/an-object');\nvar toObject = require('../internals/to-object');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPrimitive = require('../internals/to-primitive');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar nativeObjectCreate = require('../internals/object-create');\nvar objectKeys = require('../internals/object-keys');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar shared = require('../internals/shared');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar uid = require('../internals/uid');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar wrappedWellKnownSymbolModule = require('../internals/wrapped-well-known-symbol');\nvar defineWellKnownSymbol = require('../internals/define-well-known-symbol');\nvar setToStringTag = require('../internals/set-to-string-tag');\nvar InternalStateModule = require('../internals/internal-state');\nvar $forEach = require('../internals/array-iteration').forEach;\n\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE = 'prototype';\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(SYMBOL);\nvar ObjectPrototype = Object[PROTOTYPE];\nvar $Symbol = global.Symbol;\nvar JSON = global.JSON;\nvar nativeJSONStringify = JSON && JSON.stringify;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\nvar AllSymbols = shared('symbols');\nvar ObjectPrototypeSymbols = shared('op-symbols');\nvar StringToSymbolRegistry = shared('string-to-symbol-registry');\nvar SymbolToStringRegistry = shared('symbol-to-string-registry');\nvar WellKnownSymbolsStore = shared('wks');\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDescriptor = DESCRIPTORS && fails(function () {\n  return nativeObjectCreate(nativeDefineProperty({}, 'a', {\n    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n  nativeDefineProperty(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n  setInternalState(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!DESCRIPTORS) symbol.description = description;\n  return symbol;\n};\n\nvar isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return Object(it) instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject(O);\n  var key = toPrimitive(P, true);\n  anObject(Attributes);\n  if (has(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n    } return setSymbolDescriptor(O, key, Attributes);\n  } return nativeDefineProperty(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject(O);\n  var properties = toIndexedObject(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach(keys, function (key) {\n    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPrimitive(V, true);\n  var enumerable = nativePropertyIsEnumerable.call(this, P);\n  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject(O);\n  var key = toPrimitive(P, true);\n  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n      result.push(AllSymbols[key]);\n    }\n  });\n  return result;\n};\n\n// `Symbol` constructor\n// https://tc39.github.io/ecma262/#sec-symbol-constructor\nif (!NATIVE_SYMBOL) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var tag = uid(description);\n    var setter = function (value) {\n      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n    };\n    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });\n    return wrap(tag, description);\n  };\n\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n\n  propertyIsEnumerableModule.f = $propertyIsEnumerable;\n  definePropertyModule.f = $defineProperty;\n  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS) {\n    // https://github.com/tc39/proposal-Symbol-description\n    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n    if (!IS_PURE) {\n      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });\n    }\n  }\n\n  wrappedWellKnownSymbolModule.f = function (name) {\n    return wrap(wellKnownSymbol(name), name);\n  };\n}\n\n$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {\n  Symbol: $Symbol\n});\n\n$forEach(objectKeys(WellKnownSymbolsStore), function (name) {\n  defineWellKnownSymbol(name);\n});\n\n$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {\n  // `Symbol.for` method\n  // https://tc39.github.io/ecma262/#sec-symbol.for\n  'for': function (key) {\n    var string = String(key);\n    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = $Symbol(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry[symbol] = string;\n    return symbol;\n  },\n  // `Symbol.keyFor` method\n  // https://tc39.github.io/ecma262/#sec-symbol.keyfor\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  },\n  useSetter: function () { USE_SETTER = true; },\n  useSimple: function () { USE_SETTER = false; }\n});\n\n$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {\n  // `Object.create` method\n  // https://tc39.github.io/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // `Object.getOwnPropertySymbols` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return getOwnPropertySymbolsModule.f(toObject(it));\n  }\n});\n\n// `JSON.stringify` method behavior with symbols\n// https://tc39.github.io/ecma262/#sec-json.stringify\nJSON && $({ target: 'JSON', stat: true, forced: !NATIVE_SYMBOL || fails(function () {\n  var symbol = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  return nativeJSONStringify([symbol]) != '[null]'\n    // WebKit converts symbol values to JSON as null\n    || nativeJSONStringify({ a: symbol }) != '{}'\n    // V8 throws on boxed symbols\n    || nativeJSONStringify(Object(symbol)) != '{}';\n}) }, {\n  stringify: function stringify(it) {\n    var args = [it];\n    var index = 1;\n    var replacer, $replacer;\n    while (arguments.length > index) args.push(arguments[index++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return nativeJSONStringify.apply(JSON, args);\n  }\n});\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive\nif (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n}\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag($Symbol, SYMBOL);\n\nhiddenKeys[HIDDEN] = true;\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names').f;\n\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return nativeGetOwnPropertyNames(it);\n  } catch (error) {\n    return windowNames.slice();\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]'\n    ? getWindowNames(it)\n    : nativeGetOwnPropertyNames(toIndexedObject(it));\n};\n","exports.f = require('../internals/well-known-symbol');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.asyncIterator` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.asynciterator\ndefineWellKnownSymbol('asyncIterator');\n","// `Symbol.prototype.description` getter\n// https://tc39.github.io/ecma262/#sec-symbol.prototype.description\n'use strict';\nvar $ = require('../internals/export');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar has = require('../internals/has');\nvar isObject = require('../internals/is-object');\nvar defineProperty = require('../internals/object-define-property').f;\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\n\nvar NativeSymbol = global.Symbol;\n\nif (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||\n  // Safari 12 bug\n  NativeSymbol().description !== undefined\n)) {\n  var EmptyStringDescriptionStore = {};\n  // wrap Symbol constructor for correct work with undefined description\n  var SymbolWrapper = function Symbol() {\n    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var result = this instanceof SymbolWrapper\n      ? new NativeSymbol(description)\n      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'\n      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n    if (description === '') EmptyStringDescriptionStore[result] = true;\n    return result;\n  };\n  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n  symbolPrototype.constructor = SymbolWrapper;\n\n  var symbolToString = symbolPrototype.toString;\n  var native = String(NativeSymbol('test')) == 'Symbol(test)';\n  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n  defineProperty(symbolPrototype, 'description', {\n    configurable: true,\n    get: function description() {\n      var symbol = isObject(this) ? this.valueOf() : this;\n      var string = symbolToString.call(symbol);\n      if (has(EmptyStringDescriptionStore, symbol)) return '';\n      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');\n      return desc === '' ? undefined : desc;\n    }\n  });\n\n  $({ global: true, forced: true }, {\n    Symbol: SymbolWrapper\n  });\n}\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.hasInstance` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.hasinstance\ndefineWellKnownSymbol('hasInstance');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.isConcatSpreadable` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable\ndefineWellKnownSymbol('isConcatSpreadable');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.iterator` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.iterator\ndefineWellKnownSymbol('iterator');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.match` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.match\ndefineWellKnownSymbol('match');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.matchAll` well-known symbol\ndefineWellKnownSymbol('matchAll');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.replace` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.replace\ndefineWellKnownSymbol('replace');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.search` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.search\ndefineWellKnownSymbol('search');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.species` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.species\ndefineWellKnownSymbol('species');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.split` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.split\ndefineWellKnownSymbol('split');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.toPrimitive` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.toprimitive\ndefineWellKnownSymbol('toPrimitive');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.toStringTag` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.tostringtag\ndefineWellKnownSymbol('toStringTag');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.unscopables` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.unscopables\ndefineWellKnownSymbol('unscopables');\n","var setToStringTag = require('../internals/set-to-string-tag');\n\n// Math[@@toStringTag] property\n// https://tc39.github.io/ecma262/#sec-math-@@tostringtag\nsetToStringTag(Math, 'Math', true);\n","var global = require('../internals/global');\nvar setToStringTag = require('../internals/set-to-string-tag');\n\n// JSON[@@toStringTag] property\n// https://tc39.github.io/ecma262/#sec-json-@@tostringtag\nsetToStringTag(global.JSON, 'JSON', true);\n","require('../../modules/es.array.concat');\nrequire('../../modules/es.object.to-string');\nrequire('../../modules/es.symbol');\nrequire('../../modules/es.symbol.async-iterator');\nrequire('../../modules/es.symbol.description');\nrequire('../../modules/es.symbol.has-instance');\nrequire('../../modules/es.symbol.is-concat-spreadable');\nrequire('../../modules/es.symbol.iterator');\nrequire('../../modules/es.symbol.match');\nrequire('../../modules/es.symbol.match-all');\nrequire('../../modules/es.symbol.replace');\nrequire('../../modules/es.symbol.search');\nrequire('../../modules/es.symbol.species');\nrequire('../../modules/es.symbol.split');\nrequire('../../modules/es.symbol.to-primitive');\nrequire('../../modules/es.symbol.to-string-tag');\nrequire('../../modules/es.symbol.unscopables');\nrequire('../../modules/es.math.to-string-tag');\nrequire('../../modules/es.json.to-string-tag');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Symbol;\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.asyncDispose` well-known symbol\n// https://github.com/tc39/proposal-using-statement\ndefineWellKnownSymbol('asyncDispose');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.dispose` well-known symbol\n// https://github.com/tc39/proposal-using-statement\ndefineWellKnownSymbol('dispose');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.observable` well-known symbol\n// https://github.com/tc39/proposal-observable\ndefineWellKnownSymbol('observable');\n","var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.patternMatch` well-known symbol\n// https://github.com/tc39/proposal-pattern-matching\ndefineWellKnownSymbol('patternMatch');\n","// TODO: remove from `core-js@4`\nvar defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\ndefineWellKnownSymbol('replaceAll');\n","require('../../modules/es.symbol.iterator');\nrequire('../../modules/es.string.iterator');\nrequire('../../modules/web.dom-collections.iterator');\nvar WrappedWellKnownSymbolModule = require('../../internals/wrapped-well-known-symbol');\n\nmodule.exports = WrappedWellKnownSymbolModule.f('iterator');\n","'use strict';\nvar $ = require('../internals/export');\nvar global = require('../internals/global');\nvar isForced = require('../internals/is-forced');\nvar redefine = require('../internals/redefine');\nvar InternalMetadataModule = require('../internals/internal-metadata');\nvar iterate = require('../internals/iterate');\nvar anInstance = require('../internals/an-instance');\nvar isObject = require('../internals/is-object');\nvar fails = require('../internals/fails');\nvar checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');\nvar setToStringTag = require('../internals/set-to-string-tag');\nvar inheritIfRequired = require('../internals/inherit-if-required');\n\nmodule.exports = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {\n  var NativeConstructor = global[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var Constructor = NativeConstructor;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var exported = {};\n\n  var fixMethod = function (KEY) {\n    var nativeMethod = NativePrototype[KEY];\n    redefine(NativePrototype, KEY,\n      KEY == 'add' ? function add(value) {\n        nativeMethod.call(this, value === 0 ? 0 : value);\n        return this;\n      } : KEY == 'delete' ? function (key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'get' ? function get(key) {\n        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'has' ? function has(key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : function set(key, value) {\n        nativeMethod.call(this, key === 0 ? 0 : key, value);\n        return this;\n      }\n    );\n  };\n\n  // eslint-disable-next-line max-len\n  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n    new NativeConstructor().entries().next();\n  })))) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule.REQUIRED = true;\n  } else if (isForced(CONSTRUCTOR_NAME, true)) {\n    var instance = new Constructor();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    // eslint-disable-next-line no-new\n    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new NativeConstructor();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n\n    if (!ACCEPT_ITERABLES) {\n      Constructor = wrapper(function (dummy, iterable) {\n        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);\n        return that;\n      });\n      Constructor.prototype = NativePrototype;\n      NativePrototype.constructor = Constructor;\n    }\n\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n    // weak collections should not contains .clear method\n    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n  }\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $({ global: true, forced: Constructor != NativeConstructor }, exported);\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n","var isObject = require('../internals/is-object');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar iterate = require('../internals/iterate');\n\nmodule.exports = function from(source /* , mapFn, thisArg */) {\n  var length = arguments.length;\n  var mapFn = length > 1 ? arguments[1] : undefined;\n  var mapping, A, n, boundFunction;\n  aFunction(this);\n  mapping = mapFn !== undefined;\n  if (mapping) aFunction(mapFn);\n  if (source == undefined) return new this();\n  A = [];\n  if (mapping) {\n    n = 0;\n    boundFunction = bind(mapFn, length > 2 ? arguments[2] : undefined, 2);\n    iterate(source, function (nextItem) {\n      A.push(boundFunction(nextItem, n++));\n    });\n  } else {\n    iterate(source, A.push, A);\n  }\n  return new this(A);\n};\n","var fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n","var hiddenKeys = require('../internals/hidden-keys');\nvar isObject = require('../internals/is-object');\nvar has = require('../internals/has');\nvar defineProperty = require('../internals/object-define-property').f;\nvar uid = require('../internals/uid');\nvar FREEZING = require('../internals/freezing');\n\nvar METADATA = uid('meta');\nvar id = 0;\n\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\n\nvar setMetadata = function (it) {\n  defineProperty(it, METADATA, { value: {\n    objectID: 'O' + ++id, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData = function (it, create) {\n  if (!has(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar meta = module.exports = {\n  REQUIRED: false,\n  fastKey: fastKey,\n  getWeakData: getWeakData,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n","'use strict';\nvar defineProperty = require('../internals/object-define-property').f;\nvar create = require('../internals/object-create');\nvar redefineAll = require('../internals/redefine-all');\nvar bind = require('../internals/bind-context');\nvar anInstance = require('../internals/an-instance');\nvar iterate = require('../internals/iterate');\nvar defineIterator = require('../internals/define-iterator');\nvar setSpecies = require('../internals/set-species');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fastKey = require('../internals/internal-metadata').fastKey;\nvar InternalStateModule = require('../internals/internal-state');\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS) that.size = 0;\n      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);\n    });\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== 'F') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS) state.size = 0;\n        else that.size = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    redefineAll(C.prototype, IS_MAP ? {\n      // 23.1.3.6 Map.prototype.get(key)\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // 23.1.3.9 Map.prototype.set(key, value)\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // 23.2.3.1 Set.prototype.add(value)\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return C;\n  },\n  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return { value: undefined, done: true };\n      }\n      // return step by kind\n      if (kind == 'keys') return { value: entry.key, done: false };\n      if (kind == 'values') return { value: entry.value, done: false };\n      return { value: [entry.key, entry.value], done: false };\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n","'use strict';\nvar collection = require('../internals/collection');\nvar collectionStrong = require('../internals/collection-strong');\n\n// `Map` constructor\n// https://tc39.github.io/ecma262/#sec-map-objects\nmodule.exports = collection('Map', function (get) {\n  return function Map() { return get(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong, true);\n","require('../../modules/es.map');\nrequire('../../modules/es.object.to-string');\nrequire('../../modules/es.string.iterator');\nrequire('../../modules/web.dom-collections.iterator');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Map;\n","var $ = require('../internals/export');\nvar from = require('../internals/collection-from');\n\n// `Map.from` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\n$({ target: 'Map', stat: true }, {\n  from: from\n});\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nmodule.exports = function of() {\n  var length = arguments.length;\n  var A = new Array(length);\n  while (length--) A[length] = arguments[length];\n  return new this(A);\n};\n","var $ = require('../internals/export');\nvar of = require('../internals/collection-of');\n\n// `Map.of` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\n$({ target: 'Map', stat: true }, {\n  of: of\n});\n","'use strict';\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\n\n// https://github.com/tc39/collection-methods\nmodule.exports = function (/* ...elements */) {\n  var collection = anObject(this);\n  var remover = aFunction(collection['delete']);\n  var allDeleted = true;\n  var wasDeleted;\n  for (var k = 0, len = arguments.length; k < len; k++) {\n    wasDeleted = remover.call(collection, arguments[k]);\n    allDeleted = allDeleted && wasDeleted;\n  }\n  return !!allDeleted;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar collectionDeleteAll = require('../internals/collection-delete-all');\n\n// `Map.prototype.deleteAll` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  deleteAll: function deleteAll(/* ...elements */) {\n    return collectionDeleteAll.apply(this, arguments);\n  }\n});\n","module.exports = false;\n","var IS_PURE = require('../internals/is-pure');\nvar getIterator = require('../internals/get-iterator');\n\nmodule.exports = IS_PURE ? getIterator : function (it) {\n  // eslint-disable-next-line no-undef\n  return Map.prototype.entries.call(it);\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.every` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  every: function every(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return !iterate(iterator, function (key, value) {\n      if (!boundFunction(value, key, map)) return iterate.stop();\n    }, undefined, true, true).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar speciesConstructor = require('../internals/species-constructor');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.filter` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\n    var setter = aFunction(newMap.set);\n    iterate(iterator, function (key, value) {\n      if (boundFunction(value, key, map)) setter.call(newMap, key, value);\n    }, undefined, true, true);\n    return newMap;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.find` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  find: function find(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return iterate(iterator, function (key, value) {\n      if (boundFunction(value, key, map)) return iterate.stop(value);\n    }, undefined, true, true).result;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.findKey` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  findKey: function findKey(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return iterate(iterator, function (key, value) {\n      if (boundFunction(value, key, map)) return iterate.stop(key);\n    }, undefined, true, true).result;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar iterate = require('../internals/iterate');\nvar aFunction = require('../internals/a-function');\n\n// `Map.groupBy` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', stat: true }, {\n  groupBy: function groupBy(iterable, keyDerivative) {\n    var newMap = new this();\n    aFunction(keyDerivative);\n    var has = aFunction(newMap.has);\n    var get = aFunction(newMap.get);\n    var set = aFunction(newMap.set);\n    iterate(iterable, function (element) {\n      var derivedKey = keyDerivative(element);\n      if (!has.call(newMap, derivedKey)) set.call(newMap, derivedKey, [element]);\n      else get.call(newMap, derivedKey).push(element);\n    });\n    return newMap;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar sameValueZero = require('../internals/same-value-zero');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.includes` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  includes: function includes(searchElement) {\n    return iterate(getMapIterator(anObject(this)), function (key, value) {\n      if (sameValueZero(value, searchElement)) return iterate.stop();\n    }, undefined, true, true).stopped;\n  }\n});\n","// `SameValueZero` abstract operation\n// https://tc39.github.io/ecma262/#sec-samevaluezero\nmodule.exports = function (x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y || x != x && y != y;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar iterate = require('../internals/iterate');\nvar aFunction = require('../internals/a-function');\n\n// `Map.keyBy` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', stat: true }, {\n  keyBy: function keyBy(iterable, keyDerivative) {\n    var newMap = new this();\n    aFunction(keyDerivative);\n    var setter = aFunction(newMap.set);\n    iterate(iterable, function (element) {\n      setter.call(newMap, keyDerivative(element), element);\n    });\n    return newMap;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.includes` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  keyOf: function keyOf(searchElement) {\n    return iterate(getMapIterator(anObject(this)), function (key, value) {\n      if (value === searchElement) return iterate.stop(key);\n    }, undefined, true, true).result;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar speciesConstructor = require('../internals/species-constructor');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.mapKeys` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  mapKeys: function mapKeys(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\n    var setter = aFunction(newMap.set);\n    iterate(iterator, function (key, value) {\n      setter.call(newMap, boundFunction(value, key, map), value);\n    }, undefined, true, true);\n    return newMap;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar speciesConstructor = require('../internals/species-constructor');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.mapValues` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  mapValues: function mapValues(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();\n    var setter = aFunction(newMap.set);\n    iterate(iterator, function (key, value) {\n      setter.call(newMap, key, boundFunction(value, key, map));\n    }, undefined, true, true);\n    return newMap;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.merge` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  // eslint-disable-next-line no-unused-vars\n  merge: function merge(iterable /* ...iterbles */) {\n    var map = anObject(this);\n    var setter = aFunction(map.set);\n    var i = 0;\n    while (i < arguments.length) {\n      iterate(arguments[i++], setter, map, true);\n    }\n    return map;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Map.prototype.reduce` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var noInitial = arguments.length < 2;\n    var accumulator = noInitial ? undefined : arguments[1];\n    aFunction(callbackfn);\n    iterate(iterator, function (key, value) {\n      if (noInitial) {\n        noInitial = false;\n        accumulator = value;\n      } else {\n        accumulator = callbackfn(accumulator, value, key, map);\n      }\n    }, undefined, true, true);\n    if (noInitial) throw TypeError('Reduce of empty map with no initial value');\n    return accumulator;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getMapIterator = require('../internals/get-map-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.some` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  some: function some(callbackfn /* , thisArg */) {\n    var map = anObject(this);\n    var iterator = getMapIterator(map);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return iterate(iterator, function (key, value) {\n      if (boundFunction(value, key, map)) return iterate.stop();\n    }, undefined, true, true).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\n\n// `Set.prototype.update` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  update: function update(key, callback /* , thunk */) {\n    var map = anObject(this);\n    var length = arguments.length;\n    aFunction(callback);\n    var isPresentInMap = map.has(key);\n    if (!isPresentInMap && length < 3) {\n      throw TypeError('Updating absent value');\n    }\n    var value = isPresentInMap ? map.get(key) : aFunction(length > 2 ? arguments[2] : undefined)(key, map);\n    map.set(key, callback(value, key, map));\n    return map;\n  }\n});\n","'use strict';\nvar anObject = require('../internals/an-object');\n\n// `Map.prototype.upsert` method\n// https://github.com/thumbsupep/proposal-upsert\nmodule.exports = function upsert(key, updateFn /* , insertFn */) {\n  var map = anObject(this);\n  var insertFn = arguments.length > 2 ? arguments[2] : undefined;\n  var value;\n  if (typeof updateFn != 'function' && typeof insertFn != 'function') {\n    throw TypeError('At least one callback required');\n  }\n  if (map.has(key)) {\n    value = map.get(key);\n    if (typeof updateFn == 'function') {\n      value = updateFn(value);\n      map.set(key, value);\n    }\n  } else if (typeof insertFn == 'function') {\n    value = insertFn();\n    map.set(key, value);\n  } return value;\n};\n","'use strict';\n// TODO: remove from `core-js@4`\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar $upsert = require('../internals/map-upsert');\n\n// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.upsert`)\n// https://github.com/thumbsupep/proposal-upsert\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  updateOrInsert: $upsert\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar $upsert = require('../internals/map-upsert');\n\n// `Map.prototype.upsert` method\n// https://github.com/thumbsupep/proposal-upsert\n$({ target: 'Map', proto: true, real: true, forced: IS_PURE }, {\n  upsert: $upsert\n});\n","'use strict';\nvar collection = require('../internals/collection');\nvar collectionStrong = require('../internals/collection-strong');\n\n// `Set` constructor\n// https://tc39.github.io/ecma262/#sec-set-objects\nmodule.exports = collection('Set', function (get) {\n  return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n","require('../../modules/es.set');\nrequire('../../modules/es.object.to-string');\nrequire('../../modules/es.string.iterator');\nrequire('../../modules/web.dom-collections.iterator');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Set;\n","var $ = require('../internals/export');\nvar from = require('../internals/collection-from');\n\n// `Set.from` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from\n$({ target: 'Set', stat: true }, {\n  from: from\n});\n","var $ = require('../internals/export');\nvar of = require('../internals/collection-of');\n\n// `Set.of` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of\n$({ target: 'Set', stat: true }, {\n  of: of\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar collectionAddAll = require('../internals/collection-add-all');\n\n// `Set.prototype.addAll` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  addAll: function addAll(/* ...elements */) {\n    return collectionAddAll.apply(this, arguments);\n  }\n});\n","'use strict';\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\n\n// https://github.com/tc39/collection-methods\nmodule.exports = function (/* ...elements */) {\n  var set = anObject(this);\n  var adder = aFunction(set.add);\n  for (var k = 0, len = arguments.length; k < len; k++) {\n    adder.call(set, arguments[k]);\n  }\n  return set;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar collectionDeleteAll = require('../internals/collection-delete-all');\n\n// `Set.prototype.deleteAll` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  deleteAll: function deleteAll(/* ...elements */) {\n    return collectionDeleteAll.apply(this, arguments);\n  }\n});\n","var IS_PURE = require('../internals/is-pure');\nvar getIterator = require('../internals/get-iterator');\n\nmodule.exports = IS_PURE ? getIterator : function (it) {\n  // eslint-disable-next-line no-undef\n  return Set.prototype.values.call(it);\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.every` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  every: function every(callbackfn /* , thisArg */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return !iterate(iterator, function (value) {\n      if (!boundFunction(value, value, set)) return iterate.stop();\n    }, undefined, false, true).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar speciesConstructor = require('../internals/species-constructor');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.difference` method\n// https://github.com/tc39/proposal-set-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  difference: function difference(iterable) {\n    var set = anObject(this);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);\n    var remover = aFunction(newSet['delete']);\n    iterate(iterable, function (value) {\n      remover.call(newSet, value);\n    });\n    return newSet;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar speciesConstructor = require('../internals/species-constructor');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.filter` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();\n    var adder = aFunction(newSet.add);\n    iterate(iterator, function (value) {\n      if (boundFunction(value, value, set)) adder.call(newSet, value);\n    }, undefined, false, true);\n    return newSet;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.find` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  find: function find(callbackfn /* , thisArg */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return iterate(iterator, function (value) {\n      if (boundFunction(value, value, set)) return iterate.stop(value);\n    }, undefined, false, true).result;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar speciesConstructor = require('../internals/species-constructor');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.intersection` method\n// https://github.com/tc39/proposal-set-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  intersection: function intersection(iterable) {\n    var set = anObject(this);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();\n    var hasCheck = aFunction(set.has);\n    var adder = aFunction(newSet.add);\n    iterate(iterable, function (value) {\n      if (hasCheck.call(set, value)) adder.call(newSet, value);\n    });\n    return newSet;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.isDisjointFrom` method\n// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  isDisjointFrom: function isDisjointFrom(iterable) {\n    var set = anObject(this);\n    var hasCheck = aFunction(set.has);\n    return !iterate(iterable, function (value) {\n      if (hasCheck.call(set, value) === true) return iterate.stop();\n    }).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar getIterator = require('../internals/get-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.isSubsetOf` method\n// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  isSubsetOf: function isSubsetOf(iterable) {\n    var iterator = getIterator(this);\n    var otherSet = anObject(iterable);\n    var hasCheck = otherSet.has;\n    if (typeof hasCheck != 'function') {\n      otherSet = new (getBuiltIn('Set'))(iterable);\n      hasCheck = aFunction(otherSet.has);\n    }\n    return !iterate(iterator, function (value) {\n      if (hasCheck.call(otherSet, value) === false) return iterate.stop();\n    }, undefined, false, true).stopped;\n  }\n});\n","var anObject = require('../internals/an-object');\nvar getIteratorMethod = require('../internals/get-iterator-method');\n\nmodule.exports = function (it) {\n  var iteratorMethod = getIteratorMethod(it);\n  if (typeof iteratorMethod != 'function') {\n    throw TypeError(String(it) + ' is not iterable');\n  } return anObject(iteratorMethod.call(it));\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.isSupersetOf` method\n// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  isSupersetOf: function isSupersetOf(iterable) {\n    var set = anObject(this);\n    var hasCheck = aFunction(set.has);\n    return !iterate(iterable, function (value) {\n      if (hasCheck.call(set, value) === false) return iterate.stop();\n    }).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.join` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  join: function join(separator) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var sep = separator === undefined ? ',' : String(separator);\n    var result = [];\n    iterate(iterator, result.push, result, false, true);\n    return result.join(sep);\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar bind = require('../internals/bind-context');\nvar speciesConstructor = require('../internals/species-constructor');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.map` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  map: function map(callbackfn /* , thisArg */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();\n    var adder = aFunction(newSet.add);\n    iterate(iterator, function (value) {\n      adder.call(newSet, boundFunction(value, value, set));\n    }, undefined, false, true);\n    return newSet;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.reduce` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var noInitial = arguments.length < 2;\n    var accumulator = noInitial ? undefined : arguments[1];\n    aFunction(callbackfn);\n    iterate(iterator, function (value) {\n      if (noInitial) {\n        noInitial = false;\n        accumulator = value;\n      } else {\n        accumulator = callbackfn(accumulator, value, value, set);\n      }\n    }, undefined, false, true);\n    if (noInitial) throw TypeError('Reduce of empty set with no initial value');\n    return accumulator;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar anObject = require('../internals/an-object');\nvar bind = require('../internals/bind-context');\nvar getSetIterator = require('../internals/get-set-iterator');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.some` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  some: function some(callbackfn /* , thisArg */) {\n    var set = anObject(this);\n    var iterator = getSetIterator(set);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    return iterate(iterator, function (value) {\n      if (boundFunction(value, value, set)) return iterate.stop();\n    }, undefined, false, true).stopped;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar speciesConstructor = require('../internals/species-constructor');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.symmetricDifference` method\n// https://github.com/tc39/proposal-set-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  symmetricDifference: function symmetricDifference(iterable) {\n    var set = anObject(this);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);\n    var remover = aFunction(newSet['delete']);\n    var adder = aFunction(newSet.add);\n    iterate(iterable, function (value) {\n      remover.call(newSet, value) || adder.call(newSet, value);\n    });\n    return newSet;\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar getBuiltIn = require('../internals/get-built-in');\nvar anObject = require('../internals/an-object');\nvar aFunction = require('../internals/a-function');\nvar speciesConstructor = require('../internals/species-constructor');\nvar iterate = require('../internals/iterate');\n\n// `Set.prototype.union` method\n// https://github.com/tc39/proposal-set-methods\n$({ target: 'Set', proto: true, real: true, forced: IS_PURE }, {\n  union: function union(iterable) {\n    var set = anObject(this);\n    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);\n    iterate(iterable, aFunction(newSet.add), newSet);\n    return newSet;\n  }\n});\n","var isObject = require('../internals/is-object');\n\nvar floor = Math.floor;\n\n// `Number.isInteger` method implementation\n// https://tc39.github.io/ecma262/#sec-number.isinteger\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n","var $ = require('../internals/export');\nvar isInteger = require('../internals/is-integer');\n\n// `Number.isInteger` method\n// https://tc39.github.io/ecma262/#sec-number.isinteger\n$({ target: 'Number', stat: true }, {\n  isInteger: isInteger\n});\n","require('../../modules/es.number.is-integer');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Number.isInteger;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst stringToByteArray = function(str: string): number[] {\n  // TODO(user): Use native implementations if/when available\n  const out: number[] = [];\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192;\n      out[p++] = (c & 63) | 128;\n    } else if (\n      (c & 0xfc00) === 0xd800 &&\n      i + 1 < str.length &&\n      (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00\n    ) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n      out[p++] = (c >> 18) | 240;\n      out[p++] = ((c >> 12) & 63) | 128;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    } else {\n      out[p++] = (c >> 12) | 224;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    }\n  }\n  return out;\n};\n\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function(bytes: number[]): string {\n  // TODO(user): Use native implementations if/when available\n  const out: string[] = [];\n  let pos = 0,\n    c = 0;\n  while (pos < bytes.length) {\n    const c1 = bytes[pos++];\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      const c2 = bytes[pos++];\n      out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n    } else if (c1 > 239 && c1 < 365) {\n      // Surrogate Pair\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      const c4 = bytes[pos++];\n      const u =\n        (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n        0x10000;\n      out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n    } else {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      out[c++] = String.fromCharCode(\n        ((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)\n      );\n    }\n  }\n  return out.join('');\n};\n\ninterface Base64 {\n  byteToCharMap_: { [key: number]: string } | null;\n  charToByteMap_: { [key: string]: number } | null;\n  byteToCharMapWebSafe_: { [key: number]: string } | null;\n  charToByteMapWebSafe_: { [key: string]: number } | null;\n  ENCODED_VALS_BASE: string;\n  readonly ENCODED_VALS: string;\n  readonly ENCODED_VALS_WEBSAFE: string;\n  HAS_NATIVE_SUPPORT: boolean;\n  encodeByteArray(input: number[] | Uint8Array, webSafe?: boolean): string;\n  encodeString(input: string, webSafe?: boolean): string;\n  decodeString(input: string, webSafe: boolean): string;\n  decodeStringToByteArray(input: string, webSafe: boolean): number[];\n  init_(): void;\n}\n\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nexport const base64: Base64 = {\n  /**\n   * Maps bytes to characters.\n   */\n  byteToCharMap_: null,\n\n  /**\n   * Maps characters to bytes.\n   */\n  charToByteMap_: null,\n\n  /**\n   * Maps bytes to websafe characters.\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\n   * Maps websafe characters to bytes.\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   */\n  ENCODED_VALS_BASE:\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\n   * Our websafe alphabet.\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeByteArray(input: number[] | Uint8Array, webSafe?: boolean): string {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n\n    const byteToCharMap = webSafe\n      ? this.byteToCharMapWebSafe_!\n      : this.byteToCharMap_!;\n\n    const output = [];\n\n    for (let i = 0; i < input.length; i += 3) {\n      const byte1 = input[i];\n      const haveByte2 = i + 1 < input.length;\n      const byte2 = haveByte2 ? input[i + 1] : 0;\n      const haveByte3 = i + 2 < input.length;\n      const byte3 = haveByte3 ? input[i + 2] : 0;\n\n      const outByte1 = byte1 >> 2;\n      const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n      let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n      let outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(\n        byteToCharMap[outByte1],\n        byteToCharMap[outByte2],\n        byteToCharMap[outByte3],\n        byteToCharMap[outByte4]\n      );\n    }\n\n    return output.join('');\n  },\n\n  /**\n   * Base64-encode a string.\n   *\n   * @param input A string to encode.\n   * @param webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeString(input: string, webSafe?: boolean): string {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray(input), webSafe);\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * @param input to decode.\n   * @param webSafe True if we should use the\n   *     alternative alphabet.\n   * @return string representing the decoded value.\n   */\n  decodeString(input: string, webSafe: boolean): string {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param input Input to decode.\n   * @param webSafe True if we should use the web-safe alphabet.\n   * @return bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input: string, webSafe: boolean): number[] {\n    this.init_();\n\n    const charToByteMap = webSafe\n      ? this.charToByteMapWebSafe_!\n      : this.charToByteMap_!;\n\n    const output: number[] = [];\n\n    for (let i = 0; i < input.length; ) {\n      const byte1 = charToByteMap[input.charAt(i++)];\n\n      const haveByte2 = i < input.length;\n      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n\n      const haveByte3 = i < input.length;\n      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      const haveByte4 = i < input.length;\n      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      const outByte1 = (byte1 << 2) | (byte2 >> 4);\n      output.push(outByte1);\n\n      if (byte3 !== 64) {\n        const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n        output.push(outByte2);\n\n        if (byte4 !== 64) {\n          const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n\n/**\n * URL-safe base64 encoding\n */\nexport const base64Encode = function(str: string): string {\n  const utf8Bytes = stringToByteArray(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\n\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nexport const base64Decode = function(str: string): string | null {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n  return null;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\n\nexport const CONSTANTS = {\n  /**\n   * @define {boolean} Whether this is the client Node.js SDK.\n   */\n  NODE_CLIENT: false,\n  /**\n   * @define {boolean} Whether this is the Admin Node.js SDK.\n   */\n  NODE_ADMIN: false,\n\n  /**\n   * Firebase SDK Version\n   */\n  SDK_VERSION: '${JSCORE_VERSION}'\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CONSTANTS } from './constants';\n\n/**\n * Throws an error if the provided assertion is falsy\n */\nexport const assert = function(assertion: unknown, message: string): void {\n  if (!assertion) {\n    throw assertionError(message);\n  }\n};\n\n/**\n * Returns an Error object suitable for throwing.\n */\nexport const assertionError = function(message: string): Error {\n  return new Error(\n    'Firebase Database (' +\n      CONSTANTS.SDK_VERSION +\n      ') INTERNAL ASSERT FAILED: ' +\n      message\n  );\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nexport function deepCopy<T>(value: T): T {\n  return deepExtend(undefined, value) as T;\n}\n\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\nexport function deepExtend(target: unknown, source: unknown): unknown {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n    case Date:\n      // Treat Dates like scalars; if the target date object had any child\n      // properties - they will be lost!\n      const dateValue = source as Date;\n      return new Date(dateValue.getTime());\n\n    case Object:\n      if (target === undefined) {\n        target = {};\n      }\n      break;\n    case Array:\n      // Always copy the array source and overwrite the target.\n      target = [];\n      break;\n\n    default:\n      // Not a plain Object - treat it as a scalar.\n      return source;\n  }\n\n  for (const prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n    (target as { [key: string]: unknown })[prop] = deepExtend(\n      (target as { [key: string]: unknown })[prop],\n      (source as { [key: string]: unknown })[prop]\n    );\n  }\n\n  return target;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Deferred<R> {\n  promise: Promise<R>;\n  reject: (value?: unknown) => void = () => {};\n  resolve: (value?: unknown) => void = () => {};\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve as (value?: unknown) => void;\n      this.reject = reject as (value?: unknown) => void;\n    });\n  }\n\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   */\n  wrapCallback(\n    callback?: (error?: unknown, value?: unknown) => void\n  ): (error: unknown, value?: unknown) => void {\n    return (error, value?) => {\n      if (error) {\n        this.reject(error);\n      } else {\n        this.resolve(value);\n      }\n      if (typeof callback === 'function') {\n        // Attaching noop handler just in case developer wasn't expecting\n        // promises\n        this.promise.catch(() => {});\n\n        // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CONSTANTS } from './constants';\n\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nexport function getUA(): string {\n  if (\n    typeof navigator !== 'undefined' &&\n    typeof navigator['userAgent'] === 'string'\n  ) {\n    return navigator['userAgent'];\n  } else {\n    return '';\n  }\n}\n\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nexport function isMobileCordova(): boolean {\n  return (\n    typeof window !== 'undefined' &&\n    // @ts-ignore Setting up an broadly applicable index signature for Window\n    // just to deal with this case would probably be a bad idea.\n    !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n    /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA())\n  );\n}\n\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nexport function isNode(): boolean {\n  try {\n    return (\n      Object.prototype.toString.call(global.process) === '[object process]'\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Detect Browser Environment\n */\nexport function isBrowser(): boolean {\n  return typeof self === 'object' && self.self === self;\n}\n\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nexport function isReactNative(): boolean {\n  return (\n    typeof navigator === 'object' && navigator['product'] === 'ReactNative'\n  );\n}\n\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nexport function isNodeSdk(): boolean {\n  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\n\nexport type ErrorMap<ErrorCode extends string> = {\n  readonly [K in ErrorCode]: string;\n};\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString(): string;\n}\n\nexport interface ErrorData {\n  [key: string]: StringLike | undefined;\n}\n\nexport interface FirebaseError extends Error, ErrorData {\n  // Unique code for error - format is service/error-code-string.\n  readonly code: string;\n\n  // Developer-friendly error message.\n  readonly message: string;\n\n  // Always 'FirebaseError'.\n  readonly name: typeof ERROR_NAME;\n\n  // Where available - stack backtrace in a string.\n  readonly stack?: string;\n}\n\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nexport class FirebaseError extends Error {\n  readonly name = ERROR_NAME;\n\n  constructor(readonly code: string, message: string) {\n    super(message);\n\n    // Fix For ES5\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, FirebaseError.prototype);\n\n    // Maintains proper stack trace for where our error was thrown.\n    // Only available on V8.\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n}\n\nexport class ErrorFactory<\n  ErrorCode extends string,\n  ErrorParams extends { readonly [K in ErrorCode]?: ErrorData } = {}\n> {\n  constructor(\n    private readonly service: string,\n    private readonly serviceName: string,\n    private readonly errors: ErrorMap<ErrorCode>\n  ) {}\n\n  create<K extends ErrorCode>(\n    code: K,\n    ...data: K extends keyof ErrorParams ? [ErrorParams[K]] : []\n  ): FirebaseError {\n    const customData = (data[0] as ErrorData) || {};\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n\n    const message = template ? replaceTemplate(template, customData) : 'Error';\n    // Service Name: Error message (service/code).\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n\n    const error = new FirebaseError(fullCode, fullMessage);\n\n    // Keys with an underscore at the end of their name are not included in\n    // error.data for some reason.\n    // TODO: Replace with Object.entries when lib is updated to es2017.\n    for (const key of Object.keys(customData)) {\n      if (key.slice(-1) !== '_') {\n        if (key in error) {\n          console.warn(\n            `Overwriting FirebaseError base field \"${key}\" can cause unexpected behavior.`\n          );\n        }\n        error[key] = customData[key];\n      }\n    }\n\n    return error;\n  }\n}\n\nfunction replaceTemplate(template: string, data: ErrorData): string {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? value.toString() : `<${key}?>`;\n  });\n}\n\nconst PATTERN = /\\{\\$([^}]+)}/g;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nexport function jsonEval(str: string): unknown {\n  return JSON.parse(str);\n}\n\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data Javascript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nexport function stringify(data: unknown): string {\n  return JSON.stringify(data);\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { base64Decode } from './crypt';\nimport { jsonEval } from './json';\n\ninterface Claims {\n  [key: string]: {};\n}\n\ninterface DecodedToken {\n  header: object;\n  claims: Claims;\n  data: object;\n  signature: string;\n}\n\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nexport const decode = function(token: string): DecodedToken {\n  let header = {},\n    claims: Claims = {},\n    data = {},\n    signature = '';\n\n  try {\n    const parts = token.split('.');\n    header = jsonEval(base64Decode(parts[0]) || '') as object;\n    claims = jsonEval(base64Decode(parts[1]) || '') as Claims;\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n\n  return {\n    header,\n    claims,\n    data,\n    signature\n  };\n};\n\ninterface DecodedToken {\n  header: object;\n  claims: Claims;\n  data: object;\n  signature: string;\n}\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nexport const isValidTimestamp = function(token: string): boolean {\n  const claims: Claims = decode(token).claims;\n  const now: number = Math.floor(new Date().getTime() / 1000);\n  let validSince: number = 0,\n    validUntil: number = 0;\n\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'] as number;\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'] as number;\n    }\n\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'] as number;\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n\n  return (\n    !!now &&\n    !!validSince &&\n    !!validUntil &&\n    now >= validSince &&\n    now <= validUntil\n  );\n};\n\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nexport const issuedAtTime = function(token: string): number | null {\n  const claims: Claims = decode(token).claims;\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'] as number;\n  }\n  return null;\n};\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nexport const isValidFormat = function(token: string): boolean {\n  const decoded = decode(token),\n    claims = decoded.claims;\n\n  return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nexport const isAdmin = function(token: string): boolean {\n  const claims: Claims = decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function contains<T extends object>(obj: T, key: keyof T): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function safeGet<T extends object, K extends keyof T>(\n  obj: T,\n  key: K\n): T[K] | undefined {\n  if (Object.prototype.hasOwnProperty.call(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\nexport function isEmpty(obj: object): obj is {} {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function map<K extends string, V, U>(\n  obj: { [key in K]: V },\n  fn: (value: V, key: K, obj: { [key in K]: V }) => U,\n  contextObj?: unknown\n): { [key in K]: U } {\n  const res: Partial<{ [key in K]: U }> = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      res[key] = fn.call(contextObj, obj[key], key, obj);\n    }\n  }\n  return res as { [key in K]: U };\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nexport class Sha1 {\n  /**\n   * Holds the previous values of accumulated variables a-e in the compress_\n   * function.\n   * @private\n   */\n  private chain_: number[] = [];\n\n  /**\n   * A buffer holding the partially computed hash result.\n   * @private\n   */\n  private buf_: number[] = [];\n\n  /**\n   * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n   * as the message schedule in the docs.\n   * @private\n   */\n  private W_: number[] = [];\n\n  /**\n   * Contains data needed to pad messages less than 64 bytes.\n   * @private\n   */\n  private pad_: number[] = [];\n\n  /**\n   * @private {number}\n   */\n  private inbuf_: number = 0;\n\n  /**\n   * @private {number}\n   */\n  private total_: number = 0;\n\n  blockSize: number;\n\n  constructor() {\n    this.blockSize = 512 / 8;\n\n    this.pad_[0] = 128;\n    for (let i = 1; i < this.blockSize; ++i) {\n      this.pad_[i] = 0;\n    }\n\n    this.reset();\n  }\n\n  reset(): void {\n    this.chain_[0] = 0x67452301;\n    this.chain_[1] = 0xefcdab89;\n    this.chain_[2] = 0x98badcfe;\n    this.chain_[3] = 0x10325476;\n    this.chain_[4] = 0xc3d2e1f0;\n\n    this.inbuf_ = 0;\n    this.total_ = 0;\n  }\n\n  /**\n   * Internal compress helper function.\n   * @param buf Block to compress.\n   * @param offset Offset of the block in the buffer.\n   * @private\n   */\n  compress_(buf: number[] | Uint8Array | string, offset?: number): void {\n    if (!offset) {\n      offset = 0;\n    }\n\n    const W = this.W_;\n\n    // get 16 big endian words\n    if (typeof buf === 'string') {\n      for (let i = 0; i < 16; i++) {\n        // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n        // have a bug that turns the post-increment ++ operator into pre-increment\n        // during JIT compilation.  We have code that depends heavily on SHA-1 for\n        // correctness and which is affected by this bug, so I've removed all uses\n        // of post-increment ++ in which the result value is used.  We can revert\n        // this change once the Safari bug\n        // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n        // most clients have been updated.\n        W[i] =\n          (buf.charCodeAt(offset) << 24) |\n          (buf.charCodeAt(offset + 1) << 16) |\n          (buf.charCodeAt(offset + 2) << 8) |\n          buf.charCodeAt(offset + 3);\n        offset += 4;\n      }\n    } else {\n      for (let i = 0; i < 16; i++) {\n        W[i] =\n          (buf[offset] << 24) |\n          (buf[offset + 1] << 16) |\n          (buf[offset + 2] << 8) |\n          buf[offset + 3];\n        offset += 4;\n      }\n    }\n\n    // expand to 80 words\n    for (let i = 16; i < 80; i++) {\n      const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n      W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n    }\n\n    let a = this.chain_[0];\n    let b = this.chain_[1];\n    let c = this.chain_[2];\n    let d = this.chain_[3];\n    let e = this.chain_[4];\n    let f, k;\n\n    // TODO(user): Try to unroll this loop to speed up the computation.\n    for (let i = 0; i < 80; i++) {\n      if (i < 40) {\n        if (i < 20) {\n          f = d ^ (b & (c ^ d));\n          k = 0x5a827999;\n        } else {\n          f = b ^ c ^ d;\n          k = 0x6ed9eba1;\n        }\n      } else {\n        if (i < 60) {\n          f = (b & c) | (d & (b | c));\n          k = 0x8f1bbcdc;\n        } else {\n          f = b ^ c ^ d;\n          k = 0xca62c1d6;\n        }\n      }\n\n      const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n      e = d;\n      d = c;\n      c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n      b = a;\n      a = t;\n    }\n\n    this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n    this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n    this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n    this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n    this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n  }\n\n  update(bytes?: number[] | Uint8Array | string, length?: number): void {\n    // TODO(johnlenz): tighten the function signature and remove this check\n    if (bytes == null) {\n      return;\n    }\n\n    if (length === undefined) {\n      length = bytes.length;\n    }\n\n    const lengthMinusBlock = length - this.blockSize;\n    let n = 0;\n    // Using local instead of member variables gives ~5% speedup on Firefox 16.\n    const buf = this.buf_;\n    let inbuf = this.inbuf_;\n\n    // The outer while loop should execute at most twice.\n    while (n < length) {\n      // When we have no data in the block to top up, we can directly process the\n      // input buffer (assuming it contains sufficient data). This gives ~25%\n      // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n      // the data is provided in large chunks (or in multiples of 64 bytes).\n      if (inbuf === 0) {\n        while (n <= lengthMinusBlock) {\n          this.compress_(bytes, n);\n          n += this.blockSize;\n        }\n      }\n\n      if (typeof bytes === 'string') {\n        while (n < length) {\n          buf[inbuf] = bytes.charCodeAt(n);\n          ++inbuf;\n          ++n;\n          if (inbuf === this.blockSize) {\n            this.compress_(buf);\n            inbuf = 0;\n            // Jump to the outer loop so we use the full-block optimization.\n            break;\n          }\n        }\n      } else {\n        while (n < length) {\n          buf[inbuf] = bytes[n];\n          ++inbuf;\n          ++n;\n          if (inbuf === this.blockSize) {\n            this.compress_(buf);\n            inbuf = 0;\n            // Jump to the outer loop so we use the full-block optimization.\n            break;\n          }\n        }\n      }\n    }\n\n    this.inbuf_ = inbuf;\n    this.total_ += length;\n  }\n\n  /** @override */\n  digest(): number[] {\n    const digest: number[] = [];\n    let totalBits = this.total_ * 8;\n\n    // Add pad 0x80 0x00*.\n    if (this.inbuf_ < 56) {\n      this.update(this.pad_, 56 - this.inbuf_);\n    } else {\n      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n    }\n\n    // Add # bits.\n    for (let i = this.blockSize - 1; i >= 56; i--) {\n      this.buf_[i] = totalBits & 255;\n      totalBits /= 256; // Don't use bit-shifting here!\n    }\n\n    this.compress_(this.buf_);\n\n    let n = 0;\n    for (let i = 0; i < 5; i++) {\n      for (let j = 24; j >= 0; j -= 8) {\n        digest[n] = (this.chain_[i] >> j) & 255;\n        ++n;\n      }\n    }\n    return digest;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\nexport type PartialObserver<T> = Partial<Observer<T>>;\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  const proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError?: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete(): void {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver?: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (\n      implementsAnyMethods(nextOrObserver as { [key: string]: unknown }, [\n        'next',\n        'error',\n        'complete'\n      ])\n    ) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: nextOrObserver as NextFn<T>,\n        error,\n        complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    const unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number): void {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: unknown[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(\n  obj: { [key: string]: unknown },\n  methods: string[]\n): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (const method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nexport const validateArgCount = function(\n  fnName: string,\n  minCount: number,\n  maxCount: number,\n  argCount: number\n): void {\n  let argError;\n  if (argCount < minCount) {\n    argError = 'at least ' + minCount;\n  } else if (argCount > maxCount) {\n    argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n  }\n  if (argError) {\n    const error =\n      fnName +\n      ' failed: Was called with ' +\n      argCount +\n      (argCount === 1 ? ' argument.' : ' arguments.') +\n      ' Expects ' +\n      argError +\n      '.';\n    throw new Error(error);\n  }\n};\n\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argumentNumber The index of the argument\n * @param optional Whether or not the argument is optional\n * @return The prefix to add to the error thrown for validation.\n */\nexport function errorPrefix(\n  fnName: string,\n  argumentNumber: number,\n  optional: boolean\n): string {\n  let argName = '';\n  switch (argumentNumber) {\n    case 1:\n      argName = optional ? 'first' : 'First';\n      break;\n    case 2:\n      argName = optional ? 'second' : 'Second';\n      break;\n    case 3:\n      argName = optional ? 'third' : 'Third';\n      break;\n    case 4:\n      argName = optional ? 'fourth' : 'Fourth';\n      break;\n    default:\n      throw new Error(\n        'errorPrefix called with argumentNumber > 4.  Need to update it?'\n      );\n  }\n\n  let error = fnName + ' failed: ';\n\n  error += argName + ' argument ';\n  return error;\n}\n\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nexport function validateNamespace(\n  fnName: string,\n  argumentNumber: number,\n  namespace: string,\n  optional: boolean\n): void {\n  if (optional && !namespace) {\n    return;\n  }\n  if (typeof namespace !== 'string') {\n    //TODO: I should do more validation here. We only allow certain chars in namespaces.\n    throw new Error(\n      errorPrefix(fnName, argumentNumber, optional) +\n        'must be a valid firebase namespace.'\n    );\n  }\n}\n\nexport function validateCallback(\n  fnName: string,\n  argumentNumber: number,\n  callback: Function,\n  optional: boolean\n): void {\n  if (optional && !callback) {\n    return;\n  }\n  if (typeof callback !== 'function') {\n    throw new Error(\n      errorPrefix(fnName, argumentNumber, optional) +\n        'must be a valid function.'\n    );\n  }\n}\n\nexport function validateContextObject(\n  fnName: string,\n  argumentNumber: number,\n  context: unknown,\n  optional: boolean\n): void {\n  if (optional && !context) {\n    return;\n  }\n  if (typeof context !== 'object' || context === null) {\n    throw new Error(\n      errorPrefix(fnName, argumentNumber, optional) +\n        'must be a valid context object.'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from './assert';\n\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n\n/**\n * @param {string} str\n * @return {Array}\n */\nexport const stringToByteArray = function(str: string): number[] {\n  const out: number[] = [];\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n\n    // Is this the lead surrogate in a surrogate pair?\n    if (c >= 0xd800 && c <= 0xdbff) {\n      const high = c - 0xd800; // the high 10 bits.\n      i++;\n      assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n      const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n      c = 0x10000 + (high << 10) + low;\n    }\n\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192;\n      out[p++] = (c & 63) | 128;\n    } else if (c < 65536) {\n      out[p++] = (c >> 12) | 224;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    } else {\n      out[p++] = (c >> 18) | 240;\n      out[p++] = ((c >> 12) & 63) | 128;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    }\n  }\n  return out;\n};\n\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nexport const stringLength = function(str: string): number {\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    const c = str.charCodeAt(i);\n    if (c < 128) {\n      p++;\n    } else if (c < 2048) {\n      p += 2;\n    } else if (c >= 0xd800 && c <= 0xdbff) {\n      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n      p += 4;\n      i++; // skip trail surrogate.\n    } else {\n      p += 3;\n    }\n  }\n  return p;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A container for all of the Logger instances\n */\nexport const instances: Logger[] = [];\n\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nexport enum LogLevel {\n  DEBUG,\n  VERBOSE,\n  INFO,\n  WARN,\n  ERROR,\n  SILENT\n}\n\n/**\n * The default log level\n */\nconst defaultLogLevel: LogLevel = LogLevel.INFO;\n\n/**\n * We allow users the ability to pass their own log handler. We will pass the\n * type of log, the current log level, and any other arguments passed (i.e. the\n * messages that the user wants to log) to this function.\n */\nexport type LogHandler = (\n  loggerInstance: Logger,\n  logType: LogLevel,\n  ...args: unknown[]\n) => void;\n\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler: LogHandler = (instance, logType, ...args): void => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  const now = new Date().toISOString();\n  switch (logType) {\n    /**\n     * By default, `console.debug` is not displayed in the developer console (in\n     * chrome). To avoid forcing users to have to opt-in to these logs twice\n     * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n     * logs to the `console.log` function.\n     */\n    case LogLevel.DEBUG:\n      console.log(`[${now}]  ${instance.name}:`, ...args);\n      break;\n    case LogLevel.VERBOSE:\n      console.log(`[${now}]  ${instance.name}:`, ...args);\n      break;\n    case LogLevel.INFO:\n      console.info(`[${now}]  ${instance.name}:`, ...args);\n      break;\n    case LogLevel.WARN:\n      console.warn(`[${now}]  ${instance.name}:`, ...args);\n      break;\n    case LogLevel.ERROR:\n      console.error(`[${now}]  ${instance.name}:`, ...args);\n      break;\n    default:\n      throw new Error(\n        `Attempted to log a message with an invalid logType (value: ${logType})`\n      );\n  }\n};\n\nexport class Logger {\n  /**\n   * Gives you an instance of a Logger to capture messages according to\n   * Firebase's logging scheme.\n   *\n   * @param name The name that the logs will be associated with\n   */\n  constructor(public name: string) {\n    /**\n     * Capture the current instance for later use\n     */\n    instances.push(this);\n  }\n\n  /**\n   * The log level of the given Logger instance.\n   */\n  private _logLevel = defaultLogLevel;\n  get logLevel(): LogLevel {\n    return this._logLevel;\n  }\n  set logLevel(val: LogLevel) {\n    if (!(val in LogLevel)) {\n      throw new TypeError('Invalid value assigned to `logLevel`');\n    }\n    this._logLevel = val;\n  }\n\n  /**\n   * The log handler for the Logger instance.\n   */\n  private _logHandler: LogHandler = defaultLogHandler;\n  get logHandler(): LogHandler {\n    return this._logHandler;\n  }\n  set logHandler(val: LogHandler) {\n    if (typeof val !== 'function') {\n      throw new TypeError('Value assigned to `logHandler` must be a function');\n    }\n    this._logHandler = val;\n  }\n\n  /**\n   * The functions below are all based on the `console` interface\n   */\n\n  debug(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n  log(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n  info(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n  warn(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n  error(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppError {\n  NO_APP = 'no-app',\n  BAD_APP_NAME = 'bad-app-name',\n  DUPLICATE_APP = 'duplicate-app',\n  APP_DELETED = 'app-deleted',\n  INVALID_APP_ARGUMENT = 'invalid-app-argument'\n}\n\nconst ERRORS: ErrorMap<AppError> = {\n  [AppError.NO_APP]:\n    \"No Firebase App '{$appName}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  [AppError.BAD_APP_NAME]: \"Illegal App name: '{$appName}\",\n  [AppError.DUPLICATE_APP]: \"Firebase App named '{$appName}' already exists\",\n  [AppError.APP_DELETED]: \"Firebase App named '{$appName}' already deleted\",\n  [AppError.INVALID_APP_ARGUMENT]:\n    'firebase.{$appName}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\ntype ErrorParams = { [key in AppError]: { appName: string } };\n\nexport const ERROR_FACTORY = new ErrorFactory<AppError, ErrorParams>(\n  'app',\n  'Firebase',\n  ERRORS\n);\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_ENTRY_NAME = '[DEFAULT]';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseAppConfig\n} from '@firebase/app-types';\nimport {\n  _FirebaseApp,\n  _FirebaseNamespace,\n  FirebaseService,\n  FirebaseAppInternals\n} from '@firebase/app-types/private';\nimport { deepCopy, deepExtend } from '@firebase/util';\nimport { AppError, ERROR_FACTORY } from './errors';\nimport { DEFAULT_ENTRY_NAME } from './constants';\n\ninterface ServicesCache {\n  [name: string]: {\n    [serviceName: string]: FirebaseService;\n  };\n}\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nexport class FirebaseAppImpl implements FirebaseApp {\n  private readonly options_: FirebaseOptions;\n  private readonly name_: string;\n  private isDeleted_ = false;\n  private services_: ServicesCache = {};\n  private automaticDataCollectionEnabled_: boolean;\n  // An array to capture listeners before the true auth functions exist\n  private tokenListeners_: Array<(token: string | null) => void> = [];\n  // An array to capture requests to send events before analytics component loads. Use type any to make using function.apply easier\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private analyticsEventRequests_: any[] = [];\n\n  INTERNAL: FirebaseAppInternals;\n\n  constructor(\n    options: FirebaseOptions,\n    config: FirebaseAppConfig,\n    private readonly firebase_: _FirebaseNamespace\n  ) {\n    this.name_ = config.name!;\n    this.automaticDataCollectionEnabled_ =\n      config.automaticDataCollectionEnabled || false;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    const self = this;\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => Promise.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        this.tokenListeners_.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        this.tokenListeners_ = this.tokenListeners_.filter(\n          listener => listener !== callback\n        );\n      },\n      analytics: {\n        logEvent() {\n          self.analyticsEventRequests_.push(arguments);\n        }\n      }\n    };\n  }\n\n  get automaticDataCollectionEnabled(): boolean {\n    this.checkDestroyed_();\n    return this.automaticDataCollectionEnabled_;\n  }\n\n  set automaticDataCollectionEnabled(val) {\n    this.checkDestroyed_();\n    this.automaticDataCollectionEnabled_ = val;\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new Promise(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        const services: FirebaseService[] = [];\n\n        for (const serviceKey of Object.keys(this.services_)) {\n          for (const instanceKey of Object.keys(this.services_[serviceKey])) {\n            services.push(this.services_[serviceKey][instanceKey]);\n          }\n        }\n\n        return Promise.all(\n          services\n            .filter(service => 'INTERNAL' in service)\n            .map(service => service.INTERNAL!.delete())\n        );\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage and functions are the only ones that are leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n  /**\n   * Remove a service instance from the cache, so we will create a new instance for this service\n   * when people try to get this service again.\n   *\n   * NOTE: currently only firestore is using this functionality to support firestore shutdown.\n   *\n   * @param name The service name\n   * @param instanceIdentifier instance identifier in case multiple instances are allowed\n   * @internal\n   */\n  _removeServiceInstance(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): void {\n    if (this.services_[name] && this.services_[name][instanceIdentifier]) {\n      delete this.services_[name][instanceIdentifier];\n    }\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    if (props.INTERNAL) {\n      /**\n       * If the app has overwritten the addAuthTokenListener stub, forward\n       * the active token listeners on to the true fxn.\n       *\n       * TODO: This function is required due to our current module\n       * structure. Once we are able to rely strictly upon a single module\n       * implementation, this code should be refactored and Auth should\n       * provide these stubs and the upgrade logic\n       */\n      if (props.INTERNAL.addAuthTokenListener) {\n        for (const listener of this.tokenListeners_) {\n          this.INTERNAL.addAuthTokenListener(listener);\n        }\n        this.tokenListeners_ = [];\n      }\n\n      if (props.INTERNAL.analytics) {\n        for (const request of this.analyticsEventRequests_) {\n          // logEvent is the actual implementation at this point.\n          // We forward the queued events to it.\n          this.INTERNAL.analytics.logEvent.apply(undefined, request);\n        }\n        this.analyticsEventRequests_ = [];\n      }\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      throw ERROR_FACTORY.create(AppError.APP_DELETED, { appName: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/app');\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FirebaseApp,\n  FirebaseOptions,\n  FirebaseNamespace,\n  FirebaseAppConfig\n} from '@firebase/app-types';\nimport {\n  _FirebaseApp,\n  _FirebaseNamespace,\n  FirebaseService,\n  FirebaseServiceFactory,\n  FirebaseServiceNamespace,\n  AppHook\n} from '@firebase/app-types/private';\nimport { deepExtend, contains } from '@firebase/util';\nimport { FirebaseAppImpl } from './firebaseApp';\nimport { ERROR_FACTORY, AppError } from './errors';\nimport { FirebaseAppLiteImpl } from './lite/firebaseAppLite';\nimport { DEFAULT_ENTRY_NAME } from './constants';\nimport { version } from '../../firebase/package.json';\nimport { logger } from './logger';\n\n/**\n * Because auth can't share code with other components, we attach the utility functions\n * in an internal namespace to share code.\n * This function return a firebase namespace object without\n * any utility functions, so it can be shared between the regular firebaseNamespace and\n * the lite version.\n */\nexport function createFirebaseNamespaceCore(\n  firebaseAppImpl: typeof FirebaseAppImpl | typeof FirebaseAppLiteImpl\n): FirebaseNamespace {\n  const apps: { [name: string]: FirebaseApp } = {};\n  const factories: { [service: string]: FirebaseServiceFactory } = {};\n  const appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  const namespace: FirebaseNamespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    // @ts-ignore\n    __esModule: true,\n    initializeApp,\n    // @ts-ignore\n    app,\n    // @ts-ignore\n    apps: null,\n    SDK_VERSION: version,\n    INTERNAL: {\n      registerService,\n      removeApp,\n      factories,\n      useAsService\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (namespace as any)['default'] = namespace;\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    const app = apps[name];\n    callAppHooks(app, 'delete');\n    delete apps[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps, name)) {\n      throw ERROR_FACTORY.create(AppError.NO_APP, { appName: name });\n    }\n    return apps[name];\n  }\n\n  // @ts-ignore\n  app['App'] = firebaseAppImpl;\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(\n    options: FirebaseOptions,\n    config?: FirebaseAppConfig\n  ): FirebaseApp;\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n  function initializeApp(\n    options: FirebaseOptions,\n    rawConfig = {}\n  ): FirebaseApp {\n    if (typeof rawConfig !== 'object' || rawConfig === null) {\n      const name = rawConfig;\n      rawConfig = { name };\n    }\n\n    const config = rawConfig as FirebaseAppConfig;\n\n    if (config.name === undefined) {\n      config.name = DEFAULT_ENTRY_NAME;\n    }\n\n    const { name } = config;\n\n    if (typeof name !== 'string' || !name) {\n      throw ERROR_FACTORY.create(AppError.BAD_APP_NAME, {\n        appName: String(name)\n      });\n    }\n\n    if (contains(apps, name)) {\n      throw ERROR_FACTORY.create(AppError.DUPLICATE_APP, { appName: name });\n    }\n\n    const app = new firebaseAppImpl(\n      options,\n      config,\n      namespace as _FirebaseNamespace\n    );\n\n    apps[name] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps).map(name => apps[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: unknown },\n    appHook?: AppHook,\n    allowMultipleInstances = false\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // If re-registering a service that already exists, return existing service\n    if (factories[name]) {\n      logger.debug(`There were multiple attempts to register service ${name}.`);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return (namespace as any)[name] as FirebaseServiceNamespace<\n        FirebaseService\n      >;\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    function serviceNamespace(appArg: FirebaseApp = app()): FirebaseService {\n      // @ts-ignore\n      if (typeof appArg[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        throw ERROR_FACTORY.create(AppError.INVALID_APP_ARGUMENT, {\n          appName: name\n        });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      // @ts-ignore\n      return appArg[name]();\n    }\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    // @ts-ignore\n    namespace[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    // @ts-ignore\n    firebaseAppImpl.prototype[name] =\n      // TODO: The eslint disable can be removed and the 'ignoreRestArgs'\n      // option added to the no-explicit-any rule when ESlint releases it.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      function(...args: any) {\n        const serviceFxn = this._getService.bind(this, name);\n        return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n      };\n\n    return serviceNamespace;\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string): void {\n    for (const serviceName of Object.keys(factories)) {\n      // Ignore virtual services\n      const factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    }\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    const useService = name;\n\n    return useService;\n  }\n\n  return namespace;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseNamespace } from '@firebase/app-types';\nimport { createFirebaseNamespace } from './src/firebaseNamespace';\nimport { isNode, isBrowser } from '@firebase/util';\nimport { logger } from './src/logger';\n\n// Firebase Lite detection\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nif (isBrowser() && (self as any).firebase !== undefined) {\n  logger.warn(`\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  `);\n\n  // eslint-disable-next-line\n  const sdkVersion = ((self as any).firebase as FirebaseNamespace).SDK_VERSION;\n  if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {\n    logger.warn(`\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    `);\n  }\n}\n\nconst firebaseNamespace = createFirebaseNamespace();\nconst initializeApp = firebaseNamespace.initializeApp;\n\n// TODO: This disable can be removed and the 'ignoreRestArgs' option added to\n// the no-explicit-any rule when ESlint releases it.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfirebaseNamespace.initializeApp = function(...args: any) {\n  // Environment check before initializing app\n  // Do the check in initializeApp, so people have a chance to disable it by setting logLevel\n  // in @firebase/logger\n  if (isNode()) {\n    logger.warn(`\n      Warning: This is a browser-targeted Firebase bundle but it appears it is being\n      run in a Node environment.  If running in a Node environment, make sure you\n      are using the bundle specified by the \"main\" field in package.json.\n      \n      If you are using Webpack, you can specify \"main\" as the first item in\n      \"resolve.mainFields\":\n      https://webpack.js.org/configuration/resolve/#resolvemainfields\n      \n      If using Rollup, use the rollup-plugin-node-resolve plugin and specify \"main\"\n      as the first item in \"mainFields\", e.g. ['main', 'module'].\n      https://github.com/rollup/rollup-plugin-node-resolve\n      `);\n  }\n  return initializeApp.apply(undefined, args);\n};\n\nexport const firebase = firebaseNamespace;\n\n// eslint-disable-next-line import/no-default-export\nexport default firebase;\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseNamespace } from '@firebase/app-types';\nimport { _FirebaseApp, _FirebaseNamespace } from '@firebase/app-types/private';\nimport { createSubscribe, deepExtend, ErrorFactory } from '@firebase/util';\nimport { FirebaseAppImpl } from './firebaseApp';\nimport { createFirebaseNamespaceCore } from './firebaseNamespaceCore';\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);\n  (namespace as _FirebaseNamespace).INTERNAL = {\n    ...(namespace as _FirebaseNamespace).INTERNAL,\n    createFirebaseNamespace,\n    extendNamespace,\n    createSubscribe,\n    ErrorFactory,\n    deepExtend\n  };\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: unknown }): void {\n    deepExtend(namespace, props);\n  }\n\n  return namespace;\n}\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Bootstrap for the Google JS Library (Closure).\n *\n * In uncompiled mode base.js will attempt to load Closure's deps file, unless\n * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects\n * to include their own deps file(s) from different locations.\n *\n * Avoid including base.js more than once. This is strictly discouraged and not\n * supported. goog.require(...) won't work properly in that case.\n *\n * @provideGoog\n */\n\n\n/**\n * @define {boolean} Overridden to true by the compiler.\n */\nvar COMPILED = false;\n\n\n/**\n * Base namespace for the Closure library.  Checks to see goog is already\n * defined in the current scope before assigning to prevent clobbering if\n * base.js is loaded more than once.\n *\n * @const\n */\nvar goog = goog || {};\n\n/**\n * Reference to the global object.\n * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-global-object\n *\n * More info on this implementation here:\n * https://docs.google.com/document/d/1NAeW4Wk7I7FV0Y2tcUFvQdGMc89k2vdgSXInw8_nvCI/edit\n *\n * @const\n * @suppress {undefinedVars} self won't be referenced unless `this` is falsy.\n * @type {!Global}\n */\ngoog.global =\n    // Check `this` first for backwards compatibility.\n    // Valid unless running as an ES module or in a function wrapper called\n    //   without setting `this` properly.\n    // Note that base.js can't usefully be imported as an ES module, but it may\n    // be compiled into bundles that are loadable as ES modules.\n    this ||\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n    // For in-page browser environments and workers.\n    self;\n\n\n/**\n * A hook for overriding the define values in uncompiled mode.\n *\n * In uncompiled mode, `CLOSURE_UNCOMPILED_DEFINES` may be defined before\n * loading base.js.  If a key is defined in `CLOSURE_UNCOMPILED_DEFINES`,\n * `goog.define` will use the value instead of the default value.  This\n * allows flags to be overwritten without compilation (this is normally\n * accomplished with the compiler's \"define\" flag).\n *\n * Example:\n * <pre>\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\n * </pre>\n *\n * @type {Object<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\n\n\n/**\n * A hook for overriding the define values in uncompiled or compiled mode,\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\n *\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\n * string literals or the compiler will emit an error.\n *\n * While any @define value may be set, only those set with goog.define will be\n * effective for uncompiled code.\n *\n * Example:\n * <pre>\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;\n * </pre>\n *\n * @type {Object<string, (string|number|boolean)>|undefined}\n */\ngoog.global.CLOSURE_DEFINES;\n\n\n/**\n * Returns true if the specified value is not undefined.\n *\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined.\n */\ngoog.isDef = function(val) {\n  // void 0 always evaluates to undefined and hence we do not need to depend on\n  // the definition of the global variable named 'undefined'.\n  return val !== void 0;\n};\n\n/**\n * Returns true if the specified value is a string.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a string.\n */\ngoog.isString = function(val) {\n  return typeof val == 'string';\n};\n\n\n/**\n * Returns true if the specified value is a boolean.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is boolean.\n */\ngoog.isBoolean = function(val) {\n  return typeof val == 'boolean';\n};\n\n\n/**\n * Returns true if the specified value is a number.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a number.\n */\ngoog.isNumber = function(val) {\n  return typeof val == 'number';\n};\n\n\n/**\n * Builds an object structure for the provided namespace path, ensuring that\n * names that already exist are not overwritten. For example:\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\n * Used by goog.provide and goog.exportSymbol.\n * @param {string} name name of the object that this file defines.\n * @param {*=} opt_object the object to expose at the end of the path.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is `goog.global`.\n * @private\n */\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\n  var parts = name.split('.');\n  var cur = opt_objectToExportTo || goog.global;\n\n  // Internet Explorer exhibits strange behavior when throwing errors from\n  // methods externed in this manner.  See the testExportSymbolExceptions in\n  // base_test.html for an example.\n  if (!(parts[0] in cur) && typeof cur.execScript != 'undefined') {\n    cur.execScript('var ' + parts[0]);\n  }\n\n  for (var part; parts.length && (part = parts.shift());) {\n    if (!parts.length && goog.isDef(opt_object)) {\n      // last part and we have an object; use it\n      cur[part] = opt_object;\n    } else if (cur[part] && cur[part] !== Object.prototype[part]) {\n      cur = cur[part];\n    } else {\n      cur = cur[part] = {};\n    }\n  }\n};\n\n\n/**\n * Defines a named value. In uncompiled mode, the value is retrieved from\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\n * has the property specified, and otherwise used the defined defaultValue.\n * When compiled the default can be overridden using the compiler options or the\n * value set in the CLOSURE_DEFINES object. Returns the defined value so that it\n * can be used safely in modules. Note that the value type MUST be either\n * boolean, number, or string.\n *\n * @param {string} name The distinguished name to provide.\n * @param {T} defaultValue\n * @return {T} The defined value.\n * @template T\n */\ngoog.define = function(name, defaultValue) {\n  var value = defaultValue;\n  if (!COMPILED) {\n    var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;\n    var defines = goog.global.CLOSURE_DEFINES;\n    if (uncompiledDefines &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        /** @type {?} */ (uncompiledDefines).nodeType === undefined &&\n        Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {\n      value = uncompiledDefines[name];\n    } else if (\n        defines &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        /** @type {?} */ (defines).nodeType === undefined &&\n        Object.prototype.hasOwnProperty.call(defines, name)) {\n      value = defines[name];\n    }\n  }\n  return value;\n};\n\n\n/**\n * @define {number} Integer year indicating the set of browser features that are\n * guaranteed to be present.  This is defined to include exactly features that\n * work correctly on all \"modern\" browsers that are stable on January 1 of the\n * specified year.  For example,\n * ```js\n * if (goog.FEATURESET_YEAR >= 2019) {\n *   // use APIs known to be available on all major stable browsers Jan 1, 2019\n * } else {\n *   // polyfill for older browsers\n * }\n * ```\n * This is intended to be the primary define for removing\n * unnecessary browser compatibility code (such as ponyfills and workarounds),\n * and should inform the default value for most other defines:\n * ```js\n * const ASSUME_NATIVE_PROMISE =\n *     goog.define('ASSUME_NATIVE_PROMISE', goog.FEATURESET_YEAR >= 2016);\n * ```\n *\n * The default assumption is that IE9 is the lowest supported browser, which was\n * first available Jan 1, 2012.\n *\n * TODO(user): Reference more thorough documentation when it's available.\n */\ngoog.FEATURESET_YEAR = goog.define('goog.FEATURESET_YEAR', 2012);\n\n\n/**\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\n * that should not be included in a production. It can be easily stripped\n * by specifying --define goog.DEBUG=false to the Closure Compiler aka\n * JSCompiler. For example, most toString() methods should be declared inside an\n * \"if (goog.DEBUG)\" conditional because they are generally used for debugging\n * purposes and it is difficult for the JSCompiler to statically determine\n * whether they are used.\n */\ngoog.DEBUG = goog.define('goog.DEBUG', true);\n\n\n/**\n * @define {string} LOCALE defines the locale being used for compilation. It is\n * used to select locale specific data to be compiled in js binary. BUILD rule\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as a compiler\n * option.\n *\n * Take into account that the locale code format is important. You should use\n * the canonical Unicode format with hyphen as a delimiter. Language must be\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\n *\n * See more info about locale codes here:\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\n *\n * For language codes you should use values defined by ISO 693-1. See it here\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\n * be used instead of the new code (he).\n *\n */\ngoog.LOCALE = goog.define('goog.LOCALE', 'en');  // default to en\n\n\n/**\n * @define {boolean} Whether this code is running on trusted sites.\n *\n * On untrusted sites, several native functions can be defined or overridden by\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\n * to false forces closure to use its own implementations when possible.\n *\n * If your JavaScript can be loaded by a third party site and you are wary about\n * relying on non-standard implementations, specify\n * \"--define goog.TRUSTED_SITE=false\" to the compiler.\n */\ngoog.TRUSTED_SITE = goog.define('goog.TRUSTED_SITE', true);\n\n\n/**\n * @define {boolean} Whether a project is expected to be running in strict mode.\n *\n * This define can be used to trigger alternate implementations compatible with\n * running in EcmaScript Strict mode or warn about unavailable functionality.\n * @see https://goo.gl/PudQ4y\n *\n */\ngoog.STRICT_MODE_COMPATIBLE = goog.define('goog.STRICT_MODE_COMPATIBLE', false);\n\n\n/**\n * @define {boolean} Whether code that calls {@link goog.setTestOnly} should\n *     be disallowed in the compilation unit.\n */\ngoog.DISALLOW_TEST_ONLY_CODE =\n    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);\n\n\n/**\n * @define {boolean} Whether to use a Chrome app CSP-compliant method for\n *     loading scripts via goog.require. @see appendScriptSrcNode_.\n */\ngoog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING =\n    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);\n\n\n/**\n * Defines a namespace in Closure.\n *\n * A namespace may only be defined once in a codebase. It may be defined using\n * goog.provide() or goog.module().\n *\n * The presence of one or more goog.provide() calls in a file indicates\n * that the file defines the given objects/namespaces.\n * Provided symbols must not be null or undefined.\n *\n * In addition, goog.provide() creates the object stubs for a namespace\n * (for example, goog.provide(\"goog.foo.bar\") will create the object\n * goog.foo.bar if it does not already exist).\n *\n * Build tools also scan for provide/require/module statements\n * to discern dependencies, build dependency files (see deps.js), etc.\n *\n * @see goog.require\n * @see goog.module\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n */\ngoog.provide = function(name) {\n  if (goog.isInModuleLoader_()) {\n    throw new Error('goog.provide cannot be used within a module.');\n  }\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw new Error('Namespace \"' + name + '\" already declared.');\n    }\n  }\n\n  goog.constructNamespace_(name);\n};\n\n\n/**\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\".\n * @param {Object=} opt_obj The object to embed in the namespace.\n * @private\n */\ngoog.constructNamespace_ = function(name, opt_obj) {\n  if (!COMPILED) {\n    delete goog.implicitNamespaces_[name];\n\n    var namespace = name;\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\n      if (goog.getObjectByName(namespace)) {\n        break;\n      }\n      goog.implicitNamespaces_[namespace] = true;\n    }\n  }\n\n  goog.exportPath_(name, opt_obj);\n};\n\n\n/**\n * Returns CSP nonce, if set for any script tag.\n * @param {?Window=} opt_window The window context used to retrieve the nonce.\n *     Defaults to global context.\n * @return {string} CSP nonce or empty string if no nonce is present.\n */\ngoog.getScriptNonce = function(opt_window) {\n  if (opt_window && opt_window != goog.global) {\n    return goog.getScriptNonce_(opt_window.document);\n  }\n  if (goog.cspNonce_ === null) {\n    goog.cspNonce_ = goog.getScriptNonce_(goog.global.document);\n  }\n  return goog.cspNonce_;\n};\n\n\n/**\n * According to the CSP3 spec a nonce must be a valid base64 string.\n * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value\n * @private @const\n */\ngoog.NONCE_PATTERN_ = /^[\\w+/_-]+[=]{0,2}$/;\n\n\n/**\n * @private {?string}\n */\ngoog.cspNonce_ = null;\n\n\n/**\n * Returns CSP nonce, if set for any script tag.\n * @param {!Document} doc\n * @return {string} CSP nonce or empty string if no nonce is present.\n * @private\n */\ngoog.getScriptNonce_ = function(doc) {\n  var script = doc.querySelector && doc.querySelector('script[nonce]');\n  if (script) {\n    // Try to get the nonce from the IDL property first, because browsers that\n    // implement additional nonce protection features (currently only Chrome) to\n    // prevent nonce stealing via CSS do not expose the nonce via attributes.\n    // See https://github.com/whatwg/html/issues/2369\n    var nonce = script['nonce'] || script.getAttribute('nonce');\n    if (nonce && goog.NONCE_PATTERN_.test(nonce)) {\n      return nonce;\n    }\n  }\n  return '';\n};\n\n\n/**\n * Module identifier validation regexp.\n * Note: This is a conservative check, it is very possible to be more lenient,\n *   the primary exclusion here is \"/\" and \"\\\" and a leading \".\", these\n *   restrictions are intended to leave the door open for using goog.require\n *   with relative file paths rather than module identifiers.\n * @private\n */\ngoog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;\n\n\n/**\n * Defines a module in Closure.\n *\n * Marks that this file must be loaded as a module and claims the namespace.\n *\n * A namespace may only be defined once in a codebase. It may be defined using\n * goog.provide() or goog.module().\n *\n * goog.module() has three requirements:\n * - goog.module may not be used in the same file as goog.provide.\n * - goog.module must be the first statement in the file.\n * - only one goog.module is allowed per file.\n *\n * When a goog.module annotated file is loaded, it is enclosed in\n * a strict function closure. This means that:\n * - any variables declared in a goog.module file are private to the file\n * (not global), though the compiler is expected to inline the module.\n * - The code must obey all the rules of \"strict\" JavaScript.\n * - the file will be marked as \"use strict\"\n *\n * NOTE: unlike goog.provide, goog.module does not declare any symbols by\n * itself. If declared symbols are desired, use\n * goog.module.declareLegacyNamespace().\n *\n *\n * See the public goog.module proposal: http://goo.gl/Va1hin\n *\n * @param {string} name Namespace provided by this file in the form\n *     \"goog.package.part\", is expected but not required.\n * @return {void}\n */\ngoog.module = function(name) {\n  if (!goog.isString(name) || !name ||\n      name.search(goog.VALID_MODULE_RE_) == -1) {\n    throw new Error('Invalid module identifier');\n  }\n  if (!goog.isInGoogModuleLoader_()) {\n    throw new Error(\n        'Module ' + name + ' has been loaded incorrectly. Note, ' +\n        'modules cannot be loaded as normal scripts. They require some kind of ' +\n        'pre-processing step. You\\'re likely trying to load a module via a ' +\n        'script tag or as a part of a concatenated bundle without rewriting the ' +\n        'module. For more info see: ' +\n        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');\n  }\n  if (goog.moduleLoaderState_.moduleName) {\n    throw new Error('goog.module may only be called once per module.');\n  }\n\n  // Store the module name for the loader.\n  goog.moduleLoaderState_.moduleName = name;\n  if (!COMPILED) {\n    // Ensure that the same namespace isn't provided twice.\n    // A goog.module/goog.provide maps a goog.require to a specific file\n    if (goog.isProvided_(name)) {\n      throw new Error('Namespace \"' + name + '\" already declared.');\n    }\n    delete goog.implicitNamespaces_[name];\n  }\n};\n\n\n/**\n * @param {string} name The module identifier.\n * @return {?} The module exports for an already loaded module or null.\n *\n * Note: This is not an alternative to goog.require, it does not\n * indicate a hard dependency, instead it is used to indicate\n * an optional dependency or to access the exports of a module\n * that has already been loaded.\n * @suppress {missingProvide}\n */\ngoog.module.get = function(name) {\n\n  return goog.module.getInternal_(name);\n};\n\n\n/**\n * @param {string} name The module identifier.\n * @return {?} The module exports for an already loaded module or null.\n * @private\n */\ngoog.module.getInternal_ = function(name) {\n  if (!COMPILED) {\n    if (name in goog.loadedModules_) {\n      return goog.loadedModules_[name].exports;\n    } else if (!goog.implicitNamespaces_[name]) {\n      var ns = goog.getObjectByName(name);\n      return ns != null ? ns : null;\n    }\n  }\n  return null;\n};\n\n\n/**\n * Types of modules the debug loader can load.\n * @enum {string}\n */\ngoog.ModuleType = {\n  ES6: 'es6',\n  GOOG: 'goog'\n};\n\n\n/**\n * @private {?{\n *   moduleName: (string|undefined),\n *   declareLegacyNamespace:boolean,\n *   type: ?goog.ModuleType\n * }}\n */\ngoog.moduleLoaderState_ = null;\n\n\n/**\n * @private\n * @return {boolean} Whether a goog.module or an es6 module is currently being\n *     initialized.\n */\ngoog.isInModuleLoader_ = function() {\n  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();\n};\n\n\n/**\n * @private\n * @return {boolean} Whether a goog.module is currently being initialized.\n */\ngoog.isInGoogModuleLoader_ = function() {\n  return !!goog.moduleLoaderState_ &&\n      goog.moduleLoaderState_.type == goog.ModuleType.GOOG;\n};\n\n\n/**\n * @private\n * @return {boolean} Whether an es6 module is currently being initialized.\n */\ngoog.isInEs6ModuleLoader_ = function() {\n  var inLoader = !!goog.moduleLoaderState_ &&\n      goog.moduleLoaderState_.type == goog.ModuleType.ES6;\n\n  if (inLoader) {\n    return true;\n  }\n\n  var jscomp = goog.global['$jscomp'];\n\n  if (jscomp) {\n    // jscomp may not have getCurrentModulePath if this is a compiled bundle\n    // that has some of the runtime, but not all of it. This can happen if\n    // optimizations are turned on so the unused runtime is removed but renaming\n    // and Closure pass are off (so $jscomp is still named $jscomp and the\n    // goog.provide/require calls still exist).\n    if (typeof jscomp.getCurrentModulePath != 'function') {\n      return false;\n    }\n\n    // Bundled ES6 module.\n    return !!jscomp.getCurrentModulePath();\n  }\n\n  return false;\n};\n\n\n/**\n * Provide the module's exports as a globally accessible object under the\n * module's declared name.  This is intended to ease migration to goog.module\n * for files that have existing usages.\n * @suppress {missingProvide}\n */\ngoog.module.declareLegacyNamespace = function() {\n  if (!COMPILED && !goog.isInGoogModuleLoader_()) {\n    throw new Error(\n        'goog.module.declareLegacyNamespace must be called from ' +\n        'within a goog.module');\n  }\n  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {\n    throw new Error(\n        'goog.module must be called prior to ' +\n        'goog.module.declareLegacyNamespace.');\n  }\n  goog.moduleLoaderState_.declareLegacyNamespace = true;\n};\n\n\n/**\n * Associates an ES6 module with a Closure module ID so that is available via\n * goog.require. The associated ID  acts like a goog.module ID - it does not\n * create any global names, it is merely available via goog.require /\n * goog.module.get / goog.forwardDeclare / goog.requireType. goog.require and\n * goog.module.get will return the entire module as if it was import *'d. This\n * allows Closure files to reference ES6 modules for the sake of migration.\n *\n * @param {string} namespace\n * @suppress {missingProvide}\n */\ngoog.declareModuleId = function(namespace) {\n  if (!COMPILED) {\n    if (!goog.isInEs6ModuleLoader_()) {\n      throw new Error(\n          'goog.declareModuleId may only be called from ' +\n          'within an ES6 module');\n    }\n    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {\n      throw new Error(\n          'goog.declareModuleId may only be called once per module.');\n    }\n    if (namespace in goog.loadedModules_) {\n      throw new Error(\n          'Module with namespace \"' + namespace + '\" already exists.');\n    }\n  }\n  if (goog.moduleLoaderState_) {\n    // Not bundled - debug loading.\n    goog.moduleLoaderState_.moduleName = namespace;\n  } else {\n    // Bundled - not debug loading, no module loader state.\n    var jscomp = goog.global['$jscomp'];\n    if (!jscomp || typeof jscomp.getCurrentModulePath != 'function') {\n      throw new Error(\n          'Module with namespace \"' + namespace +\n          '\" has been loaded incorrectly.');\n    }\n    var exports = jscomp.require(jscomp.getCurrentModulePath());\n    goog.loadedModules_[namespace] = {\n      exports: exports,\n      type: goog.ModuleType.ES6,\n      moduleId: namespace\n    };\n  }\n};\n\n\n/**\n * Marks that the current file should only be used for testing, and never for\n * live code in production.\n *\n * In the case of unit tests, the message may optionally be an exact namespace\n * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra\n * provide (if not explicitly defined in the code).\n *\n * @param {string=} opt_message Optional message to add to the error that's\n *     raised when used in production code.\n */\ngoog.setTestOnly = function(opt_message) {\n  if (goog.DISALLOW_TEST_ONLY_CODE) {\n    opt_message = opt_message || '';\n    throw new Error(\n        'Importing test-only code into non-debug environment' +\n        (opt_message ? ': ' + opt_message : '.'));\n  }\n};\n\n\n/**\n * Forward declares a symbol. This is an indication to the compiler that the\n * symbol may be used in the source yet is not required and may not be provided\n * in compilation.\n *\n * The most common usage of forward declaration is code that takes a type as a\n * function parameter but does not need to require it. By forward declaring\n * instead of requiring, no hard dependency is made, and (if not required\n * elsewhere) the namespace may never be required and thus, not be pulled\n * into the JavaScript binary. If it is required elsewhere, it will be type\n * checked as normal.\n *\n * Before using goog.forwardDeclare, please read the documentation at\n * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to\n * understand the options and tradeoffs when working with forward declarations.\n *\n * @param {string} name The namespace to forward declare in the form of\n *     \"goog.package.part\".\n */\ngoog.forwardDeclare = function(name) {};\n\n\n/**\n * Forward declare type information. Used to assign types to goog.global\n * referenced object that would otherwise result in unknown type references\n * and thus block property disambiguation.\n */\ngoog.forwardDeclare('Document');\ngoog.forwardDeclare('HTMLScriptElement');\ngoog.forwardDeclare('XMLHttpRequest');\n\n\nif (!COMPILED) {\n  /**\n   * Check if the given name has been goog.provided. This will return false for\n   * names that are available only as implicit namespaces.\n   * @param {string} name name of the object to look for.\n   * @return {boolean} Whether the name has been provided.\n   * @private\n   */\n  goog.isProvided_ = function(name) {\n    return (name in goog.loadedModules_) ||\n        (!goog.implicitNamespaces_[name] &&\n         goog.isDefAndNotNull(goog.getObjectByName(name)));\n  };\n\n  /**\n   * Namespaces implicitly defined by goog.provide. For example,\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\n   * 'goog.events' must be namespaces.\n   *\n   * @type {!Object<string, (boolean|undefined)>}\n   * @private\n   */\n  goog.implicitNamespaces_ = {'goog.module': true};\n\n  // NOTE: We add goog.module as an implicit namespace as goog.module is defined\n  // here and because the existing module package has not been moved yet out of\n  // the goog.module namespace. This satisifies both the debug loader and\n  // ahead-of-time dependency management.\n}\n\n\n/**\n * Returns an object based on its fully qualified external name.  The object\n * is not found if null or undefined.  If you are using a compilation pass that\n * renames property names beware that using this function will not find renamed\n * properties.\n *\n * @param {string} name The fully qualified name.\n * @param {Object=} opt_obj The object within which to look; default is\n *     |goog.global|.\n * @return {?} The value (object or primitive) or, if not found, null.\n */\ngoog.getObjectByName = function(name, opt_obj) {\n  var parts = name.split('.');\n  var cur = opt_obj || goog.global;\n  for (var i = 0; i < parts.length; i++) {\n    cur = cur[parts[i]];\n    if (!goog.isDefAndNotNull(cur)) {\n      return null;\n    }\n  }\n  return cur;\n};\n\n\n/**\n * Globalizes a whole namespace, such as goog or goog.lang.\n *\n * @param {!Object} obj The namespace to globalize.\n * @param {Object=} opt_global The object to add the properties to.\n * @deprecated Properties may be explicitly exported to the global scope, but\n *     this should no longer be done in bulk.\n */\ngoog.globalize = function(obj, opt_global) {\n  var global = opt_global || goog.global;\n  for (var x in obj) {\n    global[x] = obj[x];\n  }\n};\n\n\n/**\n * Adds a dependency from a file to the files it requires.\n * @param {string} relPath The path to the js file.\n * @param {!Array<string>} provides An array of strings with\n *     the names of the objects this file provides.\n * @param {!Array<string>} requires An array of strings with\n *     the names of the objects this file requires.\n * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating\n *     how the file must be loaded.  The boolean 'true' is equivalent\n *     to {'module': 'goog'} for backwards-compatibility.  Valid properties\n *     and values include {'module': 'goog'} and {'lang': 'es6'}.\n */\ngoog.addDependency = function(relPath, provides, requires, opt_loadFlags) {\n  if (!COMPILED && goog.DEPENDENCIES_ENABLED) {\n    goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags);\n  }\n};\n\n\n\n\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\n// to do \"debug-mode\" development.  The dependency system can sometimes be\n// confusing, as can the debug DOM loader's asynchronous nature.\n//\n// With the DOM loader, a call to goog.require() is not blocking -- the script\n// will not load until some point after the current script.  If a namespace is\n// needed at runtime, it needs to be defined in a previous script, or loaded via\n// require() with its registered dependencies.\n//\n// User-defined namespaces may need their own deps file. For a reference on\n// creating a deps file, see:\n// Externally: https://developers.google.com/closure/library/docs/depswriter\n//\n// Because of legacy clients, the DOM loader can't be easily removed from\n// base.js.  Work was done to make it disableable or replaceable for\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\n// for example). See bootstrap/ for more information.\n\n\n/**\n * @define {boolean} Whether to enable the debug loader.\n *\n * If enabled, a call to goog.require() will attempt to load the namespace by\n * appending a script tag to the DOM (if the namespace has been registered).\n *\n * If disabled, goog.require() will simply assert that the namespace has been\n * provided (and depend on the fact that some outside tool correctly ordered\n * the script).\n */\ngoog.ENABLE_DEBUG_LOADER = goog.define('goog.ENABLE_DEBUG_LOADER', true);\n\n\n/**\n * @param {string} msg\n * @private\n */\ngoog.logToConsole_ = function(msg) {\n  if (goog.global.console) {\n    goog.global.console['error'](msg);\n  }\n};\n\n\n/**\n * Implements a system for the dynamic resolution of dependencies that works in\n * parallel with the BUILD system.\n *\n * Note that all calls to goog.require will be stripped by the compiler.\n *\n * @see goog.provide\n * @param {string} namespace Namespace (as was given in goog.provide,\n *     goog.module, or goog.declareModuleId) in the form\n *     \"goog.package.part\".\n * @return {?} If called within a goog.module or ES6 module file, the associated\n *     namespace or module otherwise null.\n */\ngoog.require = function(namespace) {\n  if (!COMPILED) {\n    // Might need to lazy load on old IE.\n    if (goog.ENABLE_DEBUG_LOADER) {\n      goog.debugLoader_.requested(namespace);\n    }\n\n    // If the object already exists we do not need to do anything.\n    if (goog.isProvided_(namespace)) {\n      if (goog.isInModuleLoader_()) {\n        return goog.module.getInternal_(namespace);\n      }\n    } else if (goog.ENABLE_DEBUG_LOADER) {\n      var moduleLoaderState = goog.moduleLoaderState_;\n      goog.moduleLoaderState_ = null;\n      try {\n        goog.debugLoader_.load_(namespace);\n      } finally {\n        goog.moduleLoaderState_ = moduleLoaderState;\n      }\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * Requires a symbol for its type information. This is an indication to the\n * compiler that the symbol may appear in type annotations, yet it is not\n * referenced at runtime.\n *\n * When called within a goog.module or ES6 module file, the return value may be\n * assigned to or destructured into a variable, but it may not be otherwise used\n * in code outside of a type annotation.\n *\n * Note that all calls to goog.requireType will be stripped by the compiler.\n *\n * @param {string} namespace Namespace (as was given in goog.provide,\n *     goog.module, or goog.declareModuleId) in the form\n *     \"goog.package.part\".\n * @return {?}\n */\ngoog.requireType = function(namespace) {\n  // Return an empty object so that single-level destructuring of the return\n  // value doesn't crash at runtime when using the debug loader. Multi-level\n  // destructuring isn't supported.\n  return {};\n};\n\n\n/**\n * Path for included scripts.\n * @type {string}\n */\ngoog.basePath = '';\n\n\n/**\n * A hook for overriding the base path.\n * @type {string|undefined}\n */\ngoog.global.CLOSURE_BASE_PATH;\n\n\n/**\n * Whether to attempt to load Closure's deps file. By default, when uncompiled,\n * deps files will attempt to be loaded.\n * @type {boolean|undefined}\n */\ngoog.global.CLOSURE_NO_DEPS;\n\n\n/**\n * A function to import a single script. This is meant to be overridden when\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\n * in the global scope so that it can be set before base.js is loaded, which\n * allows deps.js to be imported properly.\n *\n * The first parameter the script source, which is a relative URI. The second,\n * optional parameter is the script contents, in the event the script needed\n * transformation. It should return true if the script was imported, false\n * otherwise.\n * @type {(function(string, string=): boolean)|undefined}\n */\ngoog.global.CLOSURE_IMPORT_SCRIPT;\n\n\n/**\n * Null function used for default values of callbacks, etc.\n * @return {void} Nothing.\n */\ngoog.nullFunction = function() {};\n\n\n/**\n * When defining a class Foo with an abstract method bar(), you can do:\n * Foo.prototype.bar = goog.abstractMethod\n *\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\n * when bar() is invoked.\n *\n * @type {!Function}\n * @throws {Error} when invoked to indicate the method should be overridden.\n */\ngoog.abstractMethod = function() {\n  throw new Error('unimplemented abstract method');\n};\n\n\n/**\n * Adds a `getInstance` static method that always returns the same\n * instance object.\n * @param {!Function} ctor The constructor for the class to add the static\n *     method to.\n * @suppress {missingProperties} 'instance_' isn't a property on 'Function'\n *     but we don't have a better type to use here.\n */\ngoog.addSingletonGetter = function(ctor) {\n  // instance_ is immediately set to prevent issues with sealed constructors\n  // such as are encountered when a constructor is returned as the export object\n  // of a goog.module in unoptimized code.\n  // Delcare type to avoid conformance violations that ctor.instance_ is unknown\n  /** @type {undefined|!Object} @suppress {underscore} */\n  ctor.instance_ = undefined;\n  ctor.getInstance = function() {\n    if (ctor.instance_) {\n      return ctor.instance_;\n    }\n    if (goog.DEBUG) {\n      // NOTE: JSCompiler can't optimize away Array#push.\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\n    }\n    // Cast to avoid conformance violations that ctor.instance_ is unknown\n    return /** @type {!Object|undefined} */ (ctor.instance_) = new ctor;\n  };\n};\n\n\n/**\n * All singleton classes that have been instantiated, for testing. Don't read\n * it directly, use the `goog.testing.singleton` module. The compiler\n * removes this variable if unused.\n * @type {!Array<!Function>}\n * @private\n */\ngoog.instantiatedSingletons_ = [];\n\n\n/**\n * @define {boolean} Whether to load goog.modules using `eval` when using\n * the debug loader.  This provides a better debugging experience as the\n * source is unmodified and can be edited using Chrome Workspaces or similar.\n * However in some environments the use of `eval` is banned\n * so we provide an alternative.\n */\ngoog.LOAD_MODULE_USING_EVAL = goog.define('goog.LOAD_MODULE_USING_EVAL', true);\n\n\n/**\n * @define {boolean} Whether the exports of goog.modules should be sealed when\n * possible.\n */\ngoog.SEAL_MODULE_EXPORTS = goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);\n\n\n/**\n * The registry of initialized modules:\n * The module identifier or path to module exports map.\n * @private @const {!Object<string, {exports:?,type:string,moduleId:string}>}\n */\ngoog.loadedModules_ = {};\n\n\n/**\n * True if the debug loader enabled and used.\n * @const {boolean}\n */\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\n\n\n/**\n * @define {string} How to decide whether to transpile.  Valid values\n * are 'always', 'never', and 'detect'.  The default ('detect') is to\n * use feature detection to determine which language levels need\n * transpilation.\n */\n// NOTE(sdh): we could expand this to accept a language level to bypass\n// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but\n// would leave ES3 and ES5 files alone.\ngoog.TRANSPILE = goog.define('goog.TRANSPILE', 'detect');\n\n/**\n * @define {boolean} If true assume that ES modules have already been\n * transpiled by the jscompiler (in the same way that transpile.js would\n * transpile them - to jscomp modules). Useful only for servers that wish to use\n * the debug loader and transpile server side. Thus this is only respected if\n * goog.TRANSPILE is \"never\".\n */\ngoog.ASSUME_ES_MODULES_TRANSPILED =\n    goog.define('goog.ASSUME_ES_MODULES_TRANSPILED', false);\n\n\n/**\n * @define {string} If a file needs to be transpiled what the output language\n * should be. By default this is the highest language level this file detects\n * the current environment supports. Generally this flag should not be set, but\n * it could be useful to override. Example: If the current environment supports\n * ES6 then by default ES7+ files will be transpiled to ES6, unless this is\n * overridden.\n *\n * Valid values include: es3, es5, es6, es7, and es8. Anything not recognized\n * is treated as es3.\n *\n * Note that setting this value does not force transpilation. Just if\n * transpilation occurs this will be the output. So this is most useful when\n * goog.TRANSPILE is set to 'always' and then forcing the language level to be\n * something lower than what the environment detects.\n */\ngoog.TRANSPILE_TO_LANGUAGE = goog.define('goog.TRANSPILE_TO_LANGUAGE', '');\n\n\n/**\n * @define {string} Path to the transpiler.  Executing the script at this\n * path (relative to base.js) should define a function $jscomp.transpile.\n */\ngoog.TRANSPILER = goog.define('goog.TRANSPILER', 'transpile.js');\n\n\n/**\n * @package {?boolean}\n * Visible for testing.\n */\ngoog.hasBadLetScoping = null;\n\n\n/**\n * @return {boolean}\n * @package Visible for testing.\n */\ngoog.useSafari10Workaround = function() {\n  if (goog.hasBadLetScoping == null) {\n    var hasBadLetScoping;\n    try {\n      hasBadLetScoping = !eval(\n          '\"use strict\";' +\n          'let x = 1; function f() { return typeof x; };' +\n          'f() == \"number\";');\n    } catch (e) {\n      // Assume that ES6 syntax isn't supported.\n      hasBadLetScoping = false;\n    }\n    goog.hasBadLetScoping = hasBadLetScoping;\n  }\n  return goog.hasBadLetScoping;\n};\n\n\n/**\n * @param {string} moduleDef\n * @return {string}\n * @package Visible for testing.\n */\ngoog.workaroundSafari10EvalBug = function(moduleDef) {\n  return '(function(){' + moduleDef +\n      '\\n' +  // Terminate any trailing single line comment.\n      ';' +   // Terminate any trailing expression.\n      '})();\\n';\n};\n\n\n/**\n * @param {function(?):?|string} moduleDef The module definition.\n */\ngoog.loadModule = function(moduleDef) {\n  // NOTE: we allow function definitions to be either in the from\n  // of a string to eval (which keeps the original source intact) or\n  // in a eval forbidden environment (CSP) we allow a function definition\n  // which in its body must call `goog.module`, and return the exports\n  // of the module.\n  var previousState = goog.moduleLoaderState_;\n  try {\n    goog.moduleLoaderState_ = {\n      moduleName: '',\n      declareLegacyNamespace: false,\n      type: goog.ModuleType.GOOG\n    };\n    var exports;\n    if (goog.isFunction(moduleDef)) {\n      exports = moduleDef.call(undefined, {});\n    } else if (goog.isString(moduleDef)) {\n      if (goog.useSafari10Workaround()) {\n        moduleDef = goog.workaroundSafari10EvalBug(moduleDef);\n      }\n\n      exports = goog.loadModuleFromSource_.call(undefined, moduleDef);\n    } else {\n      throw new Error('Invalid module definition');\n    }\n\n    var moduleName = goog.moduleLoaderState_.moduleName;\n    if (goog.isString(moduleName) && moduleName) {\n      // Don't seal legacy namespaces as they may be used as a parent of\n      // another namespace\n      if (goog.moduleLoaderState_.declareLegacyNamespace) {\n        goog.constructNamespace_(moduleName, exports);\n      } else if (\n          goog.SEAL_MODULE_EXPORTS && Object.seal &&\n          typeof exports == 'object' && exports != null) {\n        Object.seal(exports);\n      }\n\n      var data = {\n        exports: exports,\n        type: goog.ModuleType.GOOG,\n        moduleId: goog.moduleLoaderState_.moduleName\n      };\n      goog.loadedModules_[moduleName] = data;\n    } else {\n      throw new Error('Invalid module name \\\"' + moduleName + '\\\"');\n    }\n  } finally {\n    goog.moduleLoaderState_ = previousState;\n  }\n};\n\n\n/**\n * @private @const\n */\ngoog.loadModuleFromSource_ = /** @type {function(string):?} */ (function() {\n  // NOTE: we avoid declaring parameters or local variables here to avoid\n  // masking globals or leaking values into the module definition.\n  'use strict';\n  var exports = {};\n  eval(arguments[0]);\n  return exports;\n});\n\n\n/**\n * Normalize a file path by removing redundant \"..\" and extraneous \".\" file\n * path components.\n * @param {string} path\n * @return {string}\n * @private\n */\ngoog.normalizePath_ = function(path) {\n  var components = path.split('/');\n  var i = 0;\n  while (i < components.length) {\n    if (components[i] == '.') {\n      components.splice(i, 1);\n    } else if (\n        i && components[i] == '..' && components[i - 1] &&\n        components[i - 1] != '..') {\n      components.splice(--i, 2);\n    } else {\n      i++;\n    }\n  }\n  return components.join('/');\n};\n\n\n/**\n * Provides a hook for loading a file when using Closure's goog.require() API\n * with goog.modules.  In particular this hook is provided to support Node.js.\n *\n * @type {(function(string):string)|undefined}\n */\ngoog.global.CLOSURE_LOAD_FILE_SYNC;\n\n\n/**\n * Loads file by synchronous XHR. Should not be used in production environments.\n * @param {string} src Source URL.\n * @return {?string} File contents, or null if load failed.\n * @private\n */\ngoog.loadFileSync_ = function(src) {\n  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {\n    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);\n  } else {\n    try {\n      /** @type {XMLHttpRequest} */\n      var xhr = new goog.global['XMLHttpRequest']();\n      xhr.open('get', src, false);\n      xhr.send();\n      // NOTE: Successful http: requests have a status of 200, but successful\n      // file: requests may have a status of zero.  Any other status, or a\n      // thrown exception (particularly in case of file: requests) indicates\n      // some sort of error, which we treat as a missing or unavailable file.\n      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;\n    } catch (err) {\n      // No need to rethrow or log, since errors should show up on their own.\n      return null;\n    }\n  }\n};\n\n\n/**\n * Lazily retrieves the transpiler and applies it to the source.\n * @param {string} code JS code.\n * @param {string} path Path to the code.\n * @param {string} target Language level output.\n * @return {string} The transpiled code.\n * @private\n */\ngoog.transpile_ = function(code, path, target) {\n  var jscomp = goog.global['$jscomp'];\n  if (!jscomp) {\n    goog.global['$jscomp'] = jscomp = {};\n  }\n  var transpile = jscomp.transpile;\n  if (!transpile) {\n    var transpilerPath = goog.basePath + goog.TRANSPILER;\n    var transpilerCode = goog.loadFileSync_(transpilerPath);\n    if (transpilerCode) {\n      // This must be executed synchronously, since by the time we know we\n      // need it, we're about to load and write the ES6 code synchronously,\n      // so a normal script-tag load will be too slow. Wrapped in a function\n      // so that code is eval'd in the global scope.\n      (function() {\n        (0, eval)(transpilerCode + '\\n//# sourceURL=' + transpilerPath);\n      }).call(goog.global);\n      // Even though the transpiler is optional, if $gwtExport is found, it's\n      // a sign the transpiler was loaded and the $jscomp.transpile *should*\n      // be there.\n      if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&\n          !goog.global['$gwtExport']['$jscomp']['transpile']) {\n        throw new Error(\n            'The transpiler did not properly export the \"transpile\" ' +\n            'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));\n      }\n      // transpile.js only exports a single $jscomp function, transpile. We\n      // grab just that and add it to the existing definition of $jscomp which\n      // contains the polyfills.\n      goog.global['$jscomp'].transpile =\n          goog.global['$gwtExport']['$jscomp']['transpile'];\n      jscomp = goog.global['$jscomp'];\n      transpile = jscomp.transpile;\n    }\n  }\n  if (!transpile) {\n    // The transpiler is an optional component.  If it's not available then\n    // replace it with a pass-through function that simply logs.\n    var suffix = ' requires transpilation but no transpiler was found.';\n    transpile = jscomp.transpile = function(code, path) {\n      // TODO(sdh): figure out some way to get this error to show up\n      // in test results, noting that the failure may occur in many\n      // different ways, including in loadModule() before the test\n      // runner even comes up.\n      goog.logToConsole_(path + suffix);\n      return code;\n    };\n  }\n  // Note: any transpilation errors/warnings will be logged to the console.\n  return transpile(code, path, target);\n};\n\n//==============================================================================\n// Language Enhancements\n//==============================================================================\n\n\n/**\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\n * operator in such a way that null returns 'null' and arrays return 'array'.\n * @param {?} value The value to get the type of.\n * @return {string} The name of the type.\n */\ngoog.typeOf = function(value) {\n  var s = typeof value;\n  if (s == 'object') {\n    if (value) {\n      // Check these first, so we can avoid calling Object.prototype.toString if\n      // possible.\n      //\n      // IE improperly marshals typeof across execution contexts, but a\n      // cross-context object will still return false for \"instanceof Object\".\n      if (value instanceof Array) {\n        return 'array';\n      } else if (value instanceof Object) {\n        return s;\n      }\n\n      // HACK: In order to use an Object prototype method on the arbitrary\n      //   value, the compiler requires the value be cast to type Object,\n      //   even though the ECMA spec explicitly allows it.\n      var className = Object.prototype.toString.call(\n          /** @type {!Object} */ (value));\n      // In Firefox 3.6, attempting to access iframe window objects' length\n      // property throws an NS_ERROR_FAILURE, so we need to special-case it\n      // here.\n      if (className == '[object Window]') {\n        return 'object';\n      }\n\n      // We cannot always use constructor == Array or instanceof Array because\n      // different frames have different Array objects. In IE6, if the iframe\n      // where the array was created is destroyed, the array loses its\n      // prototype. Then dereferencing val.splice here throws an exception, so\n      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\n      // so that will work. In this case, this function will return false and\n      // most array functions will still work because the array is still\n      // array-like (supports length and []) even though it has lost its\n      // prototype.\n      // Mark Miller noticed that Object.prototype.toString\n      // allows access to the unforgeable [[Class]] property.\n      //  15.2.4.2 Object.prototype.toString ( )\n      //  When the toString method is called, the following steps are taken:\n      //      1. Get the [[Class]] property of this object.\n      //      2. Compute a string value by concatenating the three strings\n      //         \"[object \", Result(1), and \"]\".\n      //      3. Return Result(2).\n      // and this behavior survives the destruction of the execution context.\n      if ((className == '[object Array]' ||\n           // In IE all non value types are wrapped as objects across window\n           // boundaries (not iframe though) so we have to do object detection\n           // for this edge case.\n           typeof value.length == 'number' &&\n               typeof value.splice != 'undefined' &&\n               typeof value.propertyIsEnumerable != 'undefined' &&\n               !value.propertyIsEnumerable('splice')\n\n               )) {\n        return 'array';\n      }\n      // HACK: There is still an array case that fails.\n      //     function ArrayImpostor() {}\n      //     ArrayImpostor.prototype = [];\n      //     var impostor = new ArrayImpostor;\n      // this can be fixed by getting rid of the fast path\n      // (value instanceof Array) and solely relying on\n      // (value && Object.prototype.toString.vall(value) === '[object Array]')\n      // but that would require many more function calls and is not warranted\n      // unless closure code is receiving objects from untrusted sources.\n\n      // IE in cross-window calls does not correctly marshal the function type\n      // (it appears just as an object) so we cannot use just typeof val ==\n      // 'function'. However, if the object has a call property, it is a\n      // function.\n      if ((className == '[object Function]' ||\n           typeof value.call != 'undefined' &&\n               typeof value.propertyIsEnumerable != 'undefined' &&\n               !value.propertyIsEnumerable('call'))) {\n        return 'function';\n      }\n\n    } else {\n      return 'null';\n    }\n\n  } else if (s == 'function' && typeof value.call == 'undefined') {\n    // In Safari typeof nodeList returns 'function', and on Firefox typeof\n    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We\n    // would like to return object for those and we can detect an invalid\n    // function by making sure that the function object has a call method.\n    return 'object';\n  }\n  return s;\n};\n\n\n/**\n * Returns true if the specified value is null.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is null.\n */\ngoog.isNull = function(val) {\n  return val === null;\n};\n\n\n/**\n * Returns true if the specified value is defined and not null.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is defined and not null.\n */\ngoog.isDefAndNotNull = function(val) {\n  // Note that undefined == null.\n  return val != null;\n};\n\n\n/**\n * Returns true if the specified value is an array.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArray = function(val) {\n  return goog.typeOf(val) == 'array';\n};\n\n\n/**\n * Returns true if the object looks like an array. To qualify as array like\n * the value needs to be either a NodeList or an object with a Number length\n * property. Note that for this function neither strings nor functions are\n * considered \"array-like\".\n *\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an array.\n */\ngoog.isArrayLike = function(val) {\n  var type = goog.typeOf(val);\n  // We do not use goog.isObject here in order to exclude function values.\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\n};\n\n\n/**\n * Returns true if the object looks like a Date. To qualify as Date-like the\n * value needs to be an object and have a getFullYear() function.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a like a Date.\n */\ngoog.isDateLike = function(val) {\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\n};\n\n\n/**\n * Returns true if the specified value is a function.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is a function.\n */\ngoog.isFunction = function(val) {\n  return goog.typeOf(val) == 'function';\n};\n\n\n/**\n * Returns true if the specified value is an object.  This includes arrays and\n * functions.\n * @param {?} val Variable to test.\n * @return {boolean} Whether variable is an object.\n */\ngoog.isObject = function(val) {\n  var type = typeof val;\n  return type == 'object' && val != null || type == 'function';\n  // return Object(val) === val also works, but is slower, especially if val is\n  // not an object.\n};\n\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. The unique ID is\n * guaranteed to be unique across the current session amongst objects that are\n * passed into `getUid`. There is no guarantee that the ID is unique or\n * consistent across sessions. It is unsafe to generate unique ID for function\n * prototypes.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\ngoog.getUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // In Opera window.hasOwnProperty exists but always returns false so we avoid\n  // using it. As a consequence the unique ID generated for BaseClass.prototype\n  // and SubClass.prototype will be the same.\n  return obj[goog.UID_PROPERTY_] ||\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\n};\n\n\n/**\n * Whether the given object is already assigned a unique ID.\n *\n * This does not modify the object.\n *\n * @param {!Object} obj The object to check.\n * @return {boolean} Whether there is an assigned unique id for the object.\n */\ngoog.hasUid = function(obj) {\n  return !!obj[goog.UID_PROPERTY_];\n};\n\n\n/**\n * Removes the unique ID from an object. This is useful if the object was\n * previously mutated using `goog.getUid` in which case the mutation is\n * undone.\n * @param {Object} obj The object to remove the unique ID field from.\n */\ngoog.removeUid = function(obj) {\n  // TODO(arv): Make the type stricter, do not accept null.\n\n  // In IE, DOM nodes are not instances of Object and throw an exception if we\n  // try to delete.  Instead we try to use removeAttribute.\n  if (obj !== null && 'removeAttribute' in obj) {\n    obj.removeAttribute(goog.UID_PROPERTY_);\n  }\n\n  try {\n    delete obj[goog.UID_PROPERTY_];\n  } catch (ex) {\n  }\n};\n\n\n/**\n * Name for unique ID property. Initialized in a way to help avoid collisions\n * with other closure JavaScript on the same page.\n * @type {string}\n * @private\n */\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * Counter for UID.\n * @type {number}\n * @private\n */\ngoog.uidCounter_ = 0;\n\n\n/**\n * Adds a hash code field to an object. The hash code is unique for the\n * given object.\n * @param {Object} obj The object to get the hash code for.\n * @return {number} The hash code for the object.\n * @deprecated Use goog.getUid instead.\n */\ngoog.getHashCode = goog.getUid;\n\n\n/**\n * Removes the hash code field from an object.\n * @param {Object} obj The object to remove the field from.\n * @deprecated Use goog.removeUid instead.\n */\ngoog.removeHashCode = goog.removeUid;\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\n * refer to themselves will cause infinite recursion.\n *\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\n * UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {*} obj The value to clone.\n * @return {*} A clone of the input value.\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\n */\ngoog.cloneObject = function(obj) {\n  var type = goog.typeOf(obj);\n  if (type == 'object' || type == 'array') {\n    if (typeof obj.clone === 'function') {\n      return obj.clone();\n    }\n    var clone = type == 'array' ? [] : {};\n    for (var key in obj) {\n      clone[key] = goog.cloneObject(obj[key]);\n    }\n    return clone;\n  }\n\n  return obj;\n};\n\n\n/**\n * A native implementation of goog.bind.\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @private\n */\ngoog.bindNative_ = function(fn, selfObj, var_args) {\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\n};\n\n\n/**\n * A pure-JS implementation of goog.bind.\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @private\n */\ngoog.bindJs_ = function(fn, selfObj, var_args) {\n  if (!fn) {\n    throw new Error();\n  }\n\n  if (arguments.length > 2) {\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\n    return function() {\n      // Prepend the bound arguments to the current arguments.\n      var newArgs = Array.prototype.slice.call(arguments);\n      Array.prototype.unshift.apply(newArgs, boundArgs);\n      return fn.apply(selfObj, newArgs);\n    };\n\n  } else {\n    return function() {\n      return fn.apply(selfObj, arguments);\n    };\n  }\n};\n\n\n/**\n * Partially applies this function to a particular 'this object' and zero or\n * more arguments. The result is a new function with some arguments of the first\n * function pre-filled and the value of this 'pre-specified'.\n *\n * Remaining arguments specified at call-time are appended to the pre-specified\n * ones.\n *\n * Also see: {@link #partial}.\n *\n * Usage:\n * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');\n * barMethBound('arg3', 'arg4');</pre>\n *\n * @param {?function(this:T, ...)} fn A function to partially apply.\n * @param {T} selfObj Specifies the object which this should point to when the\n *     function is run.\n * @param {...*} var_args Additional arguments that are partially applied to the\n *     function.\n * @return {!Function} A partially-applied form of the function goog.bind() was\n *     invoked as a method of.\n * @template T\n * @suppress {deprecated} See above.\n */\ngoog.bind = function(fn, selfObj, var_args) {\n  // TODO(nicksantos): narrow the type signature.\n  if (Function.prototype.bind &&\n      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome\n      // extension environment. This means that for Chrome extensions, they get\n      // the implementation of Function.prototype.bind that calls goog.bind\n      // instead of the native one. Even worse, we don't want to introduce a\n      // circular dependency between goog.bind and Function.prototype.bind, so\n      // we have to hack this to make sure it works correctly.\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\n    goog.bind = goog.bindNative_;\n  } else {\n    goog.bind = goog.bindJs_;\n  }\n  return goog.bind.apply(null, arguments);\n};\n\n\n/**\n * Like goog.bind(), except that a 'this object' is not required. Useful when\n * the target function is already bound.\n *\n * Usage:\n * var g = goog.partial(f, arg1, arg2);\n * g(arg3, arg4);\n *\n * @param {Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn.\n * @return {!Function} A partially-applied form of the function goog.partial()\n *     was invoked as a method of.\n */\ngoog.partial = function(fn, var_args) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Clone the array (with slice()) and append additional arguments\n    // to the existing arguments.\n    var newArgs = args.slice();\n    newArgs.push.apply(newArgs, arguments);\n    return fn.apply(/** @type {?} */ (this), newArgs);\n  };\n};\n\n\n/**\n * Copies all the members of a source object to a target object. This method\n * does not work on all browsers for all objects that contain keys such as\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\n * @param {Object} target Target.\n * @param {Object} source Source.\n */\ngoog.mixin = function(target, source) {\n  for (var x in source) {\n    target[x] = source[x];\n  }\n\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\n  // not enumerable on the prototype object (for example, isPrototypeOf from\n  // Object.prototype) but also it will not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n};\n\n\n/**\n * @return {number} An integer value representing the number of milliseconds\n *     between midnight, January 1, 1970 and the current time.\n */\ngoog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\n             // Unary plus operator converts its operand to a number which in\n             // the case of\n             // a date is done by calling getTime().\n             return +new Date();\n           });\n\n\n/**\n * Evals JavaScript in the global scope.  In IE this uses execScript, other\n * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\n * global scope (for example, in Safari), appends a script tag instead.\n * Throws an exception if neither execScript or eval is defined.\n * @param {string} script JavaScript string.\n */\ngoog.globalEval = function(script) {\n  if (goog.global.execScript) {\n    goog.global.execScript(script, 'JavaScript');\n  } else if (goog.global.eval) {\n    // Test to see if eval works\n    if (goog.evalWorksForGlobals_ == null) {\n      try {\n        goog.global.eval('var _evalTest_ = 1;');\n      } catch (ignore) {\n      }\n      if (typeof goog.global['_evalTest_'] != 'undefined') {\n        try {\n          delete goog.global['_evalTest_'];\n        } catch (ignore) {\n          // Microsoft edge fails the deletion above in strict mode.\n        }\n        goog.evalWorksForGlobals_ = true;\n      } else {\n        goog.evalWorksForGlobals_ = false;\n      }\n    }\n\n    if (goog.evalWorksForGlobals_) {\n      goog.global.eval(script);\n    } else {\n      /** @type {!Document} */\n      var doc = goog.global.document;\n      var scriptElt =\n          /** @type {!HTMLScriptElement} */ (doc.createElement('SCRIPT'));\n      scriptElt.type = 'text/javascript';\n      scriptElt.defer = false;\n      // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\n      // .text doesn't work in Safari 2.  Therefore we append a text node.\n      scriptElt.appendChild(doc.createTextNode(script));\n      doc.head.appendChild(scriptElt);\n      doc.head.removeChild(scriptElt);\n    }\n  } else {\n    throw new Error('goog.globalEval not available');\n  }\n};\n\n\n/**\n * Indicates whether or not we can call 'eval' directly to eval code in the\n * global scope. Set to a Boolean by the first call to goog.globalEval (which\n * empirically tests whether eval works for globals). @see goog.globalEval\n * @type {?boolean}\n * @private\n */\ngoog.evalWorksForGlobals_ = null;\n\n\n/**\n * Optional map of CSS class names to obfuscated names used with\n * goog.getCssName().\n * @private {!Object<string, string>|undefined}\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMapping_;\n\n\n/**\n * Optional obfuscation style for CSS class names. Should be set to either\n * 'BY_WHOLE' or 'BY_PART' if defined.\n * @type {string|undefined}\n * @private\n * @see goog.setCssNameMapping\n */\ngoog.cssNameMappingStyle_;\n\n\n\n/**\n * A hook for modifying the default behavior goog.getCssName. The function\n * if present, will receive the standard output of the goog.getCssName as\n * its input.\n *\n * @type {(function(string):string)|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAP_FN;\n\n\n/**\n * Handles strings that are intended to be used as CSS class names.\n *\n * This function works in tandem with @see goog.setCssNameMapping.\n *\n * Without any mapping set, the arguments are simple joined with a hyphen and\n * passed through unaltered.\n *\n * When there is a mapping, there are two possible styles in which these\n * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)\n * of the passed in css name is rewritten according to the map. In the BY_WHOLE\n * style, the full css name is looked up in the map directly. If a rewrite is\n * not specified by the map, the compiler will output a warning.\n *\n * When the mapping is passed to the compiler, it will replace calls to\n * goog.getCssName with the strings from the mapping, e.g.\n *     var x = goog.getCssName('foo');\n *     var y = goog.getCssName(this.baseClass, 'active');\n *  becomes:\n *     var x = 'foo';\n *     var y = this.baseClass + '-active';\n *\n * If one argument is passed it will be processed, if two are passed only the\n * modifier will be processed, as it is assumed the first argument was generated\n * as a result of calling goog.getCssName.\n *\n * @param {string} className The class name.\n * @param {string=} opt_modifier A modifier to be appended to the class name.\n * @return {string} The class name or the concatenation of the class name and\n *     the modifier.\n */\ngoog.getCssName = function(className, opt_modifier) {\n  // String() is used for compatibility with compiled soy where the passed\n  // className can be non-string objects.\n  if (String(className).charAt(0) == '.') {\n    throw new Error(\n        'className passed in goog.getCssName must not start with \".\".' +\n        ' You passed: ' + className);\n  }\n\n  var getMapping = function(cssName) {\n    return goog.cssNameMapping_[cssName] || cssName;\n  };\n\n  var renameByParts = function(cssName) {\n    // Remap all the parts individually.\n    var parts = cssName.split('-');\n    var mapped = [];\n    for (var i = 0; i < parts.length; i++) {\n      mapped.push(getMapping(parts[i]));\n    }\n    return mapped.join('-');\n  };\n\n  var rename;\n  if (goog.cssNameMapping_) {\n    rename =\n        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;\n  } else {\n    rename = function(a) {\n      return a;\n    };\n  }\n\n  var result =\n      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);\n\n  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further\n  // processing of the class name.\n  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {\n    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);\n  }\n\n  return result;\n};\n\n\n/**\n * Sets the map to check when returning a value from goog.getCssName(). Example:\n * <pre>\n * goog.setCssNameMapping({\n *   \"goog\": \"a\",\n *   \"disabled\": \"b\",\n * });\n *\n * var x = goog.getCssName('goog');\n * // The following evaluates to: \"a a-b\".\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\n * </pre>\n * When declared as a map of string literals to string literals, the JSCompiler\n * will replace all calls to goog.getCssName() using the supplied map if the\n * --process_closure_primitives flag is set.\n *\n * @param {!Object} mapping A map of strings to strings where keys are possible\n *     arguments to goog.getCssName() and values are the corresponding values\n *     that should be returned.\n * @param {string=} opt_style The style of css name mapping. There are two valid\n *     options: 'BY_PART', and 'BY_WHOLE'.\n * @see goog.getCssName for a description.\n */\ngoog.setCssNameMapping = function(mapping, opt_style) {\n  goog.cssNameMapping_ = mapping;\n  goog.cssNameMappingStyle_ = opt_style;\n};\n\n\n/**\n * To use CSS renaming in compiled mode, one of the input files should have a\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\n * mode, JavaScript code should be loaded before this base.js file that declares\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\n * are made in uncompiled mode.\n *\n * A hook for overriding the CSS name mapping.\n * @type {!Object<string, string>|undefined}\n */\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\n\n\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\n  // This does not call goog.setCssNameMapping() because the JSCompiler\n  // requires that goog.setCssNameMapping() be called with an object literal.\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\n}\n\n\n/**\n * Gets a localized message.\n *\n * This function is a compiler primitive. If you give the compiler a localized\n * message bundle, it will replace the string at compile-time with a localized\n * version, and expand goog.getMsg call to a concatenated string.\n *\n * Messages must be initialized in the form:\n * <code>\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\n * </code>\n *\n * This function produces a string which should be treated as plain text. Use\n * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to\n * produce SafeHtml.\n *\n * @param {string} str Translatable string, places holders in the form {$foo}.\n * @param {Object<string, string>=} opt_values Maps place holder name to value.\n * @return {string} message with placeholders filled.\n */\ngoog.getMsg = function(str, opt_values) {\n  if (opt_values) {\n    str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {\n      return (opt_values != null && key in opt_values) ? opt_values[key] :\n                                                         match;\n    });\n  }\n  return str;\n};\n\n\n/**\n * Gets a localized message. If the message does not have a translation, gives a\n * fallback message.\n *\n * This is useful when introducing a new message that has not yet been\n * translated into all languages.\n *\n * This function is a compiler primitive. Must be used in the form:\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\n * where MSG_A and MSG_B were initialized with goog.getMsg.\n *\n * @param {string} a The preferred message.\n * @param {string} b The fallback message.\n * @return {string} The best translated message.\n */\ngoog.getMsgWithFallback = function(a, b) {\n  return a;\n};\n\n\n/**\n * Exposes an unobfuscated global namespace path for the given object.\n * Note that fields of the exported object *will* be obfuscated, unless they are\n * exported in turn via this function or goog.exportProperty.\n *\n * Also handy for making public items that are defined in anonymous closures.\n *\n * ex. goog.exportSymbol('public.path.Foo', Foo);\n *\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n *     public.path.Foo.staticFunction();\n *\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n *                       Foo.prototype.myMethod);\n *     new public.path.Foo().myMethod();\n *\n * @param {string} publicPath Unobfuscated name to export.\n * @param {*} object Object the name should point to.\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\n *     is goog.global.\n */\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\n};\n\n\n/**\n * Exports a property unobfuscated into the object's namespace.\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n * @param {Object} object Object whose static property is being exported.\n * @param {string} publicName Unobfuscated name to export.\n * @param {*} symbol Object the name should point to.\n */\ngoog.exportProperty = function(object, publicName, symbol) {\n  object[publicName] = symbol;\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n * <pre>\n * function ParentClass(a, b) { }\n * ParentClass.prototype.foo = function(a) { };\n *\n * function ChildClass(a, b, c) {\n *   ChildClass.base(this, 'constructor', a, b);\n * }\n * goog.inherits(ChildClass, ParentClass);\n *\n * var child = new ChildClass('a', 'b', 'see');\n * child.foo(); // This works.\n * </pre>\n *\n * @param {!Function} childCtor Child class.\n * @param {!Function} parentCtor Parent class.\n * @suppress {strictMissingProperties} superClass_ and base is not defined on\n *    Function.\n */\ngoog.inherits = function(childCtor, parentCtor) {\n  /** @constructor */\n  function tempCtor() {}\n  tempCtor.prototype = parentCtor.prototype;\n  childCtor.superClass_ = parentCtor.prototype;\n  childCtor.prototype = new tempCtor();\n  /** @override */\n  childCtor.prototype.constructor = childCtor;\n\n  /**\n   * Calls superclass constructor/method.\n   *\n   * This function is only available if you use goog.inherits to\n   * express inheritance relationships between classes.\n   *\n   * NOTE: This is a replacement for goog.base and for superClass_\n   * property defined in childCtor.\n   *\n   * @param {!Object} me Should always be \"this\".\n   * @param {string} methodName The method name to call. Calling\n   *     superclass constructor can be done with the special string\n   *     'constructor'.\n   * @param {...*} var_args The arguments to pass to superclass\n   *     method/constructor.\n   * @return {*} The return value of the superclass method/constructor.\n   */\n  childCtor.base = function(me, methodName, var_args) {\n    // Copying using loop to avoid deop due to passing arguments object to\n    // function. This is faster in many JS engines as of late 2014.\n    var args = new Array(arguments.length - 2);\n    for (var i = 2; i < arguments.length; i++) {\n      args[i - 2] = arguments[i];\n    }\n    return parentCtor.prototype[methodName].apply(me, args);\n  };\n};\n\n\n/**\n * Call up to the superclass.\n *\n * If this is called from a constructor, then this calls the superclass\n * constructor with arguments 1-N.\n *\n * If this is called from a prototype method, then you must pass the name of the\n * method as the second argument to this function. If you do not, you will get a\n * runtime error. This calls the superclass' method with arguments 2-N.\n *\n * This function only works if you use goog.inherits to express inheritance\n * relationships between your classes.\n *\n * This function is a compiler primitive. At compile-time, the compiler will do\n * macro expansion to remove a lot of the extra overhead that this function\n * introduces. The compiler will also enforce a lot of the assumptions that this\n * function makes, and treat it as a compiler error if you break them.\n *\n * @param {!Object} me Should always be \"this\".\n * @param {*=} opt_methodName The method name if calling a super method.\n * @param {...*} var_args The rest of the arguments.\n * @return {*} The return value of the superclass method.\n * @suppress {es5Strict} This method can not be used in strict mode, but\n *     all Closure Library consumers must depend on this file.\n * @deprecated goog.base is not strict mode compatible.  Prefer the static\n *     \"base\" method added to the constructor by goog.inherits\n *     or ES6 classes and the \"super\" keyword.\n */\ngoog.base = function(me, opt_methodName, var_args) {\n  var caller = arguments.callee.caller;\n\n  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {\n    throw new Error(\n        'arguments.caller not defined.  goog.base() cannot be used ' +\n        'with strict mode code. See ' +\n        'http://www.ecma-international.org/ecma-262/5.1/#sec-C');\n  }\n\n  if (typeof caller.superClass_ !== 'undefined') {\n    // Copying using loop to avoid deop due to passing arguments object to\n    // function. This is faster in many JS engines as of late 2014.\n    var ctorArgs = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n      ctorArgs[i - 1] = arguments[i];\n    }\n    // This is a constructor. Call the superclass constructor.\n    return /** @type {!Function} */ (caller.superClass_)\n        .constructor.apply(me, ctorArgs);\n  }\n\n  if (typeof opt_methodName != 'string' && typeof opt_methodName != 'symbol') {\n    throw new Error(\n        'method names provided to goog.base must be a string or a symbol');\n  }\n\n  // Copying using loop to avoid deop due to passing arguments object to\n  // function. This is faster in many JS engines as of late 2014.\n  var args = new Array(arguments.length - 2);\n  for (var i = 2; i < arguments.length; i++) {\n    args[i - 2] = arguments[i];\n  }\n  var foundCaller = false;\n  for (var proto = me.constructor.prototype; proto;\n       proto = Object.getPrototypeOf(proto)) {\n    if (proto[opt_methodName] === caller) {\n      foundCaller = true;\n    } else if (foundCaller) {\n      return proto[opt_methodName].apply(me, args);\n    }\n  }\n\n  // If we did not find the caller in the prototype chain, then one of two\n  // things happened:\n  // 1) The caller is an instance method.\n  // 2) This method was not called by the right caller.\n  if (me[opt_methodName] === caller) {\n    return me.constructor.prototype[opt_methodName].apply(me, args);\n  } else {\n    throw new Error(\n        'goog.base called from a method of one name ' +\n        'to a method of a different name');\n  }\n};\n\n\n/**\n * Allow for aliasing within scope functions.  This function exists for\n * uncompiled code - in compiled code the calls will be inlined and the aliases\n * applied.  In uncompiled code the function is simply run since the aliases as\n * written are valid JavaScript.\n *\n *\n * @param {function()} fn Function to call.  This function can contain aliases\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\n *     (e.g. \"var Timer = goog.Timer\").\n */\ngoog.scope = function(fn) {\n  if (goog.isInModuleLoader_()) {\n    throw new Error('goog.scope is not supported within a module.');\n  }\n  fn.call(goog.global);\n};\n\n\n/*\n * To support uncompiled, strict mode bundles that use eval to divide source\n * like so:\n *    eval('someSource;//# sourceUrl sourcefile.js');\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\n * be defined externally.\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\n * extern generation when that compiler option is enabled.\n */\nif (!COMPILED) {\n  goog.global['COMPILED'] = COMPILED;\n}\n\n\n//==============================================================================\n// goog.defineClass implementation\n//==============================================================================\n\n\n/**\n * Creates a restricted form of a Closure \"class\":\n *   - from the compiler's perspective, the instance returned from the\n *     constructor is sealed (no new properties may be added).  This enables\n *     better checks.\n *   - the compiler will rewrite this definition to a form that is optimal\n *     for type checking and optimization (initially this will be a more\n *     traditional form).\n *\n * @param {Function} superClass The superclass, Object or null.\n * @param {goog.defineClass.ClassDescriptor} def\n *     An object literal describing\n *     the class.  It may have the following properties:\n *     \"constructor\": the constructor function\n *     \"statics\": an object literal containing methods to add to the constructor\n *        as \"static\" methods or a function that will receive the constructor\n *        function as its only parameter to which static properties can\n *        be added.\n *     all other properties are added to the prototype.\n * @return {!Function} The class constructor.\n * @deprecated Use ES6 class syntax instead.\n */\ngoog.defineClass = function(superClass, def) {\n  // TODO(johnlenz): consider making the superClass an optional parameter.\n  var constructor = def.constructor;\n  var statics = def.statics;\n  // Wrap the constructor prior to setting up the prototype and static methods.\n  if (!constructor || constructor == Object.prototype.constructor) {\n    constructor = function() {\n      throw new Error(\n          'cannot instantiate an interface (no constructor defined).');\n    };\n  }\n\n  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);\n  if (superClass) {\n    goog.inherits(cls, superClass);\n  }\n\n  // Remove all the properties that should not be copied to the prototype.\n  delete def.constructor;\n  delete def.statics;\n\n  goog.defineClass.applyProperties_(cls.prototype, def);\n  if (statics != null) {\n    if (statics instanceof Function) {\n      statics(cls);\n    } else {\n      goog.defineClass.applyProperties_(cls, statics);\n    }\n  }\n\n  return cls;\n};\n\n\n/**\n * @typedef {{\n *   constructor: (!Function|undefined),\n *   statics: (Object|undefined|function(Function):void)\n * }}\n */\ngoog.defineClass.ClassDescriptor;\n\n\n/**\n * @define {boolean} Whether the instances returned by goog.defineClass should\n *     be sealed when possible.\n *\n * When sealing is disabled the constructor function will not be wrapped by\n * goog.defineClass, making it incompatible with ES6 class methods.\n */\ngoog.defineClass.SEAL_CLASS_INSTANCES =\n    goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);\n\n\n/**\n * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is\n * defined, this function will wrap the constructor in a function that seals the\n * results of the provided constructor function.\n *\n * @param {!Function} ctr The constructor whose results maybe be sealed.\n * @param {Function} superClass The superclass constructor.\n * @return {!Function} The replacement constructor.\n * @private\n */\ngoog.defineClass.createSealingConstructor_ = function(ctr, superClass) {\n  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {\n    // Do now wrap the constructor when sealing is disabled. Angular code\n    // depends on this for injection to work properly.\n    return ctr;\n  }\n\n  // Compute whether the constructor is sealable at definition time, rather\n  // than when the instance is being constructed.\n  var superclassSealable = !goog.defineClass.isUnsealable_(superClass);\n\n  /**\n   * @this {Object}\n   * @return {?}\n   */\n  var wrappedCtr = function() {\n    // Don't seal an instance of a subclass when it calls the constructor of\n    // its super class as there is most likely still setup to do.\n    var instance = ctr.apply(this, arguments) || this;\n    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];\n\n    if (this.constructor === wrappedCtr && superclassSealable &&\n        Object.seal instanceof Function) {\n      Object.seal(instance);\n    }\n    return instance;\n  };\n\n  return wrappedCtr;\n};\n\n\n/**\n * @param {Function} ctr The constructor to test.\n * @return {boolean} Whether the constructor has been tagged as unsealable\n *     using goog.tagUnsealableClass.\n * @private\n */\ngoog.defineClass.isUnsealable_ = function(ctr) {\n  return ctr && ctr.prototype &&\n      ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];\n};\n\n\n// TODO(johnlenz): share these values with the goog.object\n/**\n * The names of the fields that are defined on Object.prototype.\n * @type {!Array<string>}\n * @private\n * @const\n */\ngoog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n  'toLocaleString', 'toString', 'valueOf'\n];\n\n\n// TODO(johnlenz): share this function with the goog.object\n/**\n * @param {!Object} target The object to add properties to.\n * @param {!Object} source The object to copy properties from.\n * @private\n */\ngoog.defineClass.applyProperties_ = function(target, source) {\n  // TODO(johnlenz): update this to support ES5 getters/setters\n\n  var key;\n  for (key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n\n  // For IE the for-in-loop does not contain any properties that are not\n  // enumerable on the prototype object (for example isPrototypeOf from\n  // Object.prototype) and it will also not include 'replace' on objects that\n  // extend String and change 'replace' (not that it is common for anyone to\n  // extend anything except Object).\n  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {\n    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n};\n\n\n/**\n * Sealing classes breaks the older idiom of assigning properties on the\n * prototype rather than in the constructor. As such, goog.defineClass\n * must not seal subclasses of these old-style classes until they are fixed.\n * Until then, this marks a class as \"broken\", instructing defineClass\n * not to seal subclasses.\n * @param {!Function} ctr The legacy constructor to tag as unsealable.\n */\ngoog.tagUnsealableClass = function(ctr) {\n  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {\n    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;\n  }\n};\n\n\n/**\n * Name for unsealable tag property.\n * @const @private {string}\n */\ngoog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';\n\n\n// There's a bug in the compiler where without collapse properties the\n// Closure namespace defines do not guard code correctly. To help reduce code\n// size also check for !COMPILED even though it redundant until this is fixed.\nif (!COMPILED && goog.DEPENDENCIES_ENABLED) {\n\n  /**\n   * Tries to detect whether is in the context of an HTML document.\n   * @return {boolean} True if it looks like HTML document.\n   * @private\n   */\n  goog.inHtmlDocument_ = function() {\n    /** @type {!Document} */\n    var doc = goog.global.document;\n    return doc != null && 'write' in doc;  // XULDocument misses write.\n  };\n\n\n  /**\n   * We'd like to check for if the document readyState is 'loading'; however\n   * there are bugs on IE 10 and below where the readyState being anything other\n   * than 'complete' is not reliable.\n   * @return {boolean}\n   * @private\n   */\n  goog.isDocumentLoading_ = function() {\n    // attachEvent is available on IE 6 thru 10 only, and thus can be used to\n    // detect those browsers.\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n    return doc.attachEvent ? doc.readyState != 'complete' :\n                             doc.readyState == 'loading';\n  };\n\n\n  /**\n   * Tries to detect the base path of base.js script that bootstraps Closure.\n   * @private\n   */\n  goog.findBasePath_ = function() {\n    if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &&\n        // Anti DOM-clobbering runtime check (b/37736576).\n        goog.isString(goog.global.CLOSURE_BASE_PATH)) {\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\n      return;\n    } else if (!goog.inHtmlDocument_()) {\n      return;\n    }\n    /** @type {!Document} */\n    var doc = goog.global.document;\n    // If we have a currentScript available, use it exclusively.\n    var currentScript = doc.currentScript;\n    if (currentScript) {\n      var scripts = [currentScript];\n    } else {\n      var scripts = doc.getElementsByTagName('SCRIPT');\n    }\n    // Search backwards since the current script is in almost all cases the one\n    // that has base.js.\n    for (var i = scripts.length - 1; i >= 0; --i) {\n      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);\n      var src = script.src;\n      var qmark = src.lastIndexOf('?');\n      var l = qmark == -1 ? src.length : qmark;\n      if (src.substr(l - 7, 7) == 'base.js') {\n        goog.basePath = src.substr(0, l - 7);\n        return;\n      }\n    }\n  };\n\n  goog.findBasePath_();\n\n  /** @struct @constructor @final */\n  goog.Transpiler = function() {\n    /** @private {?Object<string, boolean>} */\n    this.requiresTranspilation_ = null;\n    /** @private {string} */\n    this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;\n  };\n\n\n  /**\n   * Returns a newly created map from language mode string to a boolean\n   * indicating whether transpilation should be done for that mode as well as\n   * the highest level language that this environment supports.\n   *\n   * Guaranteed invariant:\n   * For any two modes, l1 and l2 where l2 is a newer mode than l1,\n   * `map[l1] == true` implies that `map[l2] == true`.\n   *\n   * Note this method is extracted and used elsewhere, so it cannot rely on\n   * anything external (it should easily be able to be transformed into a\n   * standalone, top level function).\n   *\n   * @private\n   * @return {{\n   *   target: string,\n   *   map: !Object<string, boolean>\n   * }}\n   */\n  goog.Transpiler.prototype.createRequiresTranspilation_ = function() {\n    var transpilationTarget = 'es3';\n    var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};\n    var transpilationRequiredForAllLaterModes = false;\n\n    /**\n     * Adds an entry to requiresTranspliation for the given language mode.\n     *\n     * IMPORTANT: Calls must be made in order from oldest to newest language\n     * mode.\n     * @param {string} modeName\n     * @param {function(): boolean} isSupported Returns true if the JS engine\n     *     supports the given mode.\n     */\n    function addNewerLanguageTranspilationCheck(modeName, isSupported) {\n      if (transpilationRequiredForAllLaterModes) {\n        requiresTranspilation[modeName] = true;\n      } else if (isSupported()) {\n        transpilationTarget = modeName;\n        requiresTranspilation[modeName] = false;\n      } else {\n        requiresTranspilation[modeName] = true;\n        transpilationRequiredForAllLaterModes = true;\n      }\n    }\n\n    /**\n     * Does the given code evaluate without syntax errors and return a truthy\n     * result?\n     */\n    function /** boolean */ evalCheck(/** string */ code) {\n      try {\n        return !!eval(code);\n      } catch (ignored) {\n        return false;\n      }\n    }\n\n    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?\n        goog.global.navigator.userAgent :\n        '';\n\n    // Identify ES3-only browsers by their incorrect treatment of commas.\n    addNewerLanguageTranspilationCheck('es5', function() {\n      return evalCheck('[1,].length==1');\n    });\n    addNewerLanguageTranspilationCheck('es6', function() {\n      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:\n      // https://github.com/Microsoft/ChakraCore/issues/1496.\n      var re = /Edge\\/(\\d+)(\\.\\d)*/i;\n      var edgeUserAgent = userAgent.match(re);\n      if (edgeUserAgent) {\n        // The Reflect.construct test below is flaky on Edge. It can sometimes\n        // pass or fail on 40 15.15063, so just exit early for Edge and treat\n        // it as ES5. Until we're on a more up to date version just always use\n        // ES5. See https://github.com/Microsoft/ChakraCore/issues/3217.\n        return false;\n      }\n      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]\n      //   (a) default params (specifically shadowing locals),\n      //   (b) destructuring, (c) block-scoped functions,\n      //   (d) for-of (const), (e) new.target/Reflect.construct\n      var es6fullTest =\n          'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +\n          'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +\n          'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +\n          'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +\n          '==3}';\n\n      return evalCheck('(()=>{\"use strict\";' + es6fullTest + '})()');\n    });\n    // ** and **= are the only new features in 'es7'\n    addNewerLanguageTranspilationCheck('es7', function() {\n      return evalCheck('2 ** 2 == 4');\n    });\n    // async functions are the only new features in 'es8'\n    addNewerLanguageTranspilationCheck('es8', function() {\n      return evalCheck('async () => 1, true');\n    });\n    addNewerLanguageTranspilationCheck('es9', function() {\n      return evalCheck('({...rest} = {}), true');\n    });\n    addNewerLanguageTranspilationCheck('es_next', function() {\n      return false;  // assume it always need to transpile\n    });\n    return {target: transpilationTarget, map: requiresTranspilation};\n  };\n\n\n  /**\n   * Determines whether the given language needs to be transpiled.\n   * @param {string} lang\n   * @param {string|undefined} module\n   * @return {boolean}\n   */\n  goog.Transpiler.prototype.needsTranspile = function(lang, module) {\n    if (goog.TRANSPILE == 'always') {\n      return true;\n    } else if (goog.TRANSPILE == 'never') {\n      return false;\n    } else if (!this.requiresTranspilation_) {\n      var obj = this.createRequiresTranspilation_();\n      this.requiresTranspilation_ = obj.map;\n      this.transpilationTarget_ = this.transpilationTarget_ || obj.target;\n    }\n    if (lang in this.requiresTranspilation_) {\n      if (this.requiresTranspilation_[lang]) {\n        return true;\n      } else if (\n          goog.inHtmlDocument_() && module == 'es6' &&\n          !('noModule' in goog.global.document.createElement('script'))) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      throw new Error('Unknown language mode: ' + lang);\n    }\n  };\n\n\n  /**\n   * Lazily retrieves the transpiler and applies it to the source.\n   * @param {string} code JS code.\n   * @param {string} path Path to the code.\n   * @return {string} The transpiled code.\n   */\n  goog.Transpiler.prototype.transpile = function(code, path) {\n    // TODO(johnplaisted): We should delete goog.transpile_ and just have this\n    // function. But there's some compile error atm where goog.global is being\n    // stripped incorrectly without this.\n    return goog.transpile_(code, path, this.transpilationTarget_);\n  };\n\n\n  /** @private @final {!goog.Transpiler} */\n  goog.transpiler_ = new goog.Transpiler();\n\n  /**\n   * Rewrites closing script tags in input to avoid ending an enclosing script\n   * tag.\n   *\n   * @param {string} str\n   * @return {string}\n   * @private\n   */\n  goog.protectScriptTag_ = function(str) {\n    return str.replace(/<\\/(SCRIPT)/ig, '\\\\x3c/$1');\n  };\n\n\n  /**\n   * A debug loader is responsible for downloading and executing javascript\n   * files in an unbundled, uncompiled environment.\n   *\n   * This can be custimized via the setDependencyFactory method, or by\n   * CLOSURE_IMPORT_SCRIPT/CLOSURE_LOAD_FILE_SYNC.\n   *\n   * @struct @constructor @final @private\n   */\n  goog.DebugLoader_ = function() {\n    /** @private @const {!Object<string, !goog.Dependency>} */\n    this.dependencies_ = {};\n    /** @private @const {!Object<string, string>} */\n    this.idToPath_ = {};\n    /** @private @const {!Object<string, boolean>} */\n    this.written_ = {};\n    /** @private @const {!Array<!goog.Dependency>} */\n    this.loadingDeps_ = [];\n    /** @private {!Array<!goog.Dependency>} */\n    this.depsToLoad_ = [];\n    /** @private {boolean} */\n    this.paused_ = false;\n    /** @private {!goog.DependencyFactory} */\n    this.factory_ = new goog.DependencyFactory(goog.transpiler_);\n    /** @private @const {!Object<string, !Function>} */\n    this.deferredCallbacks_ = {};\n    /** @private @const {!Array<string>} */\n    this.deferredQueue_ = [];\n  };\n\n  /**\n   * @param {!Array<string>} namespaces\n   * @param {function(): undefined} callback Function to call once all the\n   *     namespaces have loaded.\n   */\n  goog.DebugLoader_.prototype.bootstrap = function(namespaces, callback) {\n    var cb = callback;\n    function resolve() {\n      if (cb) {\n        goog.global.setTimeout(cb, 0);\n        cb = null;\n      }\n    }\n\n    if (!namespaces.length) {\n      resolve();\n      return;\n    }\n\n    var deps = [];\n    for (var i = 0; i < namespaces.length; i++) {\n      var path = this.getPathFromDeps_(namespaces[i]);\n      if (!path) {\n        throw new Error('Unregonized namespace: ' + namespaces[i]);\n      }\n      deps.push(this.dependencies_[path]);\n    }\n\n    var require = goog.require;\n    var loaded = 0;\n    for (var i = 0; i < namespaces.length; i++) {\n      require(namespaces[i]);\n      deps[i].onLoad(function() {\n        if (++loaded == namespaces.length) {\n          resolve();\n        }\n      });\n    }\n  };\n\n\n  /**\n   * Loads the Closure Dependency file.\n   *\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\n   * custom loading of the deps file.\n   */\n  goog.DebugLoader_.prototype.loadClosureDeps = function() {\n    // Circumvent addDependency, which would try to transpile deps.js if\n    // transpile is set to always.\n    var relPath = 'deps.js';\n    this.depsToLoad_.push(this.factory_.createDependency(\n        goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {},\n        false));\n    this.loadDeps_();\n  };\n\n\n  /**\n   * Notifies the debug loader when a dependency has been requested.\n   *\n   * @param {string} absPathOrId Path of the dependency or goog id.\n   * @param {boolean=} opt_force\n   */\n  goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {\n    var path = this.getPathFromDeps_(absPathOrId);\n    if (path &&\n        (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {\n      var callback = this.deferredCallbacks_[path];\n      if (callback) {\n        delete this.deferredCallbacks_[path];\n        callback();\n      }\n    }\n  };\n\n\n  /**\n   * Sets the dependency factory, which can be used to create custom\n   * goog.Dependency implementations to control how dependencies are loaded.\n   *\n   * @param {!goog.DependencyFactory} factory\n   */\n  goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {\n    this.factory_ = factory;\n  };\n\n\n  /**\n   * Travserses the dependency graph and queues the given dependency, and all of\n   * its transitive dependencies, for loading and then starts loading if not\n   * paused.\n   *\n   * @param {string} namespace\n   * @private\n   */\n  goog.DebugLoader_.prototype.load_ = function(namespace) {\n    if (!this.getPathFromDeps_(namespace)) {\n      var errorMessage = 'goog.require could not find: ' + namespace;\n\n      goog.logToConsole_(errorMessage);\n      throw Error(errorMessage);\n    } else {\n      var loader = this;\n\n      var deps = [];\n\n      /** @param {string} namespace */\n      var visit = function(namespace) {\n        var path = loader.getPathFromDeps_(namespace);\n\n        if (!path) {\n          throw new Error('Bad dependency path or symbol: ' + namespace);\n        }\n\n        if (loader.written_[path]) {\n          return;\n        }\n\n        loader.written_[path] = true;\n\n        var dep = loader.dependencies_[path];\n        for (var i = 0; i < dep.requires.length; i++) {\n          if (!goog.isProvided_(dep.requires[i])) {\n            visit(dep.requires[i]);\n          }\n        }\n\n        deps.push(dep);\n      };\n\n      visit(namespace);\n\n      var wasLoading = !!this.depsToLoad_.length;\n      this.depsToLoad_ = this.depsToLoad_.concat(deps);\n\n      if (!this.paused_ && !wasLoading) {\n        this.loadDeps_();\n      }\n    }\n  };\n\n\n  /**\n   * Loads any queued dependencies until they are all loaded or paused.\n   *\n   * @private\n   */\n  goog.DebugLoader_.prototype.loadDeps_ = function() {\n    var loader = this;\n    var paused = this.paused_;\n\n    while (this.depsToLoad_.length && !paused) {\n      (function() {\n        var loadCallDone = false;\n        var dep = loader.depsToLoad_.shift();\n\n        var loaded = false;\n        loader.loading_(dep);\n\n        var controller = {\n          pause: function() {\n            if (loadCallDone) {\n              throw new Error('Cannot call pause after the call to load.');\n            } else {\n              paused = true;\n            }\n          },\n          resume: function() {\n            if (loadCallDone) {\n              loader.resume_();\n            } else {\n              // Some dep called pause and then resume in the same load call.\n              // Just keep running this same loop.\n              paused = false;\n            }\n          },\n          loaded: function() {\n            if (loaded) {\n              throw new Error('Double call to loaded.');\n            }\n\n            loaded = true;\n            loader.loaded_(dep);\n          },\n          pending: function() {\n            // Defensive copy.\n            var pending = [];\n            for (var i = 0; i < loader.loadingDeps_.length; i++) {\n              pending.push(loader.loadingDeps_[i]);\n            }\n            return pending;\n          },\n          /**\n           * @param {goog.ModuleType} type\n           */\n          setModuleState: function(type) {\n            goog.moduleLoaderState_ = {\n              type: type,\n              moduleName: '',\n              declareLegacyNamespace: false\n            };\n          },\n          /** @type {function(string, string, string=)} */\n          registerEs6ModuleExports: function(\n              path, exports, opt_closureNamespace) {\n            if (opt_closureNamespace) {\n              goog.loadedModules_[opt_closureNamespace] = {\n                exports: exports,\n                type: goog.ModuleType.ES6,\n                moduleId: opt_closureNamespace || ''\n              };\n            }\n          },\n          /** @type {function(string, ?)} */\n          registerGoogModuleExports: function(moduleId, exports) {\n            goog.loadedModules_[moduleId] = {\n              exports: exports,\n              type: goog.ModuleType.GOOG,\n              moduleId: moduleId\n            };\n          },\n          clearModuleState: function() {\n            goog.moduleLoaderState_ = null;\n          },\n          defer: function(callback) {\n            if (loadCallDone) {\n              throw new Error(\n                  'Cannot register with defer after the call to load.');\n            }\n            loader.defer_(dep, callback);\n          },\n          areDepsLoaded: function() {\n            return loader.areDepsLoaded_(dep.requires);\n          }\n        };\n\n        try {\n          dep.load(controller);\n        } finally {\n          loadCallDone = true;\n        }\n      })();\n    }\n\n    if (paused) {\n      this.pause_();\n    }\n  };\n\n\n  /** @private */\n  goog.DebugLoader_.prototype.pause_ = function() {\n    this.paused_ = true;\n  };\n\n\n  /** @private */\n  goog.DebugLoader_.prototype.resume_ = function() {\n    if (this.paused_) {\n      this.paused_ = false;\n      this.loadDeps_();\n    }\n  };\n\n\n  /**\n   * Marks the given dependency as loading (load has been called but it has not\n   * yet marked itself as finished). Useful for dependencies that want to know\n   * what else is loading. Example: goog.modules cannot eval if there are\n   * loading dependencies.\n   *\n   * @param {!goog.Dependency} dep\n   * @private\n   */\n  goog.DebugLoader_.prototype.loading_ = function(dep) {\n    this.loadingDeps_.push(dep);\n  };\n\n\n  /**\n   * Marks the given dependency as having finished loading and being available\n   * for require.\n   *\n   * @param {!goog.Dependency} dep\n   * @private\n   */\n  goog.DebugLoader_.prototype.loaded_ = function(dep) {\n    for (var i = 0; i < this.loadingDeps_.length; i++) {\n      if (this.loadingDeps_[i] == dep) {\n        this.loadingDeps_.splice(i, 1);\n        break;\n      }\n    }\n\n    for (var i = 0; i < this.deferredQueue_.length; i++) {\n      if (this.deferredQueue_[i] == dep.path) {\n        this.deferredQueue_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (this.loadingDeps_.length == this.deferredQueue_.length &&\n        !this.depsToLoad_.length) {\n      // Something has asked to load these, but they may not be directly\n      // required again later, so load them now that we know we're done loading\n      // everything else. e.g. a goog module entry point.\n      while (this.deferredQueue_.length) {\n        this.requested(this.deferredQueue_.shift(), true);\n      }\n    }\n\n    dep.loaded();\n  };\n\n\n  /**\n   * @param {!Array<string>} pathsOrIds\n   * @return {boolean}\n   * @private\n   */\n  goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {\n    for (var i = 0; i < pathsOrIds.length; i++) {\n      var path = this.getPathFromDeps_(pathsOrIds[i]);\n      if (!path ||\n          (!(path in this.deferredCallbacks_) &&\n           !goog.isProvided_(pathsOrIds[i]))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * @param {string} absPathOrId\n   * @return {?string}\n   * @private\n   */\n  goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {\n    if (absPathOrId in this.idToPath_) {\n      return this.idToPath_[absPathOrId];\n    } else if (absPathOrId in this.dependencies_) {\n      return absPathOrId;\n    } else {\n      return null;\n    }\n  };\n\n\n  /**\n   * @param {!goog.Dependency} dependency\n   * @param {!Function} callback\n   * @private\n   */\n  goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {\n    this.deferredCallbacks_[dependency.path] = callback;\n    this.deferredQueue_.push(dependency.path);\n  };\n\n\n  /**\n   * Interface for goog.Dependency implementations to have some control over\n   * loading of dependencies.\n   *\n   * @record\n   */\n  goog.LoadController = function() {};\n\n\n  /**\n   * Tells the controller to halt loading of more dependencies.\n   */\n  goog.LoadController.prototype.pause = function() {};\n\n\n  /**\n   * Tells the controller to resume loading of more dependencies if paused.\n   */\n  goog.LoadController.prototype.resume = function() {};\n\n\n  /**\n   * Tells the controller that this dependency has finished loading.\n   *\n   * This causes this to be removed from pending() and any load callbacks to\n   * fire.\n   */\n  goog.LoadController.prototype.loaded = function() {};\n\n\n  /**\n   * List of dependencies on which load has been called but which have not\n   * called loaded on their controller. This includes the current dependency.\n   *\n   * @return {!Array<!goog.Dependency>}\n   */\n  goog.LoadController.prototype.pending = function() {};\n\n\n  /**\n   * Registers an object as an ES6 module's exports so that goog.modules may\n   * require it by path.\n   *\n   * @param {string} path Full path of the module.\n   * @param {?} exports\n   * @param {string=} opt_closureNamespace Closure namespace to associate with\n   *     this module.\n   */\n  goog.LoadController.prototype.registerEs6ModuleExports = function(\n      path, exports, opt_closureNamespace) {};\n\n\n  /**\n   * Sets the current module state.\n   *\n   * @param {goog.ModuleType} type Type of module.\n   */\n  goog.LoadController.prototype.setModuleState = function(type) {};\n\n\n  /**\n   * Clears the current module state.\n   */\n  goog.LoadController.prototype.clearModuleState = function() {};\n\n\n  /**\n   * Registers a callback to call once the dependency is actually requested\n   * via goog.require + all of the immediate dependencies have been loaded or\n   * all other files have been loaded. Allows for lazy loading until\n   * require'd without pausing dependency loading, which is needed on old IE.\n   *\n   * @param {!Function} callback\n   */\n  goog.LoadController.prototype.defer = function(callback) {};\n\n\n  /**\n   * @return {boolean}\n   */\n  goog.LoadController.prototype.areDepsLoaded = function() {};\n\n\n  /**\n   * Basic super class for all dependencies Closure Library can load.\n   *\n   * This default implementation is designed to load untranspiled, non-module\n   * scripts in a web broswer.\n   *\n   * For transpiled non-goog.module files {@see goog.TranspiledDependency}.\n   * For goog.modules see {@see goog.GoogModuleDependency}.\n   * For untranspiled ES6 modules {@see goog.Es6ModuleDependency}.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   */\n  goog.Dependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    /** @const */\n    this.path = path;\n    /** @const */\n    this.relativePath = relativePath;\n    /** @const */\n    this.provides = provides;\n    /** @const */\n    this.requires = requires;\n    /** @const */\n    this.loadFlags = loadFlags;\n    /** @private {boolean} */\n    this.loaded_ = false;\n    /** @private {!Array<function()>} */\n    this.loadCallbacks_ = [];\n  };\n\n\n  /**\n   * @return {string} The pathname part of this dependency's path if it is a\n   *     URI.\n   */\n  goog.Dependency.prototype.getPathName = function() {\n    var pathName = this.path;\n    var protocolIndex = pathName.indexOf('://');\n    if (protocolIndex >= 0) {\n      pathName = pathName.substring(protocolIndex + 3);\n      var slashIndex = pathName.indexOf('/');\n      if (slashIndex >= 0) {\n        pathName = pathName.substring(slashIndex + 1);\n      }\n    }\n    return pathName;\n  };\n\n\n  /**\n   * @param {function()} callback Callback to fire as soon as this has loaded.\n   * @final\n   */\n  goog.Dependency.prototype.onLoad = function(callback) {\n    if (this.loaded_) {\n      callback();\n    } else {\n      this.loadCallbacks_.push(callback);\n    }\n  };\n\n\n  /**\n   * Marks this dependency as loaded and fires any callbacks registered with\n   * onLoad.\n   * @final\n   */\n  goog.Dependency.prototype.loaded = function() {\n    this.loaded_ = true;\n    var callbacks = this.loadCallbacks_;\n    this.loadCallbacks_ = [];\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i]();\n    }\n  };\n\n\n  /**\n   * Whether or not document.written / appended script tags should be deferred.\n   *\n   * @private {boolean}\n   */\n  goog.Dependency.defer_ = false;\n\n\n  /**\n   * Map of script ready / state change callbacks. Old IE cannot handle putting\n   * these properties on goog.global.\n   *\n   * @private @const {!Object<string, function(?):undefined>}\n   */\n  goog.Dependency.callbackMap_ = {};\n\n\n  /**\n   * @param {function(...?):?} callback\n   * @return {string}\n   * @private\n   */\n  goog.Dependency.registerCallback_ = function(callback) {\n    var key = Math.random().toString(32);\n    goog.Dependency.callbackMap_[key] = callback;\n    return key;\n  };\n\n\n  /**\n   * @param {string} key\n   * @private\n   */\n  goog.Dependency.unregisterCallback_ = function(key) {\n    delete goog.Dependency.callbackMap_[key];\n  };\n\n\n  /**\n   * @param {string} key\n   * @param {...?} var_args\n   * @private\n   * @suppress {unusedPrivateMembers}\n   */\n  goog.Dependency.callback_ = function(key, var_args) {\n    if (key in goog.Dependency.callbackMap_) {\n      var callback = goog.Dependency.callbackMap_[key];\n      var args = [];\n      for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i]);\n      }\n      callback.apply(undefined, args);\n    } else {\n      var errorMessage = 'Callback key ' + key +\n          ' does not exist (was base.js loaded more than once?).';\n      throw Error(errorMessage);\n    }\n  };\n\n\n  /**\n   * Starts loading this dependency. This dependency can pause loading if it\n   * needs to and resume it later via the controller interface.\n   *\n   * When this is loaded it should call controller.loaded(). Note that this will\n   * end up calling the loaded method of this dependency; there is no need to\n   * call it explicitly.\n   *\n   * @param {!goog.LoadController} controller\n   */\n  goog.Dependency.prototype.load = function(controller) {\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    if (!goog.inHtmlDocument_()) {\n      goog.logToConsole_(\n          'Cannot use default debug loader outside of HTML documents.');\n      if (this.relativePath == 'deps.js') {\n        // Some old code is relying on base.js auto loading deps.js failing with\n        // no error before later setting CLOSURE_IMPORT_SCRIPT.\n        // CLOSURE_IMPORT_SCRIPT should be set *before* base.js is loaded, or\n        // CLOSURE_NO_DEPS set to true.\n        goog.logToConsole_(\n            'Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, ' +\n            'or setting CLOSURE_NO_DEPS to true.');\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n\n    // If the user tries to require a new symbol after document load,\n    // something has gone terribly wrong. Doing a document.write would\n    // wipe out the page. This does not apply to the CSP-compliant method\n    // of writing script tags.\n    if (doc.readyState == 'complete' &&\n        !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {\n      // Certain test frameworks load base.js multiple times, which tries\n      // to write deps.js each time. If that happens, just fail silently.\n      // These frameworks wipe the page between each load of base.js, so this\n      // is OK.\n      var isDeps = /\\bdeps.js$/.test(this.path);\n      if (isDeps) {\n        controller.loaded();\n        return;\n      } else {\n        throw Error('Cannot write \"' + this.path + '\" after document load');\n      }\n    }\n\n    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&\n        goog.isDocumentLoading_()) {\n      var key = goog.Dependency.registerCallback_(function(script) {\n        if (!goog.DebugLoader_.IS_OLD_IE_ || script.readyState == 'complete') {\n          goog.Dependency.unregisterCallback_(key);\n          controller.loaded();\n        }\n      });\n      var nonceAttr = !goog.DebugLoader_.IS_OLD_IE_ && goog.getScriptNonce() ?\n          ' nonce=\"' + goog.getScriptNonce() + '\"' :\n          '';\n      var event =\n          goog.DebugLoader_.IS_OLD_IE_ ? 'onreadystatechange' : 'onload';\n      var defer = goog.Dependency.defer_ ? 'defer' : '';\n      var script = '<script src=\"' + this.path + '\" ' + event +\n          '=\"goog.Dependency.callback_(\\'' + key +\n          '\\', this)\" type=\"text/javascript\" ' + defer + nonceAttr + '><' +\n          '/script>';\n      doc.write(\n          goog.TRUSTED_TYPES_POLICY_ ?\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n              script);\n    } else {\n      var scriptEl =\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\n      scriptEl.defer = goog.Dependency.defer_;\n      scriptEl.async = false;\n      scriptEl.type = 'text/javascript';\n\n      // If CSP nonces are used, propagate them to dynamically created scripts.\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n      var nonce = goog.getScriptNonce();\n      if (nonce) {\n        scriptEl.setAttribute('nonce', nonce);\n      }\n\n      if (goog.DebugLoader_.IS_OLD_IE_) {\n        // Execution order is not guaranteed on old IE, halt loading and write\n        // these scripts one at a time, after each loads.\n        controller.pause();\n        scriptEl.onreadystatechange = function() {\n          if (scriptEl.readyState == 'loaded' ||\n              scriptEl.readyState == 'complete') {\n            controller.loaded();\n            controller.resume();\n          }\n        };\n      } else {\n        scriptEl.onload = function() {\n          scriptEl.onload = null;\n          controller.loaded();\n        };\n      }\n\n      scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\n          goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) :\n          this.path;\n      doc.head.appendChild(scriptEl);\n    }\n  };\n\n\n  /**\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides Should be an empty array.\n   *     TODO(johnplaisted) add support for adding closure namespaces to ES6\n   *     modules for interop purposes.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   * @extends {goog.Dependency}\n   */\n  goog.Es6ModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.Es6ModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n  };\n  goog.inherits(goog.Es6ModuleDependency, goog.Dependency);\n\n\n  /** @override */\n  goog.Es6ModuleDependency.prototype.load = function(controller) {\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n    if (!goog.inHtmlDocument_()) {\n      goog.logToConsole_(\n          'Cannot use default debug loader outside of HTML documents.');\n      controller.pause();\n      return;\n    }\n\n    /** @type {!HTMLDocument} */\n    var doc = goog.global.document;\n\n    var dep = this;\n\n    // TODO(johnplaisted): Does document.writing really speed up anything? Any\n    // difference between this and just waiting for interactive mode and then\n    // appending?\n    function write(src, contents) {\n      if (contents) {\n        var script = '<script type=\"module\" crossorigin>' + contents + '</' +\n            'script>';\n        doc.write(\n            goog.TRUSTED_TYPES_POLICY_ ?\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n                script);\n      } else {\n        var script = '<script type=\"module\" crossorigin src=\"' + src + '\"></' +\n            'script>';\n        doc.write(\n            goog.TRUSTED_TYPES_POLICY_ ?\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n                script);\n      }\n    }\n\n    function append(src, contents) {\n      var scriptEl =\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\n      scriptEl.defer = true;\n      scriptEl.async = false;\n      scriptEl.type = 'module';\n      scriptEl.setAttribute('crossorigin', true);\n\n      // If CSP nonces are used, propagate them to dynamically created scripts.\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n      var nonce = goog.getScriptNonce();\n      if (nonce) {\n        scriptEl.setAttribute('nonce', nonce);\n      }\n\n      if (contents) {\n        scriptEl.textContent = goog.TRUSTED_TYPES_POLICY_ ?\n            goog.TRUSTED_TYPES_POLICY_.createScript(contents) :\n            contents;\n      } else {\n        scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\n            goog.TRUSTED_TYPES_POLICY_.createScriptURL(src) :\n            src;\n      }\n\n      doc.head.appendChild(scriptEl);\n    }\n\n    var create;\n\n    if (goog.isDocumentLoading_()) {\n      create = write;\n      // We can ONLY call document.write if we are guaranteed that any\n      // non-module script tags document.written after this are deferred.\n      // Small optimization, in theory document.writing is faster.\n      goog.Dependency.defer_ = true;\n    } else {\n      create = append;\n    }\n\n    // Write 4 separate tags here:\n    // 1) Sets the module state at the correct time (just before execution).\n    // 2) A src node for this, which just hopefully lets the browser load it a\n    //    little early (no need to parse #3).\n    // 3) Import the module and register it.\n    // 4) Clear the module state at the correct time. Guaranteed to run even\n    //    if there is an error in the module (#3 will not run if there is an\n    //    error in the module).\n    var beforeKey = goog.Dependency.registerCallback_(function() {\n      goog.Dependency.unregisterCallback_(beforeKey);\n      controller.setModuleState(goog.ModuleType.ES6);\n    });\n    create(undefined, 'goog.Dependency.callback_(\"' + beforeKey + '\")');\n\n    // TODO(johnplaisted): Does this really speed up anything?\n    create(this.path, undefined);\n\n    var registerKey = goog.Dependency.registerCallback_(function(exports) {\n      goog.Dependency.unregisterCallback_(registerKey);\n      controller.registerEs6ModuleExports(\n          dep.path, exports, goog.moduleLoaderState_.moduleName);\n    });\n    create(\n        undefined,\n        'import * as m from \"' + this.path + '\"; goog.Dependency.callback_(\"' +\n            registerKey + '\", m)');\n\n    var afterKey = goog.Dependency.registerCallback_(function() {\n      goog.Dependency.unregisterCallback_(afterKey);\n      controller.clearModuleState();\n      controller.loaded();\n    });\n    create(undefined, 'goog.Dependency.callback_(\"' + afterKey + '\")');\n  };\n\n\n  /**\n   * Superclass of any dependency that needs to be loaded into memory,\n   * transformed, and then eval'd (goog.modules and transpiled files).\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor @abstract\n   * @extends {goog.Dependency}\n   */\n  goog.TransformedDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.TransformedDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @private {?string} */\n    this.contents_ = null;\n\n    /**\n     * Whether to lazily make the synchronous XHR (when goog.require'd) or make\n     * the synchronous XHR when initially loading. On FireFox 61 there is a bug\n     * where an ES6 module cannot make a synchronous XHR (rather, it can, but if\n     * it does then no other ES6 modules will load after).\n     *\n     * tl;dr we lazy load due to bugs on older browsers and eager load due to\n     * bugs on newer ones.\n     *\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1477090\n     *\n     * @private @const {boolean}\n     */\n    this.lazyFetch_ = !goog.inHtmlDocument_() ||\n        !('noModule' in goog.global.document.createElement('script'));\n  };\n  goog.inherits(goog.TransformedDependency, goog.Dependency);\n\n\n  /** @override */\n  goog.TransformedDependency.prototype.load = function(controller) {\n    var dep = this;\n\n    function fetch() {\n      dep.contents_ = goog.loadFileSync_(dep.path);\n\n      if (dep.contents_) {\n        dep.contents_ = dep.transform(dep.contents_);\n        if (dep.contents_) {\n          dep.contents_ += '\\n//# sourceURL=' + dep.path;\n        }\n      }\n    }\n\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\n      fetch();\n      if (this.contents_ &&\n          goog.global.CLOSURE_IMPORT_SCRIPT('', this.contents_)) {\n        this.contents_ = null;\n        controller.loaded();\n      } else {\n        controller.pause();\n      }\n      return;\n    }\n\n\n    var isEs6 = this.loadFlags['module'] == goog.ModuleType.ES6;\n\n    if (!this.lazyFetch_) {\n      fetch();\n    }\n\n    function load() {\n      if (dep.lazyFetch_) {\n        fetch();\n      }\n\n      if (!dep.contents_) {\n        // loadFileSync_ or transform are responsible. Assume they logged an\n        // error.\n        return;\n      }\n\n      if (isEs6) {\n        controller.setModuleState(goog.ModuleType.ES6);\n      }\n\n      var namespace;\n\n      try {\n        var contents = dep.contents_;\n        dep.contents_ = null;\n        goog.globalEval(contents);\n        if (isEs6) {\n          namespace = goog.moduleLoaderState_.moduleName;\n        }\n      } finally {\n        if (isEs6) {\n          controller.clearModuleState();\n        }\n      }\n\n      if (isEs6) {\n        // Due to circular dependencies this may not be available for require\n        // right now.\n        goog.global['$jscomp']['require']['ensure'](\n            [dep.getPathName()], function() {\n              controller.registerEs6ModuleExports(\n                  dep.path,\n                  goog.global['$jscomp']['require'](dep.getPathName()),\n                  namespace);\n            });\n      }\n\n      controller.loaded();\n    }\n\n    // Do not fetch now; in FireFox 47 the synchronous XHR doesn't block all\n    // events. If we fetched now and then document.write'd the contents the\n    // document.write would be an eval and would execute too soon! Instead write\n    // a script tag to fetch and eval synchronously at the correct time.\n    function fetchInOwnScriptThenLoad() {\n      /** @type {!HTMLDocument} */\n      var doc = goog.global.document;\n\n      var key = goog.Dependency.registerCallback_(function() {\n        goog.Dependency.unregisterCallback_(key);\n        load();\n      });\n\n      var script = '<script type=\"text/javascript\">' +\n          goog.protectScriptTag_('goog.Dependency.callback_(\"' + key + '\");') +\n          '</' +\n          'script>';\n      doc.write(\n          goog.TRUSTED_TYPES_POLICY_ ?\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\n              script);\n    }\n\n    // If one thing is pending it is this.\n    var anythingElsePending = controller.pending().length > 1;\n\n    // If anything else is loading we need to lazy load due to bugs in old IE.\n    // Specifically script tags with src and script tags with contents could\n    // execute out of order if document.write is used, so we cannot use\n    // document.write. Do not pause here; it breaks old IE as well.\n    var useOldIeWorkAround =\n        anythingElsePending && goog.DebugLoader_.IS_OLD_IE_;\n\n    // Additionally if we are meant to defer scripts but the page is still\n    // loading (e.g. an ES6 module is loading) then also defer. Or if we are\n    // meant to defer and anything else is pending then defer (those may be\n    // scripts that did not need transformation and are just script tags with\n    // defer set to true, and we need to evaluate after that deferred script).\n    var needsAsyncLoading = goog.Dependency.defer_ &&\n        (anythingElsePending || goog.isDocumentLoading_());\n\n    if (useOldIeWorkAround || needsAsyncLoading) {\n      // Note that we only defer when we have to rather than 100% of the time.\n      // Always defering would work, but then in theory the order of\n      // goog.require calls would then matter. We want to enforce that most of\n      // the time the order of the require calls does not matter.\n      controller.defer(function() {\n        load();\n      });\n      return;\n    }\n    // TODO(johnplaisted): Externs are missing onreadystatechange for\n    // HTMLDocument.\n    /** @type {?} */\n    var doc = goog.global.document;\n\n    var isInternetExplorer =\n        goog.inHtmlDocument_() && 'ActiveXObject' in goog.global;\n\n    // Don't delay in any version of IE. There's bug around this that will\n    // cause out of order script execution. This means that on older IE ES6\n    // modules will load too early (while the document is still loading + the\n    // dom is not available). The other option is to load too late (when the\n    // document is complete and the onload even will never fire). This seems\n    // to be the lesser of two evils as scripts already act like the former.\n    if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() &&\n        !isInternetExplorer) {\n      goog.Dependency.defer_ = true;\n      // Transpiled ES6 modules still need to load like regular ES6 modules,\n      // aka only after the document is interactive.\n      controller.pause();\n      var oldCallback = doc.onreadystatechange;\n      doc.onreadystatechange = function() {\n        if (doc.readyState == 'interactive') {\n          doc.onreadystatechange = oldCallback;\n          load();\n          controller.resume();\n        }\n        if (goog.isFunction(oldCallback)) {\n          oldCallback.apply(undefined, arguments);\n        }\n      };\n    } else {\n      // Always eval on old IE.\n      if (goog.DebugLoader_.IS_OLD_IE_ || !goog.inHtmlDocument_() ||\n          !goog.isDocumentLoading_()) {\n        load();\n      } else {\n        fetchInOwnScriptThenLoad();\n      }\n    }\n  };\n\n\n  /**\n   * @param {string} contents\n   * @return {string}\n   * @abstract\n   */\n  goog.TransformedDependency.prototype.transform = function(contents) {};\n\n\n  /**\n   * Any non-goog.module dependency which needs to be transpiled before eval.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.TranspiledDependency = function(\n      path, relativePath, provides, requires, loadFlags, transpiler) {\n    goog.TranspiledDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @protected @const*/\n    this.transpiler = transpiler;\n  };\n  goog.inherits(goog.TranspiledDependency, goog.TransformedDependency);\n\n\n  /** @override */\n  goog.TranspiledDependency.prototype.transform = function(contents) {\n    // Transpile with the pathname so that ES6 modules are domain agnostic.\n    return this.transpiler.transpile(contents, this.getPathName());\n  };\n\n\n  /**\n   * An ES6 module dependency that was transpiled to a jscomp module outside\n   * of the debug loader, e.g. server side.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.PreTranspiledEs6ModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags) {\n    goog.PreTranspiledEs6ModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n  };\n  goog.inherits(\n      goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency);\n\n\n  /** @override */\n  goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(\n      contents) {\n    return contents;\n  };\n\n\n  /**\n   * A goog.module, transpiled or not. Will always perform some minimal\n   * transformation even when not transpiled to wrap in a goog.loadModule\n   * statement.\n   *\n   * @param {string} path Absolute path of this script.\n   * @param {string} relativePath Path of this script relative to goog.basePath.\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\n   *     in this file.\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\n   *     this depends on.\n   * @param {!Object<string, string>} loadFlags\n   * @param {boolean} needsTranspile\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   * @extends {goog.TransformedDependency}\n   */\n  goog.GoogModuleDependency = function(\n      path, relativePath, provides, requires, loadFlags, needsTranspile,\n      transpiler) {\n    goog.GoogModuleDependency.base(\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\n    /** @private @const */\n    this.needsTranspile_ = needsTranspile;\n    /** @private @const */\n    this.transpiler_ = transpiler;\n  };\n  goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);\n\n\n  /** @override */\n  goog.GoogModuleDependency.prototype.transform = function(contents) {\n    if (this.needsTranspile_) {\n      contents = this.transpiler_.transpile(contents, this.getPathName());\n    }\n\n    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {\n      return '' +\n          'goog.loadModule(function(exports) {' +\n          '\"use strict\";' + contents +\n          '\\n' +  // terminate any trailing single line comment.\n          ';return exports' +\n          '});' +\n          '\\n//# sourceURL=' + this.path + '\\n';\n    } else {\n      return '' +\n          'goog.loadModule(' +\n          goog.global.JSON.stringify(\n              contents + '\\n//# sourceURL=' + this.path + '\\n') +\n          ');';\n    }\n  };\n\n\n  /**\n   * Whether the browser is IE9 or earlier, which needs special handling\n   * for deferred modules.\n   * @const @private {boolean}\n   */\n  goog.DebugLoader_.IS_OLD_IE_ = !!(\n      !goog.global.atob && goog.global.document && goog.global.document['all']);\n\n\n  /**\n   * @param {string} relPath\n   * @param {!Array<string>|undefined} provides\n   * @param {!Array<string>} requires\n   * @param {boolean|!Object<string>=} opt_loadFlags\n   * @see goog.addDependency\n   */\n  goog.DebugLoader_.prototype.addDependency = function(\n      relPath, provides, requires, opt_loadFlags) {\n    provides = provides || [];\n    relPath = relPath.replace(/\\\\/g, '/');\n    var path = goog.normalizePath_(goog.basePath + relPath);\n    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {\n      opt_loadFlags = opt_loadFlags ? {'module': goog.ModuleType.GOOG} : {};\n    }\n    var dep = this.factory_.createDependency(\n        path, relPath, provides, requires, opt_loadFlags,\n        goog.transpiler_.needsTranspile(\n            opt_loadFlags['lang'] || 'es3', opt_loadFlags['module']));\n    this.dependencies_[path] = dep;\n    for (var i = 0; i < provides.length; i++) {\n      this.idToPath_[provides[i]] = path;\n    }\n    this.idToPath_[relPath] = path;\n  };\n\n\n  /**\n   * Creates goog.Dependency instances for the debug loader to load.\n   *\n   * Should be overridden to have the debug loader use custom subclasses of\n   * goog.Dependency.\n   *\n   * @param {!goog.Transpiler} transpiler\n   * @struct @constructor\n   */\n  goog.DependencyFactory = function(transpiler) {\n    /** @protected @const */\n    this.transpiler = transpiler;\n  };\n\n\n  /**\n   * @param {string} path Absolute path of the file.\n   * @param {string} relativePath Path relative to closures base.js.\n   * @param {!Array<string>} provides Array of provided goog.provide/module ids.\n   * @param {!Array<string>} requires Array of required goog.provide/module /\n   *     relative ES6 module paths.\n   * @param {!Object<string, string>} loadFlags\n   * @param {boolean} needsTranspile True if the file needs to be transpiled\n   *     per the goog.Transpiler.\n   * @return {!goog.Dependency}\n   */\n  goog.DependencyFactory.prototype.createDependency = function(\n      path, relativePath, provides, requires, loadFlags, needsTranspile) {\n\n    if (loadFlags['module'] == goog.ModuleType.GOOG) {\n      return new goog.GoogModuleDependency(\n          path, relativePath, provides, requires, loadFlags, needsTranspile,\n          this.transpiler);\n    } else if (needsTranspile) {\n      return new goog.TranspiledDependency(\n          path, relativePath, provides, requires, loadFlags, this.transpiler);\n    } else {\n      if (loadFlags['module'] == goog.ModuleType.ES6) {\n        if (goog.TRANSPILE == 'never' && goog.ASSUME_ES_MODULES_TRANSPILED) {\n          return new goog.PreTranspiledEs6ModuleDependency(\n              path, relativePath, provides, requires, loadFlags);\n        } else {\n          return new goog.Es6ModuleDependency(\n              path, relativePath, provides, requires, loadFlags);\n        }\n      } else {\n        return new goog.Dependency(\n            path, relativePath, provides, requires, loadFlags);\n      }\n    }\n  };\n\n\n  /** @private @const */\n  goog.debugLoader_ = new goog.DebugLoader_();\n\n\n  /**\n   * Loads the Closure Dependency file.\n   *\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\n   * custom loading of the deps file.\n   */\n  goog.loadClosureDeps = function() {\n    goog.debugLoader_.loadClosureDeps();\n  };\n\n\n  /**\n   * Sets the dependency factory, which can be used to create custom\n   * goog.Dependency implementations to control how dependencies are loaded.\n   *\n   * Note: if you wish to call this function and provide your own implemnetation\n   * it is a wise idea to set CLOSURE_NO_DEPS to true, otherwise the dependency\n   * file and all of its goog.addDependency calls will use the default factory.\n   * You can call goog.loadClosureDeps to load the Closure dependency file\n   * later, after your factory is injected.\n   *\n   * @param {!goog.DependencyFactory} factory\n   */\n  goog.setDependencyFactory = function(factory) {\n    goog.debugLoader_.setDependencyFactory(factory);\n  };\n\n\n  if (!goog.global.CLOSURE_NO_DEPS) {\n    goog.debugLoader_.loadClosureDeps();\n  }\n\n\n  /**\n   * Bootstraps the given namespaces and calls the callback once they are\n   * available either via goog.require. This is a replacement for using\n   * `goog.require` to bootstrap Closure JavaScript. Previously a `goog.require`\n   * in an HTML file would guarantee that the require'd namespace was available\n   * in the next immediate script tag. With ES6 modules this no longer a\n   * guarantee.\n   *\n   * @param {!Array<string>} namespaces\n   * @param {function(): ?} callback Function to call once all the namespaces\n   *     have loaded. Always called asynchronously.\n   */\n  goog.bootstrap = function(namespaces, callback) {\n    goog.debugLoader_.bootstrap(namespaces, callback);\n  };\n}\n\n\n/**\n * @define {string} Trusted Types policy name. If non-empty then Closure will\n * use Trusted Types.\n */\ngoog.TRUSTED_TYPES_POLICY_NAME =\n    goog.define('goog.TRUSTED_TYPES_POLICY_NAME', '');\n\n\n/**\n * Returns the parameter.\n * @param {string} s\n * @return {string}\n * @private\n */\ngoog.identity_ = function(s) {\n  return s;\n};\n\n\n/**\n * Creates Trusted Types policy if Trusted Types are supported by the browser.\n * The policy just blesses any string as a Trusted Type. It is not visibility\n * restricted because anyone can also call TrustedTypes.createPolicy directly.\n * However, the allowed names should be restricted by a HTTP header and the\n * reference to the created policy should be visibility restricted.\n * @param {string} name\n * @return {?TrustedTypePolicy}\n */\ngoog.createTrustedTypesPolicy = function(name) {\n  var policy = null;\n  if (typeof TrustedTypes === 'undefined' || !TrustedTypes.createPolicy) {\n    return policy;\n  }\n  // TrustedTypes.createPolicy throws if called with a name that is already\n  // registered, even in report-only mode. Until the API changes, catch the\n  // error not to break the applications functionally. In such case, the code\n  // will fall back to using regular Safe Types.\n  // TODO(koto): Remove catching once createPolicy API stops throwing.\n  try {\n    policy = TrustedTypes.createPolicy(name, {\n      createHTML: goog.identity_,\n      createScript: goog.identity_,\n      createScriptURL: goog.identity_,\n      createURL: goog.identity_\n    });\n  } catch (e) {\n    goog.logToConsole_(e.message);\n  }\n  return policy;\n};\n\n\n/** @private @const {?TrustedTypePolicy} */\ngoog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ?\n    goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#base') :\n    null;\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:util/defineproperty]"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:util/global]"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:es6/util/makeiterator]"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:es6/util/arrayiterator]"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:util/polyfill]"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/tmp/firebase-TMP/firebase-js-sdk/packages/auth/dist/[synthetic:es6/promise/promise]"},"// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.Thenable');\n\n/** @suppress {extraRequire} */\ngoog.forwardDeclare('goog.Promise'); // for the type reference.\n\n\n\n/**\n * Provides a more strict interface for Thenables in terms of\n * http://promisesaplus.com for interop with {@see goog.Promise}.\n *\n * @interface\n * @extends {IThenable<TYPE>}\n * @template TYPE\n */\ngoog.Thenable = function() {};\n\n\n/**\n * Adds callbacks that will operate on the result of the Thenable, returning a\n * new child Promise.\n *\n * If the Thenable is fulfilled, the `onFulfilled` callback will be\n * invoked with the fulfillment value as argument, and the child Promise will\n * be fulfilled with the return value of the callback. If the callback throws\n * an exception, the child Promise will be rejected with the thrown value\n * instead.\n *\n * If the Thenable is rejected, the `onRejected` callback will be invoked\n * with the rejection reason as argument, and the child Promise will be rejected\n * with the return value of the callback or thrown value.\n *\n * @param {?(function(this:THIS, TYPE): VALUE)=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fulfilled.\n * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will\n *     be invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n *\n * @return {RESULT} A new Promise that will receive the result\n *     of the fulfillment or rejection callback.\n * @template VALUE\n * @template THIS\n *\n * When a Promise (or thenable) is returned from the fulfilled callback,\n * the result is the payload of that promise, not the promise itself.\n *\n * @template RESULT := type('goog.Promise',\n *     cond(isUnknown(VALUE), unknown(),\n *       mapunion(VALUE, (V) =>\n *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),\n *           templateTypeOf(V, 0),\n *           cond(sub(V, 'Thenable'),\n *              unknown(),\n *              V)))))\n *  =:\n *\n */\ngoog.Thenable.prototype.then = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {};\n\n\n/**\n * An expando property to indicate that an object implements\n * `goog.Thenable`.\n *\n * {@see addImplementation}.\n *\n * @const\n */\ngoog.Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';\n\n\n/**\n * Marks a given class (constructor) as an implementation of Thenable, so\n * that we can query that fact at runtime. The class must have already\n * implemented the interface.\n * Exports a 'then' method on the constructor prototype, so that the objects\n * also implement the extern {@see goog.Thenable} interface for interop with\n * other Promise implementations.\n * @param {function(new:goog.Thenable,...?)} ctor The class constructor. The\n *     corresponding class must have already implemented the interface.\n */\ngoog.Thenable.addImplementation = function(ctor) {\n  if (COMPILED) {\n    ctor.prototype[goog.Thenable.IMPLEMENTED_BY_PROP] = true;\n  } else {\n    // Avoids dictionary access in uncompiled mode.\n    ctor.prototype.$goog_Thenable = true;\n  }\n};\n\n\n/**\n * @param {?} object\n * @return {boolean} Whether a given instance implements `goog.Thenable`.\n *     The class/superclass of the instance must call `addImplementation`.\n */\ngoog.Thenable.isImplementedBy = function(object) {\n  if (!object) {\n    return false;\n  }\n  try {\n    if (COMPILED) {\n      return !!object[goog.Thenable.IMPLEMENTED_BY_PROP];\n    }\n    return !!object.$goog_Thenable;\n  } catch (e) {\n    // Property access seems to be forbidden.\n    return false;\n  }\n};\n","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Provides a base class for custom Error objects such that the\n * stack is correctly maintained.\n *\n * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is\n * sufficient.\n *\n */\n\ngoog.provide('goog.debug.Error');\n\n\n\n/**\n * Base class for custom error objects.\n * @param {*=} opt_msg The message associated with the error.\n * @constructor\n * @extends {Error}\n */\ngoog.debug.Error = function(opt_msg) {\n\n  // Attempt to ensure there is a stack trace.\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, goog.debug.Error);\n  } else {\n    var stack = new Error().stack;\n    if (stack) {\n      /** @override */\n      this.stack = stack;\n    }\n  }\n\n  if (opt_msg) {\n    /** @override */\n    this.message = String(opt_msg);\n  }\n\n  /**\n   * Whether to report this error to the server. Setting this to false will\n   * cause the error reporter to not report the error back to the server,\n   * which can be useful if the client knows that the error has already been\n   * logged on the server.\n   * @type {boolean}\n   */\n  this.reportErrorToServer = true;\n};\ngoog.inherits(goog.debug.Error, Error);\n\n\n/** @override */\ngoog.debug.Error.prototype.name = 'CustomError';\n","// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities to check the preconditions, postconditions and\n * invariants runtime.\n *\n * Methods in this package are given special treatment by the compiler\n * for type-inference. For example, <code>goog.asserts.assert(foo)</code>\n * will make the compiler treat <code>foo</code> as non-nullable. Similarly,\n * <code>goog.asserts.assertNumber(foo)</code> informs the compiler about the\n * type of <code>foo</code>. Where applicable, such assertions are preferable to\n * casts by jsdoc with <code>@type</code>.\n *\n * The compiler has an option to disable asserts. So code like:\n * <code>\n * var x = goog.asserts.assert(foo());\n * goog.asserts.assert(bar());\n * </code>\n * will be transformed into:\n * <code>\n * var x = foo();\n * </code>\n * The compiler will leave in foo() (because its return value is used),\n * but it will remove bar() because it assumes it does not have side-effects.\n *\n * Additionally, note the compiler will consider the type to be \"tightened\" for\n * all statements <em>after</em> the assertion. For example:\n * <code>\n * const /** ?Object &#ast;/ value = foo();\n * goog.asserts.assert(value);\n * // \"value\" is of type {!Object} at this point.\n * </code>\n *\n * @author agrieve@google.com (Andrew Grieve)\n */\n\ngoog.provide('goog.asserts');\ngoog.provide('goog.asserts.AssertionError');\n\ngoog.require('goog.debug.Error');\ngoog.require('goog.dom.NodeType');\n\n\n/**\n * @define {boolean} Whether to strip out asserts or to leave them in.\n */\ngoog.asserts.ENABLE_ASSERTS =\n    goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);\n\n\n\n/**\n * Error object for failed assertions.\n * @param {string} messagePattern The pattern that was used to form message.\n * @param {!Array<*>} messageArgs The items to substitute into the pattern.\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.asserts.AssertionError = function(messagePattern, messageArgs) {\n  goog.debug.Error.call(this, goog.asserts.subs_(messagePattern, messageArgs));\n\n  /**\n   * The message pattern used to format the error message. Error handlers can\n   * use this to uniquely identify the assertion.\n   * @type {string}\n   */\n  this.messagePattern = messagePattern;\n};\ngoog.inherits(goog.asserts.AssertionError, goog.debug.Error);\n\n\n/** @override */\ngoog.asserts.AssertionError.prototype.name = 'AssertionError';\n\n\n/**\n * The default error handler.\n * @param {!goog.asserts.AssertionError} e The exception to be handled.\n */\ngoog.asserts.DEFAULT_ERROR_HANDLER = function(e) {\n  throw e;\n};\n\n\n/**\n * The handler responsible for throwing or logging assertion errors.\n * @private {function(!goog.asserts.AssertionError)}\n */\ngoog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;\n\n\n/**\n * Does simple python-style string substitution.\n * subs(\"foo%s hot%s\", \"bar\", \"dog\") becomes \"foobar hotdog\".\n * @param {string} pattern The string containing the pattern.\n * @param {!Array<*>} subs The items to substitute into the pattern.\n * @return {string} A copy of `str` in which each occurrence of\n *     {@code %s} has been replaced an argument from `var_args`.\n * @private\n */\ngoog.asserts.subs_ = function(pattern, subs) {\n  var splitParts = pattern.split('%s');\n  var returnString = '';\n\n  // Replace up to the last split part. We are inserting in the\n  // positions between split parts.\n  var subLast = splitParts.length - 1;\n  for (var i = 0; i < subLast; i++) {\n    // keep unsupplied as '%s'\n    var sub = (i < subs.length) ? subs[i] : '%s';\n    returnString += splitParts[i] + sub;\n  }\n  return returnString + splitParts[subLast];\n};\n\n\n/**\n * Throws an exception with the given message and \"Assertion failed\" prefixed\n * onto it.\n * @param {string} defaultMessage The message to use if givenMessage is empty.\n * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.\n * @param {string|undefined} givenMessage Message supplied by the caller.\n * @param {Array<*>} givenArgs The substitution arguments for givenMessage.\n * @throws {goog.asserts.AssertionError} When the value is not a number.\n * @private\n */\ngoog.asserts.doAssertFailure_ = function(\n    defaultMessage, defaultArgs, givenMessage, givenArgs) {\n  var message = 'Assertion failed';\n  if (givenMessage) {\n    message += ': ' + givenMessage;\n    var args = givenArgs;\n  } else if (defaultMessage) {\n    message += ': ' + defaultMessage;\n    args = defaultArgs;\n  }\n  // The '' + works around an Opera 10 bug in the unit tests. Without it,\n  // a stack trace is added to var message above. With this, a stack trace is\n  // not added until this line (it causes the extra garbage to be added after\n  // the assertion message instead of in the middle of it).\n  var e = new goog.asserts.AssertionError('' + message, args || []);\n  goog.asserts.errorHandler_(e);\n};\n\n\n/**\n * Sets a custom error handler that can be used to customize the behavior of\n * assertion failures, for example by turning all assertion failures into log\n * messages.\n * @param {function(!goog.asserts.AssertionError)} errorHandler\n */\ngoog.asserts.setErrorHandler = function(errorHandler) {\n  if (goog.asserts.ENABLE_ASSERTS) {\n    goog.asserts.errorHandler_ = errorHandler;\n  }\n};\n\n\n/**\n * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is\n * true.\n * @template T\n * @param {T} condition The condition to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {T} The value of the condition.\n * @throws {goog.asserts.AssertionError} When the condition evaluates to false.\n * @closurePrimitive {asserts.truthy}\n */\ngoog.asserts.assert = function(condition, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !condition) {\n    goog.asserts.doAssertFailure_(\n        '', null, opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return condition;\n};\n\n\n/**\n * Checks if `value` is `null` or `undefined` if goog.asserts.ENABLE_ASSERTS is\n * true.\n *\n * @param {T} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {R} `value` with its type narrowed to exclude `null` and `undefined`.\n *\n * @template T\n * @template R :=\n *     mapunion(T, (V) =>\n *         cond(eq(V, 'null'),\n *             none(),\n *             cond(eq(V, 'undefined'),\n *                 none(),\n *                 V)))\n *  =:\n *\n * @throws {!goog.asserts.AssertionError} When `value` is `null` or `undefined`.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertExists = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && value == null) {\n    goog.asserts.doAssertFailure_(\n        'Expected to exist: %s.', [value], opt_message,\n        Array.prototype.slice.call(arguments, 2));\n  }\n  return value;\n};\n\n\n/**\n * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case\n * when we want to add a check in the unreachable area like switch-case\n * statement:\n *\n * <pre>\n *  switch(type) {\n *    case FOO: doSomething(); break;\n *    case BAR: doSomethingElse(); break;\n *    default: goog.asserts.fail('Unrecognized type: ' + type);\n *      // We have only 2 types - \"default:\" section is unreachable code.\n *  }\n * </pre>\n *\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @throws {goog.asserts.AssertionError} Failure.\n * @closurePrimitive {asserts.fail}\n */\ngoog.asserts.fail = function(opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS) {\n    goog.asserts.errorHandler_(\n        new goog.asserts.AssertionError(\n            'Failure' + (opt_message ? ': ' + opt_message : ''),\n            Array.prototype.slice.call(arguments, 1)));\n  }\n};\n\n\n/**\n * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {number} The value, guaranteed to be a number when asserts enabled.\n * @throws {goog.asserts.AssertionError} When the value is not a number.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertNumber = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected number but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {number} */ (value);\n};\n\n\n/**\n * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {string} The value, guaranteed to be a string when asserts enabled.\n * @throws {goog.asserts.AssertionError} When the value is not a string.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertString = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected string but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {string} */ (value);\n};\n\n\n/**\n * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {!Function} The value, guaranteed to be a function when asserts\n *     enabled.\n * @throws {goog.asserts.AssertionError} When the value is not a function.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertFunction = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected function but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {!Function} */ (value);\n};\n\n\n/**\n * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {!Object} The value, guaranteed to be a non-null object.\n * @throws {goog.asserts.AssertionError} When the value is not an object.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertObject = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected object but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {!Object} */ (value);\n};\n\n\n/**\n * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {!Array<?>} The value, guaranteed to be a non-null array.\n * @throws {goog.asserts.AssertionError} When the value is not an array.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertArray = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected array but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {!Array<?>} */ (value);\n};\n\n\n/**\n * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {boolean} The value, guaranteed to be a boolean when asserts are\n *     enabled.\n * @throws {goog.asserts.AssertionError} When the value is not a boolean.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertBoolean = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {\n    goog.asserts.doAssertFailure_(\n        'Expected boolean but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {boolean} */ (value);\n};\n\n\n/**\n * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @return {!Element} The value, likely to be a DOM Element when asserts are\n *     enabled.\n * @throws {goog.asserts.AssertionError} When the value is not an Element.\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertElement = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS &&\n      (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {\n    goog.asserts.doAssertFailure_(\n        'Expected Element but got %s: %s.', [goog.typeOf(value), value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {!Element} */ (value);\n};\n\n\n/**\n * Checks if the value is an instance of the user-defined type if\n * goog.asserts.ENABLE_ASSERTS is true.\n *\n * The compiler may tighten the type returned by this function.\n *\n * @param {?} value The value to check.\n * @param {function(new: T, ...)} type A user-defined constructor.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @throws {goog.asserts.AssertionError} When the value is not an instance of\n *     type.\n * @return {T}\n * @template T\n * @closurePrimitive {asserts.matchesReturn}\n */\ngoog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {\n    goog.asserts.doAssertFailure_(\n        'Expected instanceof %s but got %s.',\n        [goog.asserts.getType_(type), goog.asserts.getType_(value)],\n        opt_message, Array.prototype.slice.call(arguments, 3));\n  }\n  return value;\n};\n\n\n/**\n * Checks whether the value is a finite number, if goog.asserts.ENABLE_ASSERTS\n * is true.\n *\n * @param {*} value The value to check.\n * @param {string=} opt_message Error message in case of failure.\n * @param {...*} var_args The items to substitute into the failure message.\n * @throws {goog.asserts.AssertionError} When the value is not a number, or is\n *     a non-finite number such as NaN, Infinity or -Infinity.\n * @return {number} The value initially passed in.\n */\ngoog.asserts.assertFinite = function(value, opt_message, var_args) {\n  if (goog.asserts.ENABLE_ASSERTS &&\n      (typeof value != 'number' || !isFinite(value))) {\n    goog.asserts.doAssertFailure_(\n        'Expected %s to be a finite number but it is not.', [value],\n        opt_message, Array.prototype.slice.call(arguments, 2));\n  }\n  return /** @type {number} */ (value);\n};\n\n/**\n * Checks that no enumerable keys are present in Object.prototype. Such keys\n * would break most code that use {@code for (var ... in ...)} loops.\n */\ngoog.asserts.assertObjectPrototypeIsIntact = function() {\n  for (var key in Object.prototype) {\n    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');\n  }\n};\n\n\n/**\n * Returns the type of a value. If a constructor is passed, and a suitable\n * string cannot be found, 'unknown type name' will be returned.\n * @param {*} value A constructor, object, or primitive.\n * @return {string} The best display name for the value, or 'unknown type name'.\n * @private\n */\ngoog.asserts.getType_ = function(value) {\n  if (value instanceof Function) {\n    return value.displayName || value.name || 'unknown type name';\n  } else if (value instanceof Object) {\n    return /** @type {string} */ (value.constructor.displayName) ||\n        value.constructor.name || Object.prototype.toString.call(value);\n  } else {\n    return value === null ? 'null' : typeof value;\n  }\n};\n","// Copyright 2015 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Simple freelist.\n *\n * An anterative to goog.structs.SimplePool, it imposes the requirement that the\n * objects in the list contain a \"next\" property that can be used to maintain\n * the pool.\n */\n\ngoog.provide('goog.async.FreeList');\n\n\n/**\n * @template ITEM\n */\ngoog.async.FreeList = goog.defineClass(null, {\n  /**\n   * @param {function():ITEM} create\n   * @param {function(ITEM):void} reset\n   * @param {number} limit\n   */\n  constructor: function(create, reset, limit) {\n    /** @private @const {number} */\n    this.limit_ = limit;\n    /** @private @const {function()} */\n    this.create_ = create;\n    /** @private @const {function(ITEM):void} */\n    this.reset_ = reset;\n\n    /** @private {number} */\n    this.occupants_ = 0;\n    /** @private {ITEM} */\n    this.head_ = null;\n  },\n\n  /**\n   * @return {ITEM}\n   */\n  get: function() {\n    var item;\n    if (this.occupants_ > 0) {\n      this.occupants_--;\n      item = this.head_;\n      this.head_ = item.next;\n      item.next = null;\n    } else {\n      item = this.create_();\n    }\n    return item;\n  },\n\n  /**\n   * @param {ITEM} item An item available for possible future reuse.\n   */\n  put: function(item) {\n    this.reset_(item);\n    if (this.occupants_ < this.limit_) {\n      this.occupants_++;\n      item.next = this.head_;\n      this.head_ = item;\n    }\n  },\n\n  /**\n   * Visible for testing.\n   * @package\n   * @return {number}\n   */\n  occupants: function() { return this.occupants_; }\n});\n","// Copyright 2015 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.async.WorkItem');\ngoog.provide('goog.async.WorkQueue');\n\ngoog.require('goog.asserts');\ngoog.require('goog.async.FreeList');\n\n\n// TODO(johnlenz): generalize the WorkQueue if this is used by more\n// than goog.async.run.\n\n\n\n/**\n * A low GC workqueue. The key elements of this design:\n *   - avoids the need for goog.bind or equivalent by carrying scope\n *   - avoids the need for array reallocation by using a linked list\n *   - minimizes work entry objects allocation by recycling objects\n * @constructor\n * @final\n * @struct\n */\ngoog.async.WorkQueue = function() {\n  this.workHead_ = null;\n  this.workTail_ = null;\n};\n\n\n/** @define {number} The maximum number of entries to keep for recycling. */\ngoog.async.WorkQueue.DEFAULT_MAX_UNUSED =\n    goog.define('goog.async.WorkQueue.DEFAULT_MAX_UNUSED', 100);\n\n\n/** @const @private {goog.async.FreeList<goog.async.WorkItem>} */\ngoog.async.WorkQueue.freelist_ = new goog.async.FreeList(\n    function() { return new goog.async.WorkItem(); },\n    function(item) { item.reset(); }, goog.async.WorkQueue.DEFAULT_MAX_UNUSED);\n\n\n/**\n * @param {function()} fn\n * @param {Object|null|undefined} scope\n */\ngoog.async.WorkQueue.prototype.add = function(fn, scope) {\n  var item = this.getUnusedItem_();\n  item.set(fn, scope);\n\n  if (this.workTail_) {\n    this.workTail_.next = item;\n    this.workTail_ = item;\n  } else {\n    goog.asserts.assert(!this.workHead_);\n    this.workHead_ = item;\n    this.workTail_ = item;\n  }\n};\n\n\n/**\n * @return {goog.async.WorkItem}\n */\ngoog.async.WorkQueue.prototype.remove = function() {\n  var item = null;\n\n  if (this.workHead_) {\n    item = this.workHead_;\n    this.workHead_ = this.workHead_.next;\n    if (!this.workHead_) {\n      this.workTail_ = null;\n    }\n    item.next = null;\n  }\n  return item;\n};\n\n\n/**\n * @param {goog.async.WorkItem} item\n */\ngoog.async.WorkQueue.prototype.returnUnused = function(item) {\n  goog.async.WorkQueue.freelist_.put(item);\n};\n\n\n/**\n * @return {goog.async.WorkItem}\n * @private\n */\ngoog.async.WorkQueue.prototype.getUnusedItem_ = function() {\n  return goog.async.WorkQueue.freelist_.get();\n};\n\n\n\n/**\n * @constructor\n * @final\n * @struct\n */\ngoog.async.WorkItem = function() {\n  /** @type {?function()} */\n  this.fn = null;\n  /** @type {?Object|null|undefined} */\n  this.scope = null;\n  /** @type {?goog.async.WorkItem} */\n  this.next = null;\n};\n\n\n/**\n * @param {function()} fn\n * @param {Object|null|undefined} scope\n */\ngoog.async.WorkItem.prototype.set = function(fn, scope) {\n  this.fn = fn;\n  this.scope = scope;\n  this.next = null;\n};\n\n\n/** Reset the work item so they don't prevent GC before reuse */\ngoog.async.WorkItem.prototype.reset = function() {\n  this.fn = null;\n  this.scope = null;\n  this.next = null;\n};\n","// Copyright 2017 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.dom.asserts');\n\ngoog.require('goog.asserts');\n\n/**\n * @fileoverview Custom assertions to ensure that an element has the appropriate\n * type.\n *\n * Using a goog.dom.safe wrapper on an object on the incorrect type (via an\n * incorrect static type cast) can result in security bugs: For instance,\n * g.d.s.setAnchorHref ensures that the URL assigned to the .href attribute\n * satisfies the SafeUrl contract, i.e., is safe to dereference as a hyperlink.\n * However, the value assigned to a HTMLLinkElement's .href property requires\n * the stronger TrustedResourceUrl contract, since it can refer to a stylesheet.\n * Thus, using g.d.s.setAnchorHref on an (incorrectly statically typed) object\n * of type HTMLLinkElement can result in a security vulnerability.\n * Assertions of the correct run-time type help prevent such incorrect use.\n *\n * In some cases, code using the DOM API is tested using mock objects (e.g., a\n * plain object such as {'href': url} instead of an actual Location object).\n * To allow such mocking, the assertions permit objects of types that are not\n * relevant DOM API objects at all (for instance, not Element or Location).\n *\n * Note that instanceof checks don't work straightforwardly in older versions of\n * IE, or across frames (see,\n * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object,\n * http://stackoverflow.com/questions/26248599/instanceof-htmlelement-in-iframe-is-not-element-or-object).\n *\n * Hence, these assertions may pass vacuously in such scenarios. The resulting\n * risk of security bugs is limited by the following factors:\n *  - A bug can only arise in scenarios involving incorrect static typing (the\n *    wrapper methods are statically typed to demand objects of the appropriate,\n *    precise type).\n *  - Typically, code is tested and exercised in multiple browsers.\n */\n\n/**\n * Asserts that a given object is a Location.\n *\n * To permit this assertion to pass in the context of tests where DOM APIs might\n * be mocked, also accepts any other type except for subtypes of {!Element}.\n * This is to ensure that, for instance, HTMLLinkElement is not being used in\n * place of a Location, since this could result in security bugs due to stronger\n * contracts required for assignments to the href property of the latter.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!Location}\n */\ngoog.dom.asserts.assertIsLocation = function(o) {\n  if (goog.asserts.ENABLE_ASSERTS) {\n    var win = goog.dom.asserts.getWindow_(o);\n    if (win) {\n      if (!o || (!(o instanceof win.Location) && o instanceof win.Element)) {\n        goog.asserts.fail(\n            'Argument is not a Location (or a non-Element mock); got: %s',\n            goog.dom.asserts.debugStringForType_(o));\n      }\n    }\n  }\n  return /** @type {!Location} */ (o);\n};\n\n\n/**\n * Asserts that a given object is either the given subtype of Element\n * or a non-Element, non-Location Mock.\n *\n * To permit this assertion to pass in the context of tests where DOM\n * APIs might be mocked, also accepts any other type except for\n * subtypes of {!Element}.  This is to ensure that, for instance,\n * HTMLScriptElement is not being used in place of a HTMLImageElement,\n * since this could result in security bugs due to stronger contracts\n * required for assignments to the src property of the latter.\n *\n * The DOM type is looked up in the window the object belongs to.  In\n * some contexts, this might not be possible (e.g. when running tests\n * outside a browser, cross-domain lookup). In this case, the\n * assertions are skipped.\n *\n * @param {?Object} o The object whose type to assert.\n * @param {string} typename The name of the DOM type.\n * @return {!Element} The object.\n * @private\n */\n// TODO(bangert): Make an analog of goog.dom.TagName to correctly handle casts?\ngoog.dom.asserts.assertIsElementType_ = function(o, typename) {\n  if (goog.asserts.ENABLE_ASSERTS) {\n    var win = goog.dom.asserts.getWindow_(o);\n    if (win && typeof win[typename] != 'undefined') {\n      if (!o ||\n          (!(o instanceof win[typename]) &&\n           (o instanceof win.Location || o instanceof win.Element))) {\n        goog.asserts.fail(\n            'Argument is not a %s (or a non-Element, non-Location mock); ' +\n                'got: %s',\n            typename, goog.dom.asserts.debugStringForType_(o));\n      }\n    }\n  }\n  return /** @type {!Element} */ (o);\n};\n\n/**\n * Asserts that a given object is a HTMLAnchorElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not of type Location nor a subtype\n * of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLAnchorElement}\n */\ngoog.dom.asserts.assertIsHTMLAnchorElement = function(o) {\n  return /** @type {!HTMLAnchorElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLAnchorElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLButtonElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLButtonElement}\n */\ngoog.dom.asserts.assertIsHTMLButtonElement = function(o) {\n  return /** @type {!HTMLButtonElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLButtonElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLLinkElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLLinkElement}\n */\ngoog.dom.asserts.assertIsHTMLLinkElement = function(o) {\n  return /** @type {!HTMLLinkElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLLinkElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLImageElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLImageElement}\n */\ngoog.dom.asserts.assertIsHTMLImageElement = function(o) {\n  return /** @type {!HTMLImageElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLImageElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLAudioElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLAudioElement}\n */\ngoog.dom.asserts.assertIsHTMLAudioElement = function(o) {\n  return /** @type {!HTMLAudioElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLAudioElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLVideoElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLVideoElement}\n */\ngoog.dom.asserts.assertIsHTMLVideoElement = function(o) {\n  return /** @type {!HTMLVideoElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLVideoElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLInputElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLInputElement}\n */\ngoog.dom.asserts.assertIsHTMLInputElement = function(o) {\n  return /** @type {!HTMLInputElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLInputElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLTextAreaElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLTextAreaElement}\n */\ngoog.dom.asserts.assertIsHTMLTextAreaElement = function(o) {\n  return /** @type {!HTMLTextAreaElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLTextAreaElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLCanvasElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLCanvasElement}\n */\ngoog.dom.asserts.assertIsHTMLCanvasElement = function(o) {\n  return /** @type {!HTMLCanvasElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLCanvasElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLEmbedElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLEmbedElement}\n */\ngoog.dom.asserts.assertIsHTMLEmbedElement = function(o) {\n  return /** @type {!HTMLEmbedElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLEmbedElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLFormElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLFormElement}\n */\ngoog.dom.asserts.assertIsHTMLFormElement = function(o) {\n  return /** @type {!HTMLFormElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLFormElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLFrameElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLFrameElement}\n */\ngoog.dom.asserts.assertIsHTMLFrameElement = function(o) {\n  return /** @type {!HTMLFrameElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLFrameElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLIFrameElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLIFrameElement}\n */\ngoog.dom.asserts.assertIsHTMLIFrameElement = function(o) {\n  return /** @type {!HTMLIFrameElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLIFrameElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLObjectElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLObjectElement}\n */\ngoog.dom.asserts.assertIsHTMLObjectElement = function(o) {\n  return /** @type {!HTMLObjectElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLObjectElement'));\n};\n\n/**\n * Asserts that a given object is a HTMLScriptElement.\n *\n * To permit this assertion to pass in the context of tests where elements might\n * be mocked, also accepts objects that are not a subtype of Element.\n *\n * @param {?Object} o The object whose type to assert.\n * @return {!HTMLScriptElement}\n */\ngoog.dom.asserts.assertIsHTMLScriptElement = function(o) {\n  return /** @type {!HTMLScriptElement} */ (\n      goog.dom.asserts.assertIsElementType_(o, 'HTMLScriptElement'));\n};\n\n/**\n * Returns a string representation of a value's type.\n *\n * @param {*} value An object, or primitive.\n * @return {string} The best display name for the value.\n * @private\n */\ngoog.dom.asserts.debugStringForType_ = function(value) {\n  if (goog.isObject(value)) {\n    try {\n      return value.constructor.displayName || value.constructor.name ||\n          Object.prototype.toString.call(value);\n    } catch (e) {\n      return '<object could not be stringified>';\n    }\n  } else {\n    return value === undefined ? 'undefined' :\n                                 value === null ? 'null' : typeof value;\n  }\n};\n\n/**\n * Gets window of element.\n * @param {?Object} o\n * @return {?Window}\n * @private\n * @suppress {strictMissingProperties} ownerDocument not defined on Object\n */\ngoog.dom.asserts.getWindow_ = function(o) {\n  try {\n    var doc = o && o.ownerDocument;\n    // This can throw Blocked a frame with origin \"chrome-extension://...\" from\n    // accessing a cross-origin frame in Chrome extension.\n    var win =\n        doc && /** @type {?Window} */ (doc.defaultView || doc.parentWindow);\n    win = win || /** @type {!Window} */ (goog.global);\n    // This can throw Permission denied to access property \"Element\" on\n    // cross-origin object.\n    if (win.Element && win.Location) {\n      return win;\n    }\n  } catch (ex) {\n  }\n  return null;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for manipulating arrays.\n *\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\ngoog.provide('goog.array');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should\n * rely on Array.prototype functions, if available.\n *\n * The Array.prototype functions can be defined by external libraries like\n * Prototype and setting this flag to false forces closure to use its own\n * goog.array implementation.\n *\n * If your javascript can be loaded by a third party site and you are wary about\n * relying on the prototype functions, specify\n * \"--define goog.NATIVE_ARRAY_PROTOTYPES=false\" to the JSCompiler.\n *\n * Setting goog.TRUSTED_SITE to false will automatically set\n * NATIVE_ARRAY_PROTOTYPES to false.\n */\ngoog.NATIVE_ARRAY_PROTOTYPES =\n    goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);\n\n\n/**\n * @define {boolean} If true, JSCompiler will use the native implementation of\n * array functions where appropriate (e.g., `Array#filter`) and remove the\n * unused pure JS implementation.\n */\ngoog.array.ASSUME_NATIVE_FUNCTIONS =\n    goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);\n\n\n/**\n * Returns the last element in an array without removing it.\n * Same as goog.array.last.\n * @param {IArrayLike<T>|string} array The array.\n * @return {T} Last item in array.\n * @template T\n */\ngoog.array.peek = function(array) {\n  return array[array.length - 1];\n};\n\n\n/**\n * Returns the last element in an array without removing it.\n * Same as goog.array.peek.\n * @param {IArrayLike<T>|string} array The array.\n * @return {T} Last item in array.\n * @template T\n */\ngoog.array.last = goog.array.peek;\n\n// NOTE(arv): Since most of the array functions are generic it allows you to\n// pass an array-like object. Strings have a length and are considered array-\n// like. However, the 'in' operator does not work on strings so we cannot just\n// use the array path even if the browser supports indexing into strings. We\n// therefore end up splitting the string.\n\n\n/**\n * Returns the index of the first element of an array with a specified value, or\n * -1 if the element is not present in the array.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}\n *\n * @param {IArrayLike<T>|string} arr The array to be searched.\n * @param {T} obj The object for which we are searching.\n * @param {number=} opt_fromIndex The index at which to start the search. If\n *     omitted the search starts at index 0.\n * @return {number} The index of the first matching array element.\n * @template T\n */\ngoog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ?\n    function(arr, obj, opt_fromIndex) {\n      goog.asserts.assert(arr.length != null);\n\n      return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);\n    } :\n    function(arr, obj, opt_fromIndex) {\n      var fromIndex = opt_fromIndex == null ?\n          0 :\n          (opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) :\n                               opt_fromIndex);\n\n      if (goog.isString(arr)) {\n        // Array.prototype.indexOf uses === so only strings should be found.\n        if (!goog.isString(obj) || obj.length != 1) {\n          return -1;\n        }\n        return arr.indexOf(obj, fromIndex);\n      }\n\n      for (var i = fromIndex; i < arr.length; i++) {\n        if (i in arr && arr[i] === obj) return i;\n      }\n      return -1;\n    };\n\n\n/**\n * Returns the index of the last element of an array with a specified value, or\n * -1 if the element is not present in the array.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}\n *\n * @param {!IArrayLike<T>|string} arr The array to be searched.\n * @param {T} obj The object for which we are searching.\n * @param {?number=} opt_fromIndex The index at which to start the search. If\n *     omitted the search starts at the end of the array.\n * @return {number} The index of the last matching array element.\n * @template T\n */\ngoog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ?\n    function(arr, obj, opt_fromIndex) {\n      goog.asserts.assert(arr.length != null);\n\n      // Firefox treats undefined and null as 0 in the fromIndex argument which\n      // leads it to always return -1\n      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;\n      return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);\n    } :\n    function(arr, obj, opt_fromIndex) {\n      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;\n\n      if (fromIndex < 0) {\n        fromIndex = Math.max(0, arr.length + fromIndex);\n      }\n\n      if (goog.isString(arr)) {\n        // Array.prototype.lastIndexOf uses === so only strings should be found.\n        if (!goog.isString(obj) || obj.length != 1) {\n          return -1;\n        }\n        return arr.lastIndexOf(obj, fromIndex);\n      }\n\n      for (var i = fromIndex; i >= 0; i--) {\n        if (i in arr && arr[i] === obj) return i;\n      }\n      return -1;\n    };\n\n\n/**\n * Calls a function for each element in an array. Skips holes in the array.\n * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}\n *\n * @param {IArrayLike<T>|string} arr Array or array like object over\n *     which to iterate.\n * @param {?function(this: S, T, number, ?): ?} f The function to call for every\n *     element. This function takes 3 arguments (the element, the index and the\n *     array). The return value is ignored.\n * @param {S=} opt_obj The object to be used as the value of 'this' within f.\n * @template T,S\n */\ngoog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ?\n    function(arr, f, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n\n      Array.prototype.forEach.call(arr, f, opt_obj);\n    } :\n    function(arr, f, opt_obj) {\n      var l = arr.length;  // must be fixed during loop... see docs\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\n      for (var i = 0; i < l; i++) {\n        if (i in arr2) {\n          f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\n        }\n      }\n    };\n\n\n/**\n * Calls a function for each element in an array, starting from the last\n * element rather than the first.\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this: S, T, number, ?): ?} f The function to call for every\n *     element. This function\n *     takes 3 arguments (the element, the index and the array). The return\n *     value is ignored.\n * @param {S=} opt_obj The object to be used as the value of 'this'\n *     within f.\n * @template T,S\n */\ngoog.array.forEachRight = function(arr, f, opt_obj) {\n  var l = arr.length;  // must be fixed during loop... see docs\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\n  for (var i = l - 1; i >= 0; --i) {\n    if (i in arr2) {\n      f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\n    }\n  }\n};\n\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?):boolean} f The function to call for\n *     every element. This function\n *     takes 3 arguments (the element, the index and the array) and must\n *     return a Boolean. If the return value is true the element is added to the\n *     result array. If it is false the element is not included.\n * @param {S=} opt_obj The object to be used as the value of 'this'\n *     within f.\n * @return {!Array<T>} a new array in which only elements that passed the test\n *     are present.\n * @template T,S\n */\ngoog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ?\n    function(arr, f, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n\n      return Array.prototype.filter.call(arr, f, opt_obj);\n    } :\n    function(arr, f, opt_obj) {\n      var l = arr.length;  // must be fixed during loop... see docs\n      var res = [];\n      var resLength = 0;\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\n      for (var i = 0; i < l; i++) {\n        if (i in arr2) {\n          var val = arr2[i];  // in case f mutates arr2\n          if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {\n            res[resLength++] = val;\n          }\n        }\n      }\n      return res;\n    };\n\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-map}\n *\n * @param {IArrayLike<VALUE>|string} arr Array or array like object\n *     over which to iterate.\n * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call\n *     for every element. This function takes 3 arguments (the element,\n *     the index and the array) and should return something. The result will be\n *     inserted into a new array.\n * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.\n * @return {!Array<RESULT>} a new array with the results from f.\n * @template THIS, VALUE, RESULT\n */\ngoog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ?\n    function(arr, f, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n\n      return Array.prototype.map.call(arr, f, opt_obj);\n    } :\n    function(arr, f, opt_obj) {\n      var l = arr.length;  // must be fixed during loop... see docs\n      var res = new Array(l);\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\n      for (var i = 0; i < l; i++) {\n        if (i in arr2) {\n          res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\n        }\n      }\n      return res;\n    };\n\n\n/**\n * Passes every element of an array into a function and accumulates the result.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}\n *\n * For example:\n * var a = [1, 2, 3, 4];\n * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);\n * returns 10\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {function(this:S, R, T, number, ?) : R} f The function to call for\n *     every element. This function\n *     takes 4 arguments (the function's previous result or the initial value,\n *     the value of the current array element, the current array index, and the\n *     array itself)\n *     function(previousValue, currentValue, index, array).\n * @param {?} val The initial value to pass into the function on the first call.\n * @param {S=} opt_obj  The object to be used as the value of 'this'\n *     within f.\n * @return {R} Result of evaluating f repeatedly across the values of the array.\n * @template T,S,R\n */\ngoog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ?\n    function(arr, f, val, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n      if (opt_obj) {\n        f = goog.bind(f, opt_obj);\n      }\n      return Array.prototype.reduce.call(arr, f, val);\n    } :\n    function(arr, f, val, opt_obj) {\n      var rval = val;\n      goog.array.forEach(arr, function(val, index) {\n        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);\n      });\n      return rval;\n    };\n\n\n/**\n * Passes every element of an array into a function and accumulates the result,\n * starting from the last element and working towards the first.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}\n *\n * For example:\n * var a = ['a', 'b', 'c'];\n * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');\n * returns 'cba'\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, R, T, number, ?) : R} f The function to call for\n *     every element. This function\n *     takes 4 arguments (the function's previous result or the initial value,\n *     the value of the current array element, the current array index, and the\n *     array itself)\n *     function(previousValue, currentValue, index, array).\n * @param {?} val The initial value to pass into the function on the first call.\n * @param {S=} opt_obj The object to be used as the value of 'this'\n *     within f.\n * @return {R} Object returned as a result of evaluating f repeatedly across the\n *     values of the array.\n * @template T,S,R\n */\ngoog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ?\n    function(arr, f, val, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n      goog.asserts.assert(f != null);\n      if (opt_obj) {\n        f = goog.bind(f, opt_obj);\n      }\n      return Array.prototype.reduceRight.call(arr, f, val);\n    } :\n    function(arr, f, val, opt_obj) {\n      var rval = val;\n      goog.array.forEachRight(arr, function(val, index) {\n        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);\n      });\n      return rval;\n    };\n\n\n/**\n * Calls f for each element of an array. If any call returns true, some()\n * returns true (without checking the remaining elements). If all calls\n * return false, some() returns false.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-some}\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\n *     for every element. This function takes 3 arguments (the element, the\n *     index and the array) and should return a boolean.\n * @param {S=} opt_obj  The object to be used as the value of 'this'\n *     within f.\n * @return {boolean} true if any element passes the test.\n * @template T,S\n */\ngoog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ?\n    function(arr, f, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n\n      return Array.prototype.some.call(arr, f, opt_obj);\n    } :\n    function(arr, f, opt_obj) {\n      var l = arr.length;  // must be fixed during loop... see docs\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\n      for (var i = 0; i < l; i++) {\n        if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n\n/**\n * Call f for each element of an array. If all calls return true, every()\n * returns true. If any call returns false, every() returns false and\n * does not continue to check the remaining elements.\n *\n * See {@link http://tinyurl.com/developer-mozilla-org-array-every}\n *\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\n *     for every element. This function takes 3 arguments (the element, the\n *     index and the array) and should return a boolean.\n * @param {S=} opt_obj The object to be used as the value of 'this'\n *     within f.\n * @return {boolean} false if any element fails the test.\n * @template T,S\n */\ngoog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ?\n    function(arr, f, opt_obj) {\n      goog.asserts.assert(arr.length != null);\n\n      return Array.prototype.every.call(arr, f, opt_obj);\n    } :\n    function(arr, f, opt_obj) {\n      var l = arr.length;  // must be fixed during loop... see docs\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\n      for (var i = 0; i < l; i++) {\n        if (i in arr2 && !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n\n/**\n * Counts the array elements that fulfill the predicate, i.e. for which the\n * callback function returns true. Skips holes in the array.\n *\n * @param {!IArrayLike<T>|string} arr Array or array like object\n *     over which to iterate.\n * @param {function(this: S, T, number, ?): boolean} f The function to call for\n *     every element. Takes 3 arguments (the element, the index and the array).\n * @param {S=} opt_obj The object to be used as the value of 'this' within f.\n * @return {number} The number of the matching elements.\n * @template T,S\n */\ngoog.array.count = function(arr, f, opt_obj) {\n  var count = 0;\n  goog.array.forEach(arr, function(element, index, arr) {\n    if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {\n      ++count;\n    }\n  }, opt_obj);\n  return count;\n};\n\n\n/**\n * Search an array for the first element that satisfies a given condition and\n * return that element.\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\n *     for every element. This function takes 3 arguments (the element, the\n *     index and the array) and should return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {T|null} The first array element that passes the test, or null if no\n *     element is found.\n * @template T,S\n */\ngoog.array.find = function(arr, f, opt_obj) {\n  var i = goog.array.findIndex(arr, f, opt_obj);\n  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];\n};\n\n\n/**\n * Search an array for the first element that satisfies a given condition and\n * return its index.\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\n *     every element. This function\n *     takes 3 arguments (the element, the index and the array) and should\n *     return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {number} The index of the first array element that passes the test,\n *     or -1 if no element is found.\n * @template T,S\n */\ngoog.array.findIndex = function(arr, f, opt_obj) {\n  var l = arr.length;  // must be fixed during loop... see docs\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\n  for (var i = 0; i < l; i++) {\n    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n/**\n * Search an array (in reverse order) for the last element that satisfies a\n * given condition and return that element.\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the element, the index and the array) and should\n *     return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {T|null} The last array element that passes the test, or null if no\n *     element is found.\n * @template T,S\n */\ngoog.array.findRight = function(arr, f, opt_obj) {\n  var i = goog.array.findIndexRight(arr, f, opt_obj);\n  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];\n};\n\n\n/**\n * Search an array (in reverse order) for the last element that satisfies a\n * given condition and return its index.\n * @param {IArrayLike<T>|string} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the element, the index and the array) and should\n *     return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {number} The index of the last array element that passes the test,\n *     or -1 if no element is found.\n * @template T,S\n */\ngoog.array.findIndexRight = function(arr, f, opt_obj) {\n  var l = arr.length;  // must be fixed during loop... see docs\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\n  for (var i = l - 1; i >= 0; i--) {\n    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n/**\n * Whether the array contains the given object.\n * @param {IArrayLike<?>|string} arr The array to test for the presence of the\n *     element.\n * @param {*} obj The object for which to test.\n * @return {boolean} true if obj is present.\n */\ngoog.array.contains = function(arr, obj) {\n  return goog.array.indexOf(arr, obj) >= 0;\n};\n\n\n/**\n * Whether the array is empty.\n * @param {IArrayLike<?>|string} arr The array to test.\n * @return {boolean} true if empty.\n */\ngoog.array.isEmpty = function(arr) {\n  return arr.length == 0;\n};\n\n\n/**\n * Clears the array.\n * @param {IArrayLike<?>} arr Array or array like object to clear.\n */\ngoog.array.clear = function(arr) {\n  // For non real arrays we don't have the magic length so we delete the\n  // indices.\n  if (!goog.isArray(arr)) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n      delete arr[i];\n    }\n  }\n  arr.length = 0;\n};\n\n\n/**\n * Pushes an item into an array, if it's not already in the array.\n * @param {Array<T>} arr Array into which to insert the item.\n * @param {T} obj Value to add.\n * @template T\n */\ngoog.array.insert = function(arr, obj) {\n  if (!goog.array.contains(arr, obj)) {\n    arr.push(obj);\n  }\n};\n\n\n/**\n * Inserts an object at the given index of the array.\n * @param {IArrayLike<?>} arr The array to modify.\n * @param {*} obj The object to insert.\n * @param {number=} opt_i The index at which to insert the object. If omitted,\n *      treated as 0. A negative index is counted from the end of the array.\n */\ngoog.array.insertAt = function(arr, obj, opt_i) {\n  goog.array.splice(arr, opt_i, 0, obj);\n};\n\n\n/**\n * Inserts at the given index of the array, all elements of another array.\n * @param {IArrayLike<?>} arr The array to modify.\n * @param {IArrayLike<?>} elementsToAdd The array of elements to add.\n * @param {number=} opt_i The index at which to insert the object. If omitted,\n *      treated as 0. A negative index is counted from the end of the array.\n */\ngoog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {\n  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);\n};\n\n\n/**\n * Inserts an object into an array before a specified object.\n * @param {Array<T>} arr The array to modify.\n * @param {T} obj The object to insert.\n * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2\n *     is omitted or not found, obj is inserted at the end of the array.\n * @template T\n */\ngoog.array.insertBefore = function(arr, obj, opt_obj2) {\n  var i;\n  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {\n    arr.push(obj);\n  } else {\n    goog.array.insertAt(arr, obj, i);\n  }\n};\n\n\n/**\n * Removes the first occurrence of a particular value from an array.\n * @param {IArrayLike<T>} arr Array from which to remove\n *     value.\n * @param {T} obj Object to remove.\n * @return {boolean} True if an element was removed.\n * @template T\n */\ngoog.array.remove = function(arr, obj) {\n  var i = goog.array.indexOf(arr, obj);\n  var rv;\n  if ((rv = i >= 0)) {\n    goog.array.removeAt(arr, i);\n  }\n  return rv;\n};\n\n\n/**\n * Removes the last occurrence of a particular value from an array.\n * @param {!IArrayLike<T>} arr Array from which to remove value.\n * @param {T} obj Object to remove.\n * @return {boolean} True if an element was removed.\n * @template T\n */\ngoog.array.removeLast = function(arr, obj) {\n  var i = goog.array.lastIndexOf(arr, obj);\n  if (i >= 0) {\n    goog.array.removeAt(arr, i);\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Removes from an array the element at index i\n * @param {IArrayLike<?>} arr Array or array like object from which to\n *     remove value.\n * @param {number} i The index to remove.\n * @return {boolean} True if an element was removed.\n */\ngoog.array.removeAt = function(arr, i) {\n  goog.asserts.assert(arr.length != null);\n\n  // use generic form of splice\n  // splice returns the removed items and if successful the length of that\n  // will be 1\n  return Array.prototype.splice.call(arr, i, 1).length == 1;\n};\n\n\n/**\n * Removes the first value that satisfies the given condition.\n * @param {IArrayLike<T>} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the element, the index and the array) and should\n *     return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {boolean} True if an element was removed.\n * @template T,S\n */\ngoog.array.removeIf = function(arr, f, opt_obj) {\n  var i = goog.array.findIndex(arr, f, opt_obj);\n  if (i >= 0) {\n    goog.array.removeAt(arr, i);\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Removes all values that satisfy the given condition.\n * @param {IArrayLike<T>} arr Array or array\n *     like object over which to iterate.\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the element, the index and the array) and should\n *     return a boolean.\n * @param {S=} opt_obj An optional \"this\" context for the function.\n * @return {number} The number of items removed\n * @template T,S\n */\ngoog.array.removeAllIf = function(arr, f, opt_obj) {\n  var removedCount = 0;\n  goog.array.forEachRight(arr, function(val, index) {\n    if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {\n      if (goog.array.removeAt(arr, index)) {\n        removedCount++;\n      }\n    }\n  });\n  return removedCount;\n};\n\n\n/**\n * Returns a new array that is the result of joining the arguments.  If arrays\n * are passed then their items are added, however, if non-arrays are passed they\n * will be added to the return array as is.\n *\n * Note that ArrayLike objects will be added as is, rather than having their\n * items added.\n *\n * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]\n * goog.array.concat(0, [1, 2]) -> [0, 1, 2]\n * goog.array.concat([1, 2], null) -> [1, 2, null]\n *\n * There is bug in all current versions of IE (6, 7 and 8) where arrays created\n * in an iframe become corrupted soon (not immediately) after the iframe is\n * destroyed. This is common if loading data via goog.net.IframeIo, for example.\n * This corruption only affects the concat method which will start throwing\n * Catastrophic Errors (#-2147418113).\n *\n * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.\n *\n * Internally goog.array should use this, so that all methods will continue to\n * work on these broken array objects.\n *\n * @param {...*} var_args Items to concatenate.  Arrays will have each item\n *     added, while primitives and objects will be added as is.\n * @return {!Array<?>} The new resultant array.\n */\ngoog.array.concat = function(var_args) {\n  return Array.prototype.concat.apply([], arguments);\n};\n\n\n/**\n * Returns a new array that contains the contents of all the arrays passed.\n * @param {...!Array<T>} var_args\n * @return {!Array<T>}\n * @template T\n */\ngoog.array.join = function(var_args) {\n  return Array.prototype.concat.apply([], arguments);\n};\n\n\n/**\n * Converts an object to an array.\n * @param {IArrayLike<T>|string} object  The object to convert to an\n *     array.\n * @return {!Array<T>} The object converted into an array. If object has a\n *     length property, every property indexed with a non-negative number\n *     less than length will be included in the result. If object does not\n *     have a length property, an empty array will be returned.\n * @template T\n */\ngoog.array.toArray = function(object) {\n  var length = object.length;\n\n  // If length is not a number the following is false. This case is kept for\n  // backwards compatibility since there are callers that pass objects that are\n  // not array like.\n  if (length > 0) {\n    var rv = new Array(length);\n    for (var i = 0; i < length; i++) {\n      rv[i] = object[i];\n    }\n    return rv;\n  }\n  return [];\n};\n\n\n/**\n * Does a shallow copy of an array.\n * @param {IArrayLike<T>|string} arr  Array or array-like object to\n *     clone.\n * @return {!Array<T>} Clone of the input array.\n * @template T\n */\ngoog.array.clone = goog.array.toArray;\n\n\n/**\n * Extends an array with another array, element, or \"array like\" object.\n * This function operates 'in-place', it does not create a new Array.\n *\n * Example:\n * var a = [];\n * goog.array.extend(a, [0, 1]);\n * a; // [0, 1]\n * goog.array.extend(a, 2);\n * a; // [0, 1, 2]\n *\n * @param {Array<VALUE>} arr1  The array to modify.\n * @param {...(IArrayLike<VALUE>|VALUE)} var_args The elements or arrays of\n *     elements to add to arr1.\n * @template VALUE\n */\ngoog.array.extend = function(arr1, var_args) {\n  for (var i = 1; i < arguments.length; i++) {\n    var arr2 = arguments[i];\n    if (goog.isArrayLike(arr2)) {\n      var len1 = arr1.length || 0;\n      var len2 = arr2.length || 0;\n      arr1.length = len1 + len2;\n      for (var j = 0; j < len2; j++) {\n        arr1[len1 + j] = arr2[j];\n      }\n    } else {\n      arr1.push(arr2);\n    }\n  }\n};\n\n\n/**\n * Adds or removes elements from an array. This is a generic version of Array\n * splice. This means that it might work on other objects similar to arrays,\n * such as the arguments object.\n *\n * @param {IArrayLike<T>} arr The array to modify.\n * @param {number|undefined} index The index at which to start changing the\n *     array. If not defined, treated as 0.\n * @param {number} howMany How many elements to remove (0 means no removal. A\n *     value below 0 is treated as zero and so is any other non number. Numbers\n *     are floored).\n * @param {...T} var_args Optional, additional elements to insert into the\n *     array.\n * @return {!Array<T>} the removed elements.\n * @template T\n */\ngoog.array.splice = function(arr, index, howMany, var_args) {\n  goog.asserts.assert(arr.length != null);\n\n  return Array.prototype.splice.apply(arr, goog.array.slice(arguments, 1));\n};\n\n\n/**\n * Returns a new array from a segment of an array. This is a generic version of\n * Array slice. This means that it might work on other objects similar to\n * arrays, such as the arguments object.\n *\n * @param {IArrayLike<T>|string} arr The array from\n * which to copy a segment.\n * @param {number} start The index of the first element to copy.\n * @param {number=} opt_end The index after the last element to copy.\n * @return {!Array<T>} A new array containing the specified segment of the\n *     original array.\n * @template T\n */\ngoog.array.slice = function(arr, start, opt_end) {\n  goog.asserts.assert(arr.length != null);\n\n  // passing 1 arg to slice is not the same as passing 2 where the second is\n  // null or undefined (in that case the second argument is treated as 0).\n  // we could use slice on the arguments object and then use apply instead of\n  // testing the length\n  if (arguments.length <= 2) {\n    return Array.prototype.slice.call(arr, start);\n  } else {\n    return Array.prototype.slice.call(arr, start, opt_end);\n  }\n};\n\n\n/**\n * Removes all duplicates from an array (retaining only the first\n * occurrence of each array element).  This function modifies the\n * array in place and doesn't change the order of the non-duplicate items.\n *\n * For objects, duplicates are identified as having the same unique ID as\n * defined by {@link goog.getUid}.\n *\n * Alternatively you can specify a custom hash function that returns a unique\n * value for each item in the array it should consider unique.\n *\n * Runtime: N,\n * Worstcase space: 2N (no dupes)\n *\n * @param {IArrayLike<T>} arr The array from which to remove\n *     duplicates.\n * @param {Array=} opt_rv An optional array in which to return the results,\n *     instead of performing the removal inplace.  If specified, the original\n *     array will remain unchanged.\n * @param {function(T):string=} opt_hashFn An optional function to use to\n *     apply to every item in the array. This function should return a unique\n *     value for each item in the array it should consider unique.\n * @template T\n */\ngoog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {\n  var returnArray = opt_rv || arr;\n  var defaultHashFn = function(item) {\n    // Prefix each type with a single character representing the type to\n    // prevent conflicting keys (e.g. true and 'true').\n    return goog.isObject(item) ? 'o' + goog.getUid(item) :\n                                 (typeof item).charAt(0) + item;\n  };\n  var hashFn = opt_hashFn || defaultHashFn;\n\n  var seen = {}, cursorInsert = 0, cursorRead = 0;\n  while (cursorRead < arr.length) {\n    var current = arr[cursorRead++];\n    var key = hashFn(current);\n    if (!Object.prototype.hasOwnProperty.call(seen, key)) {\n      seen[key] = true;\n      returnArray[cursorInsert++] = current;\n    }\n  }\n  returnArray.length = cursorInsert;\n};\n\n\n/**\n * Searches the specified array for the specified target using the binary\n * search algorithm.  If no opt_compareFn is specified, elements are compared\n * using <code>goog.array.defaultCompare</code>, which compares the elements\n * using the built in < and > operators.  This will produce the expected\n * behavior for homogeneous arrays of String(s) and Number(s). The array\n * specified <b>must</b> be sorted in ascending order (as defined by the\n * comparison function).  If the array is not sorted, results are undefined.\n * If the array contains multiple instances of the specified target value, any\n * of these instances may be found.\n *\n * Runtime: O(log n)\n *\n * @param {IArrayLike<VALUE>} arr The array to be searched.\n * @param {TARGET} target The sought value.\n * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison\n *     function by which the array is ordered. Should take 2 arguments to\n *     compare, the target value and an element from your array, and return a\n *     negative number, zero, or a positive number depending on whether the\n *     first argument is less than, equal to, or greater than the second.\n * @return {number} Lowest index of the target value if found, otherwise\n *     (-(insertion point) - 1). The insertion point is where the value should\n *     be inserted into arr to preserve the sorted property.  Return value >= 0\n *     iff target is found.\n * @template TARGET, VALUE\n */\ngoog.array.binarySearch = function(arr, target, opt_compareFn) {\n  return goog.array.binarySearch_(\n      arr, opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,\n      target);\n};\n\n\n/**\n * Selects an index in the specified array using the binary search algorithm.\n * The evaluator receives an element and determines whether the desired index\n * is before, at, or after it.  The evaluator must be consistent (formally,\n * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)\n * must be monotonically non-increasing).\n *\n * Runtime: O(log n)\n *\n * @param {IArrayLike<VALUE>} arr The array to be searched.\n * @param {function(this:THIS, VALUE, number, ?): number} evaluator\n *     Evaluator function that receives 3 arguments (the element, the index and\n *     the array). Should return a negative number, zero, or a positive number\n *     depending on whether the desired index is before, at, or after the\n *     element passed to it.\n * @param {THIS=} opt_obj The object to be used as the value of 'this'\n *     within evaluator.\n * @return {number} Index of the leftmost element matched by the evaluator, if\n *     such exists; otherwise (-(insertion point) - 1). The insertion point is\n *     the index of the first element for which the evaluator returns negative,\n *     or arr.length if no such element exists. The return value is non-negative\n *     iff a match is found.\n * @template THIS, VALUE\n */\ngoog.array.binarySelect = function(arr, evaluator, opt_obj) {\n  return goog.array.binarySearch_(\n      arr, evaluator, true /* isEvaluator */, undefined /* opt_target */,\n      opt_obj);\n};\n\n\n/**\n * Implementation of a binary search algorithm which knows how to use both\n * comparison functions and evaluators. If an evaluator is provided, will call\n * the evaluator with the given optional data object, conforming to the\n * interface defined in binarySelect. Otherwise, if a comparison function is\n * provided, will call the comparison function against the given data object.\n *\n * This implementation purposefully does not use goog.bind or goog.partial for\n * performance reasons.\n *\n * Runtime: O(log n)\n *\n * @param {IArrayLike<?>} arr The array to be searched.\n * @param {function(?, ?, ?): number | function(?, ?): number} compareFn\n *     Either an evaluator or a comparison function, as defined by binarySearch\n *     and binarySelect above.\n * @param {boolean} isEvaluator Whether the function is an evaluator or a\n *     comparison function.\n * @param {?=} opt_target If the function is a comparison function, then\n *     this is the target to binary search for.\n * @param {Object=} opt_selfObj If the function is an evaluator, this is an\n *     optional this object for the evaluator.\n * @return {number} Lowest index of the target value if found, otherwise\n *     (-(insertion point) - 1). The insertion point is where the value should\n *     be inserted into arr to preserve the sorted property.  Return value >= 0\n *     iff target is found.\n * @private\n */\ngoog.array.binarySearch_ = function(\n    arr, compareFn, isEvaluator, opt_target, opt_selfObj) {\n  var left = 0;            // inclusive\n  var right = arr.length;  // exclusive\n  var found;\n  while (left < right) {\n    var middle = (left + right) >> 1;\n    var compareResult;\n    if (isEvaluator) {\n      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);\n    } else {\n      // NOTE(dimvar): To avoid this cast, we'd have to use function overloading\n      // for the type of binarySearch_, which the type system can't express yet.\n      compareResult = /** @type {function(?, ?): number} */ (compareFn)(\n          opt_target, arr[middle]);\n    }\n    if (compareResult > 0) {\n      left = middle + 1;\n    } else {\n      right = middle;\n      // We are looking for the lowest index so we can't return immediately.\n      found = !compareResult;\n    }\n  }\n  // left is the index if found, or the insertion point otherwise.\n  // ~left is a shorthand for -left - 1.\n  return found ? left : ~left;\n};\n\n\n/**\n * Sorts the specified array into ascending order.  If no opt_compareFn is\n * specified, elements are compared using\n * <code>goog.array.defaultCompare</code>, which compares the elements using\n * the built in < and > operators.  This will produce the expected behavior\n * for homogeneous arrays of String(s) and Number(s), unlike the native sort,\n * but will give unpredictable results for heterogeneous lists of strings and\n * numbers with different numbers of digits.\n *\n * This sort is not guaranteed to be stable.\n *\n * Runtime: Same as <code>Array.prototype.sort</code>\n *\n * @param {Array<T>} arr The array to be sorted.\n * @param {?function(T,T):number=} opt_compareFn Optional comparison\n *     function by which the\n *     array is to be ordered. Should take 2 arguments to compare, and return a\n *     negative number, zero, or a positive number depending on whether the\n *     first argument is less than, equal to, or greater than the second.\n * @template T\n */\ngoog.array.sort = function(arr, opt_compareFn) {\n  // TODO(arv): Update type annotation since null is not accepted.\n  arr.sort(opt_compareFn || goog.array.defaultCompare);\n};\n\n\n/**\n * Sorts the specified array into ascending order in a stable way.  If no\n * opt_compareFn is specified, elements are compared using\n * <code>goog.array.defaultCompare</code>, which compares the elements using\n * the built in < and > operators.  This will produce the expected behavior\n * for homogeneous arrays of String(s) and Number(s).\n *\n * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional\n * O(n) overhead of copying the array twice.\n *\n * @param {Array<T>} arr The array to be sorted.\n * @param {?function(T, T): number=} opt_compareFn Optional comparison function\n *     by which the array is to be ordered. Should take 2 arguments to compare,\n *     and return a negative number, zero, or a positive number depending on\n *     whether the first argument is less than, equal to, or greater than the\n *     second.\n * @template T\n */\ngoog.array.stableSort = function(arr, opt_compareFn) {\n  var compArr = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++) {\n    compArr[i] = {index: i, value: arr[i]};\n  }\n  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;\n  function stableCompareFn(obj1, obj2) {\n    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;\n  }\n  goog.array.sort(compArr, stableCompareFn);\n  for (var i = 0; i < arr.length; i++) {\n    arr[i] = compArr[i].value;\n  }\n};\n\n\n/**\n * Sort the specified array into ascending order based on item keys\n * returned by the specified key function.\n * If no opt_compareFn is specified, the keys are compared in ascending order\n * using <code>goog.array.defaultCompare</code>.\n *\n * Runtime: O(S(f(n)), where S is runtime of <code>goog.array.sort</code>\n * and f(n) is runtime of the key function.\n *\n * @param {Array<T>} arr The array to be sorted.\n * @param {function(T): K} keyFn Function taking array element and returning\n *     a key used for sorting this element.\n * @param {?function(K, K): number=} opt_compareFn Optional comparison function\n *     by which the keys are to be ordered. Should take 2 arguments to compare,\n *     and return a negative number, zero, or a positive number depending on\n *     whether the first argument is less than, equal to, or greater than the\n *     second.\n * @template T,K\n */\ngoog.array.sortByKey = function(arr, keyFn, opt_compareFn) {\n  var keyCompareFn = opt_compareFn || goog.array.defaultCompare;\n  goog.array.sort(\n      arr, function(a, b) { return keyCompareFn(keyFn(a), keyFn(b)); });\n};\n\n\n/**\n * Sorts an array of objects by the specified object key and compare\n * function. If no compare function is provided, the key values are\n * compared in ascending order using <code>goog.array.defaultCompare</code>.\n * This won't work for keys that get renamed by the compiler. So use\n * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.\n * @param {Array<Object>} arr An array of objects to sort.\n * @param {string} key The object key to sort by.\n * @param {Function=} opt_compareFn The function to use to compare key\n *     values.\n */\ngoog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {\n  goog.array.sortByKey(arr, function(obj) { return obj[key]; }, opt_compareFn);\n};\n\n\n/**\n * Tells if the array is sorted.\n * @param {!IArrayLike<T>} arr The array.\n * @param {?function(T,T):number=} opt_compareFn Function to compare the\n *     array elements.\n *     Should take 2 arguments to compare, and return a negative number, zero,\n *     or a positive number depending on whether the first argument is less\n *     than, equal to, or greater than the second.\n * @param {boolean=} opt_strict If true no equal elements are allowed.\n * @return {boolean} Whether the array is sorted.\n * @template T\n */\ngoog.array.isSorted = function(arr, opt_compareFn, opt_strict) {\n  var compare = opt_compareFn || goog.array.defaultCompare;\n  for (var i = 1; i < arr.length; i++) {\n    var compareResult = compare(arr[i - 1], arr[i]);\n    if (compareResult > 0 || compareResult == 0 && opt_strict) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Compares two arrays for equality. Two arrays are considered equal if they\n * have the same length and their corresponding elements are equal according to\n * the comparison function.\n *\n * @param {IArrayLike<?>} arr1 The first array to compare.\n * @param {IArrayLike<?>} arr2 The second array to compare.\n * @param {Function=} opt_equalsFn Optional comparison function.\n *     Should take 2 arguments to compare, and return true if the arguments\n *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which\n *     compares the elements using the built-in '===' operator.\n * @return {boolean} Whether the two arrays are equal.\n */\ngoog.array.equals = function(arr1, arr2, opt_equalsFn) {\n  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||\n      arr1.length != arr2.length) {\n    return false;\n  }\n  var l = arr1.length;\n  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;\n  for (var i = 0; i < l; i++) {\n    if (!equalsFn(arr1[i], arr2[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * 3-way array compare function.\n * @param {!IArrayLike<VALUE>} arr1 The first array to\n *     compare.\n * @param {!IArrayLike<VALUE>} arr2 The second array to\n *     compare.\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\n *     function by which the array is to be ordered. Should take 2 arguments to\n *     compare, and return a negative number, zero, or a positive number\n *     depending on whether the first argument is less than, equal to, or\n *     greater than the second.\n * @return {number} Negative number, zero, or a positive number depending on\n *     whether the first argument is less than, equal to, or greater than the\n *     second.\n * @template VALUE\n */\ngoog.array.compare3 = function(arr1, arr2, opt_compareFn) {\n  var compare = opt_compareFn || goog.array.defaultCompare;\n  var l = Math.min(arr1.length, arr2.length);\n  for (var i = 0; i < l; i++) {\n    var result = compare(arr1[i], arr2[i]);\n    if (result != 0) {\n      return result;\n    }\n  }\n  return goog.array.defaultCompare(arr1.length, arr2.length);\n};\n\n\n/**\n * Compares its two arguments for order, using the built in < and >\n * operators.\n * @param {VALUE} a The first object to be compared.\n * @param {VALUE} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second,\n *     respectively.\n * @template VALUE\n */\ngoog.array.defaultCompare = function(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n};\n\n\n/**\n * Compares its two arguments for inverse order, using the built in < and >\n * operators.\n * @param {VALUE} a The first object to be compared.\n * @param {VALUE} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is greater than, equal to, or less than the second,\n *     respectively.\n * @template VALUE\n */\ngoog.array.inverseDefaultCompare = function(a, b) {\n  return -goog.array.defaultCompare(a, b);\n};\n\n\n/**\n * Compares its two arguments for equality, using the built in === operator.\n * @param {*} a The first object to compare.\n * @param {*} b The second object to compare.\n * @return {boolean} True if the two arguments are equal, false otherwise.\n */\ngoog.array.defaultCompareEquality = function(a, b) {\n  return a === b;\n};\n\n\n/**\n * Inserts a value into a sorted array. The array is not modified if the\n * value is already present.\n * @param {IArrayLike<VALUE>} array The array to modify.\n * @param {VALUE} value The object to insert.\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\n *     function by which the array is ordered. Should take 2 arguments to\n *     compare, and return a negative number, zero, or a positive number\n *     depending on whether the first argument is less than, equal to, or\n *     greater than the second.\n * @return {boolean} True if an element was inserted.\n * @template VALUE\n */\ngoog.array.binaryInsert = function(array, value, opt_compareFn) {\n  var index = goog.array.binarySearch(array, value, opt_compareFn);\n  if (index < 0) {\n    goog.array.insertAt(array, value, -(index + 1));\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Removes a value from a sorted array.\n * @param {!IArrayLike<VALUE>} array The array to modify.\n * @param {VALUE} value The object to remove.\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\n *     function by which the array is ordered. Should take 2 arguments to\n *     compare, and return a negative number, zero, or a positive number\n *     depending on whether the first argument is less than, equal to, or\n *     greater than the second.\n * @return {boolean} True if an element was removed.\n * @template VALUE\n */\ngoog.array.binaryRemove = function(array, value, opt_compareFn) {\n  var index = goog.array.binarySearch(array, value, opt_compareFn);\n  return (index >= 0) ? goog.array.removeAt(array, index) : false;\n};\n\n\n/**\n * Splits an array into disjoint buckets according to a splitting function.\n * @param {IArrayLike<T>} array The array.\n * @param {function(this:S, T, number, !IArrayLike<T>):?} sorter Function to\n *     call for every element.  This takes 3 arguments (the element, the index\n *     and the array) and must return a valid object key (a string, number,\n *     etc), or undefined, if that object should not be placed in a bucket.\n * @param {S=} opt_obj The object to be used as the value of 'this' within\n *     sorter.\n * @return {!Object<!Array<T>>} An object, with keys being all of the unique\n *     return values of sorter, and values being arrays containing the items for\n *     which the splitter returned that key.\n * @template T,S\n */\ngoog.array.bucket = function(array, sorter, opt_obj) {\n  var buckets = {};\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n    var key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);\n    if (goog.isDef(key)) {\n      // Push the value to the right bucket, creating it if necessary.\n      var bucket = buckets[key] || (buckets[key] = []);\n      bucket.push(value);\n    }\n  }\n\n  return buckets;\n};\n\n\n/**\n * Creates a new object built from the provided array and the key-generation\n * function.\n * @param {IArrayLike<T>} arr Array or array like object over\n *     which to iterate whose elements will be the values in the new object.\n * @param {?function(this:S, T, number, ?) : string} keyFunc The function to\n *     call for every element. This function takes 3 arguments (the element, the\n *     index and the array) and should return a string that will be used as the\n *     key for the element in the new object. If the function returns the same\n *     key for more than one element, the value for that key is\n *     implementation-defined.\n * @param {S=} opt_obj The object to be used as the value of 'this'\n *     within keyFunc.\n * @return {!Object<T>} The new object.\n * @template T,S\n */\ngoog.array.toObject = function(arr, keyFunc, opt_obj) {\n  var ret = {};\n  goog.array.forEach(arr, function(element, index) {\n    ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =\n        element;\n  });\n  return ret;\n};\n\n\n/**\n * Creates a range of numbers in an arithmetic progression.\n *\n * Range takes 1, 2, or 3 arguments:\n * <pre>\n * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]\n * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]\n * range(-2, -5, -1) produces [-2, -3, -4]\n * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.\n * </pre>\n *\n * @param {number} startOrEnd The starting value of the range if an end argument\n *     is provided. Otherwise, the start value is 0, and this is the end value.\n * @param {number=} opt_end The optional end value of the range.\n * @param {number=} opt_step The step size between range values. Defaults to 1\n *     if opt_step is undefined or 0.\n * @return {!Array<number>} An array of numbers for the requested range. May be\n *     an empty array if adding the step would not converge toward the end\n *     value.\n */\ngoog.array.range = function(startOrEnd, opt_end, opt_step) {\n  var array = [];\n  var start = 0;\n  var end = startOrEnd;\n  var step = opt_step || 1;\n  if (opt_end !== undefined) {\n    start = startOrEnd;\n    end = opt_end;\n  }\n\n  if (step * (end - start) < 0) {\n    // Sign mismatch: start + step will never reach the end value.\n    return [];\n  }\n\n  if (step > 0) {\n    for (var i = start; i < end; i += step) {\n      array.push(i);\n    }\n  } else {\n    for (var i = start; i > end; i += step) {\n      array.push(i);\n    }\n  }\n  return array;\n};\n\n\n/**\n * Returns an array consisting of the given value repeated N times.\n *\n * @param {VALUE} value The value to repeat.\n * @param {number} n The repeat count.\n * @return {!Array<VALUE>} An array with the repeated value.\n * @template VALUE\n */\ngoog.array.repeat = function(value, n) {\n  var array = [];\n  for (var i = 0; i < n; i++) {\n    array[i] = value;\n  }\n  return array;\n};\n\n\n/**\n * Returns an array consisting of every argument with all arrays\n * expanded in-place recursively.\n *\n * @param {...*} var_args The values to flatten.\n * @return {!Array<?>} An array containing the flattened values.\n */\ngoog.array.flatten = function(var_args) {\n  var CHUNK_SIZE = 8192;\n\n  var result = [];\n  for (var i = 0; i < arguments.length; i++) {\n    var element = arguments[i];\n    if (goog.isArray(element)) {\n      for (var c = 0; c < element.length; c += CHUNK_SIZE) {\n        var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);\n        var recurseResult = goog.array.flatten.apply(null, chunk);\n        for (var r = 0; r < recurseResult.length; r++) {\n          result.push(recurseResult[r]);\n        }\n      }\n    } else {\n      result.push(element);\n    }\n  }\n  return result;\n};\n\n\n/**\n * Rotates an array in-place. After calling this method, the element at\n * index i will be the element previously at index (i - n) %\n * array.length, for all values of i between 0 and array.length - 1,\n * inclusive.\n *\n * For example, suppose list comprises [t, a, n, k, s]. After invoking\n * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].\n *\n * @param {!Array<T>} array The array to rotate.\n * @param {number} n The amount to rotate.\n * @return {!Array<T>} The array.\n * @template T\n */\ngoog.array.rotate = function(array, n) {\n  goog.asserts.assert(array.length != null);\n\n  if (array.length) {\n    n %= array.length;\n    if (n > 0) {\n      Array.prototype.unshift.apply(array, array.splice(-n, n));\n    } else if (n < 0) {\n      Array.prototype.push.apply(array, array.splice(0, -n));\n    }\n  }\n  return array;\n};\n\n\n/**\n * Moves one item of an array to a new position keeping the order of the rest\n * of the items. Example use case: keeping a list of JavaScript objects\n * synchronized with the corresponding list of DOM elements after one of the\n * elements has been dragged to a new position.\n * @param {!IArrayLike<?>} arr The array to modify.\n * @param {number} fromIndex Index of the item to move between 0 and\n *     {@code arr.length - 1}.\n * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.\n */\ngoog.array.moveItem = function(arr, fromIndex, toIndex) {\n  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);\n  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);\n  // Remove 1 item at fromIndex.\n  var removedItems = Array.prototype.splice.call(arr, fromIndex, 1);\n  // Insert the removed item at toIndex.\n  Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);\n  // We don't use goog.array.insertAt and goog.array.removeAt, because they're\n  // significantly slower than splice.\n};\n\n\n/**\n * Creates a new array for which the element at position i is an array of the\n * ith element of the provided arrays.  The returned array will only be as long\n * as the shortest array provided; additional values are ignored.  For example,\n * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].\n *\n * This is similar to the zip() function in Python.  See {@link\n * http://docs.python.org/library/functions.html#zip}\n *\n * @param {...!IArrayLike<?>} var_args Arrays to be combined.\n * @return {!Array<!Array<?>>} A new array of arrays created from\n *     provided arrays.\n */\ngoog.array.zip = function(var_args) {\n  if (!arguments.length) {\n    return [];\n  }\n  var result = [];\n  var minLen = arguments[0].length;\n  for (var i = 1; i < arguments.length; i++) {\n    if (arguments[i].length < minLen) {\n      minLen = arguments[i].length;\n    }\n  }\n  for (var i = 0; i < minLen; i++) {\n    var value = [];\n    for (var j = 0; j < arguments.length; j++) {\n      value.push(arguments[j][i]);\n    }\n    result.push(value);\n  }\n  return result;\n};\n\n\n/**\n * Shuffles the values in the specified array using the Fisher-Yates in-place\n * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()\n * and so resets the state of that random number generator. Similarly, may reset\n * the state of any other specified random number generator.\n *\n * Runtime: O(n)\n *\n * @param {!Array<?>} arr The array to be shuffled.\n * @param {function():number=} opt_randFn Optional random function to use for\n *     shuffling.\n *     Takes no arguments, and returns a random number on the interval [0, 1).\n *     Defaults to Math.random() using JavaScript's built-in Math library.\n */\ngoog.array.shuffle = function(arr, opt_randFn) {\n  var randFn = opt_randFn || Math.random;\n\n  for (var i = arr.length - 1; i > 0; i--) {\n    // Choose a random array index in [0, i] (inclusive with i).\n    var j = Math.floor(randFn() * (i + 1));\n\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n};\n\n\n/**\n * Returns a new array of elements from arr, based on the indexes of elements\n * provided by index_arr. For example, the result of index copying\n * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].\n *\n * @param {!IArrayLike<T>} arr The array to get a indexed copy from.\n * @param {!IArrayLike<number>} index_arr An array of indexes to get from arr.\n * @return {!Array<T>} A new array of elements from arr in index_arr order.\n * @template T\n */\ngoog.array.copyByIndex = function(arr, index_arr) {\n  var result = [];\n  goog.array.forEach(index_arr, function(index) { result.push(arr[index]); });\n  return result;\n};\n\n\n/**\n * Maps each element of the input array into zero or more elements of the output\n * array.\n *\n * @param {!IArrayLike<VALUE>|string} arr Array or array like object\n *     over which to iterate.\n * @param {function(this:THIS, VALUE, number, ?): !Array<RESULT>} f The function\n *     to call for every element. This function takes 3 arguments (the element,\n *     the index and the array) and should return an array. The result will be\n *     used to extend a new array.\n * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.\n * @return {!Array<RESULT>} a new array with the concatenation of all arrays\n *     returned from f.\n * @template THIS, VALUE, RESULT\n */\ngoog.array.concatMap = function(arr, f, opt_obj) {\n  return goog.array.concat.apply([], goog.array.map(arr, f, opt_obj));\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for manipulating objects/maps/hashes.\n * @author arv@google.com (Erik Arvidsson)\n */\n\ngoog.provide('goog.object');\n\n\n/**\n * Whether two values are not observably distinguishable. This\n * correctly detects that 0 is not the same as -0 and two NaNs are\n * practically equivalent.\n *\n * The implementation is as suggested by harmony:egal proposal.\n *\n * @param {*} v The first value to compare.\n * @param {*} v2 The second value to compare.\n * @return {boolean} Whether two values are not observably distinguishable.\n * @see http://wiki.ecmascript.org/doku.php?id=harmony:egal\n */\ngoog.object.is = function(v, v2) {\n  if (v === v2) {\n    // 0 === -0, but they are not identical.\n    // We need the cast because the compiler requires that v2 is a\n    // number (although 1/v2 works with non-number). We cast to ? to\n    // stop the compiler from type-checking this statement.\n    return v !== 0 || 1 / v === 1 / /** @type {?} */ (v2);\n  }\n\n  // NaN is non-reflexive: NaN !== NaN, although they are identical.\n  return v !== v && v2 !== v2;\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):?} f The function to call\n *     for every element. This function takes 3 arguments (the value, the\n *     key and the object) and the return value is ignored.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @template T,K,V\n */\ngoog.object.forEach = function(obj, f, opt_obj) {\n  for (var key in obj) {\n    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\n  }\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If that call returns\n * true, adds the element to a new object.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call\n *     for every element. This\n *     function takes 3 arguments (the value, the key and the object)\n *     and should return a boolean. If the return value is true the\n *     element is added to the result object. If it is false the\n *     element is not included.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {!Object<K,V>} a new object in which only elements that passed the\n *     test are present.\n * @template T,K,V\n */\ngoog.object.filter = function(obj, f, opt_obj) {\n  var res = {};\n  for (var key in obj) {\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\n\n\n/**\n * For every element in an object/map/hash calls a function and inserts the\n * result into a new object.\n *\n * @param {Object<K,V>} obj The object over which to iterate.\n * @param {function(this:T,V,?,Object<K,V>):R} f The function to call\n *     for every element. This function\n *     takes 3 arguments (the value, the key and the object)\n *     and should return something. The result will be inserted\n *     into a new object.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {!Object<K,R>} a new object with the results from f.\n * @template T,K,V,R\n */\ngoog.object.map = function(obj, f, opt_obj) {\n  var res = {};\n  for (var key in obj) {\n    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\n  }\n  return res;\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If any\n * call returns true, returns true (without checking the rest). If\n * all calls return false, returns false.\n *\n * @param {Object<K,V>} obj The object to check.\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to\n *     call for every element. This function\n *     takes 3 arguments (the value, the key and the object) and should\n *     return a boolean.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {boolean} true if any element passes the test.\n * @template T,K,V\n */\ngoog.object.some = function(obj, f, opt_obj) {\n  for (var key in obj) {\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Calls a function for each element in an object/map/hash. If\n * all calls return true, returns true. If any call returns false, returns\n * false at this point and does not continue to check the remaining elements.\n *\n * @param {Object<K,V>} obj The object to check.\n * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to\n *     call for every element. This function\n *     takes 3 arguments (the value, the key and the object) and should\n *     return a boolean.\n * @param {T=} opt_obj This is used as the 'this' object within f.\n * @return {boolean} false if any element fails the test.\n * @template T,K,V\n */\ngoog.object.every = function(obj, f, opt_obj) {\n  for (var key in obj) {\n    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Returns the number of key-value pairs in the object map.\n *\n * @param {Object} obj The object for which to get the number of key-value\n *     pairs.\n * @return {number} The number of key-value pairs in the object map.\n */\ngoog.object.getCount = function(obj) {\n  var rv = 0;\n  for (var key in obj) {\n    rv++;\n  }\n  return rv;\n};\n\n\n/**\n * Returns one key from the object map, if any exists.\n * For map literals the returned key will be the first one in most of the\n * browsers (a know exception is Konqueror).\n *\n * @param {Object} obj The object to pick a key from.\n * @return {string|undefined} The key or undefined if the object is empty.\n */\ngoog.object.getAnyKey = function(obj) {\n  for (var key in obj) {\n    return key;\n  }\n};\n\n\n/**\n * Returns one value from the object map, if any exists.\n * For map literals the returned value will be the first one in most of the\n * browsers (a know exception is Konqueror).\n *\n * @param {Object<K,V>} obj The object to pick a value from.\n * @return {V|undefined} The value or undefined if the object is empty.\n * @template K,V\n */\ngoog.object.getAnyValue = function(obj) {\n  for (var key in obj) {\n    return obj[key];\n  }\n};\n\n\n/**\n * Whether the object/hash/map contains the given object as a value.\n * An alias for goog.object.containsValue(obj, val).\n *\n * @param {Object<K,V>} obj The object in which to look for val.\n * @param {V} val The object for which to check.\n * @return {boolean} true if val is present.\n * @template K,V\n */\ngoog.object.contains = function(obj, val) {\n  return goog.object.containsValue(obj, val);\n};\n\n\n/**\n * Returns the values of the object/map/hash.\n *\n * @param {Object<K,V>} obj The object from which to get the values.\n * @return {!Array<V>} The values in the object/map/hash.\n * @template K,V\n */\ngoog.object.getValues = function(obj) {\n  var res = [];\n  var i = 0;\n  for (var key in obj) {\n    res[i++] = obj[key];\n  }\n  return res;\n};\n\n\n/**\n * Returns the keys of the object/map/hash.\n *\n * @param {Object} obj The object from which to get the keys.\n * @return {!Array<string>} Array of property keys.\n */\ngoog.object.getKeys = function(obj) {\n  var res = [];\n  var i = 0;\n  for (var key in obj) {\n    res[i++] = key;\n  }\n  return res;\n};\n\n\n/**\n * Get a value from an object multiple levels deep.  This is useful for\n * pulling values from deeply nested objects, such as JSON responses.\n * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)\n *\n * @param {!Object} obj An object to get the value from.  Can be array-like.\n * @param {...(string|number|!IArrayLike<number|string>)}\n *     var_args A number of keys\n *     (as strings, or numbers, for array-like objects).  Can also be\n *     specified as a single array of keys.\n * @return {*} The resulting value.  If, at any point, the value for a key\n *     in the current object is null or undefined, returns undefined.\n */\ngoog.object.getValueByKeys = function(obj, var_args) {\n  var isArrayLike = goog.isArrayLike(var_args);\n  var keys = isArrayLike ?\n      /** @type {!IArrayLike<number|string>} */ (var_args) :\n      arguments;\n\n  // Start with the 2nd parameter for the variable parameters syntax.\n  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {\n    if (obj == null) return undefined;\n    obj = obj[keys[i]];\n  }\n\n  return obj;\n};\n\n\n/**\n * Whether the object/map/hash contains the given key.\n *\n * @param {Object} obj The object in which to look for key.\n * @param {?} key The key for which to check.\n * @return {boolean} true If the map contains the key.\n */\ngoog.object.containsKey = function(obj, key) {\n  return obj !== null && key in obj;\n};\n\n\n/**\n * Whether the object/map/hash contains the given value. This is O(n).\n *\n * @param {Object<K,V>} obj The object in which to look for val.\n * @param {V} val The value for which to check.\n * @return {boolean} true If the map contains the value.\n * @template K,V\n */\ngoog.object.containsValue = function(obj, val) {\n  for (var key in obj) {\n    if (obj[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Searches an object for an element that satisfies the given condition and\n * returns its key.\n * @param {Object<K,V>} obj The object to search in.\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The\n *      function to call for every element. Takes 3 arguments (the value,\n *     the key and the object) and should return a boolean.\n * @param {T=} opt_this An optional \"this\" context for the function.\n * @return {string|undefined} The key of an element for which the function\n *     returns true or undefined if no such element is found.\n * @template T,K,V\n */\ngoog.object.findKey = function(obj, f, opt_this) {\n  for (var key in obj) {\n    if (f.call(/** @type {?} */ (opt_this), obj[key], key, obj)) {\n      return key;\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * Searches an object for an element that satisfies the given condition and\n * returns its value.\n * @param {Object<K,V>} obj The object to search in.\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The function\n *     to call for every element. Takes 3 arguments (the value, the key\n *     and the object) and should return a boolean.\n * @param {T=} opt_this An optional \"this\" context for the function.\n * @return {V} The value of an element for which the function returns true or\n *     undefined if no such element is found.\n * @template T,K,V\n */\ngoog.object.findValue = function(obj, f, opt_this) {\n  var key = goog.object.findKey(obj, f, opt_this);\n  return key && obj[key];\n};\n\n\n/**\n * Whether the object/map/hash is empty.\n *\n * @param {Object} obj The object to test.\n * @return {boolean} true if obj is empty.\n */\ngoog.object.isEmpty = function(obj) {\n  for (var key in obj) {\n    return false;\n  }\n  return true;\n};\n\n\n/**\n * Removes all key value pairs from the object/map/hash.\n *\n * @param {Object} obj The object to clear.\n */\ngoog.object.clear = function(obj) {\n  for (var i in obj) {\n    delete obj[i];\n  }\n};\n\n\n/**\n * Removes a key-value pair based on the key.\n *\n * @param {Object} obj The object from which to remove the key.\n * @param {?} key The key to remove.\n * @return {boolean} Whether an element was removed.\n */\ngoog.object.remove = function(obj, key) {\n  var rv;\n  if (rv = key in /** @type {!Object} */ (obj)) {\n    delete obj[key];\n  }\n  return rv;\n};\n\n\n/**\n * Adds a key-value pair to the object. Throws an exception if the key is\n * already in use. Use set if you want to change an existing pair.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} val The value to add.\n * @template K,V\n */\ngoog.object.add = function(obj, key, val) {\n  if (obj !== null && key in obj) {\n    throw new Error('The object already contains the key \"' + key + '\"');\n  }\n  goog.object.set(obj, key, val);\n};\n\n\n/**\n * Returns the value for the given key.\n *\n * @param {Object<K,V>} obj The object from which to get the value.\n * @param {string} key The key for which to get the value.\n * @param {R=} opt_val The value to return if no item is found for the given\n *     key (default is undefined).\n * @return {V|R|undefined} The value for the given key.\n * @template K,V,R\n */\ngoog.object.get = function(obj, key, opt_val) {\n  if (obj !== null && key in obj) {\n    return obj[key];\n  }\n  return opt_val;\n};\n\n\n/**\n * Adds a key-value pair to the object/map/hash.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} value The value to add.\n * @template K,V\n */\ngoog.object.set = function(obj, key, value) {\n  obj[key] = value;\n};\n\n\n/**\n * Adds a key-value pair to the object/map/hash if it doesn't exist yet.\n *\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {V} value The value to add if the key wasn't present.\n * @return {V} The value of the entry at the end of the function.\n * @template K,V\n */\ngoog.object.setIfUndefined = function(obj, key, value) {\n  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);\n};\n\n\n/**\n * Sets a key and value to an object if the key is not set. The value will be\n * the return value of the given function. If the key already exists, the\n * object will not be changed and the function will not be called (the function\n * will be lazily evaluated -- only called if necessary).\n *\n * This function is particularly useful when used with an `Object` which is\n * acting as a cache.\n *\n * @param {!Object<K,V>} obj The object to which to add the key-value pair.\n * @param {string} key The key to add.\n * @param {function():V} f The value to add if the key wasn't present.\n * @return {V} The value of the entry at the end of the function.\n * @template K,V\n */\ngoog.object.setWithReturnValueIfNotSet = function(obj, key, f) {\n  if (key in obj) {\n    return obj[key];\n  }\n\n  var val = f();\n  obj[key] = val;\n  return val;\n};\n\n\n/**\n * Compares two objects for equality using === on the values.\n *\n * @param {!Object<K,V>} a\n * @param {!Object<K,V>} b\n * @return {boolean}\n * @template K,V\n */\ngoog.object.equals = function(a, b) {\n  for (var k in a) {\n    if (!(k in b) || a[k] !== b[k]) {\n      return false;\n    }\n  }\n  for (var k in b) {\n    if (!(k in a)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Returns a shallow clone of the object.\n *\n * @param {Object<K,V>} obj Object to clone.\n * @return {!Object<K,V>} Clone of the input object.\n * @template K,V\n */\ngoog.object.clone = function(obj) {\n  // We cannot use the prototype trick because a lot of methods depend on where\n  // the actual key is set.\n\n  var res = {};\n  for (var key in obj) {\n    res[key] = obj[key];\n  }\n  return res;\n  // We could also use goog.mixin but I wanted this to be independent from that.\n};\n\n\n/**\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\n * arrays will be cloned recursively.\n *\n * WARNINGS:\n * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects\n * that refer to themselves will cause infinite recursion.\n *\n * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and\n * copies UIDs created by <code>getUid</code> into cloned results.\n *\n * @param {T} obj The value to clone.\n * @return {T} A clone of the input value.\n * @template T\n */\ngoog.object.unsafeClone = function(obj) {\n  var type = goog.typeOf(obj);\n  if (type == 'object' || type == 'array') {\n    if (goog.isFunction(obj.clone)) {\n      return obj.clone();\n    }\n    var clone = type == 'array' ? [] : {};\n    for (var key in obj) {\n      clone[key] = goog.object.unsafeClone(obj[key]);\n    }\n    return clone;\n  }\n\n  return obj;\n};\n\n\n/**\n * Returns a new object in which all the keys and values are interchanged\n * (keys become values and values become keys). If multiple keys map to the\n * same value, the chosen transposed value is implementation-dependent.\n *\n * @param {Object} obj The object to transpose.\n * @return {!Object} The transposed object.\n */\ngoog.object.transpose = function(obj) {\n  var transposed = {};\n  for (var key in obj) {\n    transposed[obj[key]] = key;\n  }\n  return transposed;\n};\n\n\n/**\n * The names of the fields that are defined on Object.prototype.\n * @type {Array<string>}\n * @private\n */\ngoog.object.PROTOTYPE_FIELDS_ = [\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n  'toLocaleString', 'toString', 'valueOf'\n];\n\n\n/**\n * Extends an object with another object.\n * This operates 'in-place'; it does not create a new Object.\n *\n * Example:\n * var o = {};\n * goog.object.extend(o, {a: 0, b: 1});\n * o; // {a: 0, b: 1}\n * goog.object.extend(o, {b: 2, c: 3});\n * o; // {a: 0, b: 2, c: 3}\n *\n * @param {Object} target The object to modify. Existing properties will be\n *     overwritten if they are also present in one of the objects in\n *     `var_args`.\n * @param {...(Object|null|undefined)} var_args The objects from which values\n *     will be copied.\n */\ngoog.object.extend = function(target, var_args) {\n  var key, source;\n  for (var i = 1; i < arguments.length; i++) {\n    source = arguments[i];\n    for (key in source) {\n      target[key] = source[key];\n    }\n\n    // For IE the for-in-loop does not contain any properties that are not\n    // enumerable on the prototype object (for example isPrototypeOf from\n    // Object.prototype) and it will also not include 'replace' on objects that\n    // extend String and change 'replace' (not that it is common for anyone to\n    // extend anything except Object).\n\n    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {\n      key = goog.object.PROTOTYPE_FIELDS_[j];\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n};\n\n\n/**\n * Creates a new object built from the key-value pairs provided as arguments.\n * @param {...*} var_args If only one argument is provided and it is an array\n *     then this is used as the arguments, otherwise even arguments are used as\n *     the property names and odd arguments are used as the property values.\n * @return {!Object} The new object.\n * @throws {Error} If there are uneven number of arguments or there is only one\n *     non array argument.\n */\ngoog.object.create = function(var_args) {\n  var argLength = arguments.length;\n  if (argLength == 1 && goog.isArray(arguments[0])) {\n    return goog.object.create.apply(null, arguments[0]);\n  }\n\n  if (argLength % 2) {\n    throw new Error('Uneven number of arguments');\n  }\n\n  var rv = {};\n  for (var i = 0; i < argLength; i += 2) {\n    rv[arguments[i]] = arguments[i + 1];\n  }\n  return rv;\n};\n\n\n/**\n * Creates a new object where the property names come from the arguments but\n * the value is always set to true\n * @param {...*} var_args If only one argument is provided and it is an array\n *     then this is used as the arguments, otherwise the arguments are used\n *     as the property names.\n * @return {!Object} The new object.\n */\ngoog.object.createSet = function(var_args) {\n  var argLength = arguments.length;\n  if (argLength == 1 && goog.isArray(arguments[0])) {\n    return goog.object.createSet.apply(null, arguments[0]);\n  }\n\n  var rv = {};\n  for (var i = 0; i < argLength; i++) {\n    rv[arguments[i]] = true;\n  }\n  return rv;\n};\n\n\n/**\n * Creates an immutable view of the underlying object, if the browser\n * supports immutable objects.\n *\n * In default mode, writes to this view will fail silently. In strict mode,\n * they will throw an error.\n *\n * @param {!Object<K,V>} obj An object.\n * @return {!Object<K,V>} An immutable view of that object, or the\n *     original object if this browser does not support immutables.\n * @template K,V\n */\ngoog.object.createImmutableView = function(obj) {\n  var result = obj;\n  if (Object.isFrozen && !Object.isFrozen(obj)) {\n    result = Object.create(obj);\n    Object.freeze(result);\n  }\n  return result;\n};\n\n\n/**\n * @param {!Object} obj An object.\n * @return {boolean} Whether this is an immutable view of the object.\n */\ngoog.object.isImmutableView = function(obj) {\n  return !!Object.isFrozen && Object.isFrozen(obj);\n};\n\n\n/**\n * Get all properties names on a given Object regardless of enumerability.\n *\n * <p> If the browser does not support `Object.getOwnPropertyNames` nor\n * `Object.getPrototypeOf` then this is equivalent to using\n * `goog.object.getKeys`\n *\n * @param {?Object} obj The object to get the properties of.\n * @param {boolean=} opt_includeObjectPrototype Whether properties defined on\n *     `Object.prototype` should be included in the result.\n * @param {boolean=} opt_includeFunctionPrototype Whether properties defined on\n *     `Function.prototype` should be included in the result.\n * @return {!Array<string>}\n * @public\n */\ngoog.object.getAllPropertyNames = function(\n    obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {\n  if (!obj) {\n    return [];\n  }\n\n  // Naively use a for..in loop to get the property names if the browser doesn't\n  // support any other APIs for getting it.\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n    return goog.object.getKeys(obj);\n  }\n\n  var visitedSet = {};\n\n  // Traverse the prototype chain and add all properties to the visited set.\n  var proto = obj;\n  while (proto &&\n         (proto !== Object.prototype || !!opt_includeObjectPrototype) &&\n         (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {\n    var names = Object.getOwnPropertyNames(proto);\n    for (var i = 0; i < names.length; i++) {\n      visitedSet[names[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return goog.object.getKeys(visitedSet);\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.string.Const');\n\ngoog.require('goog.asserts');\ngoog.require('goog.string.TypedString');\n\n\n\n/**\n * Wrapper for compile-time-constant strings.\n *\n * Const is a wrapper for strings that can only be created from program\n * constants (i.e., string literals).  This property relies on a custom Closure\n * compiler check that `goog.string.Const.from` is only invoked on\n * compile-time-constant expressions.\n *\n * Const is useful in APIs whose correct and secure use requires that certain\n * arguments are not attacker controlled: Compile-time constants are inherently\n * under the control of the application and not under control of external\n * attackers, and hence are safe to use in such contexts.\n *\n * Instances of this type must be created via its factory method\n * `goog.string.Const.from` and not by invoking its constructor.  The\n * constructor intentionally takes no parameters and the type is immutable;\n * hence only a default instance corresponding to the empty string can be\n * obtained via constructor invocation.  Use goog.string.Const.EMPTY\n * instead of using this constructor to get an empty Const string.\n *\n * @see goog.string.Const#from\n * @constructor\n * @final\n * @struct\n * @implements {goog.string.TypedString}\n * @param {Object=} opt_token package-internal implementation detail.\n * @param {string=} opt_content package-internal implementation detail.\n */\ngoog.string.Const = function(opt_token, opt_content) {\n  /**\n   * The wrapped value of this Const object.  The field has a purposely ugly\n   * name to make (non-compiled) code that attempts to directly access this\n   * field stand out.\n   * @private {string}\n   */\n  this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ =\n      ((opt_token ===\n        goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_) &&\n       opt_content) ||\n      '';\n\n  /**\n   * A type marker used to implement additional run-time type checking.\n   * @see goog.string.Const#unwrap\n   * @const {!Object}\n   * @private\n   */\n  this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ =\n      goog.string.Const.TYPE_MARKER_;\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.string.Const.prototype.implementsGoogStringTypedString = true;\n\n\n/**\n * Returns this Const's value a string.\n *\n * IMPORTANT: In code where it is security-relevant that an object's type is\n * indeed `goog.string.Const`, use `goog.string.Const.unwrap`\n * instead of this method.\n *\n * @see goog.string.Const#unwrap\n * @override\n */\ngoog.string.Const.prototype.getTypedStringValue = function() {\n  return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;\n};\n\n\n/**\n * Returns a debug-string representation of this value.\n *\n * To obtain the actual string value wrapped inside an object of this type,\n * use `goog.string.Const.unwrap`.\n *\n * @see goog.string.Const#unwrap\n * @override\n */\ngoog.string.Const.prototype.toString = function() {\n  return 'Const{' +\n      this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ +\n      '}';\n};\n\n\n/**\n * Performs a runtime check that the provided object is indeed an instance\n * of `goog.string.Const`, and returns its value.\n * @param {!goog.string.Const} stringConst The object to extract from.\n * @return {string} The Const object's contained string, unless the run-time\n *     type check fails. In that case, `unwrap` returns an innocuous\n *     string, or, if assertions are enabled, throws\n *     `goog.asserts.AssertionError`.\n */\ngoog.string.Const.unwrap = function(stringConst) {\n  // Perform additional run-time type-checking to ensure that stringConst is\n  // indeed an instance of the expected type.  This provides some additional\n  // protection against security bugs due to application code that disables type\n  // checks.\n  if (stringConst instanceof goog.string.Const &&\n      stringConst.constructor === goog.string.Const &&\n      stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ ===\n          goog.string.Const.TYPE_MARKER_) {\n    return stringConst\n        .stringConstValueWithSecurityContract__googStringSecurityPrivate_;\n  } else {\n    goog.asserts.fail(\n        'expected object of type Const, got \\'' + stringConst + '\\'');\n    return 'type_error:Const';\n  }\n};\n\n\n/**\n * Creates a Const object from a compile-time constant string.\n *\n * It is illegal to invoke this function on an expression whose\n * compile-time-constant value cannot be determined by the Closure compiler.\n *\n * Correct invocations include,\n * <pre>\n *   var s = goog.string.Const.from('hello');\n *   var t = goog.string.Const.from('hello' + 'world');\n * </pre>\n *\n * In contrast, the following are illegal:\n * <pre>\n *   var s = goog.string.Const.from(getHello());\n *   var t = goog.string.Const.from('hello' + world);\n * </pre>\n *\n * @param {string} s A constant string from which to create a Const.\n * @return {!goog.string.Const} A Const object initialized to stringConst.\n */\ngoog.string.Const.from = function(s) {\n  return new goog.string.Const(\n      goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, s);\n};\n\n/**\n * Type marker for the Const type, used to implement additional run-time\n * type checking.\n * @const {!Object}\n * @private\n */\ngoog.string.Const.TYPE_MARKER_ = {};\n\n/**\n * @type {!Object}\n * @private\n * @const\n */\ngoog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {};\n\n/**\n * A Const instance wrapping the empty string.\n * @const {!goog.string.Const}\n */\ngoog.string.Const.EMPTY = goog.string.Const.from('');\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview The TrustedResourceUrl type and its builders.\n *\n * TODO(xtof): Link to document stating type contract.\n */\n\ngoog.provide('goog.html.TrustedResourceUrl');\n\ngoog.require('goog.asserts');\ngoog.require('goog.html.trustedtypes');\ngoog.require('goog.i18n.bidi.Dir');\ngoog.require('goog.i18n.bidi.DirectionalString');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.TypedString');\n\n\n\n/**\n * A URL which is under application control and from which script, CSS, and\n * other resources that represent executable code, can be fetched.\n *\n * Given that the URL can only be constructed from strings under application\n * control and is used to load resources, bugs resulting in a malformed URL\n * should not have a security impact and are likely to be easily detectable\n * during testing. Given the wide number of non-RFC compliant URLs in use,\n * stricter validation could prevent some applications from being able to use\n * this type.\n *\n * Instances of this type must be created via the factory method,\n * (`fromConstant`, `fromConstants`, `format` or\n * `formatWithParams`), and not by invoking its constructor. The constructor\n * intentionally takes no parameters and the type is immutable; hence only a\n * default instance corresponding to the empty string can be obtained via\n * constructor invocation.\n *\n * @see goog.html.TrustedResourceUrl#fromConstant\n * @constructor\n * @final\n * @struct\n * @implements {goog.i18n.bidi.DirectionalString}\n * @implements {goog.string.TypedString}\n */\ngoog.html.TrustedResourceUrl = function() {\n  /**\n   * The contained value of this TrustedResourceUrl.  The field has a purposely\n   * ugly name to make (non-compiled) code that attempts to directly access this\n   * field stand out.\n   * @private {!TrustedScriptURL|string}\n   */\n  this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = '';\n\n  /**\n   * Value stored as TrustedURL. TrustedResourceURL corresponds to TrustedURL in\n   * some context thus we need to store it separately.\n   * @private {?TrustedURL}\n   */\n  this.trustedURL_ = null;\n\n  /**\n   * A type marker used to implement additional run-time type checking.\n   * @see goog.html.TrustedResourceUrl#unwrap\n   * @const {!Object}\n   * @private\n   */\n  this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =\n      goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = true;\n\n\n/**\n * Returns this TrustedResourceUrl's value as a string.\n *\n * IMPORTANT: In code where it is security relevant that an object's type is\n * indeed `TrustedResourceUrl`, use\n * `goog.html.TrustedResourceUrl.unwrap` instead of this method. If in\n * doubt, assume that it's security relevant. In particular, note that\n * goog.html functions which return a goog.html type do not guarantee that\n * the returned instance is of the right type. For example:\n *\n * <pre>\n * var fakeSafeHtml = new String('fake');\n * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;\n * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);\n * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by\n * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml instanceof\n * // goog.html.SafeHtml.\n * </pre>\n *\n * @see goog.html.TrustedResourceUrl#unwrap\n * @override\n */\ngoog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {\n  return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_\n      .toString();\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString =\n    true;\n\n\n/**\n * Returns this URLs directionality, which is always `LTR`.\n * @override\n */\ngoog.html.TrustedResourceUrl.prototype.getDirection = function() {\n  return goog.i18n.bidi.Dir.LTR;\n};\n\n\n/**\n * Creates a new TrustedResourceUrl with params added to URL. Both search and\n * hash params can be specified.\n *\n * @param {string|?Object<string, *>|undefined} searchParams Search parameters\n *     to add to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for\n *     exact format definition.\n * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add\n *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact\n *     format definition.\n * @return {!goog.html.TrustedResourceUrl} New TrustedResourceUrl with params.\n */\ngoog.html.TrustedResourceUrl.prototype.cloneWithParams = function(\n    searchParams, opt_hashParams) {\n  var url = goog.html.TrustedResourceUrl.unwrap(this);\n  var parts = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(url);\n  var urlBase = parts[1];\n  var urlSearch = parts[2] || '';\n  var urlHash = parts[3] || '';\n\n  return goog.html.TrustedResourceUrl\n      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(\n          urlBase +\n          goog.html.TrustedResourceUrl.stringifyParams_(\n              '?', urlSearch, searchParams) +\n          goog.html.TrustedResourceUrl.stringifyParams_(\n              '#', urlHash, opt_hashParams));\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Returns a debug string-representation of this value.\n   *\n   * To obtain the actual string value wrapped in a TrustedResourceUrl, use\n   * `goog.html.TrustedResourceUrl.unwrap`.\n   *\n   * @see goog.html.TrustedResourceUrl#unwrap\n   * @override\n   */\n  goog.html.TrustedResourceUrl.prototype.toString = function() {\n    return 'TrustedResourceUrl{' +\n        this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + '}';\n  };\n}\n\n\n/**\n * Performs a runtime check that the provided object is indeed a\n * TrustedResourceUrl object, and returns its value.\n *\n * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl The object to\n *     extract from.\n * @return {string} The trustedResourceUrl object's contained string, unless\n *     the run-time type check fails. In that case, `unwrap` returns an\n *     innocuous string, or, if assertions are enabled, throws\n *     `goog.asserts.AssertionError`.\n */\ngoog.html.TrustedResourceUrl.unwrap = function(trustedResourceUrl) {\n  return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(trustedResourceUrl)\n      .toString();\n};\n\n\n/**\n * Unwraps value as TrustedScriptURL if supported or as a string if not.\n * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl\n * @return {!TrustedScriptURL|string}\n * @see goog.html.TrustedResourceUrl.unwrap\n */\ngoog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(\n    trustedResourceUrl) {\n  // Perform additional Run-time type-checking to ensure that\n  // trustedResourceUrl is indeed an instance of the expected type.  This\n  // provides some additional protection against security bugs due to\n  // application code that disables type checks.\n  // Specifically, the following checks are performed:\n  // 1. The object is an instance of the expected type.\n  // 2. The object is not an instance of a subclass.\n  // 3. The object carries a type marker for the expected type. \"Faking\" an\n  // object requires a reference to the type marker, which has names intended\n  // to stand out in code reviews.\n  if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl &&\n      trustedResourceUrl.constructor === goog.html.TrustedResourceUrl &&\n      trustedResourceUrl\n              .TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===\n          goog.html.TrustedResourceUrl\n              .TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {\n    return trustedResourceUrl\n        .privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;\n  } else {\n    goog.asserts.fail('expected object of type TrustedResourceUrl, got \\'' +\n        trustedResourceUrl + '\\' of type ' + goog.typeOf(trustedResourceUrl));\n    return 'type_error:TrustedResourceUrl';\n  }\n};\n\n\n/**\n * Unwraps value as TrustedURL if supported or as a string if not.\n * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl\n * @return {!TrustedURL|string}\n * @see goog.html.TrustedResourceUrl.unwrap\n */\ngoog.html.TrustedResourceUrl.unwrapTrustedURL = function(trustedResourceUrl) {\n  return trustedResourceUrl.trustedURL_ ?\n      trustedResourceUrl.trustedURL_ :\n      goog.html.TrustedResourceUrl.unwrap(trustedResourceUrl);\n};\n\n\n/**\n * Creates a TrustedResourceUrl from a format string and arguments.\n *\n * The arguments for interpolation into the format string map labels to values.\n * Values of type `goog.string.Const` are interpolated without modifcation.\n * Values of other types are cast to string and encoded with\n * encodeURIComponent.\n *\n * `%{<label>}` markers are used in the format string to indicate locations\n * to be interpolated with the valued mapped to the given label. `<label>`\n * must contain only alphanumeric and `_` characters.\n *\n * The format string must match goog.html.TrustedResourceUrl.BASE_URL_.\n *\n * Example usage:\n *\n *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(\n *        'https://www.google.com/search?q=%{query}'), {'query': searchTerm});\n *\n *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(\n *        '//www.youtube.com/v/%{videoId}?hl=en&fs=1%{autoplay}'), {\n *        'videoId': videoId,\n *        'autoplay': opt_autoplay ?\n *            goog.string.Const.from('&autoplay=1') : goog.string.Const.EMPTY\n *    });\n *\n * While this function can be used to create a TrustedResourceUrl from only\n * constants, fromConstant() and fromConstants() are generally preferable for\n * that purpose.\n *\n * @param {!goog.string.Const} format The format string.\n * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping\n *     of labels to values to be interpolated into the format string.\n *     goog.string.Const values are interpolated without encoding.\n * @return {!goog.html.TrustedResourceUrl}\n * @throws {!Error} On an invalid format string or if a label used in the\n *     the format string is not present in args.\n */\ngoog.html.TrustedResourceUrl.format = function(format, args) {\n  var formatStr = goog.string.Const.unwrap(format);\n  if (!goog.html.TrustedResourceUrl.BASE_URL_.test(formatStr)) {\n    throw new Error('Invalid TrustedResourceUrl format: ' + formatStr);\n  }\n  var result = formatStr.replace(\n      goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(match, id) {\n        if (!Object.prototype.hasOwnProperty.call(args, id)) {\n          throw new Error(\n              'Found marker, \"' + id + '\", in format string, \"' + formatStr +\n              '\", but no valid label mapping found ' +\n              'in args: ' + JSON.stringify(args));\n        }\n        var arg = args[id];\n        if (arg instanceof goog.string.Const) {\n          return goog.string.Const.unwrap(arg);\n        } else {\n          return encodeURIComponent(String(arg));\n        }\n      });\n  return goog.html.TrustedResourceUrl\n      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(result);\n};\n\n\n/**\n * @private @const {!RegExp}\n */\ngoog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\\w+)}/g;\n\n\n/**\n * The URL must be absolute, scheme-relative or path-absolute. So it must\n * start with:\n * - https:// followed by allowed origin characters.\n * - // followed by allowed origin characters.\n * - Any absolute or relative path.\n *\n * Based on\n * https://url.spec.whatwg.org/commit-snapshots/56b74ce7cca8883eab62e9a12666e2fac665d03d/#url-parsing\n * an initial / which is not followed by another / or \\ will end up in the \"path\n * state\" and from there it can only go to \"fragment state\" and \"query state\".\n *\n * We don't enforce a well-formed domain name. So '.' or '1.2' are valid.\n * That's ok because the origin comes from a compile-time constant.\n *\n * A regular expression is used instead of goog.uri for several reasons:\n * - Strictness. E.g. we don't want any userinfo component and we don't\n *   want '/./, nor \\' in the first path component.\n * - Small trusted base. goog.uri is generic and might need to change,\n *   reasoning about all the ways it can parse a URL now and in the future\n *   is error-prone.\n * - Code size. We expect many calls to .format(), many of which might\n *   not be using goog.uri.\n * - Simplicity. Using goog.uri would likely not result in simpler nor shorter\n *   code.\n * @private @const {!RegExp}\n */\ngoog.html.TrustedResourceUrl.BASE_URL_ = new RegExp(\n    '^((https:)?//[0-9a-z.:[\\\\]-]+/'  // Origin.\n        + '|/[^/\\\\\\\\]'                // Absolute path.\n        + '|[^:/\\\\\\\\%]+/'             // Relative path.\n        + '|[^:/\\\\\\\\%]*[?#]'          // Query string or fragment.\n        + '|about:blank#'             // about:blank with fragment.\n        + ')',\n    'i');\n\n/**\n * RegExp for splitting a URL into the base, search field, and hash field.\n *\n * @private @const {!RegExp}\n */\ngoog.html.TrustedResourceUrl.URL_PARAM_PARSER_ =\n    /^([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/;\n\n\n/**\n * Formats the URL same as TrustedResourceUrl.format and then adds extra URL\n * parameters.\n *\n * Example usage:\n *\n *     // Creates '//www.youtube.com/v/abc?autoplay=1' for videoId='abc' and\n *     // opt_autoplay=1. Creates '//www.youtube.com/v/abc' for videoId='abc'\n *     // and opt_autoplay=undefined.\n *     var url = goog.html.TrustedResourceUrl.formatWithParams(\n *         goog.string.Const.from('//www.youtube.com/v/%{videoId}'),\n *         {'videoId': videoId},\n *         {'autoplay': opt_autoplay});\n *\n * @param {!goog.string.Const} format The format string.\n * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping\n *     of labels to values to be interpolated into the format string.\n *     goog.string.Const values are interpolated without encoding.\n * @param {string|?Object<string, *>|undefined} searchParams Parameters to add\n *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact\n *     format definition.\n * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add\n *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact\n *     format definition.\n * @return {!goog.html.TrustedResourceUrl}\n * @throws {!Error} On an invalid format string or if a label used in the\n *     the format string is not present in args.\n */\ngoog.html.TrustedResourceUrl.formatWithParams = function(\n    format, args, searchParams, opt_hashParams) {\n  var url = goog.html.TrustedResourceUrl.format(format, args);\n  return url.cloneWithParams(searchParams, opt_hashParams);\n};\n\n\n/**\n * Creates a TrustedResourceUrl object from a compile-time constant string.\n *\n * Compile-time constant strings are inherently program-controlled and hence\n * trusted.\n *\n * @param {!goog.string.Const} url A compile-time-constant string from which to\n *     create a TrustedResourceUrl.\n * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object\n *     initialized to `url`.\n */\ngoog.html.TrustedResourceUrl.fromConstant = function(url) {\n  return goog.html.TrustedResourceUrl\n      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(\n          goog.string.Const.unwrap(url));\n};\n\n\n/**\n * Creates a TrustedResourceUrl object from a compile-time constant strings.\n *\n * Compile-time constant strings are inherently program-controlled and hence\n * trusted.\n *\n * @param {!Array<!goog.string.Const>} parts Compile-time-constant strings from\n *     which to create a TrustedResourceUrl.\n * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object\n *     initialized to concatenation of `parts`.\n */\ngoog.html.TrustedResourceUrl.fromConstants = function(parts) {\n  var unwrapped = '';\n  for (var i = 0; i < parts.length; i++) {\n    unwrapped += goog.string.Const.unwrap(parts[i]);\n  }\n  return goog.html.TrustedResourceUrl\n      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(unwrapped);\n};\n\n\n/**\n * Type marker for the TrustedResourceUrl type, used to implement additional\n * run-time type checking.\n * @const {!Object}\n * @private\n */\ngoog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};\n\n\n/**\n * Package-internal utility method to create TrustedResourceUrl instances.\n *\n * @param {string} url The string to initialize the TrustedResourceUrl object\n *     with.\n * @return {!goog.html.TrustedResourceUrl} The initialized TrustedResourceUrl\n *     object.\n * @package\n */\ngoog.html.TrustedResourceUrl\n    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(url) {\n  var trustedResourceUrl = new goog.html.TrustedResourceUrl();\n  trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ =\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ?\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY\n          .createScriptURL(url) :\n      url;\n  if (goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY) {\n    trustedResourceUrl.trustedURL_ =\n        goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(\n            url);\n  }\n  return trustedResourceUrl;\n};\n\n\n/**\n * Stringifies the passed params to be used as either a search or hash field of\n * a URL.\n *\n * @param {string} prefix The prefix character for the given field ('?' or '#').\n * @param {string} currentString The existing field value (including the prefix\n *     character, if the field is present).\n * @param {string|?Object<string, *>|undefined} params The params to set or\n *     append to the field.\n * - If `undefined` or `null`, the field remains unchanged.\n * - If a string, then the string will be escaped and the field will be\n *   overwritten with that value.\n * - If an Object, that object is treated as a set of key-value pairs to be\n *   appended to the current field. Note that JavaScript doesn't guarantee the\n *   order of values in an object which might result in non-deterministic order\n *   of the parameters. However, browsers currently preserve the order. The\n *   rules for each entry:\n *   - If an array, it will be processed as if each entry were an additional\n *     parameter with exactly the same key, following the same logic below.\n *   - If `undefined` or `null`, it will be skipped.\n *   - Otherwise, it will be turned into a string, escaped, and appended.\n * @return {string}\n * @private\n */\ngoog.html.TrustedResourceUrl.stringifyParams_ = function(\n    prefix, currentString, params) {\n  if (params == null) {\n    // Do not modify the field.\n    return currentString;\n  }\n  if (goog.isString(params)) {\n    // Set field to the passed string.\n    return params ? prefix + encodeURIComponent(params) : '';\n  }\n  // Add on parameters to field from key-value object.\n  for (var key in params) {\n    var value = params[key];\n    var outputValues = goog.isArray(value) ? value : [value];\n    for (var i = 0; i < outputValues.length; i++) {\n      var outputValue = outputValues[i];\n      if (outputValue != null) {\n        if (!currentString) {\n          currentString = prefix;\n        }\n        currentString += (currentString.length > prefix.length ? '&' : '') +\n            encodeURIComponent(key) + '=' +\n            encodeURIComponent(String(outputValue));\n      }\n    }\n  }\n  return currentString;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview String functions called from Closure packages that couldn't\n * depend on each other. Outside Closure, use goog.string function which\n * delegate to these.\n */\n\n\ngoog.provide('goog.string.internal');\n\n\n/**\n * Fast prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix A string to look for at the start of `str`.\n * @return {boolean} True if `str` begins with `prefix`.\n * @see goog.string.startsWith\n */\ngoog.string.internal.startsWith = function(str, prefix) {\n  return str.lastIndexOf(prefix, 0) == 0;\n};\n\n\n/**\n * Fast suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of `str`.\n * @return {boolean} True if `str` ends with `suffix`.\n * @see goog.string.endsWith\n */\ngoog.string.internal.endsWith = function(str, suffix) {\n  var l = str.length - suffix.length;\n  return l >= 0 && str.indexOf(suffix, l) == l;\n};\n\n\n/**\n * Case-insensitive prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix  A string to look for at the end of `str`.\n * @return {boolean} True if `str` begins with `prefix` (ignoring\n *     case).\n * @see goog.string.caseInsensitiveStartsWith\n */\ngoog.string.internal.caseInsensitiveStartsWith = function(str, prefix) {\n  return goog.string.internal.caseInsensitiveCompare(\n             prefix, str.substr(0, prefix.length)) == 0;\n};\n\n\n/**\n * Case-insensitive suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of `str`.\n * @return {boolean} True if `str` ends with `suffix` (ignoring\n *     case).\n * @see goog.string.caseInsensitiveEndsWith\n */\ngoog.string.internal.caseInsensitiveEndsWith = function(str, suffix) {\n  return (\n      goog.string.internal.caseInsensitiveCompare(\n          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);\n};\n\n\n/**\n * Case-insensitive equality checker.\n * @param {string} str1 First string to check.\n * @param {string} str2 Second string to check.\n * @return {boolean} True if `str1` and `str2` are the same string,\n *     ignoring case.\n * @see goog.string.caseInsensitiveEquals\n */\ngoog.string.internal.caseInsensitiveEquals = function(str1, str2) {\n  return str1.toLowerCase() == str2.toLowerCase();\n};\n\n\n/**\n * Checks if a string is empty or contains only whitespaces.\n * @param {string} str The string to check.\n * @return {boolean} Whether `str` is empty or whitespace only.\n * @see goog.string.isEmptyOrWhitespace\n */\ngoog.string.internal.isEmptyOrWhitespace = function(str) {\n  // testing length == 0 first is actually slower in all browsers (about the\n  // same in Opera).\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return /^[\\s\\xa0]*$/.test(str);\n};\n\n\n/**\n * Trims white spaces to the left and right of a string.\n * @param {string} str The string to trim.\n * @return {string} A trimmed copy of `str`.\n */\ngoog.string.internal.trim =\n    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {\n      return str.trim();\n    } : function(str) {\n      // Since IE doesn't include non-breaking-space (0xa0) in their \\s\n      // character class (as required by section 7.2 of the ECMAScript spec),\n      // we explicitly include it in the regexp to enforce consistent\n      // cross-browser behavior.\n      // NOTE: We don't use String#replace because it might have side effects\n      // causing this function to not compile to 0 bytes.\n      return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(str)[1];\n    };\n\n\n/**\n * A string comparator that ignores case.\n * -1 = str1 less than str2\n *  0 = str1 equals str2\n *  1 = str1 greater than str2\n *\n * @param {string} str1 The string to compare.\n * @param {string} str2 The string to compare `str1` to.\n * @return {number} The comparator result, as described above.\n * @see goog.string.caseInsensitiveCompare\n */\ngoog.string.internal.caseInsensitiveCompare = function(str1, str2) {\n  var test1 = String(str1).toLowerCase();\n  var test2 = String(str2).toLowerCase();\n\n  if (test1 < test2) {\n    return -1;\n  } else if (test1 == test2) {\n    return 0;\n  } else {\n    return 1;\n  }\n};\n\n\n/**\n * Converts \\n to <br>s or <br />s.\n * @param {string} str The string in which to convert newlines.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} A copy of `str` with converted newlines.\n * @see goog.string.newLineToBr\n */\ngoog.string.internal.newLineToBr = function(str, opt_xml) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, opt_xml ? '<br />' : '<br>');\n};\n\n\n/**\n * Escapes double quote '\"' and single quote '\\'' characters in addition to\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\n * value within double or single quotes.\n * @param {string} str string to be escaped.\n * @param {boolean=} opt_isLikelyToContainHtmlChars\n * @return {string} An escaped copy of `str`.\n * @see goog.string.htmlEscape\n */\ngoog.string.internal.htmlEscape = function(\n    str, opt_isLikelyToContainHtmlChars) {\n  if (opt_isLikelyToContainHtmlChars) {\n    str = str.replace(goog.string.internal.AMP_RE_, '&amp;')\n              .replace(goog.string.internal.LT_RE_, '&lt;')\n              .replace(goog.string.internal.GT_RE_, '&gt;')\n              .replace(goog.string.internal.QUOT_RE_, '&quot;')\n              .replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;')\n              .replace(goog.string.internal.NULL_RE_, '&#0;');\n    return str;\n\n  } else {\n    // quick test helps in the case when there are no chars to replace, in\n    // worst case this makes barely a difference to the time taken\n    if (!goog.string.internal.ALL_RE_.test(str)) return str;\n\n    // str.indexOf is faster than regex.test in this case\n    if (str.indexOf('&') != -1) {\n      str = str.replace(goog.string.internal.AMP_RE_, '&amp;');\n    }\n    if (str.indexOf('<') != -1) {\n      str = str.replace(goog.string.internal.LT_RE_, '&lt;');\n    }\n    if (str.indexOf('>') != -1) {\n      str = str.replace(goog.string.internal.GT_RE_, '&gt;');\n    }\n    if (str.indexOf('\"') != -1) {\n      str = str.replace(goog.string.internal.QUOT_RE_, '&quot;');\n    }\n    if (str.indexOf('\\'') != -1) {\n      str = str.replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;');\n    }\n    if (str.indexOf('\\x00') != -1) {\n      str = str.replace(goog.string.internal.NULL_RE_, '&#0;');\n    }\n    return str;\n  }\n};\n\n\n/**\n * Regular expression that matches an ampersand, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.AMP_RE_ = /&/g;\n\n\n/**\n * Regular expression that matches a less than sign, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.LT_RE_ = /</g;\n\n\n/**\n * Regular expression that matches a greater than sign, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.GT_RE_ = />/g;\n\n\n/**\n * Regular expression that matches a double quote, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.QUOT_RE_ = /\"/g;\n\n\n/**\n * Regular expression that matches a single quote, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.SINGLE_QUOTE_RE_ = /'/g;\n\n\n/**\n * Regular expression that matches null character, for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.NULL_RE_ = /\\x00/g;\n\n\n/**\n * Regular expression that matches any character that needs to be escaped.\n * @const {!RegExp}\n * @private\n */\ngoog.string.internal.ALL_RE_ = /[\\x00&<>\"']/;\n\n\n/**\n * Do escaping of whitespace to preserve spatial formatting. We use character\n * entity #160 to make it safer for xml.\n * @param {string} str The string in which to escape whitespace.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} An escaped copy of `str`.\n * @see goog.string.whitespaceEscape\n */\ngoog.string.internal.whitespaceEscape = function(str, opt_xml) {\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\n  return goog.string.internal.newLineToBr(\n      str.replace(/  /g, ' &#160;'), opt_xml);\n};\n\n\n/**\n * Determines whether a string contains a substring.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether `str` contains `subString`.\n * @see goog.string.contains\n */\ngoog.string.internal.contains = function(str, subString) {\n  return str.indexOf(subString) != -1;\n};\n\n\n/**\n * Determines whether a string contains a substring, ignoring case.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether `str` contains `subString`.\n * @see goog.string.caseInsensitiveContains\n */\ngoog.string.internal.caseInsensitiveContains = function(str, subString) {\n  return goog.string.internal.contains(\n      str.toLowerCase(), subString.toLowerCase());\n};\n\n\n/**\n * Compares two version numbers.\n *\n * @param {string|number} version1 Version of first item.\n * @param {string|number} version2 Version of second item.\n *\n * @return {number}  1 if `version1` is higher.\n *                   0 if arguments are equal.\n *                  -1 if `version2` is higher.\n * @see goog.string.compareVersions\n */\ngoog.string.internal.compareVersions = function(version1, version2) {\n  var order = 0;\n  // Trim leading and trailing whitespace and split the versions into\n  // subversions.\n  var v1Subs = goog.string.internal.trim(String(version1)).split('.');\n  var v2Subs = goog.string.internal.trim(String(version2)).split('.');\n  var subCount = Math.max(v1Subs.length, v2Subs.length);\n\n  // Iterate over the subversions, as long as they appear to be equivalent.\n  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {\n    var v1Sub = v1Subs[subIdx] || '';\n    var v2Sub = v2Subs[subIdx] || '';\n\n    do {\n      // Split the subversions into pairs of numbers and qualifiers (like 'b').\n      // Two different RegExp objects are use to make it clear the code\n      // is side-effect free\n      var v1Comp = /(\\d*)(\\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];\n      var v2Comp = /(\\d*)(\\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];\n      // Break if there are no more matches.\n      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {\n        break;\n      }\n\n      // Parse the numeric part of the subversion. A missing number is\n      // equivalent to 0.\n      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);\n      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);\n\n      // Compare the subversion components. The number has the highest\n      // precedence. Next, if the numbers are equal, a subversion without any\n      // qualifier is always higher than a subversion with any qualifier. Next,\n      // the qualifiers are compared as strings.\n      order = goog.string.internal.compareElements_(v1CompNum, v2CompNum) ||\n          goog.string.internal.compareElements_(\n              v1Comp[2].length == 0, v2Comp[2].length == 0) ||\n          goog.string.internal.compareElements_(v1Comp[2], v2Comp[2]);\n      // Stop as soon as an inequality is discovered.\n\n      v1Sub = v1Comp[3];\n      v2Sub = v2Comp[3];\n    } while (order == 0);\n  }\n\n  return order;\n};\n\n\n/**\n * Compares elements of a version number.\n *\n * @param {string|number|boolean} left An element from a version number.\n * @param {string|number|boolean} right An element from a version number.\n *\n * @return {number}  1 if `left` is higher.\n *                   0 if arguments are equal.\n *                  -1 if `right` is higher.\n * @private\n */\ngoog.string.internal.compareElements_ = function(left, right) {\n  if (left < right) {\n    return -1;\n  } else if (left > right) {\n    return 1;\n  }\n  return 0;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview The SafeUrl type and its builders.\n *\n * TODO(xtof): Link to document stating type contract.\n */\n\ngoog.provide('goog.html.SafeUrl');\n\ngoog.require('goog.asserts');\ngoog.require('goog.fs.url');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.html.trustedtypes');\ngoog.require('goog.i18n.bidi.Dir');\ngoog.require('goog.i18n.bidi.DirectionalString');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.TypedString');\ngoog.require('goog.string.internal');\n\n\n\n/**\n * A string that is safe to use in URL context in DOM APIs and HTML documents.\n *\n * A SafeUrl is a string-like object that carries the security type contract\n * that its value as a string will not cause untrusted script execution\n * when evaluated as a hyperlink URL in a browser.\n *\n * Values of this type are guaranteed to be safe to use in URL/hyperlink\n * contexts, such as assignment to URL-valued DOM properties, in the sense that\n * the use will not result in a Cross-Site-Scripting vulnerability. Similarly,\n * SafeUrls can be interpolated into the URL context of an HTML template (e.g.,\n * inside a href attribute). However, appropriate HTML-escaping must still be\n * applied.\n *\n * Note that, as documented in `goog.html.SafeUrl.unwrap`, this type's\n * contract does not guarantee that instances are safe to interpolate into HTML\n * without appropriate escaping.\n *\n * Note also that this type's contract does not imply any guarantees regarding\n * the resource the URL refers to.  In particular, SafeUrls are <b>not</b>\n * safe to use in a context where the referred-to resource is interpreted as\n * trusted code, e.g., as the src of a script tag.\n *\n * Instances of this type must be created via the factory methods\n * (`goog.html.SafeUrl.fromConstant`, `goog.html.SafeUrl.sanitize`),\n * etc and not by invoking its constructor.  The constructor intentionally\n * takes no parameters and the type is immutable; hence only a default instance\n * corresponding to the empty string can be obtained via constructor invocation.\n *\n * @see goog.html.SafeUrl#fromConstant\n * @see goog.html.SafeUrl#from\n * @see goog.html.SafeUrl#sanitize\n * @constructor\n * @final\n * @struct\n * @implements {goog.i18n.bidi.DirectionalString}\n * @implements {goog.string.TypedString}\n */\ngoog.html.SafeUrl = function() {\n  /**\n   * The contained value of this SafeUrl.  The field has a purposely ugly\n   * name to make (non-compiled) code that attempts to directly access this\n   * field stand out.\n   * @private {!TrustedURL|string}\n   */\n  this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = '';\n\n  /**\n   * A type marker used to implement additional run-time type checking.\n   * @see goog.html.SafeUrl#unwrap\n   * @const {!Object}\n   * @private\n   */\n  this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =\n      goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;\n};\n\n\n/**\n * The innocuous string generated by goog.html.SafeUrl.sanitize when passed\n * an unsafe URL.\n *\n * about:invalid is registered in\n * http://www.w3.org/TR/css3-values/#about-invalid.\n * http://tools.ietf.org/html/rfc6694#section-2.2.1 permits about URLs to\n * contain a fragment, which is not to be considered when determining if an\n * about URL is well-known.\n *\n * Using about:invalid seems preferable to using a fixed data URL, since\n * browsers might choose to not report CSP violations on it, as legitimate\n * CSS function calls to attr() can result in this URL being produced. It is\n * also a standard URL which matches exactly the semantics we need:\n * \"The about:invalid URI references a non-existent document with a generic\n * error condition. It can be used when a URI is necessary, but the default\n * value shouldn't be resolveable as any type of document\".\n *\n * @const {string}\n */\ngoog.html.SafeUrl.INNOCUOUS_STRING = 'about:invalid#zClosurez';\n\n\n/**\n * @override\n * @const\n */\ngoog.html.SafeUrl.prototype.implementsGoogStringTypedString = true;\n\n\n/**\n * Returns this SafeUrl's value a string.\n *\n * IMPORTANT: In code where it is security relevant that an object's type is\n * indeed `SafeUrl`, use `goog.html.SafeUrl.unwrap` instead of this\n * method. If in doubt, assume that it's security relevant. In particular, note\n * that goog.html functions which return a goog.html type do not guarantee that\n * the returned instance is of the right type.\n *\n * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the\n * behavior of browsers when interpreting URLs. Values of SafeUrl objects MUST\n * be appropriately escaped before embedding in a HTML document. Note that the\n * required escaping is context-sensitive (e.g. a different escaping is\n * required for embedding a URL in a style property within a style\n * attribute, as opposed to embedding in a href attribute).\n *\n * @see goog.html.SafeUrl#unwrap\n * @override\n */\ngoog.html.SafeUrl.prototype.getTypedStringValue = function() {\n  return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = true;\n\n\n/**\n * Returns this URLs directionality, which is always `LTR`.\n * @override\n */\ngoog.html.SafeUrl.prototype.getDirection = function() {\n  return goog.i18n.bidi.Dir.LTR;\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Returns a debug string-representation of this value.\n   *\n   * To obtain the actual string value wrapped in a SafeUrl, use\n   * `goog.html.SafeUrl.unwrap`.\n   *\n   * @see goog.html.SafeUrl#unwrap\n   * @override\n   */\n  goog.html.SafeUrl.prototype.toString = function() {\n    return 'SafeUrl{' + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + '}';\n  };\n}\n\n\n/**\n * Performs a runtime check that the provided object is indeed a SafeUrl\n * object, and returns its value.\n *\n * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the\n * behavior of  browsers when interpreting URLs. Values of SafeUrl objects MUST\n * be appropriately escaped before embedding in a HTML document. Note that the\n * required escaping is context-sensitive (e.g. a different escaping is\n * required for embedding a URL in a style property within a style\n * attribute, as opposed to embedding in a href attribute).\n *\n * @param {!goog.html.SafeUrl} safeUrl The object to extract from.\n * @return {string} The SafeUrl object's contained string, unless the run-time\n *     type check fails. In that case, `unwrap` returns an innocuous\n *     string, or, if assertions are enabled, throws\n *     `goog.asserts.AssertionError`.\n */\ngoog.html.SafeUrl.unwrap = function(safeUrl) {\n  return goog.html.SafeUrl.unwrapTrustedURL(safeUrl).toString();\n};\n\n\n/**\n * Unwraps value as TrustedURL if supported or as a string if not.\n * @param {!goog.html.SafeUrl} safeUrl\n * @return {!TrustedURL|string}\n * @see goog.html.SafeUrl.unwrap\n */\ngoog.html.SafeUrl.unwrapTrustedURL = function(safeUrl) {\n  // Perform additional Run-time type-checking to ensure that safeUrl is indeed\n  // an instance of the expected type.  This provides some additional protection\n  // against security bugs due to application code that disables type checks.\n  // Specifically, the following checks are performed:\n  // 1. The object is an instance of the expected type.\n  // 2. The object is not an instance of a subclass.\n  // 3. The object carries a type marker for the expected type. \"Faking\" an\n  // object requires a reference to the type marker, which has names intended\n  // to stand out in code reviews.\n  if (safeUrl instanceof goog.html.SafeUrl &&\n      safeUrl.constructor === goog.html.SafeUrl &&\n      safeUrl.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===\n          goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {\n    return safeUrl.privateDoNotAccessOrElseSafeUrlWrappedValue_;\n  } else {\n    goog.asserts.fail('expected object of type SafeUrl, got \\'' +\n        safeUrl + '\\' of type ' + goog.typeOf(safeUrl));\n    return 'type_error:SafeUrl';\n  }\n};\n\n\n/**\n * Creates a SafeUrl object from a compile-time constant string.\n *\n * Compile-time constant strings are inherently program-controlled and hence\n * trusted.\n *\n * @param {!goog.string.Const} url A compile-time-constant string from which to\n *         create a SafeUrl.\n * @return {!goog.html.SafeUrl} A SafeUrl object initialized to `url`.\n */\ngoog.html.SafeUrl.fromConstant = function(url) {\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      goog.string.Const.unwrap(url));\n};\n\n\n/**\n * A pattern that matches Blob or data types that can have SafeUrls created\n * from URL.createObjectURL(blob) or via a data: URI.\n *\n * This has some parameter support (most notably, we haven't implemented the\n * more complex parts like %-encoded characters or non-alphanumerical ones for\n * simplicity's sake). The specs are fairly complex, and they don't\n * always match Chrome's behavior: we settled on a subset where we're confident\n * all parties involved agree.\n *\n * The spec is available at https://mimesniff.spec.whatwg.org/ (and see\n * https://tools.ietf.org/html/rfc2397 for data: urls, which override some of\n * it).\n * @const\n * @private\n */\ngoog.html.SAFE_MIME_TYPE_PATTERN_ = new RegExp(\n    // Note: Due to content-sniffing concerns, only add MIME types for\n    // media formats.\n    '^(?:audio/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|' +\n        'image/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|' +\n        // TODO(b/68188949): Due to content-sniffing concerns, text/csv should\n        // be removed from the whitelist.\n        'text/csv|' +\n        'video/(?:mpeg|mp4|ogg|webm|quicktime))' +\n        '(?:;\\\\w+=(?:\\\\w+|\"[\\\\w;=]+\"))*$',  // MIME type parameters\n    'i');\n\n\n/**\n * @param {string} mimeType The MIME type to check if safe.\n * @return {boolean} True if the MIME type is safe and creating a Blob via\n *   `SafeUrl.fromBlob()` with that type will not fail due to the type. False\n *   otherwise.\n */\ngoog.html.SafeUrl.isSafeMimeType = function(mimeType) {\n  return goog.html.SAFE_MIME_TYPE_PATTERN_.test(mimeType);\n};\n\n\n/**\n * Creates a SafeUrl wrapping a blob URL for the given `blob`.\n *\n * The blob URL is created with `URL.createObjectURL`. If the MIME type\n * for `blob` is not of a known safe audio, image or video MIME type,\n * then the SafeUrl will wrap {@link #INNOCUOUS_STRING}.\n *\n * @see http://www.w3.org/TR/FileAPI/#url\n * @param {!Blob} blob\n * @return {!goog.html.SafeUrl} The blob URL, or an innocuous string wrapped\n *   as a SafeUrl.\n */\ngoog.html.SafeUrl.fromBlob = function(blob) {\n  var url = goog.html.SAFE_MIME_TYPE_PATTERN_.test(blob.type) ?\n      goog.fs.url.createObjectUrl(blob) :\n      goog.html.SafeUrl.INNOCUOUS_STRING;\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);\n};\n\n\n/**\n * Matches a base-64 data URL, with the first match group being the MIME type.\n * @const\n * @private\n */\ngoog.html.DATA_URL_PATTERN_ = /^data:([^,]*);base64,[a-z0-9+\\/]+=*$/i;\n\n\n/**\n * Creates a SafeUrl wrapping a data: URL, after validating it matches a\n * known-safe audio, image or video MIME type.\n *\n * @param {string} dataUrl A valid base64 data URL with one of the whitelisted\n *     audio, image or video MIME types.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromDataUrl = function(dataUrl) {\n  // RFC4648 suggest to ignore CRLF in base64 encoding.\n  // See https://tools.ietf.org/html/rfc4648.\n  // Remove the CR (%0D) and LF (%0A) from the dataUrl.\n  var filteredDataUrl = dataUrl.replace(/(%0A|%0D)/g, '');\n  // There's a slight risk here that a browser sniffs the content type if it\n  // doesn't know the MIME type and executes HTML within the data: URL. For this\n  // to cause XSS it would also have to execute the HTML in the same origin\n  // of the page with the link. It seems unlikely that both of these will\n  // happen, particularly in not really old IEs.\n  var match = filteredDataUrl.match(goog.html.DATA_URL_PATTERN_);\n  var valid = match && goog.html.SAFE_MIME_TYPE_PATTERN_.test(match[1]);\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      valid ? filteredDataUrl : goog.html.SafeUrl.INNOCUOUS_STRING);\n};\n\n\n/**\n * Creates a SafeUrl wrapping a tel: URL.\n *\n * @param {string} telUrl A tel URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromTelUrl = function(telUrl) {\n  // There's a risk that a tel: URL could immediately place a call once\n  // clicked, without requiring user confirmation. For that reason it is\n  // handled in this separate function.\n  if (!goog.string.internal.caseInsensitiveStartsWith(telUrl, 'tel:')) {\n    telUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      telUrl);\n};\n\n\n/**\n * Matches a sip/sips URL. We only allow urls that consist of an email address.\n * The characters '?' and '#' are not allowed in the local part of the email\n * address.\n * @const\n * @private\n */\ngoog.html.SIP_URL_PATTERN_ = new RegExp(\n    '^sip[s]?:[+a-z0-9_.!$%&\\'*\\\\/=^`{|}~-]+@([a-z0-9-]+\\\\.)+[a-z0-9]{2,63}$',\n    'i');\n\n\n/**\n * Creates a SafeUrl wrapping a sip: URL. We only allow urls that consist of an\n * email address. The characters '?' and '#' are not allowed in the local part\n * of the email address.\n *\n * @param {string} sipUrl A sip URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromSipUrl = function(sipUrl) {\n  if (!goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(sipUrl))) {\n    sipUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      sipUrl);\n};\n\n\n/**\n * Creates a SafeUrl wrapping a fb-messenger://share URL.\n *\n * @param {string} facebookMessengerUrl A facebook messenger URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromFacebookMessengerUrl = function(facebookMessengerUrl) {\n  if (!goog.string.internal.caseInsensitiveStartsWith(\n          facebookMessengerUrl, 'fb-messenger://share')) {\n    facebookMessengerUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      facebookMessengerUrl);\n};\n\n/**\n * Creates a SafeUrl wrapping a whatsapp://send URL.\n *\n * @param {string} whatsAppUrl A WhatsApp URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromWhatsAppUrl = function(whatsAppUrl) {\n  if (!goog.string.internal.caseInsensitiveStartsWith(\n          whatsAppUrl, 'whatsapp://send')) {\n    whatsAppUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      whatsAppUrl);\n};\n\n/**\n * Creates a SafeUrl wrapping a sms: URL.\n *\n * @param {string} smsUrl A sms URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromSmsUrl = function(smsUrl) {\n  if (!goog.string.internal.caseInsensitiveStartsWith(smsUrl, 'sms:') ||\n      !goog.html.SafeUrl.isSmsUrlBodyValid_(smsUrl)) {\n    smsUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      smsUrl);\n};\n\n\n/**\n * Validates SMS URL `body` parameter, which is optional and should appear at\n * most once and should be percent-encoded if present. Rejects many malformed\n * bodies, but may spuriously reject some URLs and does not reject all malformed\n * sms: URLs.\n *\n * @param {string} smsUrl A sms URL.\n * @return {boolean} Whether SMS URL has a valid `body` parameter if it exists.\n * @private\n */\ngoog.html.SafeUrl.isSmsUrlBodyValid_ = function(smsUrl) {\n  var hash = smsUrl.indexOf('#');\n  if (hash > 0) {\n    smsUrl = smsUrl.substring(0, hash);\n  }\n  var bodyParams = smsUrl.match(/[?&]body=/gi);\n  // \"body\" param is optional\n  if (!bodyParams) {\n    return true;\n  }\n  // \"body\" MUST only appear once\n  if (bodyParams.length > 1) {\n    return false;\n  }\n  // Get the encoded `body` parameter value.\n  var bodyValue = smsUrl.match(/[?&]body=([^&]*)/)[1];\n  if (!bodyValue) {\n    return true;\n  }\n  try {\n    decodeURIComponent(bodyValue);\n  } catch (error) {\n    return false;\n  }\n  return /^(?:[a-z0-9\\-_.~]|%[0-9a-f]{2})+$/i.test(bodyValue);\n};\n\n\n/**\n * Creates a SafeUrl wrapping a ssh: URL.\n *\n * @param {string} sshUrl A ssh URL.\n * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}\n *     wrapped as a SafeUrl if it does not pass.\n */\ngoog.html.SafeUrl.fromSshUrl = function(sshUrl) {\n  if (!goog.string.internal.caseInsensitiveStartsWith(sshUrl, 'ssh://')) {\n    sshUrl = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      sshUrl);\n};\n\n/**\n * Sanitizes a Chrome extension URL to SafeUrl, given a compile-time-constant\n * extension identifier. Can also be restricted to chrome extensions.\n *\n * @param {string} url The url to sanitize. Should start with the extension\n *     scheme and the extension identifier.\n * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The\n *     extension id to accept, as a compile-time constant or an array of those.\n *\n * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or\n *     `INNOCUOUS_STRING` if it's not.\n */\ngoog.html.SafeUrl.sanitizeChromeExtensionUrl = function(url, extensionId) {\n  return goog.html.SafeUrl.sanitizeExtensionUrl_(\n      /^chrome-extension:\\/\\/([^\\/]+)\\//, url, extensionId);\n};\n\n/**\n * Sanitizes a Firefox extension URL to SafeUrl, given a compile-time-constant\n * extension identifier. Can also be restricted to chrome extensions.\n *\n * @param {string} url The url to sanitize. Should start with the extension\n *     scheme and the extension identifier.\n * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The\n *     extension id to accept, as a compile-time constant or an array of those.\n *\n * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or\n *     `INNOCUOUS_STRING` if it's not.\n */\ngoog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(url, extensionId) {\n  return goog.html.SafeUrl.sanitizeExtensionUrl_(\n      /^moz-extension:\\/\\/([^\\/]+)\\//, url, extensionId);\n};\n\n/**\n * Sanitizes a Edge extension URL to SafeUrl, given a compile-time-constant\n * extension identifier. Can also be restricted to chrome extensions.\n *\n * @param {string} url The url to sanitize. Should start with the extension\n *     scheme and the extension identifier.\n * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The\n *     extension id to accept, as a compile-time constant or an array of those.\n *\n * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or\n *     `INNOCUOUS_STRING` if it's not.\n */\ngoog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(url, extensionId) {\n  return goog.html.SafeUrl.sanitizeExtensionUrl_(\n      /^ms-browser-extension:\\/\\/([^\\/]+)\\//, url, extensionId);\n};\n\n/**\n * Private helper for converting extension URLs to SafeUrl, given the scheme for\n * that particular extension type. Use the sanitizeFirefoxExtensionUrl,\n * sanitizeChromeExtensionUrl or sanitizeEdgeExtensionUrl unless you're building\n * new helpers.\n *\n * @private\n * @param {!RegExp} scheme The scheme to accept as a RegExp extracting the\n *     extension identifier.\n * @param {string} url The url to sanitize. Should start with the extension\n *     scheme and the extension identifier.\n * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The\n *     extension id to accept, as a compile-time constant or an array of those.\n *\n * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or\n *     `INNOCUOUS_STRING` if it's not.\n */\ngoog.html.SafeUrl.sanitizeExtensionUrl_ = function(scheme, url, extensionId) {\n  var matches = scheme.exec(url);\n  if (!matches) {\n    url = goog.html.SafeUrl.INNOCUOUS_STRING;\n  } else {\n    var extractedExtensionId = matches[1];\n    var acceptedExtensionIds;\n    if (extensionId instanceof goog.string.Const) {\n      acceptedExtensionIds = [goog.string.Const.unwrap(extensionId)];\n    } else {\n      acceptedExtensionIds = extensionId.map(function unwrap(x) {\n        return goog.string.Const.unwrap(x);\n      });\n    }\n    if (acceptedExtensionIds.indexOf(extractedExtensionId) == -1) {\n      url = goog.html.SafeUrl.INNOCUOUS_STRING;\n    }\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);\n};\n\n\n/**\n * Creates a SafeUrl from TrustedResourceUrl. This is safe because\n * TrustedResourceUrl is more tightly restricted than SafeUrl.\n *\n * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl\n * @return {!goog.html.SafeUrl}\n */\ngoog.html.SafeUrl.fromTrustedResourceUrl = function(trustedResourceUrl) {\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n      goog.html.TrustedResourceUrl.unwrap(trustedResourceUrl));\n};\n\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that satisfy\n * the SafeUrl contract.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * @private\n * @const {!RegExp}\n */\ngoog.html.SAFE_URL_PATTERN_ =\n    /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;\n\n/**\n * Public version of goog.html.SAFE_URL_PATTERN_. Updating\n * goog.html.SAFE_URL_PATTERN_ doesn't seem to be backward compatible.\n * Namespace is also changed to goog.html.SafeUrl so it can be imported using\n * goog.require('goog.dom.SafeUrl').\n *\n * TODO(bangert): Remove SAFE_URL_PATTERN_\n * @const {!RegExp}\n */\ngoog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_;\n\n\n/**\n * Creates a SafeUrl object from `url`. If `url` is a\n * goog.html.SafeUrl then it is simply returned. Otherwise the input string is\n * validated to match a pattern of commonly used safe URLs.\n *\n * `url` may be a URL with the http, https, mailto or ftp scheme,\n * or a relative URL (i.e., a URL without a scheme; specifically, a\n * scheme-relative, absolute-path-relative, or path-relative URL).\n *\n * @see http://url.spec.whatwg.org/#concept-relative-url\n * @param {string|!goog.string.TypedString} url The URL to validate.\n * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.\n */\ngoog.html.SafeUrl.sanitize = function(url) {\n  if (url instanceof goog.html.SafeUrl) {\n    return url;\n  } else if (typeof url == 'object' && url.implementsGoogStringTypedString) {\n    url = /** @type {!goog.string.TypedString} */ (url).getTypedStringValue();\n  } else {\n    url = String(url);\n  }\n  if (!goog.html.SAFE_URL_PATTERN_.test(url)) {\n    url = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);\n};\n\n/**\n * Creates a SafeUrl object from `url`. If `url` is a\n * goog.html.SafeUrl then it is simply returned. Otherwise the input string is\n * validated to match a pattern of commonly used safe URLs.\n *\n * `url` may be a URL with the http, https, mailto or ftp scheme,\n * or a relative URL (i.e., a URL without a scheme; specifically, a\n * scheme-relative, absolute-path-relative, or path-relative URL).\n *\n * This function asserts (using goog.asserts) that the URL matches this pattern.\n * If it does not, in addition to failing the assert, an innocous URL will be\n * returned.\n *\n * @see http://url.spec.whatwg.org/#concept-relative-url\n * @param {string|!goog.string.TypedString} url The URL to validate.\n * @param {boolean=} opt_allowDataUrl Whether to allow valid data: URLs.\n * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.\n */\ngoog.html.SafeUrl.sanitizeAssertUnchanged = function(url, opt_allowDataUrl) {\n  if (url instanceof goog.html.SafeUrl) {\n    return url;\n  } else if (typeof url == 'object' && url.implementsGoogStringTypedString) {\n    url = /** @type {!goog.string.TypedString} */ (url).getTypedStringValue();\n  } else {\n    url = String(url);\n  }\n  if (opt_allowDataUrl && /^data:/i.test(url)) {\n    var safeUrl = goog.html.SafeUrl.fromDataUrl(url);\n    if (safeUrl.getTypedStringValue() == url) {\n      return safeUrl;\n    }\n  }\n  if (!goog.asserts.assert(\n          goog.html.SAFE_URL_PATTERN_.test(url),\n          '%s does not match the safe URL pattern', url)) {\n    url = goog.html.SafeUrl.INNOCUOUS_STRING;\n  }\n  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);\n};\n\n\n\n/**\n * Type marker for the SafeUrl type, used to implement additional run-time\n * type checking.\n * @const {!Object}\n * @private\n */\ngoog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};\n\n\n/**\n * Package-internal utility method to create SafeUrl instances.\n *\n * @param {string} url The string to initialize the SafeUrl object with.\n * @return {!goog.html.SafeUrl} The initialized SafeUrl object.\n * @package\n */\ngoog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(\n    url) {\n  var safeUrl = new goog.html.SafeUrl();\n  safeUrl.privateDoNotAccessOrElseSafeUrlWrappedValue_ =\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ?\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(\n          url) :\n      url;\n  return safeUrl;\n};\n\n\n/**\n * A SafeUrl corresponding to the special about:blank url.\n * @const {!goog.html.SafeUrl}\n */\ngoog.html.SafeUrl.ABOUT_BLANK =\n    goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(\n        'about:blank');\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities used by goog.labs.userAgent tools. These functions\n * should not be used outside of goog.labs.userAgent.*.\n *\n * @author nnaze@google.com (Nathan Naze)\n */\n\ngoog.provide('goog.labs.userAgent.util');\n\ngoog.require('goog.string.internal');\n\n\n/**\n * Gets the native userAgent string from navigator if it exists.\n * If navigator or navigator.userAgent string is missing, returns an empty\n * string.\n * @return {string}\n * @private\n */\ngoog.labs.userAgent.util.getNativeUserAgentString_ = function() {\n  var navigator = goog.labs.userAgent.util.getNavigator_();\n  if (navigator) {\n    var userAgent = navigator.userAgent;\n    if (userAgent) {\n      return userAgent;\n    }\n  }\n  return '';\n};\n\n\n/**\n * Getter for the native navigator.\n * This is a separate function so it can be stubbed out in testing.\n * @return {Navigator}\n * @private\n */\ngoog.labs.userAgent.util.getNavigator_ = function() {\n  return goog.global.navigator;\n};\n\n\n/**\n * A possible override for applications which wish to not check\n * navigator.userAgent but use a specified value for detection instead.\n * @private {string}\n */\ngoog.labs.userAgent.util.userAgent_ =\n    goog.labs.userAgent.util.getNativeUserAgentString_();\n\n\n/**\n * Applications may override browser detection on the built in\n * navigator.userAgent object by setting this string. Set to null to use the\n * browser object instead.\n * @param {?string=} opt_userAgent The User-Agent override.\n */\ngoog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {\n  goog.labs.userAgent.util.userAgent_ =\n      opt_userAgent || goog.labs.userAgent.util.getNativeUserAgentString_();\n};\n\n\n/**\n * @return {string} The user agent string.\n */\ngoog.labs.userAgent.util.getUserAgent = function() {\n  return goog.labs.userAgent.util.userAgent_;\n};\n\n\n/**\n * @param {string} str\n * @return {boolean} Whether the user agent contains the given string.\n */\ngoog.labs.userAgent.util.matchUserAgent = function(str) {\n  var userAgent = goog.labs.userAgent.util.getUserAgent();\n  return goog.string.internal.contains(userAgent, str);\n};\n\n\n/**\n * @param {string} str\n * @return {boolean} Whether the user agent contains the given string, ignoring\n *     case.\n */\ngoog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {\n  var userAgent = goog.labs.userAgent.util.getUserAgent();\n  return goog.string.internal.caseInsensitiveContains(userAgent, str);\n};\n\n\n/**\n * Parses the user agent into tuples for each section.\n * @param {string} userAgent\n * @return {!Array<!Array<string>>} Tuples of key, version, and the contents\n *     of the parenthetical.\n */\ngoog.labs.userAgent.util.extractVersionTuples = function(userAgent) {\n  // Matches each section of a user agent string.\n  // Example UA:\n  // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)\n  // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405\n  // This has three version tuples: Mozilla, AppleWebKit, and Mobile.\n\n  var versionRegExp = new RegExp(\n      // Key. Note that a key may have a space.\n      // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')\n      '(\\\\w[\\\\w ]+)' +\n\n          '/' +                // slash\n          '([^\\\\s]+)' +        // version (i.e. '5.0b')\n          '\\\\s*' +             // whitespace\n          '(?:\\\\((.*?)\\\\))?',  // parenthetical info. parentheses not matched.\n      'g');\n\n  var data = [];\n  var match;\n\n  // Iterate and collect the version tuples.  Each iteration will be the\n  // next regex match.\n  while (match = versionRegExp.exec(userAgent)) {\n    data.push([\n      match[1],  // key\n      match[2],  // value\n      // || undefined as this is not undefined in IE7 and IE8\n      match[3] || undefined  // info\n    ]);\n  }\n\n  return data;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview The SafeHtml type and its builders.\n *\n * TODO(xtof): Link to document stating type contract.\n */\n\ngoog.provide('goog.html.SafeHtml');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.tags');\ngoog.require('goog.html.SafeScript');\ngoog.require('goog.html.SafeStyle');\ngoog.require('goog.html.SafeStyleSheet');\ngoog.require('goog.html.SafeUrl');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.html.trustedtypes');\ngoog.require('goog.i18n.bidi.Dir');\ngoog.require('goog.i18n.bidi.DirectionalString');\ngoog.require('goog.labs.userAgent.browser');\ngoog.require('goog.object');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.TypedString');\ngoog.require('goog.string.internal');\n\n\n\n/**\n * A string that is safe to use in HTML context in DOM APIs and HTML documents.\n *\n * A SafeHtml is a string-like object that carries the security type contract\n * that its value as a string will not cause untrusted script execution when\n * evaluated as HTML in a browser.\n *\n * Values of this type are guaranteed to be safe to use in HTML contexts,\n * such as, assignment to the innerHTML DOM property, or interpolation into\n * a HTML template in HTML PC_DATA context, in the sense that the use will not\n * result in a Cross-Site-Scripting vulnerability.\n *\n * Instances of this type must be created via the factory methods\n * (`goog.html.SafeHtml.create`, `goog.html.SafeHtml.htmlEscape`),\n * etc and not by invoking its constructor.  The constructor intentionally\n * takes no parameters and the type is immutable; hence only a default instance\n * corresponding to the empty string can be obtained via constructor invocation.\n *\n * Note that there is no `goog.html.SafeHtml.fromConstant`. The reason is that\n * the following code would create an unsafe HTML:\n *\n * ```\n * goog.html.SafeHtml.concat(\n *     goog.html.SafeHtml.fromConstant(goog.string.Const.from('<script>')),\n *     goog.html.SafeHtml.htmlEscape(userInput),\n *     goog.html.SafeHtml.fromConstant(goog.string.Const.from('<\\/script>')));\n * ```\n *\n * There's `goog.dom.constHtmlToNode` to create a node from constant strings\n * only.\n *\n * @see goog.html.SafeHtml.create\n * @see goog.html.SafeHtml.htmlEscape\n * @constructor\n * @final\n * @struct\n * @implements {goog.i18n.bidi.DirectionalString}\n * @implements {goog.string.TypedString}\n */\ngoog.html.SafeHtml = function() {\n  /**\n   * The contained value of this SafeHtml.  The field has a purposely ugly\n   * name to make (non-compiled) code that attempts to directly access this\n   * field stand out.\n   * @private {!TrustedHTML|string}\n   */\n  this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = '';\n\n  /**\n   * A type marker used to implement additional run-time type checking.\n   * @see goog.html.SafeHtml.unwrap\n   * @const {!Object}\n   * @private\n   */\n  this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ =\n      goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;\n\n  /**\n   * This SafeHtml's directionality, or null if unknown.\n   * @private {?goog.i18n.bidi.Dir}\n   */\n  this.dir_ = null;\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = true;\n\n\n/** @override */\ngoog.html.SafeHtml.prototype.getDirection = function() {\n  return this.dir_;\n};\n\n\n/**\n * @override\n * @const\n */\ngoog.html.SafeHtml.prototype.implementsGoogStringTypedString = true;\n\n\n/**\n * Returns this SafeHtml's value as string.\n *\n * IMPORTANT: In code where it is security relevant that an object's type is\n * indeed `SafeHtml`, use `goog.html.SafeHtml.unwrap` instead of\n * this method. If in doubt, assume that it's security relevant. In particular,\n * note that goog.html functions which return a goog.html type do not guarantee\n * that the returned instance is of the right type. For example:\n *\n * <pre>\n * var fakeSafeHtml = new String('fake');\n * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;\n * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);\n * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by\n * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml\n * // instanceof goog.html.SafeHtml.\n * </pre>\n *\n * @see goog.html.SafeHtml.unwrap\n * @override\n */\ngoog.html.SafeHtml.prototype.getTypedStringValue = function() {\n  return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Returns a debug string-representation of this value.\n   *\n   * To obtain the actual string value wrapped in a SafeHtml, use\n   * `goog.html.SafeHtml.unwrap`.\n   *\n   * @see goog.html.SafeHtml.unwrap\n   * @override\n   */\n  goog.html.SafeHtml.prototype.toString = function() {\n    return 'SafeHtml{' + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ +\n        '}';\n  };\n}\n\n\n/**\n * Performs a runtime check that the provided object is indeed a SafeHtml\n * object, and returns its value.\n * @param {!goog.html.SafeHtml} safeHtml The object to extract from.\n * @return {string} The SafeHtml object's contained string, unless the run-time\n *     type check fails. In that case, `unwrap` returns an innocuous\n *     string, or, if assertions are enabled, throws\n *     `goog.asserts.AssertionError`.\n */\ngoog.html.SafeHtml.unwrap = function(safeHtml) {\n  return goog.html.SafeHtml.unwrapTrustedHTML(safeHtml).toString();\n};\n\n\n/**\n * Unwraps value as TrustedHTML if supported or as a string if not.\n * @param {!goog.html.SafeHtml} safeHtml\n * @return {!TrustedHTML|string}\n * @see goog.html.SafeHtml.unwrap\n */\ngoog.html.SafeHtml.unwrapTrustedHTML = function(safeHtml) {\n  // Perform additional run-time type-checking to ensure that safeHtml is indeed\n  // an instance of the expected type.  This provides some additional protection\n  // against security bugs due to application code that disables type checks.\n  // Specifically, the following checks are performed:\n  // 1. The object is an instance of the expected type.\n  // 2. The object is not an instance of a subclass.\n  // 3. The object carries a type marker for the expected type. \"Faking\" an\n  // object requires a reference to the type marker, which has names intended\n  // to stand out in code reviews.\n  if (safeHtml instanceof goog.html.SafeHtml &&\n      safeHtml.constructor === goog.html.SafeHtml &&\n      safeHtml.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ===\n          goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) {\n    return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;\n  } else {\n    goog.asserts.fail('expected object of type SafeHtml, got \\'' +\n        safeHtml + '\\' of type ' + goog.typeOf(safeHtml));\n    return 'type_error:SafeHtml';\n  }\n};\n\n\n/**\n * Shorthand for union of types that can sensibly be converted to strings\n * or might already be SafeHtml (as SafeHtml is a goog.string.TypedString).\n * @private\n * @typedef {string|number|boolean|!goog.string.TypedString|\n *           !goog.i18n.bidi.DirectionalString}\n */\ngoog.html.SafeHtml.TextOrHtml_;\n\n\n/**\n * Returns HTML-escaped text as a SafeHtml object.\n *\n * If text is of a type that implements\n * `goog.i18n.bidi.DirectionalString`, the directionality of the new\n * `SafeHtml` object is set to `text`'s directionality, if known.\n * Otherwise, the directionality of the resulting SafeHtml is unknown (i.e.,\n * `null`).\n *\n * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If\n *     the parameter is of type SafeHtml it is returned directly (no escaping\n *     is done).\n * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.\n */\ngoog.html.SafeHtml.htmlEscape = function(textOrHtml) {\n  if (textOrHtml instanceof goog.html.SafeHtml) {\n    return textOrHtml;\n  }\n  var textIsObject = typeof textOrHtml == 'object';\n  var dir = null;\n  if (textIsObject && textOrHtml.implementsGoogI18nBidiDirectionalString) {\n    dir = /** @type {!goog.i18n.bidi.DirectionalString} */ (textOrHtml)\n              .getDirection();\n  }\n  var textAsString;\n  if (textIsObject && textOrHtml.implementsGoogStringTypedString) {\n    textAsString = /** @type {!goog.string.TypedString} */ (textOrHtml)\n                       .getTypedStringValue();\n  } else {\n    textAsString = String(textOrHtml);\n  }\n  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n      goog.string.internal.htmlEscape(textAsString), dir);\n};\n\n\n/**\n * Returns HTML-escaped text as a SafeHtml object, with newlines changed to\n * &lt;br&gt;.\n * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If\n *     the parameter is of type SafeHtml it is returned directly (no escaping\n *     is done).\n * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.\n */\ngoog.html.SafeHtml.htmlEscapePreservingNewlines = function(textOrHtml) {\n  if (textOrHtml instanceof goog.html.SafeHtml) {\n    return textOrHtml;\n  }\n  var html = goog.html.SafeHtml.htmlEscape(textOrHtml);\n  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n      goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(html)),\n      html.getDirection());\n};\n\n\n/**\n * Returns HTML-escaped text as a SafeHtml object, with newlines changed to\n * &lt;br&gt; and escaping whitespace to preserve spatial formatting. Character\n * entity #160 is used to make it safer for XML.\n * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text to escape. If\n *     the parameter is of type SafeHtml it is returned directly (no escaping\n *     is done).\n * @return {!goog.html.SafeHtml} The escaped text, wrapped as a SafeHtml.\n */\ngoog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(\n    textOrHtml) {\n  if (textOrHtml instanceof goog.html.SafeHtml) {\n    return textOrHtml;\n  }\n  var html = goog.html.SafeHtml.htmlEscape(textOrHtml);\n  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n      goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(html)),\n      html.getDirection());\n};\n\n\n/**\n * Coerces an arbitrary object into a SafeHtml object.\n *\n * If `textOrHtml` is already of type `goog.html.SafeHtml`, the same\n * object is returned. Otherwise, `textOrHtml` is coerced to string, and\n * HTML-escaped. If `textOrHtml` is of a type that implements\n * `goog.i18n.bidi.DirectionalString`, its directionality, if known, is\n * preserved.\n *\n * @param {!goog.html.SafeHtml.TextOrHtml_} textOrHtml The text or SafeHtml to\n *     coerce.\n * @return {!goog.html.SafeHtml} The resulting SafeHtml object.\n * @deprecated Use goog.html.SafeHtml.htmlEscape.\n */\ngoog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape;\n\n\n/**\n * @const\n * @private\n */\ngoog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/;\n\n\n/**\n * Set of attributes containing URL as defined at\n * http://www.w3.org/TR/html5/index.html#attributes-1.\n * @private @const {!Object<string,boolean>}\n */\ngoog.html.SafeHtml.URL_ATTRIBUTES_ = goog.object.createSet(\n    'action', 'cite', 'data', 'formaction', 'href', 'manifest', 'poster',\n    'src');\n\n\n/**\n * Tags which are unsupported via create(). They might be supported via a\n * tag-specific create method. These are tags which might require a\n * TrustedResourceUrl in one of their attributes or a restricted type for\n * their content.\n * @private @const {!Object<string,boolean>}\n */\ngoog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = goog.object.createSet(\n    goog.dom.TagName.APPLET, goog.dom.TagName.BASE, goog.dom.TagName.EMBED,\n    goog.dom.TagName.IFRAME, goog.dom.TagName.LINK, goog.dom.TagName.MATH,\n    goog.dom.TagName.META, goog.dom.TagName.OBJECT, goog.dom.TagName.SCRIPT,\n    goog.dom.TagName.STYLE, goog.dom.TagName.SVG, goog.dom.TagName.TEMPLATE);\n\n\n/**\n * @typedef {string|number|goog.string.TypedString|\n *     goog.html.SafeStyle.PropertyMap|undefined}\n */\ngoog.html.SafeHtml.AttributeValue;\n\n\n/**\n * Creates a SafeHtml content consisting of a tag with optional attributes and\n * optional content.\n *\n * For convenience tag names and attribute names are accepted as regular\n * strings, instead of goog.string.Const. Nevertheless, you should not pass\n * user-controlled values to these parameters. Note that these parameters are\n * syntactically validated at runtime, and invalid values will result in\n * an exception.\n *\n * Example usage:\n *\n * goog.html.SafeHtml.create('br');\n * goog.html.SafeHtml.create('div', {'class': 'a'});\n * goog.html.SafeHtml.create('p', {}, 'a');\n * goog.html.SafeHtml.create('p', {}, goog.html.SafeHtml.create('br'));\n *\n * goog.html.SafeHtml.create('span', {\n *   'style': {'margin': '0'}\n * });\n *\n * To guarantee SafeHtml's type contract is upheld there are restrictions on\n * attribute values and tag names.\n *\n * - For attributes which contain script code (on*), a goog.string.Const is\n *   required.\n * - For attributes which contain style (style), a goog.html.SafeStyle or a\n *   goog.html.SafeStyle.PropertyMap is required.\n * - For attributes which are interpreted as URLs (e.g. src, href) a\n *   goog.html.SafeUrl, goog.string.Const or string is required. If a string\n *   is passed, it will be sanitized with SafeUrl.sanitize().\n * - For tags which can load code or set security relevant page metadata,\n *   more specific goog.html.SafeHtml.create*() functions must be used. Tags\n *   which are not supported by this function are applet, base, embed, iframe,\n *   link, math, object, script, style, svg, and template.\n *\n * @param {!goog.dom.TagName|string} tagName The name of the tag. Only tag names\n *     consisting of [a-zA-Z0-9-] are allowed. Tag names documented above are\n *     disallowed.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes\n *     the attribute to be omitted.\n * @param {!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to\n *     HTML-escape and put inside the tag. This must be empty for void tags\n *     like <br>. Array elements are concatenated.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid tag name, attribute name, or attribute value is\n *     provided.\n * @throws {goog.asserts.AssertionError} If content for void tag is provided.\n */\ngoog.html.SafeHtml.create = function(tagName, opt_attributes, opt_content) {\n  goog.html.SafeHtml.verifyTagName(String(tagName));\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      String(tagName), opt_attributes, opt_content);\n};\n\n\n/**\n * Verifies if the tag name is valid and if it doesn't change the context.\n * E.g. STRONG is fine but SCRIPT throws because it changes context. See\n * goog.html.SafeHtml.create for an explanation of allowed tags.\n * @param {string} tagName\n * @throws {Error} If invalid tag name is provided.\n * @package\n */\ngoog.html.SafeHtml.verifyTagName = function(tagName) {\n  if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(tagName)) {\n    throw new Error('Invalid tag name <' + tagName + '>.');\n  }\n  if (tagName.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_) {\n    throw new Error('Tag name <' + tagName + '> is not allowed for SafeHtml.');\n  }\n};\n\n\n/**\n * Creates a SafeHtml representing an iframe tag.\n *\n * This by default restricts the iframe as much as possible by setting the\n * sandbox attribute to the empty string. If the iframe requires less\n * restrictions, set the sandbox attribute as tight as possible, but do not rely\n * on the sandbox as a security feature because it is not supported by older\n * browsers. If a sandbox is essential to security (e.g. for third-party\n * frames), use createSandboxIframe which checks for browser support.\n *\n * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox\n *\n * @param {?goog.html.TrustedResourceUrl=} opt_src The value of the src\n *     attribute. If null or undefined src will not be set.\n * @param {?goog.html.SafeHtml=} opt_srcdoc The value of the srcdoc attribute.\n *     If null or undefined srcdoc will not be set.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes\n *     the attribute to be omitted.\n * @param {!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to\n *     HTML-escape and put inside the tag. Array elements are concatenated.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid tag name, attribute name, or attribute value is\n *     provided. If opt_attributes contains the src or srcdoc attributes.\n */\ngoog.html.SafeHtml.createIframe = function(\n    opt_src, opt_srcdoc, opt_attributes, opt_content) {\n  if (opt_src) {\n    // Check whether this is really TrustedResourceUrl.\n    goog.html.TrustedResourceUrl.unwrap(opt_src);\n  }\n\n  var fixedAttributes = {};\n  fixedAttributes['src'] = opt_src || null;\n  fixedAttributes['srcdoc'] =\n      opt_srcdoc && goog.html.SafeHtml.unwrap(opt_srcdoc);\n  var defaultAttributes = {'sandbox': ''};\n  var attributes = goog.html.SafeHtml.combineAttributes(\n      fixedAttributes, defaultAttributes, opt_attributes);\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'iframe', attributes, opt_content);\n};\n\n\n/**\n * Creates a SafeHtml representing a sandboxed iframe tag.\n *\n * The sandbox attribute is enforced in its most restrictive mode, an empty\n * string. Consequently, the security requirements for the src and srcdoc\n * attributes are relaxed compared to SafeHtml.createIframe. This function\n * will throw on browsers that do not support the sandbox attribute, as\n * determined by SafeHtml.canUseSandboxIframe.\n *\n * The SafeHtml returned by this function can trigger downloads with no\n * user interaction on Chrome (though only a few, further attempts are blocked).\n * Firefox and IE will block all downloads from the sandbox.\n *\n * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox\n * @see https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Feb/0112.html\n *\n * @param {string|!goog.html.SafeUrl=} opt_src The value of the src\n *     attribute. If null or undefined src will not be set.\n * @param {string=} opt_srcdoc The value of the srcdoc attribute.\n *     If null or undefined srcdoc will not be set. Will not be sanitized.\n * @param {!Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes\n *     the attribute to be omitted.\n * @param {!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content Content to\n *     HTML-escape and put inside the tag. Array elements are concatenated.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid tag name, attribute name, or attribute value is\n *     provided. If opt_attributes contains the src, srcdoc or sandbox\n *     attributes. If browser does not support the sandbox attribute on iframe.\n */\ngoog.html.SafeHtml.createSandboxIframe = function(\n    opt_src, opt_srcdoc, opt_attributes, opt_content) {\n  if (!goog.html.SafeHtml.canUseSandboxIframe()) {\n    throw new Error('The browser does not support sandboxed iframes.');\n  }\n\n  var fixedAttributes = {};\n  if (opt_src) {\n    // Note that sanitize is a no-op on SafeUrl.\n    fixedAttributes['src'] =\n        goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(opt_src));\n  } else {\n    fixedAttributes['src'] = null;\n  }\n  fixedAttributes['srcdoc'] = opt_srcdoc || null;\n  fixedAttributes['sandbox'] = '';\n  var attributes =\n      goog.html.SafeHtml.combineAttributes(fixedAttributes, {}, opt_attributes);\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'iframe', attributes, opt_content);\n};\n\n\n/**\n * Checks if the user agent supports sandboxed iframes.\n * @return {boolean}\n */\ngoog.html.SafeHtml.canUseSandboxIframe = function() {\n  return goog.global['HTMLIFrameElement'] &&\n      ('sandbox' in goog.global['HTMLIFrameElement'].prototype);\n};\n\n\n/**\n * Creates a SafeHtml representing a script tag with the src attribute.\n * @param {!goog.html.TrustedResourceUrl} src The value of the src\n * attribute.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=}\n * opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined\n *     causes the attribute to be omitted.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid attribute name or value is provided. If\n *     opt_attributes contains the src attribute.\n */\ngoog.html.SafeHtml.createScriptSrc = function(src, opt_attributes) {\n  // TODO(mlourenco): The charset attribute should probably be blocked. If\n  // its value is attacker controlled, the script contains attacker controlled\n  // sub-strings (even if properly escaped) and the server does not set charset\n  // then XSS is likely possible.\n  // https://html.spec.whatwg.org/multipage/scripting.html#dom-script-charset\n\n  // Check whether this is really TrustedResourceUrl.\n  goog.html.TrustedResourceUrl.unwrap(src);\n\n  var fixedAttributes = {'src': src};\n  var defaultAttributes = {};\n  var attributes = goog.html.SafeHtml.combineAttributes(\n      fixedAttributes, defaultAttributes, opt_attributes);\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'script', attributes);\n};\n\n\n/**\n * Creates a SafeHtml representing a script tag. Does not allow the language,\n * src, text or type attributes to be set.\n * @param {!goog.html.SafeScript|!Array<!goog.html.SafeScript>}\n *     script Content to put inside the tag. Array elements are\n *     concatenated.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes\n *     the attribute to be omitted.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid attribute name or attribute value is provided. If\n *     opt_attributes contains the language, src, text or type attribute.\n */\ngoog.html.SafeHtml.createScript = function(script, opt_attributes) {\n  for (var attr in opt_attributes) {\n    var attrLower = attr.toLowerCase();\n    if (attrLower == 'language' || attrLower == 'src' || attrLower == 'text' ||\n        attrLower == 'type') {\n      throw new Error('Cannot set \"' + attrLower + '\" attribute');\n    }\n  }\n\n  var content = '';\n  script = goog.array.concat(script);\n  for (var i = 0; i < script.length; i++) {\n    content += goog.html.SafeScript.unwrap(script[i]);\n  }\n  // Convert to SafeHtml so that it's not HTML-escaped. This is safe because\n  // as part of its contract, SafeScript should have no dangerous '<'.\n  var htmlContent =\n      goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n          content, goog.i18n.bidi.Dir.NEUTRAL);\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'script', opt_attributes, htmlContent);\n};\n\n\n/**\n * Creates a SafeHtml representing a style tag. The type attribute is set\n * to \"text/css\".\n * @param {!goog.html.SafeStyleSheet|!Array<!goog.html.SafeStyleSheet>}\n *     styleSheet Content to put inside the tag. Array elements are\n *     concatenated.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Mapping from attribute names to their values. Only attribute names\n *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined causes\n *     the attribute to be omitted.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n * @throws {Error} If invalid attribute name or attribute value is provided. If\n *     opt_attributes contains the type attribute.\n */\ngoog.html.SafeHtml.createStyle = function(styleSheet, opt_attributes) {\n  var fixedAttributes = {'type': 'text/css'};\n  var defaultAttributes = {};\n  var attributes = goog.html.SafeHtml.combineAttributes(\n      fixedAttributes, defaultAttributes, opt_attributes);\n\n  var content = '';\n  styleSheet = goog.array.concat(styleSheet);\n  for (var i = 0; i < styleSheet.length; i++) {\n    content += goog.html.SafeStyleSheet.unwrap(styleSheet[i]);\n  }\n  // Convert to SafeHtml so that it's not HTML-escaped. This is safe because\n  // as part of its contract, SafeStyleSheet should have no dangerous '<'.\n  var htmlContent =\n      goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n          content, goog.i18n.bidi.Dir.NEUTRAL);\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'style', attributes, htmlContent);\n};\n\n\n/**\n * Creates a SafeHtml representing a meta refresh tag.\n * @param {!goog.html.SafeUrl|string} url Where to redirect. If a string is\n *     passed, it will be sanitized with SafeUrl.sanitize().\n * @param {number=} opt_secs Number of seconds until the page should be\n *     reloaded. Will be set to 0 if unspecified.\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n */\ngoog.html.SafeHtml.createMetaRefresh = function(url, opt_secs) {\n\n  // Note that sanitize is a no-op on SafeUrl.\n  var unwrappedUrl = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(url));\n\n  if (goog.labs.userAgent.browser.isIE() ||\n      goog.labs.userAgent.browser.isEdge()) {\n    // IE/EDGE can't parse the content attribute if the url contains a\n    // semicolon. We can fix this by adding quotes around the url, but then we\n    // can't parse quotes in the URL correctly. Also, it seems that IE/EDGE\n    // did not unescape semicolons in these URLs at some point in the past. We\n    // take a best-effort approach.\n    //\n    // If the URL has semicolons (which may happen in some cases, see\n    // http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2\n    // for instance), wrap it in single quotes to protect the semicolons.\n    // If the URL has semicolons and single quotes, url-encode the single quotes\n    // as well.\n    //\n    // This is imperfect. Notice that both ' and ; are reserved characters in\n    // URIs, so this could do the wrong thing, but at least it will do the wrong\n    // thing in only rare cases.\n    if (goog.string.internal.contains(unwrappedUrl, ';')) {\n      unwrappedUrl = \"'\" + unwrappedUrl.replace(/'/g, '%27') + \"'\";\n    }\n  }\n  var attributes = {\n    'http-equiv': 'refresh',\n    'content': (opt_secs || 0) + '; url=' + unwrappedUrl\n  };\n\n  // This function will handle the HTML escaping for attributes.\n  return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(\n      'meta', attributes);\n};\n\n\n/**\n * @param {string} tagName The tag name.\n * @param {string} name The attribute name.\n * @param {!goog.html.SafeHtml.AttributeValue} value The attribute value.\n * @return {string} A \"name=value\" string.\n * @throws {Error} If attribute value is unsafe for the given tag and attribute.\n * @private\n */\ngoog.html.SafeHtml.getAttrNameAndValue_ = function(tagName, name, value) {\n  // If it's goog.string.Const, allow any valid attribute name.\n  if (value instanceof goog.string.Const) {\n    value = goog.string.Const.unwrap(value);\n  } else if (name.toLowerCase() == 'style') {\n    value = goog.html.SafeHtml.getStyleValue_(value);\n  } else if (/^on/i.test(name)) {\n    // TODO(jakubvrana): Disallow more attributes with a special meaning.\n    throw new Error(\n        'Attribute \"' + name + '\" requires goog.string.Const value, \"' + value +\n        '\" given.');\n    // URL attributes handled differently according to tag.\n  } else if (name.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_) {\n    if (value instanceof goog.html.TrustedResourceUrl) {\n      value = goog.html.TrustedResourceUrl.unwrap(value);\n    } else if (value instanceof goog.html.SafeUrl) {\n      value = goog.html.SafeUrl.unwrap(value);\n    } else if (goog.isString(value)) {\n      value = goog.html.SafeUrl.sanitize(value).getTypedStringValue();\n    } else {\n      throw new Error(\n          'Attribute \"' + name + '\" on tag \"' + tagName +\n          '\" requires goog.html.SafeUrl, goog.string.Const, or string,' +\n          ' value \"' + value + '\" given.');\n    }\n  }\n\n  // Accept SafeUrl, TrustedResourceUrl, etc. for attributes which only require\n  // HTML-escaping.\n  if (value.implementsGoogStringTypedString) {\n    // Ok to call getTypedStringValue() since there's no reliance on the type\n    // contract for security here.\n    value =\n        /** @type {!goog.string.TypedString} */ (value).getTypedStringValue();\n  }\n\n  goog.asserts.assert(\n      goog.isString(value) || goog.isNumber(value),\n      'String or number value expected, got ' + (typeof value) +\n          ' with value: ' + value);\n  return name + '=\"' + goog.string.internal.htmlEscape(String(value)) + '\"';\n};\n\n\n/**\n * Gets value allowed in \"style\" attribute.\n * @param {!goog.html.SafeHtml.AttributeValue} value It could be SafeStyle or a\n *     map which will be passed to goog.html.SafeStyle.create.\n * @return {string} Unwrapped value.\n * @throws {Error} If string value is given.\n * @private\n */\ngoog.html.SafeHtml.getStyleValue_ = function(value) {\n  if (!goog.isObject(value)) {\n    throw new Error(\n        'The \"style\" attribute requires goog.html.SafeStyle or map ' +\n        'of style properties, ' + (typeof value) + ' given: ' + value);\n  }\n  if (!(value instanceof goog.html.SafeStyle)) {\n    // Process the property bag into a style object.\n    value = goog.html.SafeStyle.create(value);\n  }\n  return goog.html.SafeStyle.unwrap(value);\n};\n\n\n/**\n * Creates a SafeHtml content with known directionality consisting of a tag with\n * optional attributes and optional content.\n * @param {!goog.i18n.bidi.Dir} dir Directionality.\n * @param {string} tagName\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n * @param {!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>=} opt_content\n * @return {!goog.html.SafeHtml} The SafeHtml content with the tag.\n */\ngoog.html.SafeHtml.createWithDir = function(\n    dir, tagName, opt_attributes, opt_content) {\n  var html = goog.html.SafeHtml.create(tagName, opt_attributes, opt_content);\n  html.dir_ = dir;\n  return html;\n};\n\n\n/**\n * Creates a new SafeHtml object by joining the parts with separator.\n * @param {!goog.html.SafeHtml.TextOrHtml_} separator\n * @param {!Array<!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>>} parts Parts to join. If a part\n *     contains an array then each member of this array is also joined with the\n *     separator.\n * @return {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.join = function(separator, parts) {\n  var separatorHtml = goog.html.SafeHtml.htmlEscape(separator);\n  var dir = separatorHtml.getDirection();\n  var content = [];\n\n  /**\n   * @param {!goog.html.SafeHtml.TextOrHtml_|\n   *     !Array<!goog.html.SafeHtml.TextOrHtml_>} argument\n   */\n  var addArgument = function(argument) {\n    if (goog.isArray(argument)) {\n      goog.array.forEach(argument, addArgument);\n    } else {\n      var html = goog.html.SafeHtml.htmlEscape(argument);\n      content.push(goog.html.SafeHtml.unwrap(html));\n      var htmlDir = html.getDirection();\n      if (dir == goog.i18n.bidi.Dir.NEUTRAL) {\n        dir = htmlDir;\n      } else if (htmlDir != goog.i18n.bidi.Dir.NEUTRAL && dir != htmlDir) {\n        dir = null;\n      }\n    }\n  };\n\n  goog.array.forEach(parts, addArgument);\n  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n      content.join(goog.html.SafeHtml.unwrap(separatorHtml)), dir);\n};\n\n\n/**\n * Creates a new SafeHtml object by concatenating values.\n * @param {...(!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>)} var_args Values to concatenate.\n * @return {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.concat = function(var_args) {\n  return goog.html.SafeHtml.join(\n      goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));\n};\n\n\n/**\n * Creates a new SafeHtml object with known directionality by concatenating the\n * values.\n * @param {!goog.i18n.bidi.Dir} dir Directionality.\n * @param {...(!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>)} var_args Elements of array\n *     arguments would be processed recursively.\n * @return {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.concatWithDir = function(dir, var_args) {\n  var html = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));\n  html.dir_ = dir;\n  return html;\n};\n\n\n/**\n * Type marker for the SafeHtml type, used to implement additional run-time\n * type checking.\n * @const {!Object}\n * @private\n */\ngoog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};\n\n\n/**\n * Package-internal utility method to create SafeHtml instances.\n *\n * @param {string} html The string to initialize the SafeHtml object with.\n * @param {?goog.i18n.bidi.Dir} dir The directionality of the SafeHtml to be\n *     constructed, or null if unknown.\n * @return {!goog.html.SafeHtml} The initialized SafeHtml object.\n * @package\n */\ngoog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(\n    html, dir) {\n  return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(\n      html, dir);\n};\n\n\n/**\n * Called from createSafeHtmlSecurityPrivateDoNotAccessOrElse(). This\n * method exists only so that the compiler can dead code eliminate static\n * fields (like EMPTY) when they're not accessed.\n * @param {string} html\n * @param {?goog.i18n.bidi.Dir} dir\n * @return {!goog.html.SafeHtml}\n * @private\n */\ngoog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(\n    html, dir) {\n  this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ =\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ?\n      goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(\n          html) :\n      html;\n  this.dir_ = dir;\n  return this;\n};\n\n\n/**\n * Like create() but does not restrict which tags can be constructed.\n *\n * @param {string} tagName Tag name. Set or validated by caller.\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n * @param {(!goog.html.SafeHtml.TextOrHtml_|\n *     !Array<!goog.html.SafeHtml.TextOrHtml_>)=} opt_content\n * @return {!goog.html.SafeHtml}\n * @throws {Error} If invalid or unsafe attribute name or value is provided.\n * @throws {goog.asserts.AssertionError} If content for void tag is provided.\n * @package\n */\ngoog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(\n    tagName, opt_attributes, opt_content) {\n  var dir = null;\n  var result = '<' + tagName;\n  result += goog.html.SafeHtml.stringifyAttributes(tagName, opt_attributes);\n\n  var content = opt_content;\n  if (!goog.isDefAndNotNull(content)) {\n    content = [];\n  } else if (!goog.isArray(content)) {\n    content = [content];\n  }\n\n  if (goog.dom.tags.isVoidTag(tagName.toLowerCase())) {\n    goog.asserts.assert(\n        !content.length, 'Void tag <' + tagName + '> does not allow content.');\n    result += '>';\n  } else {\n    var html = goog.html.SafeHtml.concat(content);\n    result += '>' + goog.html.SafeHtml.unwrap(html) + '</' + tagName + '>';\n    dir = html.getDirection();\n  }\n\n  var dirAttribute = opt_attributes && opt_attributes['dir'];\n  if (dirAttribute) {\n    if (/^(ltr|rtl|auto)$/i.test(dirAttribute)) {\n      // If the tag has the \"dir\" attribute specified then its direction is\n      // neutral because it can be safely used in any context.\n      dir = goog.i18n.bidi.Dir.NEUTRAL;\n    } else {\n      dir = null;\n    }\n  }\n\n  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n      result, dir);\n};\n\n\n/**\n * Creates a string with attributes to insert after tagName.\n * @param {string} tagName\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n * @return {string} Returns an empty string if there are no attributes, returns\n *     a string starting with a space otherwise.\n * @throws {Error} If attribute value is unsafe for the given tag and attribute.\n * @package\n */\ngoog.html.SafeHtml.stringifyAttributes = function(tagName, opt_attributes) {\n  var result = '';\n  if (opt_attributes) {\n    for (var name in opt_attributes) {\n      if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(name)) {\n        throw new Error('Invalid attribute name \"' + name + '\".');\n      }\n      var value = opt_attributes[name];\n      if (!goog.isDefAndNotNull(value)) {\n        continue;\n      }\n      result +=\n          ' ' + goog.html.SafeHtml.getAttrNameAndValue_(tagName, name, value);\n    }\n  }\n  return result;\n};\n\n\n/**\n * @param {!Object<string, ?goog.html.SafeHtml.AttributeValue>} fixedAttributes\n * @param {!Object<string, string>} defaultAttributes\n * @param {?Object<string, ?goog.html.SafeHtml.AttributeValue>=} opt_attributes\n *     Optional attributes passed to create*().\n * @return {!Object<string, ?goog.html.SafeHtml.AttributeValue>}\n * @throws {Error} If opt_attributes contains an attribute with the same name\n *     as an attribute in fixedAttributes.\n * @package\n */\ngoog.html.SafeHtml.combineAttributes = function(\n    fixedAttributes, defaultAttributes, opt_attributes) {\n  var combinedAttributes = {};\n  var name;\n\n  for (name in fixedAttributes) {\n    goog.asserts.assert(name.toLowerCase() == name, 'Must be lower case');\n    combinedAttributes[name] = fixedAttributes[name];\n  }\n  for (name in defaultAttributes) {\n    goog.asserts.assert(name.toLowerCase() == name, 'Must be lower case');\n    combinedAttributes[name] = defaultAttributes[name];\n  }\n\n  for (name in opt_attributes) {\n    var nameLower = name.toLowerCase();\n    if (nameLower in fixedAttributes) {\n      throw new Error(\n          'Cannot override \"' + nameLower + '\" attribute, got \"' + name +\n          '\" with value \"' + opt_attributes[name] + '\"');\n    }\n    if (nameLower in defaultAttributes) {\n      delete combinedAttributes[nameLower];\n    }\n    combinedAttributes[name] = opt_attributes[name];\n  }\n\n  return combinedAttributes;\n};\n\n\n/**\n * A SafeHtml instance corresponding to the HTML doctype: \"<!DOCTYPE html>\".\n * @const {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.DOCTYPE_HTML =\n    goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n        '<!DOCTYPE html>', goog.i18n.bidi.Dir.NEUTRAL);\n\n\n/**\n * A SafeHtml instance corresponding to the empty string.\n * @const {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.EMPTY =\n    goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n        '', goog.i18n.bidi.Dir.NEUTRAL);\n\n\n/**\n * A SafeHtml instance corresponding to the <br> tag.\n * @const {!goog.html.SafeHtml}\n */\ngoog.html.SafeHtml.BR =\n    goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(\n        '<br>', goog.i18n.bidi.Dir.NEUTRAL);\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Provides a function to schedule running a function as soon\n * as possible after the current JS execution stops and yields to the event\n * loop.\n *\n */\n\ngoog.provide('goog.async.nextTick');\ngoog.provide('goog.async.throwException');\n\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.safe');\ngoog.require('goog.functions');\ngoog.require('goog.html.SafeHtml');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.labs.userAgent.browser');\ngoog.require('goog.labs.userAgent.engine');\ngoog.require('goog.string.Const');\n\n\n/**\n * Throw an item without interrupting the current execution context.  For\n * example, if processing a group of items in a loop, sometimes it is useful\n * to report an error while still allowing the rest of the batch to be\n * processed.\n * @param {*} exception\n */\ngoog.async.throwException = function(exception) {\n  // Each throw needs to be in its own context.\n  goog.global.setTimeout(function() { throw exception; }, 0);\n};\n\n\n/**\n * Fires the provided callbacks as soon as possible after the current JS\n * execution context. setTimeout(, 0) takes at least 4ms when called from\n * within another setTimeout(, 0) for legacy reasons.\n *\n * This will not schedule the callback as a microtask (i.e. a task that can\n * preempt user input or networking callbacks). It is meant to emulate what\n * setTimeout(_, 0) would do if it were not throttled. If you desire microtask\n * behavior, use {@see goog.Promise} instead.\n *\n * @param {function(this:SCOPE)} callback Callback function to fire as soon as\n *     possible.\n * @param {SCOPE=} opt_context Object in whose scope to call the listener.\n * @param {boolean=} opt_useSetImmediate Avoid the IE workaround that\n *     ensures correctness at the cost of speed. See comments for details.\n * @template SCOPE\n */\ngoog.async.nextTick = function(callback, opt_context, opt_useSetImmediate) {\n  var cb = callback;\n  if (opt_context) {\n    cb = goog.bind(callback, opt_context);\n  }\n  cb = goog.async.nextTick.wrapCallback_(cb);\n  // Note we do allow callers to also request setImmediate if they are willing\n  // to accept the possible tradeoffs of incorrectness in exchange for speed.\n  // The IE fallback of readystate change is much slower. See useSetImmediate_\n  // for details.\n  if (goog.isFunction(goog.global.setImmediate) &&\n      (opt_useSetImmediate || goog.async.nextTick.useSetImmediate_())) {\n    goog.global.setImmediate(cb);\n    return;\n  }\n\n  // Look for and cache the custom fallback version of setImmediate.\n  if (!goog.async.nextTick.setImmediate_) {\n    goog.async.nextTick.setImmediate_ =\n        goog.async.nextTick.getSetImmediateEmulator_();\n  }\n  goog.async.nextTick.setImmediate_(cb);\n};\n\n\n/**\n * Returns whether should use setImmediate implementation currently on window.\n *\n * window.setImmediate was introduced and currently only supported by IE10+,\n * but due to a bug in the implementation it is not guaranteed that\n * setImmediate is faster than setTimeout nor that setImmediate N is before\n * setImmediate N+1. That is why we do not use the native version if\n * available. We do, however, call setImmediate if it is a non-native function\n * because that indicates that it has been replaced by goog.testing.MockClock\n * which we do want to support.\n * See\n * http://connect.microsoft.com/IE/feedback/details/801823/setimmediate-and-messagechannel-are-broken-in-ie10\n *\n * @return {boolean} Whether to use the implementation of setImmediate defined\n *     on Window.\n * @private\n * @suppress {missingProperties} For \"Window.prototype.setImmediate\"\n */\ngoog.async.nextTick.useSetImmediate_ = function() {\n  // Not a browser environment.\n  if (!goog.global.Window || !goog.global.Window.prototype) {\n    return true;\n  }\n\n  // MS Edge has window.setImmediate natively, but it's not on Window.prototype.\n  // Also, there's no clean way to detect if the goog.global.setImmediate has\n  // been replaced by mockClock as its replacement also shows up as \"[native\n  // code]\" when using toString. Therefore, just always use\n  // goog.global.setImmediate for Edge. It's unclear if it suffers the same\n  // issues as IE10/11, but based on\n  // https://dev.modern.ie/testdrive/demos/setimmediatesorting/\n  // it seems they've been working to ensure it's WAI.\n  if (goog.labs.userAgent.browser.isEdge() ||\n      goog.global.Window.prototype.setImmediate != goog.global.setImmediate) {\n    // Something redefined setImmediate in which case we decide to use it (This\n    // is so that we use the mockClock setImmediate).\n    return true;\n  }\n\n  return false;\n};\n\n\n/**\n * Cache for the setImmediate implementation.\n * @type {function(function())}\n * @private\n */\ngoog.async.nextTick.setImmediate_;\n\n\n/**\n * Determines the best possible implementation to run a function as soon as\n * the JS event loop is idle.\n * @return {function(function())} The \"setImmediate\" implementation.\n * @private\n */\ngoog.async.nextTick.getSetImmediateEmulator_ = function() {\n  // Create a private message channel and use it to postMessage empty messages\n  // to ourselves.\n  /** @type {!Function|undefined} */\n  var Channel = goog.global['MessageChannel'];\n  // If MessageChannel is not available and we are in a browser, implement\n  // an iframe based polyfill in browsers that have postMessage and\n  // document.addEventListener. The latter excludes IE8 because it has a\n  // synchronous postMessage implementation.\n  if (typeof Channel === 'undefined' && typeof window !== 'undefined' &&\n      window.postMessage && window.addEventListener &&\n      // Presto (The old pre-blink Opera engine) has problems with iframes\n      // and contentWindow.\n      !goog.labs.userAgent.engine.isPresto()) {\n    /** @constructor */\n    Channel = function() {\n      // Make an empty, invisible iframe.\n      var iframe = /** @type {!HTMLIFrameElement} */ (\n          document.createElement(String(goog.dom.TagName.IFRAME)));\n      iframe.style.display = 'none';\n      goog.dom.safe.setIframeSrc(\n          iframe,\n          goog.html.TrustedResourceUrl.fromConstant(goog.string.Const.EMPTY));\n      document.documentElement.appendChild(iframe);\n      var win = iframe.contentWindow;\n      var doc = win.document;\n      doc.open();\n      goog.dom.safe.documentWrite(doc, goog.html.SafeHtml.EMPTY);\n      doc.close();\n      // Do not post anything sensitive over this channel, as the workaround for\n      // pages with file: origin could allow that information to be modified or\n      // intercepted.\n      var message = 'callImmediate' + Math.random();\n      // The same origin policy rejects attempts to postMessage from file: urls\n      // unless the origin is '*'.\n      var origin = win.location.protocol == 'file:' ?\n          '*' :\n          win.location.protocol + '//' + win.location.host;\n      var onmessage = goog.bind(function(e) {\n        // Validate origin and message to make sure that this message was\n        // intended for us. If the origin is set to '*' (see above) only the\n        // message needs to match since, for example, '*' != 'file://'. Allowing\n        // the wildcard is ok, as we are not concerned with security here.\n        if ((origin != '*' && e.origin != origin) || e.data != message) {\n          return;\n        }\n        this['port1'].onmessage();\n      }, this);\n      win.addEventListener('message', onmessage, false);\n      this['port1'] = {};\n      this['port2'] = {\n        postMessage: function() { win.postMessage(message, origin); }\n      };\n    };\n  }\n  if (typeof Channel !== 'undefined' && !goog.labs.userAgent.browser.isIE()) {\n    // Exclude all of IE due to\n    // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\n    // which allows starving postMessage with a busy setTimeout loop.\n    // This currently affects IE10 and IE11 which would otherwise be able\n    // to use the postMessage based fallbacks.\n    var channel = new Channel();\n    // Use a fifo linked list to call callbacks in the right order.\n    var head = {};\n    var tail = head;\n    channel['port1'].onmessage = function() {\n      if (goog.isDef(head.next)) {\n        head = head.next;\n        var cb = head.cb;\n        head.cb = null;\n        cb();\n      }\n    };\n    return function(cb) {\n      tail.next = {cb: cb};\n      tail = tail.next;\n      channel['port2'].postMessage(0);\n    };\n  }\n  // Implementation for IE6 to IE10: Script elements fire an asynchronous\n  // onreadystatechange event when inserted into the DOM.\n  if (typeof document !== 'undefined' &&\n      'onreadystatechange' in\n          document.createElement(String(goog.dom.TagName.SCRIPT))) {\n    return function(cb) {\n      var script = /** @type {!HTMLScriptElement} */ (\n          document.createElement(String(goog.dom.TagName.SCRIPT)));\n      script.onreadystatechange = function() {\n        // Clean up and call the callback.\n        script.onreadystatechange = null;\n        script.parentNode.removeChild(script);\n        script = null;\n        cb();\n        cb = null;\n      };\n      document.documentElement.appendChild(script);\n    };\n  }\n  // Fall back to setTimeout with 0. In browsers this creates a delay of 5ms\n  // or more.\n  // NOTE(user): This fallback is used for IE11.\n  return function(cb) {\n    goog.global.setTimeout(/** @type {function()} */ (cb), 0);\n  };\n};\n\n\n/**\n * Helper function that is overrided to protect callbacks with entry point\n * monitor if the application monitors entry points.\n * @param {function()} callback Callback function to fire as soon as possible.\n * @return {function()} The wrapped callback.\n * @private\n */\ngoog.async.nextTick.wrapCallback_ = goog.functions.identity;\n\n\n// Register the callback function as an entry point, so that it can be\n// monitored for exception handling, etc. This has to be done in this file\n// since it requires special code to handle all browsers.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) { goog.async.nextTick.wrapCallback_ = transformer; });\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.async.run');\n\ngoog.require('goog.async.WorkQueue');\ngoog.require('goog.async.nextTick');\ngoog.require('goog.async.throwException');\n\n/**\n * @define {boolean} If true, use the global Promise to implement goog.async.run\n * assuming either the native, or polyfill version will be used. Does still\n * permit tests to use forceNextTick.\n */\ngoog.ASSUME_NATIVE_PROMISE = goog.define('goog.ASSUME_NATIVE_PROMISE', false);\n\n/**\n * Fires the provided callback just before the current callstack unwinds, or as\n * soon as possible after the current JS execution context.\n * @param {function(this:THIS)} callback\n * @param {THIS=} opt_context Object to use as the \"this value\" when calling\n *     the provided function.\n * @template THIS\n */\ngoog.async.run = function(callback, opt_context) {\n  if (!goog.async.run.schedule_) {\n    goog.async.run.initializeRunner_();\n  }\n  if (!goog.async.run.workQueueScheduled_) {\n    // Nothing is currently scheduled, schedule it now.\n    goog.async.run.schedule_();\n    goog.async.run.workQueueScheduled_ = true;\n  }\n\n  goog.async.run.workQueue_.add(callback, opt_context);\n};\n\n\n/**\n * Initializes the function to use to process the work queue.\n * @private\n */\ngoog.async.run.initializeRunner_ = function() {\n  if (goog.ASSUME_NATIVE_PROMISE ||\n      (goog.global.Promise && goog.global.Promise.resolve)) {\n    // Use goog.global.Promise instead of just Promise because the relevant\n    // externs may be missing, and don't alias it because this could confuse the\n    // compiler into thinking the polyfill is required when it should be treated\n    // as optional.\n    var promise = goog.global.Promise.resolve(undefined);\n    goog.async.run.schedule_ = function() {\n      promise.then(goog.async.run.processWorkQueue);\n    };\n  } else {\n    goog.async.run.schedule_ = function() {\n      goog.async.nextTick(goog.async.run.processWorkQueue);\n    };\n  }\n};\n\n\n/**\n * Forces goog.async.run to use nextTick instead of Promise.\n *\n * This should only be done in unit tests. It's useful because MockClock\n * replaces nextTick, but not the browser Promise implementation, so it allows\n * Promise-based code to be tested with MockClock.\n *\n * However, we also want to run promises if the MockClock is no longer in\n * control so we schedule a backup \"setTimeout\" to the unmocked timeout if\n * provided.\n *\n * @param {function(function())=} opt_realSetTimeout\n */\ngoog.async.run.forceNextTick = function(opt_realSetTimeout) {\n  goog.async.run.schedule_ = function() {\n    goog.async.nextTick(goog.async.run.processWorkQueue);\n    if (opt_realSetTimeout) {\n      opt_realSetTimeout(goog.async.run.processWorkQueue);\n    }\n  };\n};\n\n\n/**\n * The function used to schedule work asynchronousely.\n * @private {function()}\n */\ngoog.async.run.schedule_;\n\n\n/** @private {boolean} */\ngoog.async.run.workQueueScheduled_ = false;\n\n\n/** @private {!goog.async.WorkQueue} */\ngoog.async.run.workQueue_ = new goog.async.WorkQueue();\n\n\nif (goog.DEBUG) {\n  /**\n   * Reset the work queue. Only available for tests in debug mode.\n   */\n  goog.async.run.resetQueue = function() {\n    goog.async.run.workQueueScheduled_ = false;\n    goog.async.run.workQueue_ = new goog.async.WorkQueue();\n  };\n}\n\n\n/**\n * Run any pending goog.async.run work items. This function is not intended\n * for general use, but for use by entry point handlers to run items ahead of\n * goog.async.nextTick.\n */\ngoog.async.run.processWorkQueue = function() {\n  // NOTE: additional work queue items may be added while processing.\n  var item = null;\n  while (item = goog.async.run.workQueue_.remove()) {\n    try {\n      item.fn.call(item.scope);\n    } catch (e) {\n      goog.async.throwException(e);\n    }\n    goog.async.run.workQueue_.returnUnused(item);\n  }\n\n  // There are no more work items, allow processing to be scheduled again.\n  goog.async.run.workQueueScheduled_ = false;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for string manipulation.\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\n/**\n * Namespace for string utilities\n */\ngoog.provide('goog.string');\ngoog.provide('goog.string.Unicode');\n\ngoog.require('goog.dom.safe');\ngoog.require('goog.html.uncheckedconversions');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.internal');\n\n\n/**\n * @define {boolean} Enables HTML escaping of lowercase letter \"e\" which helps\n * with detection of double-escaping as this letter is frequently used.\n */\ngoog.string.DETECT_DOUBLE_ESCAPING =\n    goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);\n\n\n/**\n * @define {boolean} Whether to force non-dom html unescaping.\n */\ngoog.string.FORCE_NON_DOM_HTML_UNESCAPING =\n    goog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);\n\n\n/**\n * Common Unicode string characters.\n * @enum {string}\n */\ngoog.string.Unicode = {\n  NBSP: '\\xa0'\n};\n\n\n/**\n * Fast prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix A string to look for at the start of `str`.\n * @return {boolean} True if `str` begins with `prefix`.\n */\ngoog.string.startsWith = goog.string.internal.startsWith;\n\n\n/**\n * Fast suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of `str`.\n * @return {boolean} True if `str` ends with `suffix`.\n */\ngoog.string.endsWith = goog.string.internal.endsWith;\n\n\n/**\n * Case-insensitive prefix-checker.\n * @param {string} str The string to check.\n * @param {string} prefix  A string to look for at the end of `str`.\n * @return {boolean} True if `str` begins with `prefix` (ignoring\n *     case).\n */\ngoog.string.caseInsensitiveStartsWith =\n    goog.string.internal.caseInsensitiveStartsWith;\n\n\n/**\n * Case-insensitive suffix-checker.\n * @param {string} str The string to check.\n * @param {string} suffix A string to look for at the end of `str`.\n * @return {boolean} True if `str` ends with `suffix` (ignoring\n *     case).\n */\ngoog.string.caseInsensitiveEndsWith =\n    goog.string.internal.caseInsensitiveEndsWith;\n\n\n/**\n * Case-insensitive equality checker.\n * @param {string} str1 First string to check.\n * @param {string} str2 Second string to check.\n * @return {boolean} True if `str1` and `str2` are the same string,\n *     ignoring case.\n */\ngoog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals;\n\n\n/**\n * Does simple python-style string substitution.\n * subs(\"foo%s hot%s\", \"bar\", \"dog\") becomes \"foobar hotdog\".\n * @param {string} str The string containing the pattern.\n * @param {...*} var_args The items to substitute into the pattern.\n * @return {string} A copy of `str` in which each occurrence of\n *     {@code %s} has been replaced an argument from `var_args`.\n */\ngoog.string.subs = function(str, var_args) {\n  var splitParts = str.split('%s');\n  var returnString = '';\n\n  var subsArguments = Array.prototype.slice.call(arguments, 1);\n  while (subsArguments.length &&\n         // Replace up to the last split part. We are inserting in the\n         // positions between split parts.\n         splitParts.length > 1) {\n    returnString += splitParts.shift() + subsArguments.shift();\n  }\n\n  return returnString + splitParts.join('%s');  // Join unused '%s'\n};\n\n\n/**\n * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines\n * and tabs) to a single space, and strips leading and trailing whitespace.\n * @param {string} str Input string.\n * @return {string} A copy of `str` with collapsed whitespace.\n */\ngoog.string.collapseWhitespace = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/[\\s\\xa0]+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n};\n\n\n/**\n * Checks if a string is empty or contains only whitespaces.\n * @param {string} str The string to check.\n * @return {boolean} Whether `str` is empty or whitespace only.\n */\ngoog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace;\n\n\n/**\n * Checks if a string is empty.\n * @param {string} str The string to check.\n * @return {boolean} Whether `str` is empty.\n */\ngoog.string.isEmptyString = function(str) {\n  return str.length == 0;\n};\n\n\n/**\n * Checks if a string is empty or contains only whitespaces.\n *\n * @param {string} str The string to check.\n * @return {boolean} Whether `str` is empty or whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\n\n\n/**\n * Checks if a string is null, undefined, empty or contains only whitespaces.\n * @param {*} str The string to check.\n * @return {boolean} Whether `str` is null, undefined, empty, or\n *     whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))\n *     instead.\n */\ngoog.string.isEmptyOrWhitespaceSafe = function(str) {\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));\n};\n\n\n/**\n * Checks if a string is null, undefined, empty or contains only whitespaces.\n *\n * @param {*} str The string to check.\n * @return {boolean} Whether `str` is null, undefined, empty, or\n *     whitespace only.\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\n */\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\n\n\n/**\n * Checks if a string is all breaking whitespace.\n * @param {string} str The string to check.\n * @return {boolean} Whether the string is all breaking whitespace.\n */\ngoog.string.isBreakingWhitespace = function(str) {\n  return !/[^\\t\\n\\r ]/.test(str);\n};\n\n\n/**\n * Checks if a string contains all letters.\n * @param {string} str string to check.\n * @return {boolean} True if `str` consists entirely of letters.\n */\ngoog.string.isAlpha = function(str) {\n  return !/[^a-zA-Z]/.test(str);\n};\n\n\n/**\n * Checks if a string contains only numbers.\n * @param {*} str string to check. If not a string, it will be\n *     casted to one.\n * @return {boolean} True if `str` is numeric.\n */\ngoog.string.isNumeric = function(str) {\n  return !/[^0-9]/.test(str);\n};\n\n\n/**\n * Checks if a string contains only numbers or letters.\n * @param {string} str string to check.\n * @return {boolean} True if `str` is alphanumeric.\n */\ngoog.string.isAlphaNumeric = function(str) {\n  return !/[^a-zA-Z0-9]/.test(str);\n};\n\n\n/**\n * Checks if a character is a space character.\n * @param {string} ch Character to check.\n * @return {boolean} True if `ch` is a space.\n */\ngoog.string.isSpace = function(ch) {\n  return ch == ' ';\n};\n\n\n/**\n * Checks if a character is a valid unicode character.\n * @param {string} ch Character to check.\n * @return {boolean} True if `ch` is a valid unicode character.\n */\ngoog.string.isUnicodeChar = function(ch) {\n  return ch.length == 1 && ch >= ' ' && ch <= '~' ||\n      ch >= '\\u0080' && ch <= '\\uFFFD';\n};\n\n\n/**\n * Takes a string and replaces newlines with a space. Multiple lines are\n * replaced with a single space.\n * @param {string} str The string from which to strip newlines.\n * @return {string} A copy of `str` stripped of newlines.\n */\ngoog.string.stripNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)+/g, ' ');\n};\n\n\n/**\n * Replaces Windows and Mac new lines with unix style: \\r or \\r\\n with \\n.\n * @param {string} str The string to in which to canonicalize newlines.\n * @return {string} `str` A copy of {@code} with canonicalized newlines.\n */\ngoog.string.canonicalizeNewlines = function(str) {\n  return str.replace(/(\\r\\n|\\r|\\n)/g, '\\n');\n};\n\n\n/**\n * Normalizes whitespace in a string, replacing all whitespace chars with\n * a space.\n * @param {string} str The string in which to normalize whitespace.\n * @return {string} A copy of `str` with all whitespace normalized.\n */\ngoog.string.normalizeWhitespace = function(str) {\n  return str.replace(/\\xa0|\\s/g, ' ');\n};\n\n\n/**\n * Normalizes spaces in a string, replacing all consecutive spaces and tabs\n * with a single space. Replaces non-breaking space with a space.\n * @param {string} str The string in which to normalize spaces.\n * @return {string} A copy of `str` with all consecutive spaces and tabs\n *    replaced with a single space.\n */\ngoog.string.normalizeSpaces = function(str) {\n  return str.replace(/\\xa0|[ \\t]+/g, ' ');\n};\n\n\n/**\n * Removes the breaking spaces from the left and right of the string and\n * collapses the sequences of breaking spaces in the middle into single spaces.\n * The original and the result strings render the same way in HTML.\n * @param {string} str A string in which to collapse spaces.\n * @return {string} Copy of the string with normalized breaking spaces.\n */\ngoog.string.collapseBreakingSpaces = function(str) {\n  return str.replace(/[\\t\\r\\n ]+/g, ' ')\n      .replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\n};\n\n\n/**\n * Trims white spaces to the left and right of a string.\n * @param {string} str The string to trim.\n * @return {string} A trimmed copy of `str`.\n */\ngoog.string.trim = goog.string.internal.trim;\n\n\n/**\n * Trims whitespaces at the left end of a string.\n * @param {string} str The string to left trim.\n * @return {string} A trimmed copy of `str`.\n */\ngoog.string.trimLeft = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/^[\\s\\xa0]+/, '');\n};\n\n\n/**\n * Trims whitespaces at the right end of a string.\n * @param {string} str The string to right trim.\n * @return {string} A trimmed copy of `str`.\n */\ngoog.string.trimRight = function(str) {\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\n  // include it in the regexp to enforce consistent cross-browser behavior.\n  return str.replace(/[\\s\\xa0]+$/, '');\n};\n\n\n/**\n * A string comparator that ignores case.\n * -1 = str1 less than str2\n *  0 = str1 equals str2\n *  1 = str1 greater than str2\n *\n * @param {string} str1 The string to compare.\n * @param {string} str2 The string to compare `str1` to.\n * @return {number} The comparator result, as described above.\n */\ngoog.string.caseInsensitiveCompare =\n    goog.string.internal.caseInsensitiveCompare;\n\n\n/**\n * Compares two strings interpreting their numeric substrings as numbers.\n *\n * @param {string} str1 First string.\n * @param {string} str2 Second string.\n * @param {!RegExp} tokenizerRegExp Splits a string into substrings of\n *     non-negative integers, non-numeric characters and optionally fractional\n *     numbers starting with a decimal point.\n * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if\n *     str1 > str2.\n * @private\n */\ngoog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {\n  if (str1 == str2) {\n    return 0;\n  }\n  if (!str1) {\n    return -1;\n  }\n  if (!str2) {\n    return 1;\n  }\n\n  // Using match to split the entire string ahead of time turns out to be faster\n  // for most inputs than using RegExp.exec or iterating over each character.\n  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);\n  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);\n\n  var count = Math.min(tokens1.length, tokens2.length);\n\n  for (var i = 0; i < count; i++) {\n    var a = tokens1[i];\n    var b = tokens2[i];\n\n    // Compare pairs of tokens, returning if one token sorts before the other.\n    if (a != b) {\n      // Only if both tokens are integers is a special comparison required.\n      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').\n      var num1 = parseInt(a, 10);\n      if (!isNaN(num1)) {\n        var num2 = parseInt(b, 10);\n        if (!isNaN(num2) && num1 - num2) {\n          return num1 - num2;\n        }\n      }\n      return a < b ? -1 : 1;\n    }\n  }\n\n  // If one string is a substring of the other, the shorter string sorts first.\n  if (tokens1.length != tokens2.length) {\n    return tokens1.length - tokens2.length;\n  }\n\n  // The two strings must be equivalent except for case (perfect equality is\n  // tested at the head of the function.) Revert to default ASCII string\n  // comparison to stabilize the sort.\n  return str1 < str2 ? -1 : 1;\n};\n\n\n/**\n * String comparison function that handles non-negative integer numbers in a\n * way humans might expect. Using this function, the string 'File 2.jpg' sorts\n * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison\n * is mostly case-insensitive, though strings that are identical except for case\n * are sorted with the upper-case strings before lower-case.\n *\n * This comparison function is up to 50x slower than either the default or the\n * case-insensitive compare. It should not be used in time-critical code, but\n * should be fast enough to sort several hundred short strings (like filenames)\n * with a reasonable delay.\n *\n * @param {string} str1 The string to compare in a numerically sensitive way.\n * @param {string} str2 The string to compare `str1` to.\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\n *     0 if str1 > str2.\n */\ngoog.string.intAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\D+/g);\n};\n\n\n/**\n * String comparison function that handles non-negative integer and fractional\n * numbers in a way humans might expect. Using this function, the string\n * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent\n * to {@link goog.string.intAwareCompare} apart from the way how it interprets\n * dots.\n *\n * @param {string} str1 The string to compare in a numerically sensitive way.\n * @param {string} str2 The string to compare `str1` to.\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\n *     0 if str1 > str2.\n */\ngoog.string.floatAwareCompare = function(str1, str2) {\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\.\\d+|\\D+/g);\n};\n\n\n/**\n * Alias for {@link goog.string.floatAwareCompare}.\n *\n * @param {string} str1\n * @param {string} str2\n * @return {number}\n */\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\n\n\n/**\n * URL-encodes a string\n * @param {*} str The string to url-encode.\n * @return {string} An encoded copy of `str` that is safe for urls.\n *     Note that '#', ':', and other characters used to delimit portions\n *     of URLs *will* be encoded.\n */\ngoog.string.urlEncode = function(str) {\n  return encodeURIComponent(String(str));\n};\n\n\n/**\n * URL-decodes the string. We need to specially handle '+'s because\n * the javascript library doesn't convert them to spaces.\n * @param {string} str The string to url decode.\n * @return {string} The decoded `str`.\n */\ngoog.string.urlDecode = function(str) {\n  return decodeURIComponent(str.replace(/\\+/g, ' '));\n};\n\n\n/**\n * Converts \\n to <br>s or <br />s.\n * @param {string} str The string in which to convert newlines.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} A copy of `str` with converted newlines.\n */\ngoog.string.newLineToBr = goog.string.internal.newLineToBr;\n\n\n/**\n * Escapes double quote '\"' and single quote '\\'' characters in addition to\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\n * value within double or single quotes.\n *\n * It should be noted that > doesn't need to be escaped for the HTML or XML to\n * be valid, but it has been decided to escape it for consistency with other\n * implementations.\n *\n * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the\n * lowercase letter \"e\".\n *\n * NOTE(user):\n * HtmlEscape is often called during the generation of large blocks of HTML.\n * Using statics for the regular expressions and strings is an optimization\n * that can more than half the amount of time IE spends in this function for\n * large apps, since strings and regexes both contribute to GC allocations.\n *\n * Testing for the presence of a character before escaping increases the number\n * of function calls, but actually provides a speed increase for the average\n * case -- since the average case often doesn't require the escaping of all 4\n * characters and indexOf() is much cheaper than replace().\n * The worst case does suffer slightly from the additional calls, therefore the\n * opt_isLikelyToContainHtmlChars option has been included for situations\n * where all 4 HTML entities are very likely to be present and need escaping.\n *\n * Some benchmarks (times tended to fluctuate +-0.05ms):\n *                                     FireFox                     IE6\n * (no chars / average (mix of cases) / all 4 chars)\n * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80\n * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84\n * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85\n *\n * An additional advantage of checking if replace actually needs to be called\n * is a reduction in the number of object allocations, so as the size of the\n * application grows the difference between the various methods would increase.\n *\n * @param {string} str string to be escaped.\n * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see\n *     if the character needs replacing - use this option if you expect each of\n *     the characters to appear often. Leave false if you expect few html\n *     characters to occur in your strings, such as if you are escaping HTML.\n * @return {string} An escaped copy of `str`.\n */\ngoog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {\n  str = goog.string.internal.htmlEscape(str, opt_isLikelyToContainHtmlChars);\n  if (goog.string.DETECT_DOUBLE_ESCAPING) {\n    str = str.replace(goog.string.E_RE_, '&#101;');\n  }\n  return str;\n};\n\n\n/**\n * Regular expression that matches a lowercase letter \"e\", for use in escaping.\n * @const {!RegExp}\n * @private\n */\ngoog.string.E_RE_ = /e/g;\n\n\n/**\n * Unescapes an HTML string.\n *\n * @param {string} str The string to unescape.\n * @return {string} An unescaped copy of `str`.\n */\ngoog.string.unescapeEntities = function(str) {\n  if (goog.string.contains(str, '&')) {\n    // We are careful not to use a DOM if we do not have one or we explicitly\n    // requested non-DOM html unescaping.\n    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&\n        'document' in goog.global) {\n      return goog.string.unescapeEntitiesUsingDom_(str);\n    } else {\n      // Fall back on pure XML entities\n      return goog.string.unescapePureXmlEntities_(str);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Unescapes a HTML string using the provided document.\n *\n * @param {string} str The string to unescape.\n * @param {!Document} document A document to use in escaping the string.\n * @return {string} An unescaped copy of `str`.\n */\ngoog.string.unescapeEntitiesWithDocument = function(str, document) {\n  if (goog.string.contains(str, '&')) {\n    return goog.string.unescapeEntitiesUsingDom_(str, document);\n  }\n  return str;\n};\n\n\n/**\n * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric\n * entities. This function is XSS-safe and whitespace-preserving.\n * @private\n * @param {string} str The string to unescape.\n * @param {Document=} opt_document An optional document to use for creating\n *     elements. If this is not specified then the default window.document\n *     will be used.\n * @return {string} The unescaped `str` string.\n */\ngoog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {\n  /** @type {!Object<string, string>} */\n  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"'};\n  /** @type {!Element} */\n  var div;\n  if (opt_document) {\n    div = opt_document.createElement('div');\n  } else {\n    div = goog.global.document.createElement('div');\n  }\n  // Match as many valid entity characters as possible. If the actual entity\n  // happens to be shorter, it will still work as innerHTML will return the\n  // trailing characters unchanged. Since the entity characters do not include\n  // open angle bracket, there is no chance of XSS from the innerHTML use.\n  // Since no whitespace is passed to innerHTML, whitespace is preserved.\n  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {\n    // Check for cached entity.\n    var value = seen[s];\n    if (value) {\n      return value;\n    }\n    // Check for numeric entity.\n    if (entity.charAt(0) == '#') {\n      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.\n      var n = Number('0' + entity.substr(1));\n      if (!isNaN(n)) {\n        value = String.fromCharCode(n);\n      }\n    }\n    // Fall back to innerHTML otherwise.\n    if (!value) {\n      // Append a non-entity character to avoid a bug in Webkit that parses\n      // an invalid entity at the end of innerHTML text as the empty string.\n      goog.dom.safe.setInnerHtml(\n          div,\n          goog.html.uncheckedconversions\n              .safeHtmlFromStringKnownToSatisfyTypeContract(\n                  goog.string.Const.from('Single HTML entity.'), s + ' '));\n      // Then remove the trailing character from the result.\n      value = div.firstChild.nodeValue.slice(0, -1);\n    }\n    // Cache and return.\n    return seen[s] = value;\n  });\n};\n\n\n/**\n * Unescapes XML entities.\n * @private\n * @param {string} str The string to unescape.\n * @return {string} An unescaped copy of `str`.\n */\ngoog.string.unescapePureXmlEntities_ = function(str) {\n  return str.replace(/&([^;]+);/g, function(s, entity) {\n    switch (entity) {\n      case 'amp':\n        return '&';\n      case 'lt':\n        return '<';\n      case 'gt':\n        return '>';\n      case 'quot':\n        return '\"';\n      default:\n        if (entity.charAt(0) == '#') {\n          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.\n          var n = Number('0' + entity.substr(1));\n          if (!isNaN(n)) {\n            return String.fromCharCode(n);\n          }\n        }\n        // For invalid entities we just return the entity\n        return s;\n    }\n  });\n};\n\n\n/**\n * Regular expression that matches an HTML entity.\n * See also HTML5: Tokenization / Tokenizing character references.\n * @private\n * @type {!RegExp}\n */\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\n\n\n/**\n * Do escaping of whitespace to preserve spatial formatting. We use character\n * entity #160 to make it safer for xml.\n * @param {string} str The string in which to escape whitespace.\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\n * @return {string} An escaped copy of `str`.\n */\ngoog.string.whitespaceEscape = function(str, opt_xml) {\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\n  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);\n};\n\n\n/**\n * Preserve spaces that would be otherwise collapsed in HTML by replacing them\n * with non-breaking space Unicode characters.\n * @param {string} str The string in which to preserve whitespace.\n * @return {string} A copy of `str` with preserved whitespace.\n */\ngoog.string.preserveSpaces = function(str) {\n  return str.replace(/(^|[\\n ]) /g, '$1' + goog.string.Unicode.NBSP);\n};\n\n\n/**\n * Strip quote characters around a string.  The second argument is a string of\n * characters to treat as quotes.  This can be a single character or a string of\n * multiple character and in that case each of those are treated as possible\n * quote characters. For example:\n *\n * <pre>\n * goog.string.stripQuotes('\"abc\"', '\"`') --> 'abc'\n * goog.string.stripQuotes('`abc`', '\"`') --> 'abc'\n * </pre>\n *\n * @param {string} str The string to strip.\n * @param {string} quoteChars The quote characters to strip.\n * @return {string} A copy of `str` without the quotes.\n */\ngoog.string.stripQuotes = function(str, quoteChars) {\n  var length = quoteChars.length;\n  for (var i = 0; i < length; i++) {\n    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);\n    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {\n      return str.substring(1, str.length - 1);\n    }\n  }\n  return str;\n};\n\n\n/**\n * Truncates a string to a certain length and adds '...' if necessary.  The\n * length also accounts for the ellipsis, so a maximum length of 10 and a string\n * 'Hello World!' produces 'Hello W...'.\n * @param {string} str The string to truncate.\n * @param {number} chars Max number of characters.\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\n *     characters from being cut off in the middle.\n * @return {string} The truncated `str` string.\n */\ngoog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n\n  if (str.length > chars) {\n    str = str.substring(0, chars - 3) + '...';\n  }\n\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n\n  return str;\n};\n\n\n/**\n * Truncate a string in the middle, adding \"...\" if necessary,\n * and favoring the beginning of the string.\n * @param {string} str The string to truncate the middle of.\n * @param {number} chars Max number of characters.\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\n *     characters from being cutoff in the middle.\n * @param {number=} opt_trailingChars Optional number of trailing characters to\n *     leave at the end of the string, instead of truncating as close to the\n *     middle as possible.\n * @return {string} A truncated copy of `str`.\n */\ngoog.string.truncateMiddle = function(\n    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.unescapeEntities(str);\n  }\n\n  if (opt_trailingChars && str.length > chars) {\n    if (opt_trailingChars > chars) {\n      opt_trailingChars = chars;\n    }\n    var endPoint = str.length - opt_trailingChars;\n    var startPoint = chars - opt_trailingChars;\n    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);\n  } else if (str.length > chars) {\n    // Favor the beginning of the string:\n    var half = Math.floor(chars / 2);\n    var endPos = str.length - half;\n    half += chars % 2;\n    str = str.substring(0, half) + '...' + str.substring(endPos);\n  }\n\n  if (opt_protectEscapedCharacters) {\n    str = goog.string.htmlEscape(str);\n  }\n\n  return str;\n};\n\n\n/**\n * Special chars that need to be escaped for goog.string.quote.\n * @private {!Object<string, string>}\n */\ngoog.string.specialEscapeChars_ = {\n  '\\0': '\\\\0',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\x0B': '\\\\x0B',  // '\\v' is not supported in JScript\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  // To support the use case of embedding quoted strings inside of script\n  // tags, we have to make sure HTML comments and opening/closing script tags do\n  // not appear in the resulting string. The specific strings that must be\n  // escaped are documented at:\n  // https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements\n  '<': '\\\\u003C'  // NOTE: JSON.parse crashes on '\\\\x3c'.\n};\n\n\n/**\n * Character mappings used internally for goog.string.escapeChar.\n * @private {!Object<string, string>}\n */\ngoog.string.jsEscapeCache_ = {\n  '\\'': '\\\\\\''\n};\n\n\n/**\n * Encloses a string in double quotes and escapes characters so that the\n * string is a valid JS string. The resulting string is safe to embed in\n * `<script>` tags as \"<\" is escaped.\n * @param {string} s The string to quote.\n * @return {string} A copy of `s` surrounded by double quotes.\n */\ngoog.string.quote = function(s) {\n  s = String(s);\n  var sb = ['\"'];\n  for (var i = 0; i < s.length; i++) {\n    var ch = s.charAt(i);\n    var cc = ch.charCodeAt(0);\n    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||\n        ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));\n  }\n  sb.push('\"');\n  return sb.join('');\n};\n\n\n/**\n * Takes a string and returns the escaped string for that input string.\n * @param {string} str The string to escape.\n * @return {string} An escaped string representing `str`.\n */\ngoog.string.escapeString = function(str) {\n  var sb = [];\n  for (var i = 0; i < str.length; i++) {\n    sb[i] = goog.string.escapeChar(str.charAt(i));\n  }\n  return sb.join('');\n};\n\n\n/**\n * Takes a character and returns the escaped string for that character. For\n * example escapeChar(String.fromCharCode(15)) -> \"\\\\x0E\".\n * @param {string} c The character to escape.\n * @return {string} An escaped string representing `c`.\n */\ngoog.string.escapeChar = function(c) {\n  if (c in goog.string.jsEscapeCache_) {\n    return goog.string.jsEscapeCache_[c];\n  }\n\n  if (c in goog.string.specialEscapeChars_) {\n    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];\n  }\n\n  var rv = c;\n  var cc = c.charCodeAt(0);\n  if (cc > 31 && cc < 127) {\n    rv = c;\n  } else {\n    // tab is 9 but handled above\n    if (cc < 256) {\n      rv = '\\\\x';\n      if (cc < 16 || cc > 256) {\n        rv += '0';\n      }\n    } else {\n      rv = '\\\\u';\n      if (cc < 4096) {  // \\u1000\n        rv += '0';\n      }\n    }\n    rv += cc.toString(16).toUpperCase();\n  }\n\n  return goog.string.jsEscapeCache_[c] = rv;\n};\n\n\n/**\n * Determines whether a string contains a substring.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether `str` contains `subString`.\n */\ngoog.string.contains = goog.string.internal.contains;\n\n\n/**\n * Determines whether a string contains a substring, ignoring case.\n * @param {string} str The string to search.\n * @param {string} subString The substring to search for.\n * @return {boolean} Whether `str` contains `subString`.\n */\ngoog.string.caseInsensitiveContains =\n    goog.string.internal.caseInsensitiveContains;\n\n\n/**\n * Returns the non-overlapping occurrences of ss in s.\n * If either s or ss evalutes to false, then returns zero.\n * @param {string} s The string to look in.\n * @param {string} ss The string to look for.\n * @return {number} Number of occurrences of ss in s.\n */\ngoog.string.countOf = function(s, ss) {\n  return s && ss ? s.split(ss).length - 1 : 0;\n};\n\n\n/**\n * Removes a substring of a specified length at a specific\n * index in a string.\n * @param {string} s The base string from which to remove.\n * @param {number} index The index at which to remove the substring.\n * @param {number} stringLength The length of the substring to remove.\n * @return {string} A copy of `s` with the substring removed or the full\n *     string if nothing is removed or the input is invalid.\n */\ngoog.string.removeAt = function(s, index, stringLength) {\n  var resultStr = s;\n  // If the index is greater or equal to 0 then remove substring\n  if (index >= 0 && index < s.length && stringLength > 0) {\n    resultStr = s.substr(0, index) +\n        s.substr(index + stringLength, s.length - index - stringLength);\n  }\n  return resultStr;\n};\n\n\n/**\n * Removes the first occurrence of a substring from a string.\n * @param {string} str The base string from which to remove.\n * @param {string} substr The string to remove.\n * @return {string} A copy of `str` with `substr` removed or the\n *     full string if nothing is removed.\n */\ngoog.string.remove = function(str, substr) {\n  return str.replace(substr, '');\n};\n\n\n/**\n *  Removes all occurrences of a substring from a string.\n *  @param {string} s The base string from which to remove.\n *  @param {string} ss The string to remove.\n *  @return {string} A copy of `s` with `ss` removed or the full\n *      string if nothing is removed.\n */\ngoog.string.removeAll = function(s, ss) {\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\n  return s.replace(re, '');\n};\n\n\n/**\n *  Replaces all occurrences of a substring of a string with a new substring.\n *  @param {string} s The base string from which to remove.\n *  @param {string} ss The string to replace.\n *  @param {string} replacement The replacement string.\n *  @return {string} A copy of `s` with `ss` replaced by\n *      `replacement` or the original string if nothing is replaced.\n */\ngoog.string.replaceAll = function(s, ss, replacement) {\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\n  return s.replace(re, replacement.replace(/\\$/g, '$$$$'));\n};\n\n\n/**\n * Escapes characters in the string that are not safe to use in a RegExp.\n * @param {*} s The string to escape. If not a string, it will be casted\n *     to one.\n * @return {string} A RegExp safe, escaped copy of `s`.\n */\ngoog.string.regExpEscape = function(s) {\n  return String(s)\n      .replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\n      .replace(/\\x08/g, '\\\\x08');\n};\n\n\n/**\n * Repeats a string n times.\n * @param {string} string The string to repeat.\n * @param {number} length The number of times to repeat.\n * @return {string} A string containing `length` repetitions of\n *     `string`.\n */\ngoog.string.repeat = (String.prototype.repeat) ? function(string, length) {\n  // The native method is over 100 times faster than the alternative.\n  return string.repeat(length);\n} : function(string, length) {\n  return new Array(length + 1).join(string);\n};\n\n\n/**\n * Pads number to given length and optionally rounds it to a given precision.\n * For example:\n * <pre>padNumber(1.25, 2, 3) -> '01.250'\n * padNumber(1.25, 2) -> '01.25'\n * padNumber(1.25, 2, 1) -> '01.3'\n * padNumber(1.25, 0) -> '1.25'</pre>\n *\n * @param {number} num The number to pad.\n * @param {number} length The desired length.\n * @param {number=} opt_precision The desired precision.\n * @return {string} `num` as a string with the given options.\n */\ngoog.string.padNumber = function(num, length, opt_precision) {\n  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);\n  var index = s.indexOf('.');\n  if (index == -1) {\n    index = s.length;\n  }\n  return goog.string.repeat('0', Math.max(0, length - index)) + s;\n};\n\n\n/**\n * Returns a string representation of the given object, with\n * null and undefined being returned as the empty string.\n *\n * @param {*} obj The object to convert.\n * @return {string} A string representation of the `obj`.\n */\ngoog.string.makeSafe = function(obj) {\n  return obj == null ? '' : String(obj);\n};\n\n\n/**\n * Concatenates string expressions. This is useful\n * since some browsers are very inefficient when it comes to using plus to\n * concat strings. Be careful when using null and undefined here since\n * these will not be included in the result. If you need to represent these\n * be sure to cast the argument to a String first.\n * For example:\n * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'\n * buildString(null, undefined) -> ''\n * </pre>\n * @param {...*} var_args A list of strings to concatenate. If not a string,\n *     it will be casted to one.\n * @return {string} The concatenation of `var_args`.\n */\ngoog.string.buildString = function(var_args) {\n  return Array.prototype.join.call(arguments, '');\n};\n\n\n/**\n * Returns a string with at least 64-bits of randomness.\n *\n * Doesn't trust JavaScript's random function entirely. Uses a combination of\n * random and current timestamp, and then encodes the string in base-36 to\n * make it shorter.\n *\n * @return {string} A random string, e.g. sn1s7vb4gcic.\n */\ngoog.string.getRandomString = function() {\n  var x = 2147483648;\n  return Math.floor(Math.random() * x).toString(36) +\n      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);\n};\n\n\n/**\n * Compares two version numbers.\n *\n * @param {string|number} version1 Version of first item.\n * @param {string|number} version2 Version of second item.\n *\n * @return {number}  1 if `version1` is higher.\n *                   0 if arguments are equal.\n *                  -1 if `version2` is higher.\n */\ngoog.string.compareVersions = goog.string.internal.compareVersions;\n\n\n/**\n * String hash function similar to java.lang.String.hashCode().\n * The hash code for a string is computed as\n * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n * where s[i] is the ith character of the string and n is the length of\n * the string. We mod the result to make it between 0 (inclusive) and 2^32\n * (exclusive).\n * @param {string} str A string.\n * @return {number} Hash value for `str`, between 0 (inclusive) and 2^32\n *  (exclusive). The empty string returns 0.\n */\ngoog.string.hashCode = function(str) {\n  var result = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Normalize to 4 byte range, 0 ... 2^32.\n    result = (31 * result + str.charCodeAt(i)) >>> 0;\n  }\n  return result;\n};\n\n\n/**\n * The most recent unique ID. |0 is equivalent to Math.floor in this case.\n * @type {number}\n * @private\n */\ngoog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;\n\n\n/**\n * Generates and returns a string which is unique in the current document.\n * This is useful, for example, to create unique IDs for DOM elements.\n * @return {string} A unique id.\n */\ngoog.string.createUniqueString = function() {\n  return 'goog_' + goog.string.uniqueStringCounter_++;\n};\n\n\n/**\n * Converts the supplied string to a number, which may be Infinity or NaN.\n * This function strips whitespace: (toNumber(' 123') === 123)\n * This function accepts scientific notation: (toNumber('1e1') === 10)\n *\n * This is better than JavaScript's built-in conversions because, sadly:\n *     (Number(' ') === 0) and (parseFloat('123a') === 123)\n *\n * @param {string} str The string to convert.\n * @return {number} The number the supplied string represents, or NaN.\n */\ngoog.string.toNumber = function(str) {\n  var num = Number(str);\n  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {\n    return NaN;\n  }\n  return num;\n};\n\n\n/**\n * Returns whether the given string is lower camel case (e.g. \"isFooBar\").\n *\n * Note that this assumes the string is entirely letters.\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\n *\n * @param {string} str String to test.\n * @return {boolean} Whether the string is lower camel case.\n */\ngoog.string.isLowerCamelCase = function(str) {\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);\n};\n\n\n/**\n * Returns whether the given string is upper camel case (e.g. \"FooBarBaz\").\n *\n * Note that this assumes the string is entirely letters.\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\n *\n * @param {string} str String to test.\n * @return {boolean} Whether the string is upper camel case.\n */\ngoog.string.isUpperCamelCase = function(str) {\n  return /^([A-Z][a-z]*)+$/.test(str);\n};\n\n\n/**\n * Converts a string from selector-case to camelCase (e.g. from\n * \"multi-part-string\" to \"multiPartString\"), useful for converting\n * CSS selectors and HTML dataset keys to their equivalent JS properties.\n * @param {string} str The string in selector-case form.\n * @return {string} The string in camelCase form.\n */\ngoog.string.toCamelCase = function(str) {\n  return String(str).replace(/\\-([a-z])/g, function(all, match) {\n    return match.toUpperCase();\n  });\n};\n\n\n/**\n * Converts a string from camelCase to selector-case (e.g. from\n * \"multiPartString\" to \"multi-part-string\"), useful for converting JS\n * style and dataset properties to equivalent CSS selectors and HTML keys.\n * @param {string} str The string in camelCase form.\n * @return {string} The string in selector-case form.\n */\ngoog.string.toSelectorCase = function(str) {\n  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n\n/**\n * Converts a string into TitleCase. First character of the string is always\n * capitalized in addition to the first letter of every subsequent word.\n * Words are delimited by one or more whitespaces by default. Custom delimiters\n * can optionally be specified to replace the default, which doesn't preserve\n * whitespace delimiters and instead must be explicitly included if needed.\n *\n * Default delimiter => \" \":\n *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'\n *    goog.string.toTitleCase('one two three')  => 'One Two Three'\n *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '\n *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'\n *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'\n *\n * Custom delimiter => \"_-.\":\n *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'\n *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'\n *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '\n *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'\n *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'\n *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'\n *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'\n *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'\n *\n * @param {string} str String value in camelCase form.\n * @param {string=} opt_delimiters Custom delimiter character set used to\n *      distinguish words in the string value. Each character represents a\n *      single delimiter. When provided, default whitespace delimiter is\n *      overridden and must be explicitly included if needed.\n * @return {string} String value in TitleCase form.\n */\ngoog.string.toTitleCase = function(str, opt_delimiters) {\n  var delimiters = goog.isString(opt_delimiters) ?\n      goog.string.regExpEscape(opt_delimiters) :\n      '\\\\s';\n\n  // For IE8, we need to prevent using an empty character set. Otherwise,\n  // incorrect matching will occur.\n  delimiters = delimiters ? '|[' + delimiters + ']+' : '';\n\n  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');\n  return str.replace(regexp, function(all, p1, p2) {\n    return p1 + p2.toUpperCase();\n  });\n};\n\n\n/**\n * Capitalizes a string, i.e. converts the first letter to uppercase\n * and all other letters to lowercase, e.g.:\n *\n * goog.string.capitalize('one')     => 'One'\n * goog.string.capitalize('ONE')     => 'One'\n * goog.string.capitalize('one two') => 'One two'\n *\n * Note that this function does not trim initial whitespace.\n *\n * @param {string} str String value to capitalize.\n * @return {string} String value with first letter in uppercase.\n */\ngoog.string.capitalize = function(str) {\n  return String(str.charAt(0)).toUpperCase() +\n      String(str.substr(1)).toLowerCase();\n};\n\n\n/**\n * Parse a string in decimal or hexidecimal ('0xFFFF') form.\n *\n * To parse a particular radix, please use parseInt(string, radix) directly. See\n * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt\n *\n * This is a wrapper for the built-in parseInt function that will only parse\n * numbers as base 10 or base 16.  Some JS implementations assume strings\n * starting with \"0\" are intended to be octal. ES3 allowed but discouraged\n * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.\n *\n * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj\n *\n * @param {string|number|null|undefined} value The value to be parsed.\n * @return {number} The number, parsed. If the string failed to parse, this\n *     will be NaN.\n */\ngoog.string.parseInt = function(value) {\n  // Force finite numbers to strings.\n  if (isFinite(value)) {\n    value = String(value);\n  }\n\n  if (goog.isString(value)) {\n    // If the string starts with '0x' or '-0x', parse as hex.\n    return /^\\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);\n  }\n\n  return NaN;\n};\n\n\n/**\n * Splits a string on a separator a limited number of times.\n *\n * This implementation is more similar to Python or Java, where the limit\n * parameter specifies the maximum number of splits rather than truncating\n * the number of results.\n *\n * See http://docs.python.org/2/library/stdtypes.html#str.split\n * See JavaDoc: http://goo.gl/F2AsY\n * See Mozilla reference: http://goo.gl/dZdZs\n *\n * @param {string} str String to split.\n * @param {string} separator The separator.\n * @param {number} limit The limit to the number of splits. The resulting array\n *     will have a maximum length of limit+1.  Negative numbers are the same\n *     as zero.\n * @return {!Array<string>} The string, split.\n */\ngoog.string.splitLimit = function(str, separator, limit) {\n  var parts = str.split(separator);\n  var returnVal = [];\n\n  // Only continue doing this while we haven't hit the limit and we have\n  // parts left.\n  while (limit > 0 && parts.length) {\n    returnVal.push(parts.shift());\n    limit--;\n  }\n\n  // If there are remaining parts, append them to the end.\n  if (parts.length) {\n    returnVal.push(parts.join(separator));\n  }\n\n  return returnVal;\n};\n\n\n/**\n * Finds the characters to the right of the last instance of any separator\n *\n * This function is similar to goog.string.path.baseName, except it can take a\n * list of characters to split the string on. It will return the rightmost\n * grouping of characters to the right of any separator as a left-to-right\n * oriented string.\n *\n * @see goog.string.path.baseName\n * @param {string} str The string\n * @param {string|!Array<string>} separators A list of separator characters\n * @return {string} The last part of the string with respect to the separators\n */\ngoog.string.lastComponent = function(str, separators) {\n  if (!separators) {\n    return str;\n  } else if (typeof separators == 'string') {\n    separators = [separators];\n  }\n\n  var lastSeparatorIndex = -1;\n  for (var i = 0; i < separators.length; i++) {\n    if (separators[i] == '') {\n      continue;\n    }\n    var currentSeparatorIndex = str.lastIndexOf(separators[i]);\n    if (currentSeparatorIndex > lastSeparatorIndex) {\n      lastSeparatorIndex = currentSeparatorIndex;\n    }\n  }\n  if (lastSeparatorIndex == -1) {\n    return str;\n  }\n  return str.slice(lastSeparatorIndex + 1);\n};\n\n\n/**\n * Computes the Levenshtein edit distance between two strings.\n * @param {string} a\n * @param {string} b\n * @return {number} The edit distance between the two strings.\n */\ngoog.string.editDistance = function(a, b) {\n  var v0 = [];\n  var v1 = [];\n\n  if (a == b) {\n    return 0;\n  }\n\n  if (!a.length || !b.length) {\n    return Math.max(a.length, b.length);\n  }\n\n  for (var i = 0; i < b.length + 1; i++) {\n    v0[i] = i;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    v1[0] = i + 1;\n\n    for (var j = 0; j < b.length; j++) {\n      var cost = Number(a[i] != b[j]);\n      // Cost for the substring is the minimum of adding one character, removing\n      // one character, or a swap.\n      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);\n    }\n\n    for (var j = 0; j < v0.length; j++) {\n      v0[j] = v1[j];\n    }\n  }\n\n  return v1[b.length];\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Closure user agent detection.\n * @see http://en.wikipedia.org/wiki/User_agent\n * For more information on browser brand, platform, or device see the other\n * sub-namespaces in goog.labs.userAgent (browser, platform, and device).\n *\n */\n\ngoog.provide('goog.labs.userAgent.engine');\n\ngoog.require('goog.array');\ngoog.require('goog.labs.userAgent.util');\ngoog.require('goog.string');\n\n\n/**\n * @return {boolean} Whether the rendering engine is Presto.\n */\ngoog.labs.userAgent.engine.isPresto = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Presto');\n};\n\n\n/**\n * @return {boolean} Whether the rendering engine is Trident.\n */\ngoog.labs.userAgent.engine.isTrident = function() {\n  // IE only started including the Trident token in IE8.\n  return goog.labs.userAgent.util.matchUserAgent('Trident') ||\n      goog.labs.userAgent.util.matchUserAgent('MSIE');\n};\n\n\n/**\n * @return {boolean} Whether the rendering engine is EdgeHTML.\n */\ngoog.labs.userAgent.engine.isEdge = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Edge');\n};\n\n\n/**\n * @return {boolean} Whether the rendering engine is WebKit. This will return\n * true for Chrome, Blink-based Opera (15+), Edge Chromium and Safari.\n */\ngoog.labs.userAgent.engine.isWebKit = function() {\n  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit') &&\n      !goog.labs.userAgent.engine.isEdge();\n};\n\n\n/**\n * @return {boolean} Whether the rendering engine is Gecko.\n */\ngoog.labs.userAgent.engine.isGecko = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Gecko') &&\n      !goog.labs.userAgent.engine.isWebKit() &&\n      !goog.labs.userAgent.engine.isTrident() &&\n      !goog.labs.userAgent.engine.isEdge();\n};\n\n\n/**\n * @return {string} The rendering engine's version or empty string if version\n *     can't be determined.\n */\ngoog.labs.userAgent.engine.getVersion = function() {\n  var userAgentString = goog.labs.userAgent.util.getUserAgent();\n  if (userAgentString) {\n    var tuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);\n\n    var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);\n    if (engineTuple) {\n      // In Gecko, the version string is either in the browser info or the\n      // Firefox version.  See Gecko user agent string reference:\n      // http://goo.gl/mULqa\n      if (engineTuple[0] == 'Gecko') {\n        return goog.labs.userAgent.engine.getVersionForKey_(tuples, 'Firefox');\n      }\n\n      return engineTuple[1];\n    }\n\n    // MSIE has only one version identifier, and the Trident version is\n    // specified in the parenthetical. IE Edge is covered in the engine tuple\n    // detection.\n    var browserTuple = tuples[0];\n    var info;\n    if (browserTuple && (info = browserTuple[2])) {\n      var match = /Trident\\/([^\\s;]+)/.exec(info);\n      if (match) {\n        return match[1];\n      }\n    }\n  }\n  return '';\n};\n\n\n/**\n * @param {!Array<!Array<string>>} tuples Extracted version tuples.\n * @return {!Array<string>|undefined} The engine tuple or undefined if not\n *     found.\n * @private\n */\ngoog.labs.userAgent.engine.getEngineTuple_ = function(tuples) {\n  if (!goog.labs.userAgent.engine.isEdge()) {\n    return tuples[1];\n  }\n  for (var i = 0; i < tuples.length; i++) {\n    var tuple = tuples[i];\n    if (tuple[0] == 'Edge') {\n      return tuple;\n    }\n  }\n};\n\n\n/**\n * @param {string|number} version The version to check.\n * @return {boolean} Whether the rendering engine version is higher or the same\n *     as the given version.\n */\ngoog.labs.userAgent.engine.isVersionOrHigher = function(version) {\n  return goog.string.compareVersions(\n             goog.labs.userAgent.engine.getVersion(), version) >= 0;\n};\n\n\n/**\n * @param {!Array<!Array<string>>} tuples Version tuples.\n * @param {string} key The key to look for.\n * @return {string} The version string of the given key, if present.\n *     Otherwise, the empty string.\n * @private\n */\ngoog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {\n  // TODO(nnaze): Move to util if useful elsewhere.\n\n  var pair = goog.array.find(tuples, function(pair) { return key == pair[0]; });\n\n  return pair && pair[1] || '';\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Type-safe wrappers for unsafe DOM APIs.\n *\n * This file provides type-safe wrappers for DOM APIs that can result in\n * cross-site scripting (XSS) vulnerabilities, if the API is supplied with\n * untrusted (attacker-controlled) input.  Instead of plain strings, the type\n * safe wrappers consume values of types from the goog.html package whose\n * contract promises that values are safe to use in the corresponding context.\n *\n * Hence, a program that exclusively uses the wrappers in this file (i.e., whose\n * only reference to security-sensitive raw DOM APIs are in this file) is\n * guaranteed to be free of XSS due to incorrect use of such DOM APIs (modulo\n * correctness of code that produces values of the respective goog.html types,\n * and absent code that violates type safety).\n *\n * For example, assigning to an element's .innerHTML property a string that is\n * derived (even partially) from untrusted input typically results in an XSS\n * vulnerability. The type-safe wrapper goog.dom.safe.setInnerHtml consumes a\n * value of type goog.html.SafeHtml, whose contract states that using its values\n * in a HTML context will not result in XSS. Hence a program that is free of\n * direct assignments to any element's innerHTML property (with the exception of\n * the assignment to .innerHTML in this file) is guaranteed to be free of XSS\n * due to assignment of untrusted strings to the innerHTML property.\n */\n\ngoog.provide('goog.dom.safe');\ngoog.provide('goog.dom.safe.InsertAdjacentHtmlPosition');\n\ngoog.require('goog.asserts');\ngoog.require('goog.dom.asserts');\ngoog.require('goog.functions');\ngoog.require('goog.html.SafeHtml');\ngoog.require('goog.html.SafeScript');\ngoog.require('goog.html.SafeStyle');\ngoog.require('goog.html.SafeUrl');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.html.uncheckedconversions');\ngoog.require('goog.string.Const');\ngoog.require('goog.string.internal');\n\n\n/** @enum {string} */\ngoog.dom.safe.InsertAdjacentHtmlPosition = {\n  AFTERBEGIN: 'afterbegin',\n  AFTEREND: 'afterend',\n  BEFOREBEGIN: 'beforebegin',\n  BEFOREEND: 'beforeend'\n};\n\n\n/**\n * Inserts known-safe HTML into a Node, at the specified position.\n * @param {!Node} node The node on which to call insertAdjacentHTML.\n * @param {!goog.dom.safe.InsertAdjacentHtmlPosition} position Position where\n *     to insert the HTML.\n * @param {!goog.html.SafeHtml} html The known-safe HTML to insert.\n */\ngoog.dom.safe.insertAdjacentHtml = function(node, position, html) {\n  node.insertAdjacentHTML(position, goog.html.SafeHtml.unwrapTrustedHTML(html));\n};\n\n\n/**\n * Tags not allowed in goog.dom.safe.setInnerHtml.\n * @private @const {!Object<string, boolean>}\n */\ngoog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = {\n  'MATH': true,\n  'SCRIPT': true,\n  'STYLE': true,\n  'SVG': true,\n  'TEMPLATE': true\n};\n\n\n/**\n * Whether assigning to innerHTML results in a non-spec-compliant clean-up. Used\n * to define goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse.\n *\n * <p>As mentioned in https://stackoverflow.com/questions/28741528, re-rendering\n * an element in IE by setting innerHTML causes IE to recursively disconnect all\n * parent/children connections that were in the previous contents of the\n * element. Unfortunately, this can unexpectedly result in confusing cases where\n * a function is run (typically asynchronously) on element that has since\n * disconnected from the DOM but assumes the presence of its children. A simple\n * workaround is to remove all children first. Testing on IE11 via\n * https://jsperf.com/innerhtml-vs-removechild/239, removeChild seems to be\n * ~10x faster than innerHTML='' for a large number of children (perhaps due\n * to the latter's recursive behavior), implying that this workaround would\n * not hurt performance and might actually improve it.\n * @return {boolean}\n * @private\n */\ngoog.dom.safe.isInnerHtmlCleanupRecursive_ =\n    goog.functions.cacheReturnValue(function() {\n      // `document` missing in some test frameworks.\n      if (goog.DEBUG && typeof document === 'undefined') {\n        return false;\n      }\n      // Create 3 nested <div>s without using innerHTML.\n      // We're not chaining the appendChilds in one call,  as this breaks\n      // in a DocumentFragment.\n      var div = document.createElement('div');\n      var childDiv = document.createElement('div');\n      childDiv.appendChild(document.createElement('div'));\n      div.appendChild(childDiv);\n      // `firstChild` is null in Google Js Test.\n      if (goog.DEBUG && !div.firstChild) {\n        return false;\n      }\n      var innerChild = div.firstChild.firstChild;\n      div.innerHTML =\n          goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);\n      return !innerChild.parentElement;\n    });\n\n\n/**\n * Assigns HTML to an element's innerHTML property. Helper to use only here and\n * in soy.js.\n * @param {?Element} elem The element whose innerHTML is to be assigned to.\n * @param {!goog.html.SafeHtml} html\n */\ngoog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(elem, html) {\n  // See comment above goog.dom.safe.isInnerHtmlCleanupRecursive_.\n  if (goog.dom.safe.isInnerHtmlCleanupRecursive_()) {\n    while (elem.lastChild) {\n      elem.removeChild(elem.lastChild);\n    }\n  }\n  elem.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(html);\n};\n\n\n/**\n * Assigns known-safe HTML to an element's innerHTML property.\n * @param {!Element} elem The element whose innerHTML is to be assigned to.\n * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.\n * @throws {Error} If called with one of these tags: math, script, style, svg,\n *     template.\n */\ngoog.dom.safe.setInnerHtml = function(elem, html) {\n  if (goog.asserts.ENABLE_ASSERTS) {\n    var tagName = elem.tagName.toUpperCase();\n    if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[tagName]) {\n      throw new Error(\n          'goog.dom.safe.setInnerHtml cannot be used to set content of ' +\n          elem.tagName + '.');\n    }\n  }\n\n  goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(elem, html);\n};\n\n\n/**\n * Assigns known-safe HTML to an element's outerHTML property.\n * @param {!Element} elem The element whose outerHTML is to be assigned to.\n * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.\n */\ngoog.dom.safe.setOuterHtml = function(elem, html) {\n  elem.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(html);\n};\n\n\n/**\n * Safely assigns a URL a form element's action property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * anchor's href property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.setFormElementAction(formEl, url);\n * which is a safe alternative to\n *   formEl.action = url;\n * The latter can result in XSS vulnerabilities if url is a\n * user-/attacker-controlled value.\n *\n * @param {!Element} form The form element whose action property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setFormElementAction = function(form, url) {\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  goog.dom.asserts.assertIsHTMLFormElement(form).action =\n      goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Safely assigns a URL to a button element's formaction property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * anchor's href property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.setButtonFormAction(buttonEl, url);\n * which is a safe alternative to\n *   buttonEl.action = url;\n * The latter can result in XSS vulnerabilities if url is a\n * user-/attacker-controlled value.\n *\n * @param {!Element} button The button element whose action property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setButtonFormAction = function(button, url) {\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  goog.dom.asserts.assertIsHTMLButtonElement(button).formAction =\n      goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n/**\n * Safely assigns a URL to an input element's formaction property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * anchor's href property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.setInputFormAction(inputEl, url);\n * which is a safe alternative to\n *   inputEl.action = url;\n * The latter can result in XSS vulnerabilities if url is a\n * user-/attacker-controlled value.\n *\n * @param {!Element} input The input element whose action property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setInputFormAction = function(input, url) {\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  goog.dom.asserts.assertIsHTMLInputElement(input).formAction =\n      goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Sets the given element's style property to the contents of the provided\n * SafeStyle object.\n * @param {!Element} elem\n * @param {!goog.html.SafeStyle} style\n */\ngoog.dom.safe.setStyle = function(elem, style) {\n  elem.style.cssText = goog.html.SafeStyle.unwrap(style);\n};\n\n\n/**\n * Writes known-safe HTML to a document.\n * @param {!Document} doc The document to be written to.\n * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.\n */\ngoog.dom.safe.documentWrite = function(doc, html) {\n  doc.write(goog.html.SafeHtml.unwrapTrustedHTML(html));\n};\n\n\n/**\n * Safely assigns a URL to an anchor element's href property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * anchor's href property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.setAnchorHref(anchorEl, url);\n * which is a safe alternative to\n *   anchorEl.href = url;\n * The latter can result in XSS vulnerabilities if url is a\n * user-/attacker-controlled value.\n *\n * @param {!HTMLAnchorElement} anchor The anchor element whose href property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setAnchorHref = function(anchor, url) {\n  goog.dom.asserts.assertIsHTMLAnchorElement(anchor);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  anchor.href = goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n\n/**\n * Safely assigns a URL to an image element's src property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * image's src property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * @param {!HTMLImageElement} imageElement The image element whose src property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setImageSrc = function(imageElement, url) {\n  goog.dom.asserts.assertIsHTMLImageElement(imageElement);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    var allowDataUrl = /^data:image\\//i.test(url);\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);\n  }\n  imageElement.src = goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Safely assigns a URL to a audio element's src property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * audio's src property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * @param {!HTMLAudioElement} audioElement The audio element whose src property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setAudioSrc = function(audioElement, url) {\n  goog.dom.asserts.assertIsHTMLAudioElement(audioElement);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    var allowDataUrl = /^data:audio\\//i.test(url);\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);\n  }\n  audioElement.src = goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Safely assigns a URL to a video element's src property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * video's src property.  If url is of type string however, it is first\n * sanitized using goog.html.SafeUrl.sanitize.\n *\n * @param {!HTMLVideoElement} videoElement The video element whose src property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setVideoSrc = function(videoElement, url) {\n  goog.dom.asserts.assertIsHTMLVideoElement(videoElement);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    var allowDataUrl = /^data:video\\//i.test(url);\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);\n  }\n  videoElement.src = goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Safely assigns a URL to an embed element's src property.\n *\n * Example usage:\n *   goog.dom.safe.setEmbedSrc(embedEl, url);\n * which is a safe alternative to\n *   embedEl.src = url;\n * The latter can result in loading untrusted code unless it is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLEmbedElement} embed The embed element whose src property\n *     is to be assigned to.\n * @param {!goog.html.TrustedResourceUrl} url The URL to assign.\n */\ngoog.dom.safe.setEmbedSrc = function(embed, url) {\n  goog.dom.asserts.assertIsHTMLEmbedElement(embed);\n  embed.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);\n};\n\n\n/**\n * Safely assigns a URL to a frame element's src property.\n *\n * Example usage:\n *   goog.dom.safe.setFrameSrc(frameEl, url);\n * which is a safe alternative to\n *   frameEl.src = url;\n * The latter can result in loading untrusted code unless it is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLFrameElement} frame The frame element whose src property\n *     is to be assigned to.\n * @param {!goog.html.TrustedResourceUrl} url The URL to assign.\n */\ngoog.dom.safe.setFrameSrc = function(frame, url) {\n  goog.dom.asserts.assertIsHTMLFrameElement(frame);\n  frame.src = goog.html.TrustedResourceUrl.unwrapTrustedURL(url);\n};\n\n\n/**\n * Safely assigns a URL to an iframe element's src property.\n *\n * Example usage:\n *   goog.dom.safe.setIframeSrc(iframeEl, url);\n * which is a safe alternative to\n *   iframeEl.src = url;\n * The latter can result in loading untrusted code unless it is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLIFrameElement} iframe The iframe element whose src property\n *     is to be assigned to.\n * @param {!goog.html.TrustedResourceUrl} url The URL to assign.\n */\ngoog.dom.safe.setIframeSrc = function(iframe, url) {\n  goog.dom.asserts.assertIsHTMLIFrameElement(iframe);\n  iframe.src = goog.html.TrustedResourceUrl.unwrapTrustedURL(url);\n};\n\n\n/**\n * Safely assigns HTML to an iframe element's srcdoc property.\n *\n * Example usage:\n *   goog.dom.safe.setIframeSrcdoc(iframeEl, safeHtml);\n * which is a safe alternative to\n *   iframeEl.srcdoc = html;\n * The latter can result in loading untrusted code.\n *\n * @param {!HTMLIFrameElement} iframe The iframe element whose srcdoc property\n *     is to be assigned to.\n * @param {!goog.html.SafeHtml} html The HTML to assign.\n */\ngoog.dom.safe.setIframeSrcdoc = function(iframe, html) {\n  goog.dom.asserts.assertIsHTMLIFrameElement(iframe);\n  iframe.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(html);\n};\n\n\n/**\n * Safely sets a link element's href and rel properties. Whether or not\n * the URL assigned to href has to be a goog.html.TrustedResourceUrl\n * depends on the value of the rel property. If rel contains \"stylesheet\"\n * then a TrustedResourceUrl is required.\n *\n * Example usage:\n *   goog.dom.safe.setLinkHrefAndRel(linkEl, url, 'stylesheet');\n * which is a safe alternative to\n *   linkEl.rel = 'stylesheet';\n *   linkEl.href = url;\n * The latter can result in loading untrusted code unless it is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLLinkElement} link The link element whose href property\n *     is to be assigned to.\n * @param {string|!goog.html.SafeUrl|!goog.html.TrustedResourceUrl} url The URL\n *     to assign to the href property. Must be a TrustedResourceUrl if the\n *     value assigned to rel contains \"stylesheet\". A string value is\n *     sanitized with goog.html.SafeUrl.sanitize.\n * @param {string} rel The value to assign to the rel property.\n * @throws {Error} if rel contains \"stylesheet\" and url is not a\n *     TrustedResourceUrl\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setLinkHrefAndRel = function(link, url, rel) {\n  goog.dom.asserts.assertIsHTMLLinkElement(link);\n  link.rel = rel;\n  if (goog.string.internal.caseInsensitiveContains(rel, 'stylesheet')) {\n    goog.asserts.assert(\n        url instanceof goog.html.TrustedResourceUrl,\n        'URL must be TrustedResourceUrl because \"rel\" contains \"stylesheet\"');\n    link.href = goog.html.TrustedResourceUrl.unwrapTrustedURL(url);\n  } else if (url instanceof goog.html.TrustedResourceUrl) {\n    link.href = goog.html.TrustedResourceUrl.unwrapTrustedURL(url);\n  } else if (url instanceof goog.html.SafeUrl) {\n    link.href = goog.html.SafeUrl.unwrapTrustedURL(url);\n  } else {  // string\n    // SafeUrl.sanitize must return legitimate SafeUrl when passed a string.\n    link.href = goog.html.SafeUrl.unwrapTrustedURL(\n        goog.html.SafeUrl.sanitizeAssertUnchanged(url));\n  }\n};\n\n\n/**\n * Safely assigns a URL to an object element's data property.\n *\n * Example usage:\n *   goog.dom.safe.setObjectData(objectEl, url);\n * which is a safe alternative to\n *   objectEl.data = url;\n * The latter can result in loading untrusted code unless setit is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLObjectElement} object The object element whose data property\n *     is to be assigned to.\n * @param {!goog.html.TrustedResourceUrl} url The URL to assign.\n */\ngoog.dom.safe.setObjectData = function(object, url) {\n  goog.dom.asserts.assertIsHTMLObjectElement(object);\n  object.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);\n};\n\n\n/**\n * Safely assigns a URL to a script element's src property.\n *\n * Example usage:\n *   goog.dom.safe.setScriptSrc(scriptEl, url);\n * which is a safe alternative to\n *   scriptEl.src = url;\n * The latter can result in loading untrusted code unless it is ensured that\n * the URL refers to a trustworthy resource.\n *\n * @param {!HTMLScriptElement} script The script element whose src property\n *     is to be assigned to.\n * @param {!goog.html.TrustedResourceUrl} url The URL to assign.\n */\ngoog.dom.safe.setScriptSrc = function(script, url) {\n  goog.dom.asserts.assertIsHTMLScriptElement(script);\n  script.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);\n\n  // If CSP nonces are used, propagate them to dynamically created scripts.\n  // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n  var nonce = goog.getScriptNonce();\n  if (nonce) {\n    script.setAttribute('nonce', nonce);\n  }\n};\n\n\n/**\n * Safely assigns a value to a script element's content.\n *\n * Example usage:\n *   goog.dom.safe.setScriptContent(scriptEl, content);\n * which is a safe alternative to\n *   scriptEl.text = content;\n * The latter can result in executing untrusted code unless it is ensured that\n * the code is loaded from a trustworthy resource.\n *\n * @param {!HTMLScriptElement} script The script element whose content is being\n *     set.\n * @param {!goog.html.SafeScript} content The content to assign.\n */\ngoog.dom.safe.setScriptContent = function(script, content) {\n  goog.dom.asserts.assertIsHTMLScriptElement(script);\n  script.text = goog.html.SafeScript.unwrapTrustedScript(content);\n\n  // If CSP nonces are used, propagate them to dynamically created scripts.\n  // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\n  var nonce = goog.getScriptNonce();\n  if (nonce) {\n    script.setAttribute('nonce', nonce);\n  }\n};\n\n\n/**\n * Safely assigns a URL to a Location object's href property.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to\n * loc's href property.  If url is of type string however, it is first sanitized\n * using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.setLocationHref(document.location, redirectUrl);\n * which is a safe alternative to\n *   document.location.href = redirectUrl;\n * The latter can result in XSS vulnerabilities if redirectUrl is a\n * user-/attacker-controlled value.\n *\n * @param {!Location} loc The Location object whose href property is to be\n *     assigned to.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.setLocationHref = function(loc, url) {\n  goog.dom.asserts.assertIsLocation(loc);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  loc.href = goog.html.SafeUrl.unwrapTrustedURL(safeUrl);\n};\n\n/**\n * Safely assigns the URL of a Location object.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and\n * passed to Location#assign. If url is of type string however, it is\n * first sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.assignLocation(document.location, newUrl);\n * which is a safe alternative to\n *   document.location.assign(newUrl);\n * The latter can result in XSS vulnerabilities if newUrl is a\n * user-/attacker-controlled value.\n *\n * This has the same behaviour as setLocationHref, however some test\n * mock Location.assign instead of a property assignment.\n *\n * @param {!Location} loc The Location object which is to be assigned.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.assignLocation = function(loc, url) {\n  goog.dom.asserts.assertIsLocation(loc);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  loc.assign(goog.html.SafeUrl.unwrapTrustedURL(safeUrl));\n};\n\n\n/**\n * Safely replaces the URL of a Location object.\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and\n * passed to Location#replace. If url is of type string however, it is\n * first sanitized using goog.html.SafeUrl.sanitize.\n *\n * Example usage:\n *   goog.dom.safe.replaceLocation(document.location, newUrl);\n * which is a safe alternative to\n *   document.location.replace(newUrl);\n * The latter can result in XSS vulnerabilities if newUrl is a\n * user-/attacker-controlled value.\n *\n * @param {!Location} loc The Location object which is to be replaced.\n * @param {string|!goog.html.SafeUrl} url The URL to assign.\n * @see goog.html.SafeUrl#sanitize\n */\ngoog.dom.safe.replaceLocation = function(loc, url) {\n  goog.dom.asserts.assertIsLocation(loc);\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  loc.replace(goog.html.SafeUrl.unwrapTrustedURL(safeUrl));\n};\n\n\n/**\n * Safely opens a URL in a new window (via window.open).\n *\n * If url is of type goog.html.SafeUrl, its value is unwrapped and passed in to\n * window.open.  If url is of type string however, it is first sanitized\n * using goog.html.SafeUrl.sanitize.\n *\n * Note that this function does not prevent leakages via the referer that is\n * sent by window.open. It is advised to only use this to open 1st party URLs.\n *\n * Example usage:\n *   goog.dom.safe.openInWindow(url);\n * which is a safe alternative to\n *   window.open(url);\n * The latter can result in XSS vulnerabilities if redirectUrl is a\n * user-/attacker-controlled value.\n *\n * @param {string|!goog.html.SafeUrl} url The URL to open.\n * @param {Window=} opt_openerWin Window of which to call the .open() method.\n *     Defaults to the global window.\n * @param {!goog.string.Const=} opt_name Name of the window to open in. Can be\n *     _top, etc as allowed by window.open().\n * @param {string=} opt_specs Comma-separated list of specifications, same as\n *     in window.open().\n * @param {boolean=} opt_replace Whether to replace the current entry in browser\n *     history, same as in window.open().\n * @return {Window} Window the url was opened in.\n */\ngoog.dom.safe.openInWindow = function(\n    url, opt_openerWin, opt_name, opt_specs, opt_replace) {\n  /** @type {!goog.html.SafeUrl} */\n  var safeUrl;\n  if (url instanceof goog.html.SafeUrl) {\n    safeUrl = url;\n  } else {\n    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);\n  }\n  var win = opt_openerWin || goog.global;\n  return win.open(\n      goog.html.SafeUrl.unwrapTrustedURL(safeUrl),\n      // If opt_name is undefined, simply passing that in to open() causes IE to\n      // reuse the current window instead of opening a new one. Thus we pass ''\n      // in instead, which according to spec opens a new window. See\n      // https://html.spec.whatwg.org/multipage/browsers.html#dom-open .\n      opt_name ? goog.string.Const.unwrap(opt_name) : '', opt_specs,\n      opt_replace);\n};\n\n\n/**\n * Parses the HTML as 'text/html'.\n * @param {!DOMParser} parser\n * @param {!goog.html.SafeHtml} html The HTML to be parsed.\n * @return {?Document}\n */\ngoog.dom.safe.parseFromStringHtml = function(parser, html) {\n  return goog.dom.safe.parseFromString(parser, html, 'text/html');\n};\n\n\n/**\n * Parses the string.\n * @param {!DOMParser} parser\n * @param {!goog.html.SafeHtml} content Note: We don't have a special type for\n *     XML od SVG supported by this function so we use SafeHtml.\n * @param {string} type\n * @return {?Document}\n */\ngoog.dom.safe.parseFromString = function(parser, content, type) {\n  return parser.parseFromString(\n      goog.html.SafeHtml.unwrapTrustedHTML(content), type);\n};\n\n\n/**\n * Safely creates an HTMLImageElement from a Blob.\n *\n * Example usage:\n *     goog.dom.safe.createImageFromBlob(blob);\n * which is a safe alternative to\n *     image.src = createObjectUrl(blob)\n * The latter can result in executing malicious same-origin scripts from a bad\n * Blob.\n * @param {!Blob} blob The blob to create the image from.\n * @return {!HTMLImageElement} The image element created from the blob.\n * @throws {!Error} If called with a Blob with a MIME type other than image/.*.\n */\ngoog.dom.safe.createImageFromBlob = function(blob) {\n  // Any image/* MIME type is accepted as safe.\n  if (!/^image\\/.*/g.test(blob.type)) {\n    throw new Error(\n        'goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.');\n  }\n  var objectUrl = goog.global.URL.createObjectURL(blob);\n  var image = new goog.global.Image();\n  image.onload = function() {\n    goog.global.URL.revokeObjectURL(objectUrl);\n  };\n  goog.dom.safe.setImageSrc(\n      image,\n      goog.html.uncheckedconversions\n          .safeUrlFromStringKnownToSatisfyTypeContract(\n              goog.string.Const.from('Image blob URL.'), objectUrl));\n  return image;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Closure user agent detection (Browser).\n * @see <a href=\"http://www.useragentstring.com/\">User agent strings</a>\n * For more information on rendering engine, platform, or device see the other\n * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,\n * goog.labs.userAgent.device respectively.)\n *\n * @author martone@google.com (Andy Martone)\n */\n\ngoog.provide('goog.labs.userAgent.browser');\n\ngoog.require('goog.array');\ngoog.require('goog.labs.userAgent.util');\ngoog.require('goog.object');\ngoog.require('goog.string.internal');\n\n\n// TODO(nnaze): Refactor to remove excessive exclusion logic in matching\n// functions.\n\n\n/**\n * @return {boolean} Whether the user's browser is Opera.  Note: Chromium\n *     based Opera (Opera 15+) is detected as Chrome to avoid unnecessary\n *     special casing.\n * @private\n */\ngoog.labs.userAgent.browser.matchOpera_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Opera');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is IE.\n * @private\n */\ngoog.labs.userAgent.browser.matchIE_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Trident') ||\n      goog.labs.userAgent.util.matchUserAgent('MSIE');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Edge. This refers to EdgeHTML\n * based Edge.\n * @private\n */\ngoog.labs.userAgent.browser.matchEdgeHtml_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Edge');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Chromium based Edge.\n * @private\n */\ngoog.labs.userAgent.browser.matchEdgeChromium_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Edg/');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Chromium based Opera.\n * @private\n */\ngoog.labs.userAgent.browser.matchOperaChromium_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('OPR');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Firefox.\n * @private\n */\ngoog.labs.userAgent.browser.matchFirefox_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Firefox') ||\n      goog.labs.userAgent.util.matchUserAgent('FxiOS');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Safari.\n * @private\n */\ngoog.labs.userAgent.browser.matchSafari_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Safari') &&\n      !(goog.labs.userAgent.browser.matchChrome_() ||\n        goog.labs.userAgent.browser.matchCoast_() ||\n        goog.labs.userAgent.browser.matchOpera_() ||\n        goog.labs.userAgent.browser.matchEdgeHtml_() ||\n        goog.labs.userAgent.browser.matchEdgeChromium_() ||\n        goog.labs.userAgent.browser.matchOperaChromium_() ||\n        goog.labs.userAgent.browser.matchFirefox_() ||\n        goog.labs.userAgent.browser.isSilk() ||\n        goog.labs.userAgent.util.matchUserAgent('Android'));\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based\n *     iOS browser).\n * @private\n */\ngoog.labs.userAgent.browser.matchCoast_ = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Coast');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is iOS Webview.\n * @private\n */\ngoog.labs.userAgent.browser.matchIosWebview_ = function() {\n  // iOS Webview does not show up as Chrome or Safari. Also check for Opera's\n  // WebKit-based iOS browser, Coast.\n  return (goog.labs.userAgent.util.matchUserAgent('iPad') ||\n          goog.labs.userAgent.util.matchUserAgent('iPhone')) &&\n      !goog.labs.userAgent.browser.matchSafari_() &&\n      !goog.labs.userAgent.browser.matchChrome_() &&\n      !goog.labs.userAgent.browser.matchCoast_() &&\n      !goog.labs.userAgent.browser.matchFirefox_() &&\n      goog.labs.userAgent.util.matchUserAgent('AppleWebKit');\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is any Chromium browser. This\n * returns true for Chrome, Opera 15+, and Edge Chromium.\n * @private\n */\ngoog.labs.userAgent.browser.matchChrome_ = function() {\n  return (goog.labs.userAgent.util.matchUserAgent('Chrome') ||\n          goog.labs.userAgent.util.matchUserAgent('CriOS')) &&\n      !goog.labs.userAgent.browser.matchEdgeHtml_();\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is the Android browser.\n * @private\n */\ngoog.labs.userAgent.browser.matchAndroidBrowser_ = function() {\n  // Android can appear in the user agent string for Chrome on Android.\n  // This is not the Android standalone browser if it does.\n  return goog.labs.userAgent.util.matchUserAgent('Android') &&\n      !(goog.labs.userAgent.browser.isChrome() ||\n        goog.labs.userAgent.browser.isFirefox() ||\n        goog.labs.userAgent.browser.isOpera() ||\n        goog.labs.userAgent.browser.isSilk());\n};\n\n\n/**\n * @return {boolean} Whether the user's browser is Opera.\n */\ngoog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;\n\n\n/**\n * @return {boolean} Whether the user's browser is IE.\n */\ngoog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;\n\n\n/**\n * @return {boolean} Whether the user's browser is EdgeHTML based Edge.\n */\ngoog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_;\n\n\n/**\n * @return {boolean} Whether the user's browser is Chromium based Edge.\n */\ngoog.labs.userAgent.browser.isEdgeChromium =\n    goog.labs.userAgent.browser.matchEdgeChromium_;\n\n/**\n * @return {boolean} Whether the user's browser is Chromium based Opera.\n */\ngoog.labs.userAgent.browser.isOperaChromium =\n    goog.labs.userAgent.browser.matchOperaChromium_;\n\n/**\n * @return {boolean} Whether the user's browser is Firefox.\n */\ngoog.labs.userAgent.browser.isFirefox =\n    goog.labs.userAgent.browser.matchFirefox_;\n\n\n/**\n * @return {boolean} Whether the user's browser is Safari.\n */\ngoog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;\n\n\n/**\n * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based\n *     iOS browser).\n */\ngoog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;\n\n\n/**\n * @return {boolean} Whether the user's browser is iOS Webview.\n */\ngoog.labs.userAgent.browser.isIosWebview =\n    goog.labs.userAgent.browser.matchIosWebview_;\n\n\n/**\n * @return {boolean} Whether the user's browser is any Chromium based browser (\n * Chrome, Blink-based Opera (15+) and Edge Chromium).\n */\ngoog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;\n\n\n/**\n * @return {boolean} Whether the user's browser is the Android browser.\n */\ngoog.labs.userAgent.browser.isAndroidBrowser =\n    goog.labs.userAgent.browser.matchAndroidBrowser_;\n\n\n/**\n * For more information, see:\n * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html\n * @return {boolean} Whether the user's browser is Silk.\n */\ngoog.labs.userAgent.browser.isSilk = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Silk');\n};\n\n\n/**\n * @return {string} The browser version or empty string if version cannot be\n *     determined. Note that for Internet Explorer, this returns the version of\n *     the browser, not the version of the rendering engine. (IE 8 in\n *     compatibility mode will return 8.0 rather than 7.0. To determine the\n *     rendering engine version, look at document.documentMode instead. See\n *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more\n *     details.)\n */\ngoog.labs.userAgent.browser.getVersion = function() {\n  var userAgentString = goog.labs.userAgent.util.getUserAgent();\n  // Special case IE since IE's version is inside the parenthesis and\n  // without the '/'.\n  if (goog.labs.userAgent.browser.isIE()) {\n    return goog.labs.userAgent.browser.getIEVersion_(userAgentString);\n  }\n\n  var versionTuples =\n      goog.labs.userAgent.util.extractVersionTuples(userAgentString);\n\n  // Construct a map for easy lookup.\n  var versionMap = {};\n  goog.array.forEach(versionTuples, function(tuple) {\n    // Note that the tuple is of length three, but we only care about the\n    // first two.\n    var key = tuple[0];\n    var value = tuple[1];\n    versionMap[key] = value;\n  });\n\n  var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);\n\n  // Gives the value with the first key it finds, otherwise empty string.\n  function lookUpValueWithKeys(keys) {\n    var key = goog.array.find(keys, versionMapHasKey);\n    return versionMap[key] || '';\n  }\n\n  // Check Opera before Chrome since Opera 15+ has \"Chrome\" in the string.\n  // See\n  // http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond\n  if (goog.labs.userAgent.browser.isOpera()) {\n    // Opera 10 has Version/10.0 but Opera/9.8, so look for \"Version\" first.\n    // Opera uses 'OPR' for more recent UAs.\n    return lookUpValueWithKeys(['Version', 'Opera']);\n  }\n\n  // Check Edge before Chrome since it has Chrome in the string.\n  if (goog.labs.userAgent.browser.isEdge()) {\n    return lookUpValueWithKeys(['Edge']);\n  }\n\n  // Check Chromium Edge before Chrome since it has Chrome in the string.\n  if (goog.labs.userAgent.browser.isEdgeChromium()) {\n    return lookUpValueWithKeys(['Edg']);\n  }\n\n  if (goog.labs.userAgent.browser.isChrome()) {\n    return lookUpValueWithKeys(['Chrome', 'CriOS']);\n  }\n\n  // Usually products browser versions are in the third tuple after \"Mozilla\"\n  // and the engine.\n  var tuple = versionTuples[2];\n  return tuple && tuple[1] || '';\n};\n\n\n/**\n * @param {string|number} version The version to check.\n * @return {boolean} Whether the browser version is higher or the same as the\n *     given version.\n */\ngoog.labs.userAgent.browser.isVersionOrHigher = function(version) {\n  return goog.string.internal.compareVersions(\n             goog.labs.userAgent.browser.getVersion(), version) >= 0;\n};\n\n\n/**\n * Determines IE version. More information:\n * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString\n * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx\n * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx\n * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx\n *\n * @param {string} userAgent the User-Agent.\n * @return {string}\n * @private\n */\ngoog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {\n  // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade\n  // bug. Example UA:\n  // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)\n  // like Gecko.\n  // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.\n  var rv = /rv: *([\\d\\.]*)/.exec(userAgent);\n  if (rv && rv[1]) {\n    return rv[1];\n  }\n\n  var version = '';\n  var msie = /MSIE +([\\d\\.]+)/.exec(userAgent);\n  if (msie && msie[1]) {\n    // IE in compatibility mode usually identifies itself as MSIE 7.0; in this\n    // case, use the Trident version to determine the version of IE. For more\n    // details, see the links above.\n    var tridentVersion = /Trident\\/(\\d.\\d)/.exec(userAgent);\n    if (msie[1] == '7.0') {\n      if (tridentVersion && tridentVersion[1]) {\n        switch (tridentVersion[1]) {\n          case '4.0':\n            version = '8.0';\n            break;\n          case '5.0':\n            version = '9.0';\n            break;\n          case '6.0':\n            version = '10.0';\n            break;\n          case '7.0':\n            version = '11.0';\n            break;\n        }\n      } else {\n        version = '7.0';\n      }\n    } else {\n      version = msie[1];\n    }\n  }\n  return version;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.Promise');\n\ngoog.require('goog.Thenable');\ngoog.require('goog.asserts');\ngoog.require('goog.async.FreeList');\ngoog.require('goog.async.run');\ngoog.require('goog.async.throwException');\ngoog.require('goog.debug.Error');\ngoog.require('goog.promise.Resolver');\n\n\n\n/**\n * NOTE: This class was created in anticipation of the built-in Promise type\n * being standardized and implemented across browsers. Now that Promise is\n * available in modern browsers, and is automatically polyfilled by the Closure\n * Compiler, by default, most new code should use native `Promise`\n * instead of `goog.Promise`. However, `goog.Promise` has the\n * concept of cancellation which native Promises do not yet have. So code\n * needing cancellation may still want to use `goog.Promise`.\n *\n * Promises provide a result that may be resolved asynchronously. A Promise may\n * be resolved by being fulfilled with a fulfillment value, rejected with a\n * rejection reason, or blocked by another Promise. A Promise is said to be\n * settled if it is either fulfilled or rejected. Once settled, the Promise\n * result is immutable.\n *\n * Promises may represent results of any type, including undefined. Rejection\n * reasons are typically Errors, but may also be of any type. Closure Promises\n * allow for optional type annotations that enforce that fulfillment values are\n * of the appropriate types at compile time.\n *\n * The result of a Promise is accessible by calling `then` and registering\n * `onFulfilled` and `onRejected` callbacks. Once the Promise\n * is settled, the relevant callbacks are invoked with the fulfillment value or\n * rejection reason as argument. Callbacks are always invoked in the order they\n * were registered, even when additional `then` calls are made from inside\n * another callback. A callback is always run asynchronously sometime after the\n * scope containing the registering `then` invocation has returned.\n *\n * If a Promise is resolved with another Promise, the first Promise will block\n * until the second is settled, and then assumes the same result as the second\n * Promise. This allows Promises to depend on the results of other Promises,\n * linking together multiple asynchronous operations.\n *\n * This implementation is compatible with the Promises/A+ specification and\n * passes that specification's conformance test suite. A Closure Promise may be\n * resolved with a Promise instance (or sufficiently compatible Promise-like\n * object) created by other Promise implementations. From the specification,\n * Promise-like objects are known as \"Thenables\".\n *\n * @see http://promisesaplus.com/\n *\n * @param {function(\n *             this:RESOLVER_CONTEXT,\n *             function((TYPE|IThenable<TYPE>|Thenable)=),\n *             function(*=)): void} resolver\n *     Initialization function that is invoked immediately with `resolve`\n *     and `reject` functions as arguments. The Promise is resolved or\n *     rejected with the first argument passed to either function.\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\n *     resolver function. If unspecified, the resolver function will be executed\n *     in the default scope.\n * @constructor\n * @struct\n * @final\n * @implements {goog.Thenable<TYPE>}\n * @template TYPE,RESOLVER_CONTEXT\n */\ngoog.Promise = function(resolver, opt_context) {\n  /**\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\n   * BLOCKED.\n   * @private {goog.Promise.State_}\n   */\n  this.state_ = goog.Promise.State_.PENDING;\n\n  /**\n   * The settled result of the Promise. Immutable once set with either a\n   * fulfillment value or rejection reason.\n   * @private {*}\n   */\n  this.result_ = undefined;\n\n  /**\n   * For Promises created by calling `then()`, the originating parent.\n   * @private {?goog.Promise}\n   */\n  this.parent_ = null;\n\n  /**\n   * The linked list of `onFulfilled` and `onRejected` callbacks\n   * added to this Promise by calls to `then()`.\n   * @private {?goog.Promise.CallbackEntry_}\n   */\n  this.callbackEntries_ = null;\n\n  /**\n   * The tail of the linked list of `onFulfilled` and `onRejected`\n   * callbacks added to this Promise by calls to `then()`.\n   * @private {?goog.Promise.CallbackEntry_}\n   */\n  this.callbackEntriesTail_ = null;\n\n  /**\n   * Whether the Promise is in the queue of Promises to execute.\n   * @private {boolean}\n   */\n  this.executing_ = false;\n\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    /**\n     * A timeout ID used when the `UNHANDLED_REJECTION_DELAY` is greater\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\n     * cleared only if an `onRejected` callback is invoked for the\n     * Promise (or one of its descendants) before the delay is exceeded.\n     *\n     * If the rejection is not handled before the timeout completes, the\n     * rejection reason is passed to the unhandled rejection handler.\n     * @private {number}\n     */\n    this.unhandledRejectionId_ = 0;\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    /**\n     * When the `UNHANDLED_REJECTION_DELAY` is set to 0 milliseconds, a\n     * boolean that is set if the Promise is rejected, and reset to false if an\n     * `onRejected` callback is invoked for the Promise (or one of its\n     * descendants). If the rejection is not handled before the next timestep,\n     * the rejection reason is passed to the unhandled rejection handler.\n     * @private {boolean}\n     */\n    this.hadUnhandledRejection_ = false;\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    /**\n     * A list of stack trace frames pointing to the locations where this Promise\n     * was created or had callbacks added to it. Saved to add additional context\n     * to stack traces when an exception is thrown.\n     * @private {!Array<string>}\n     */\n    this.stack_ = [];\n    this.addStackTrace_(new Error('created'));\n\n    /**\n     * Index of the most recently executed stack frame entry.\n     * @private {number}\n     */\n    this.currentStep_ = 0;\n  }\n\n  // As an optimization, we can skip this if resolver is goog.nullFunction.\n  // This value is passed internally when creating a promise which will be\n  // resolved through a more optimized path.\n  if (resolver != goog.nullFunction) {\n    try {\n      var self = this;\n      resolver.call(\n          opt_context,\n          function(value) {\n            self.resolve_(goog.Promise.State_.FULFILLED, value);\n          },\n          function(reason) {\n            if (goog.DEBUG &&\n                !(reason instanceof goog.Promise.CancellationError)) {\n              try {\n                // Promise was rejected. Step up one call frame to see why.\n                if (reason instanceof Error) {\n                  throw reason;\n                } else {\n                  throw new Error('Promise rejected.');\n                }\n              } catch (e) {\n                // Only thrown so browser dev tools can catch rejections of\n                // promises when the option to break on caught exceptions is\n                // activated.\n              }\n            }\n            self.resolve_(goog.Promise.State_.REJECTED, reason);\n          });\n    } catch (e) {\n      this.resolve_(goog.Promise.State_.REJECTED, e);\n    }\n  }\n};\n\n\n/**\n * @define {boolean} Whether traces of `then` calls should be included in\n * exceptions thrown\n */\ngoog.Promise.LONG_STACK_TRACES =\n    goog.define('goog.Promise.LONG_STACK_TRACES', false);\n\n\n/**\n * @define {number} The delay in milliseconds before a rejected Promise's reason\n * is passed to the rejection handler. By default, the rejection handler\n * rethrows the rejection reason so that it appears in the developer console or\n * `window.onerror` handler.\n *\n * Rejections are rethrown as quickly as possible by default. A negative value\n * disables rejection handling entirely.\n */\ngoog.Promise.UNHANDLED_REJECTION_DELAY =\n    goog.define('goog.Promise.UNHANDLED_REJECTION_DELAY', 0);\n\n\n/**\n * The possible internal states for a Promise. These states are not directly\n * observable to external callers.\n * @enum {number}\n * @private\n */\ngoog.Promise.State_ = {\n  /** The Promise is waiting for resolution. */\n  PENDING: 0,\n\n  /** The Promise is blocked waiting for the result of another Thenable. */\n  BLOCKED: 1,\n\n  /** The Promise has been resolved with a fulfillment value. */\n  FULFILLED: 2,\n\n  /** The Promise has been resolved with a rejection reason. */\n  REJECTED: 3\n};\n\n\n\n/**\n * Entries in the callback chain. Each call to `then`,\n * `thenCatch`, or `thenAlways` creates an entry containing the\n * functions that may be invoked once the Promise is settled.\n *\n * @private @final @struct @constructor\n */\ngoog.Promise.CallbackEntry_ = function() {\n  /** @type {?goog.Promise} */\n  this.child = null;\n  /** @type {?Function} */\n  this.onFulfilled = null;\n  /** @type {?Function} */\n  this.onRejected = null;\n  /** @type {?} */\n  this.context = null;\n  /** @type {?goog.Promise.CallbackEntry_} */\n  this.next = null;\n\n  /**\n   * A boolean value to indicate this is a \"thenAlways\" callback entry.\n   * Unlike a normal \"then/thenVoid\" a \"thenAlways doesn't participate\n   * in \"cancel\" considerations but is simply an observer and requires\n   * special handling.\n   * @type {boolean}\n   */\n  this.always = false;\n};\n\n\n/** clear the object prior to reuse */\ngoog.Promise.CallbackEntry_.prototype.reset = function() {\n  this.child = null;\n  this.onFulfilled = null;\n  this.onRejected = null;\n  this.context = null;\n  this.always = false;\n};\n\n\n/**\n * @define {number} The number of currently unused objects to keep around for\n *    reuse.\n */\ngoog.Promise.DEFAULT_MAX_UNUSED =\n    goog.define('goog.Promise.DEFAULT_MAX_UNUSED', 100);\n\n\n/** @const @private {goog.async.FreeList<!goog.Promise.CallbackEntry_>} */\ngoog.Promise.freelist_ = new goog.async.FreeList(\n    function() { return new goog.Promise.CallbackEntry_(); },\n    function(item) { item.reset(); }, goog.Promise.DEFAULT_MAX_UNUSED);\n\n\n/**\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n * @param {?} context\n * @return {!goog.Promise.CallbackEntry_}\n * @private\n */\ngoog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {\n  var entry = goog.Promise.freelist_.get();\n  entry.onFulfilled = onFulfilled;\n  entry.onRejected = onRejected;\n  entry.context = context;\n  return entry;\n};\n\n\n/**\n * @param {!goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.returnEntry_ = function(entry) {\n  goog.Promise.freelist_.put(entry);\n};\n\n\n// NOTE: this is the same template expression as is used for\n// goog.IThenable.prototype.then\n\n\n/**\n * @param {VALUE=} opt_value\n * @return {RESULT} A new Promise that is immediately resolved\n *     with the given value. If the input value is already a goog.Promise, it\n *     will be returned immediately without creating a new instance.\n * @template VALUE\n * @template RESULT := type('goog.Promise',\n *     cond(isUnknown(VALUE), unknown(),\n *       mapunion(VALUE, (V) =>\n *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),\n *           templateTypeOf(V, 0),\n *           cond(sub(V, 'Thenable'),\n *              unknown(),\n *              V)))))\n * =:\n */\ngoog.Promise.resolve = function(opt_value) {\n  if (opt_value instanceof goog.Promise) {\n    // Avoid creating a new object if we already have a promise object\n    // of the correct type.\n    return opt_value;\n  }\n\n  // Passing goog.nullFunction will cause the constructor to take an optimized\n  // path that skips calling the resolver function.\n  var promise = new goog.Promise(goog.nullFunction);\n  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);\n  return promise;\n};\n\n\n/**\n * @param {*=} opt_reason\n * @return {!goog.Promise} A new Promise that is immediately rejected with the\n *     given reason.\n */\ngoog.Promise.reject = function(opt_reason) {\n  return new goog.Promise(function(resolve, reject) { reject(opt_reason); });\n};\n\n\n/**\n * This is identical to\n * {@code goog.Promise.resolve(value).then(onFulfilled, onRejected)}, but it\n * avoids creating an unnecessary wrapper Promise when `value` is already\n * thenable.\n *\n * @param {?(goog.Thenable<TYPE>|Thenable|TYPE)} value\n * @param {function(TYPE): ?} onFulfilled\n * @param {function(*): *} onRejected\n * @template TYPE\n * @private\n */\ngoog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {\n  var isThenable =\n      goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);\n  if (!isThenable) {\n    goog.async.run(goog.partial(onFulfilled, value));\n  }\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<TYPE>} A Promise that receives the result of the\n *     first Promise (or Promise-like) input to settle immediately after it\n *     settles.\n * @template TYPE\n */\ngoog.Promise.race = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    if (!promises.length) {\n      resolve(undefined);\n    }\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, resolve, reject);\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<!Array<TYPE>>} A Promise that receives a list of\n *     every fulfilled value once every input Promise (or Promise-like) is\n *     successfully fulfilled, or is rejected with the first rejection reason\n *     immediately after it is rejected.\n * @template TYPE\n */\ngoog.Promise.all = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toFulfill = promises.length;\n    var values = [];\n\n    if (!toFulfill) {\n      resolve(values);\n      return;\n    }\n\n    var onFulfill = function(index, value) {\n      toFulfill--;\n      values[index] = value;\n      if (toFulfill == 0) {\n        resolve(values);\n      }\n    };\n\n    var onReject = function(reason) { reject(reason); };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<!Array<{\n *     fulfilled: boolean,\n *     value: (TYPE|undefined),\n *     reason: (*|undefined)}>>} A Promise that resolves with a list of\n *         result objects once all input Promises (or Promise-like) have\n *         settled. Each result object contains a 'fulfilled' boolean indicating\n *         whether an input Promise was fulfilled or rejected. For fulfilled\n *         Promises, the resulting value is stored in the 'value' field. For\n *         rejected Promises, the rejection reason is stored in the 'reason'\n *         field.\n * @template TYPE\n */\ngoog.Promise.allSettled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toSettle = promises.length;\n    var results = [];\n\n    if (!toSettle) {\n      resolve(results);\n      return;\n    }\n\n    var onSettled = function(index, fulfilled, result) {\n      toSettle--;\n      results[index] = fulfilled ? {fulfilled: true, value: result} :\n                                   {fulfilled: false, reason: result};\n      if (toSettle == 0) {\n        resolve(results);\n      }\n    };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(\n          promise, goog.partial(onSettled, i, true /* fulfilled */),\n          goog.partial(onSettled, i, false /* fulfilled */));\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<TYPE>} A Promise that receives the value of the first\n *     input to be fulfilled, or is rejected with a list of every rejection\n *     reason if all inputs are rejected.\n * @template TYPE\n */\ngoog.Promise.firstFulfilled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toReject = promises.length;\n    var reasons = [];\n\n    if (!toReject) {\n      resolve(undefined);\n      return;\n    }\n\n    var onFulfill = function(value) { resolve(value); };\n\n    var onReject = function(index, reason) {\n      toReject--;\n      reasons[index] = reason;\n      if (toReject == 0) {\n        reject(reasons);\n      }\n    };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));\n    }\n  });\n};\n\n\n/**\n * @return {!goog.promise.Resolver<TYPE>} Resolver wrapping the promise and its\n *     resolve / reject functions. Resolving or rejecting the resolver\n *     resolves or rejects the promise.\n * @template TYPE\n */\ngoog.Promise.withResolver = function() {\n  var resolve, reject;\n  var promise = new goog.Promise(function(rs, rj) {\n    resolve = rs;\n    reject = rj;\n  });\n  return new goog.Promise.Resolver_(promise, resolve, reject);\n};\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise, returning a\n * new child Promise.\n *\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\n * with the fulfillment value as argument, and the child Promise will be\n * fulfilled with the return value of the callback. If the callback throws an\n * exception, the child Promise will be rejected with the thrown value instead.\n *\n * If the Promise is rejected, the `onRejected` callback will be invoked\n * with the rejection reason as argument, and the child Promise will be resolved\n * with the return value or rejected with the thrown value of the callback.\n *\n * @override\n */\ngoog.Promise.prototype.then = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {\n\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(\n        opt_onRejected,\n        'opt_onRejected should be a function. Did you pass opt_context ' +\n            'as the second argument instead of the third?');\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('then'));\n  }\n\n  return this.addChildPromise_(\n      goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\n      goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);\n};\ngoog.Thenable.addImplementation(goog.Promise);\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise without\n * returning a child Promise (unlike \"then\").\n *\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\n * with the fulfillment value as argument.\n *\n * If the Promise is rejected, the `onRejected` callback will be invoked\n * with the rejection reason as argument.\n *\n * @param {?(function(this:THIS, TYPE):?)=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fulfilled.\n * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will\n *     be invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n * @package\n * @template THIS\n */\ngoog.Promise.prototype.thenVoid = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {\n\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(\n        opt_onRejected,\n        'opt_onRejected should be a function. Did you pass opt_context ' +\n            'as the second argument instead of the third?');\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('then'));\n  }\n\n  // Note: no default rejection handler is provided here as we need to\n  // distinguish unhandled rejections.\n  this.addCallbackEntry_(\n      goog.Promise.getCallbackEntry_(\n          opt_onFulfilled || goog.nullFunction, opt_onRejected || null,\n          opt_context));\n};\n\n\n/**\n * Adds a callback that will be invoked when the Promise is settled (fulfilled\n * or rejected). The callback receives no argument, and no new child Promise is\n * created. This is useful for ensuring that cleanup takes place after certain\n * asynchronous operations. Callbacks added with `thenAlways` will be\n * executed in the same order with other calls to `then`,\n * `thenAlways`, or `thenCatch`.\n *\n * Since it does not produce a new child Promise, cancellation propagation is\n * not prevented by adding callbacks with `thenAlways`. A Promise that has\n * a cleanup handler added with `thenAlways` will be canceled if all of\n * its children created by `then` (or `thenCatch`) are canceled.\n * Additionally, since any rejections are not passed to the callback, it does\n * not stop the unhandled rejection handler from running.\n *\n * @param {function(this:THIS): void} onSettled A function that will be invoked\n *     when the Promise is settled (fulfilled or rejected).\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!goog.Promise<TYPE>} This Promise, for chaining additional calls.\n * @template THIS\n */\ngoog.Promise.prototype.thenAlways = function(onSettled, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('thenAlways'));\n  }\n\n  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);\n  entry.always = true;\n  this.addCallbackEntry_(entry);\n  return this;\n};\n\n\n/**\n * Adds a callback that will be invoked only if the Promise is rejected. This\n * is equivalent to `then(null, onRejected)`.\n *\n * @param {function(this:THIS, *): *} onRejected A function that will be\n *     invoked with the rejection reason if this Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!goog.Promise} A new Promise that will resolve either to the\n *     value of this promise, or if this promise is rejected, the result of\n *     `onRejected`. The returned Promise will reject if `onRejected` throws.\n * @template THIS\n */\ngoog.Promise.prototype.thenCatch = function(onRejected, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('thenCatch'));\n  }\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\n\n\n/**\n * Cancels the Promise if it is still pending by rejecting it with a cancel\n * Error. No action is performed if the Promise is already resolved.\n *\n * All child Promises of the canceled Promise will be rejected with the same\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\n * is the only child of a pending Promise, the parent Promise will also be\n * canceled. Cancellation may propagate upward through multiple generations.\n *\n * @param {string=} opt_message An optional debugging message for describing the\n *     cancellation reason.\n */\ngoog.Promise.prototype.cancel = function(opt_message) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    goog.async.run(function() {\n      var err = new goog.Promise.CancellationError(opt_message);\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\n\n\n/**\n * Cancels this Promise with the given error.\n *\n * @param {!Error} err The cancellation error.\n * @private\n */\ngoog.Promise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    if (this.parent_) {\n      // Cancel the Promise and remove it from the parent's child list.\n      this.parent_.cancelChild_(this, err);\n      this.parent_ = null;\n    } else {\n      this.resolve_(goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Cancels a child Promise from the list of callback entries. If the Promise has\n * not already been resolved, reject it with a cancel error. If there are no\n * other children in the list of callback entries, propagate the cancellation\n * by canceling this Promise as well.\n *\n * @param {!goog.Promise} childPromise The Promise to cancel.\n * @param {!Error} err The cancel error to use for rejecting the Promise.\n * @private\n */\ngoog.Promise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childEntry = null;\n  var beforeChildEntry = null;\n\n  // Find the callback entry for the childPromise, and count whether there are\n  // additional child Promises.\n  for (var entry = this.callbackEntries_; entry; entry = entry.next) {\n    if (!entry.always) {\n      childCount++;\n      if (entry.child == childPromise) {\n        childEntry = entry;\n      }\n      if (childEntry && childCount > 1) {\n        break;\n      }\n    }\n    if (!childEntry) {\n      beforeChildEntry = entry;\n    }\n  }\n\n  // Can a child entry be missing?\n\n  // If the child Promise was the only child, cancel this Promise as well.\n  // Otherwise, reject only the child Promise with the cancel error.\n  if (childEntry) {\n    if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) {\n      this.cancelInternal_(err);\n    } else {\n      if (beforeChildEntry) {\n        this.removeEntryAfter_(beforeChildEntry);\n      } else {\n        this.popEntry_();\n      }\n\n      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Adds a callback entry to the current Promise, and schedules callback\n * execution if the Promise has already been settled.\n *\n * @param {goog.Promise.CallbackEntry_} callbackEntry Record containing\n *     `onFulfilled` and `onRejected` callbacks to execute after\n *     the Promise is settled.\n * @private\n */\ngoog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if (!this.hasEntry_() && (this.state_ == goog.Promise.State_.FULFILLED ||\n                            this.state_ == goog.Promise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  this.queueEntry_(callbackEntry);\n};\n\n\n/**\n * Creates a child Promise and adds it to the callback entry list. The result of\n * the child Promise is determined by the state of the parent Promise and the\n * result of the `onFulfilled` or `onRejected` callbacks as\n * specified in the Promise resolution procedure.\n *\n * @see http://promisesaplus.com/#the__method\n *\n * @param {?function(this:THIS, TYPE):\n *          (RESULT|goog.Promise<RESULT>|Thenable)} onFulfilled A callback that\n *     will be invoked if the Promise is fulfilled, or null.\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\n *     invoked if the Promise is rejected, or null.\n * @param {THIS=} opt_context An optional execution context for the callbacks.\n *     in the default calling context.\n * @return {!goog.Promise} The child Promise.\n * @template RESULT,THIS\n * @private\n */\ngoog.Promise.prototype.addChildPromise_ = function(\n    onFulfilled, onRejected, opt_context) {\n\n  /** @type {goog.Promise.CallbackEntry_} */\n  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);\n\n  callbackEntry.child = new goog.Promise(function(resolve, reject) {\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n\n    // Invoke onRejected, or reject with the parent's reason if absent.\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (!goog.isDef(result) &&\n            reason instanceof goog.Promise.CancellationError) {\n          // Propagate cancellation to children if no other result is returned.\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(callbackEntry);\n  return callbackEntry.child;\n};\n\n\n/**\n * Unblocks the Promise and fulfills it with the given value.\n *\n * @param {TYPE} value\n * @private\n */\ngoog.Promise.prototype.unblockAndFulfill_ = function(value) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.FULFILLED, value);\n};\n\n\n/**\n * Unblocks the Promise and rejects it with the given rejection reason.\n *\n * @param {*} reason\n * @private\n */\ngoog.Promise.prototype.unblockAndReject_ = function(reason) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.REJECTED, reason);\n};\n\n\n/**\n * Attempts to resolve a Promise with a given resolution state and value. This\n * is a no-op if the given Promise has already been resolved.\n *\n * If the given result is a Thenable (such as another Promise), the Promise will\n * be settled with the same state and result as the Thenable once it is itself\n * settled.\n *\n * If the given result is not a Thenable, the Promise will be settled (fulfilled\n * or rejected) with that result based on the given state.\n *\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\n *\n * @param {goog.Promise.State_} state\n * @param {*} x The result to apply to the Promise.\n * @private\n */\ngoog.Promise.prototype.resolve_ = function(state, x) {\n  if (this.state_ != goog.Promise.State_.PENDING) {\n    return;\n  }\n\n  if (this === x) {\n    state = goog.Promise.State_.REJECTED;\n    x = new TypeError('Promise cannot resolve to itself');\n  }\n\n  this.state_ = goog.Promise.State_.BLOCKED;\n  var isThenable = goog.Promise.maybeThen_(\n      x, this.unblockAndFulfill_, this.unblockAndReject_, this);\n  if (isThenable) {\n    return;\n  }\n\n  this.result_ = x;\n  this.state_ = state;\n  // Since we can no longer be canceled, remove link to parent, so that the\n  // child promise does not keep the parent promise alive.\n  this.parent_ = null;\n  this.scheduleCallbacks_();\n\n  if (state == goog.Promise.State_.REJECTED &&\n      !(x instanceof goog.Promise.CancellationError)) {\n    goog.Promise.addUnhandledRejection_(this, x);\n  }\n};\n\n\n/**\n * Invokes the \"then\" method of an input value if that value is a Thenable. This\n * is a no-op if the value is not thenable.\n *\n * @param {?} value A potentially thenable value.\n * @param {!Function} onFulfilled\n * @param {!Function} onRejected\n * @param {?} context\n * @return {boolean} Whether the input value was thenable.\n * @private\n */\ngoog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {\n  if (value instanceof goog.Promise) {\n    value.thenVoid(onFulfilled, onRejected, context);\n    return true;\n  } else if (goog.Thenable.isImplementedBy(value)) {\n    value = /** @type {!goog.Thenable} */ (value);\n    value.then(onFulfilled, onRejected, context);\n    return true;\n  } else if (goog.isObject(value)) {\n    try {\n      var then = value['then'];\n      if (goog.isFunction(then)) {\n        goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);\n        return true;\n      }\n    } catch (e) {\n      onRejected.call(context, e);\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Attempts to call the `then` method on an object in the hopes that it is\n * a Promise-compatible instance. This allows interoperation between different\n * Promise implementations, however a non-compliant object may cause a Promise\n * to hang indefinitely. If the `then` method throws an exception, the\n * dependent Promise will be rejected with the thrown value.\n *\n * @see http://promisesaplus.com/#point-70\n *\n * @param {Thenable} thenable An object with a `then` method that may be\n *     compatible with the Promise/A+ specification.\n * @param {!Function} then The `then` method of the Thenable object.\n * @param {!Function} onFulfilled\n * @param {!Function} onRejected\n * @param {*} context\n * @private\n */\ngoog.Promise.tryThen_ = function(\n    thenable, then, onFulfilled, onRejected, context) {\n\n  var called = false;\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      onFulfilled.call(context, value);\n    }\n  };\n\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      onRejected.call(context, reason);\n    }\n  };\n\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\n\n\n/**\n * Executes the pending callbacks of a settled Promise after a timeout.\n *\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\n * callbacks must only be invoked from a call stack that only contains Promise\n * implementation code, which we accomplish by invoking callback execution after\n * a timeout. If `startExecution_` is called multiple times for the same\n * Promise, the callback chain will be evaluated only once. Additional callbacks\n * may be added during the evaluation phase, and will be executed in the same\n * event loop.\n *\n * All Promises added to the waiting list during the same browser event loop\n * will be executed in one batch to avoid using a separate timeout per Promise.\n *\n * @private\n */\ngoog.Promise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    goog.async.run(this.executeCallbacks_, this);\n  }\n};\n\n\n/**\n * @return {boolean} Whether there are any pending callbacks queued.\n * @private\n */\ngoog.Promise.prototype.hasEntry_ = function() {\n  return !!this.callbackEntries_;\n};\n\n\n/**\n * @param {goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.prototype.queueEntry_ = function(entry) {\n  goog.asserts.assert(entry.onFulfilled != null);\n\n  if (this.callbackEntriesTail_) {\n    this.callbackEntriesTail_.next = entry;\n    this.callbackEntriesTail_ = entry;\n  } else {\n    // It the work queue was empty set the head too.\n    this.callbackEntries_ = entry;\n    this.callbackEntriesTail_ = entry;\n  }\n};\n\n\n/**\n * @return {goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.prototype.popEntry_ = function() {\n  var entry = null;\n  if (this.callbackEntries_) {\n    entry = this.callbackEntries_;\n    this.callbackEntries_ = entry.next;\n    entry.next = null;\n  }\n  // It the work queue is empty clear the tail too.\n  if (!this.callbackEntries_) {\n    this.callbackEntriesTail_ = null;\n  }\n\n  if (entry != null) {\n    goog.asserts.assert(entry.onFulfilled != null);\n  }\n  return entry;\n};\n\n\n/**\n * @param {goog.Promise.CallbackEntry_} previous\n * @private\n */\ngoog.Promise.prototype.removeEntryAfter_ = function(previous) {\n  goog.asserts.assert(this.callbackEntries_);\n  goog.asserts.assert(previous != null);\n  // If the last entry is being removed, update the tail\n  if (previous.next == this.callbackEntriesTail_) {\n    this.callbackEntriesTail_ = previous;\n  }\n\n  previous.next = previous.next.next;\n};\n\n\n/**\n * Executes all pending callbacks for this Promise.\n *\n * @private\n */\ngoog.Promise.prototype.executeCallbacks_ = function() {\n  var entry = null;\n  while (entry = this.popEntry_()) {\n    if (goog.Promise.LONG_STACK_TRACES) {\n      this.currentStep_++;\n    }\n    this.executeCallback_(entry, this.state_, this.result_);\n  }\n  this.executing_ = false;\n};\n\n\n/**\n * Executes a pending callback for this Promise. Invokes an `onFulfilled`\n * or `onRejected` callback based on the settled state of the Promise.\n *\n * @param {!goog.Promise.CallbackEntry_} callbackEntry An entry containing the\n *     onFulfilled and/or onRejected callbacks for this step.\n * @param {goog.Promise.State_} state The resolution status of the Promise,\n *     either FULFILLED or REJECTED.\n * @param {*} result The settled result of the Promise.\n * @private\n */\ngoog.Promise.prototype.executeCallback_ = function(\n    callbackEntry, state, result) {\n  // Cancel an unhandled rejection if the then/thenVoid call had an onRejected.\n  if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected &&\n      !callbackEntry.always) {\n    this.removeUnhandledRejection_();\n  }\n\n  if (callbackEntry.child) {\n    // When the parent is settled, the child no longer needs to hold on to it,\n    // as the parent can no longer be canceled.\n    callbackEntry.child.parent_ = null;\n    goog.Promise.invokeCallback_(callbackEntry, state, result);\n  } else {\n    // Callbacks created with thenAlways or thenVoid do not have the rejection\n    // handling code normally set up in the child Promise.\n    try {\n      callbackEntry.always ?\n          callbackEntry.onFulfilled.call(callbackEntry.context) :\n          goog.Promise.invokeCallback_(callbackEntry, state, result);\n    } catch (err) {\n      goog.Promise.handleRejection_.call(null, err);\n    }\n  }\n  goog.Promise.returnEntry_(callbackEntry);\n};\n\n\n/**\n * Executes the onFulfilled or onRejected callback for a callbackEntry.\n *\n * @param {!goog.Promise.CallbackEntry_} callbackEntry\n * @param {goog.Promise.State_} state\n * @param {*} result\n * @private\n */\ngoog.Promise.invokeCallback_ = function(callbackEntry, state, result) {\n  if (state == goog.Promise.State_.FULFILLED) {\n    callbackEntry.onFulfilled.call(callbackEntry.context, result);\n  } else if (callbackEntry.onRejected) {\n    callbackEntry.onRejected.call(callbackEntry.context, result);\n  }\n};\n\n\n/**\n * Records a stack trace entry for functions that call `then` or the\n * Promise constructor. May be disabled by unsetting `LONG_STACK_TRACES`.\n *\n * @param {!Error} err An Error object created by the calling function for\n *     providing a stack trace.\n * @private\n */\ngoog.Promise.prototype.addStackTrace_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && goog.isString(err.stack)) {\n    // Extract the third line of the stack trace, which is the entry for the\n    // user function that called into Promise code.\n    var trace = err.stack.split('\\n', 4)[3];\n    var message = err.message;\n\n    // Pad the message to align the traces.\n    message += Array(11 - message.length).join(' ');\n    this.stack_.push(message + trace);\n  }\n};\n\n\n/**\n * Adds extra stack trace information to an exception for the list of\n * asynchronous `then` calls that have been run for this Promise. Stack\n * trace information is recorded in {@see #addStackTrace_}, and appended to\n * rethrown errors when `LONG_STACK_TRACES` is enabled.\n *\n * @param {?} err An unhandled exception captured during callback execution.\n * @private\n */\ngoog.Promise.prototype.appendLongStack_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && err && goog.isString(err.stack) &&\n      this.stack_.length) {\n    var longTrace = ['Promise trace:'];\n\n    for (var promise = this; promise; promise = promise.parent_) {\n      for (var i = this.currentStep_; i >= 0; i--) {\n        longTrace.push(promise.stack_[i]);\n      }\n      longTrace.push(\n          'Value: ' +\n          '[' + (promise.state_ == goog.Promise.State_.REJECTED ? 'REJECTED' :\n                                                                  'FULFILLED') +\n          '] ' +\n          '<' + String(promise.result_) + '>');\n    }\n    err.stack += '\\n\\n' + longTrace.join('\\n');\n  }\n};\n\n\n/**\n * Marks this rejected Promise as having being handled. Also marks any parent\n * Promises in the rejected state as handled. The rejection handler will no\n * longer be invoked for this Promise (if it has not been called already).\n *\n * @private\n */\ngoog.Promise.prototype.removeUnhandledRejection_ = function() {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      goog.global.clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n      p.hadUnhandledRejection_ = false;\n    }\n  }\n};\n\n\n/**\n * Marks this rejected Promise as unhandled. If no `onRejected` callback\n * is called for this Promise before the `UNHANDLED_REJECTION_DELAY`\n * expires, the reason will be passed to the unhandled rejection handler. The\n * handler typically rethrows the rejection reason so that it becomes visible in\n * the developer console.\n *\n * @param {!goog.Promise} promise The rejected Promise.\n * @param {*} reason The Promise rejection reason.\n * @private\n */\ngoog.Promise.addUnhandledRejection_ = function(promise, reason) {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {\n      promise.appendLongStack_(reason);\n      goog.Promise.handleRejection_.call(null, reason);\n    }, goog.Promise.UNHANDLED_REJECTION_DELAY);\n\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    promise.hadUnhandledRejection_ = true;\n    goog.async.run(function() {\n      if (promise.hadUnhandledRejection_) {\n        promise.appendLongStack_(reason);\n        goog.Promise.handleRejection_.call(null, reason);\n      }\n    });\n  }\n};\n\n\n/**\n * A method that is invoked with the rejection reasons for Promises that are\n * rejected but have no `onRejected` callbacks registered yet.\n * @type {function(*)}\n * @private\n */\ngoog.Promise.handleRejection_ = goog.async.throwException;\n\n\n/**\n * Sets a handler that will be called with reasons from unhandled rejected\n * Promises. If the rejected Promise (or one of its descendants) has an\n * `onRejected` callback registered, the rejection will be considered\n * handled, and the rejection handler will not be called.\n *\n * By default, unhandled rejections are rethrown so that the error may be\n * captured by the developer console or a `window.onerror` handler.\n *\n * @param {function(*)} handler A function that will be called with reasons from\n *     rejected Promises. Defaults to `goog.async.throwException`.\n */\ngoog.Promise.setUnhandledRejectionHandler = function(handler) {\n  goog.Promise.handleRejection_ = handler;\n};\n\n\n\n/**\n * Error used as a rejection reason for canceled Promises.\n *\n * @param {string=} opt_message\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.Promise.CancellationError = function(opt_message) {\n  goog.Promise.CancellationError.base(this, 'constructor', opt_message);\n};\ngoog.inherits(goog.Promise.CancellationError, goog.debug.Error);\n\n\n/** @override */\ngoog.Promise.CancellationError.prototype.name = 'cancel';\n\n\n\n/**\n * Internal implementation of the resolver interface.\n *\n * @param {!goog.Promise<TYPE>} promise\n * @param {function((TYPE|goog.Promise<TYPE>|Thenable)=)} resolve\n * @param {function(*=): void} reject\n * @implements {goog.promise.Resolver<TYPE>}\n * @final @struct\n * @constructor\n * @private\n * @template TYPE\n */\ngoog.Promise.Resolver_ = function(promise, resolve, reject) {\n  /** @const */\n  this.promise = promise;\n\n  /** @const */\n  this.resolve = resolve;\n\n  /** @const */\n  this.reject = reject;\n};\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Implements the disposable interface. The dispose method is used\n * to clean up references and resources.\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\ngoog.provide('goog.Disposable');\ngoog.provide('goog.dispose');\ngoog.provide('goog.disposeAll');\n\ngoog.require('goog.disposable.IDisposable');\n\n\n\n/**\n * Class that provides the basic implementation for disposable objects. If your\n * class holds one or more references to COM objects, DOM nodes, or other\n * disposable objects, it should extend this class or implement the disposable\n * interface (defined in goog.disposable.IDisposable).\n * @constructor\n * @implements {goog.disposable.IDisposable}\n */\ngoog.Disposable = function() {\n  /**\n   * If monitoring the goog.Disposable instances is enabled, stores the creation\n   * stack trace of the Disposable instance.\n   * @type {string|undefined}\n   */\n  this.creationStack;\n\n  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\n    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {\n      this.creationStack = new Error().stack;\n    }\n    goog.Disposable.instances_[goog.getUid(this)] = this;\n  }\n  // Support sealing\n  this.disposed_ = this.disposed_;\n  this.onDisposeCallbacks_ = this.onDisposeCallbacks_;\n};\n\n\n/**\n * @enum {number} Different monitoring modes for Disposable.\n */\ngoog.Disposable.MonitoringMode = {\n  /**\n   * No monitoring.\n   */\n  OFF: 0,\n  /**\n   * Creating and disposing the goog.Disposable instances is monitored. All\n   * disposable objects need to call the `goog.Disposable` base\n   * constructor. The PERMANENT mode must be switched on before creating any\n   * goog.Disposable instances.\n   */\n  PERMANENT: 1,\n  /**\n   * INTERACTIVE mode can be switched on and off on the fly without producing\n   * errors. It also doesn't warn if the disposable objects don't call the\n   * `goog.Disposable` base constructor.\n   */\n  INTERACTIVE: 2\n};\n\n\n/**\n * @define {number} The monitoring mode of the goog.Disposable\n *     instances. Default is OFF. Switching on the monitoring is only\n *     recommended for debugging because it has a significant impact on\n *     performance and memory usage. If switched off, the monitoring code\n *     compiles down to 0 bytes.\n */\ngoog.Disposable.MONITORING_MODE =\n    goog.define('goog.Disposable.MONITORING_MODE', 0);\n\n\n/**\n * @define {boolean} Whether to attach creation stack to each created disposable\n *     instance; This is only relevant for when MonitoringMode != OFF.\n */\ngoog.Disposable.INCLUDE_STACK_ON_CREATION =\n    goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);\n\n\n/**\n * Maps the unique ID of every undisposed `goog.Disposable` object to\n * the object itself.\n * @type {!Object<number, !goog.Disposable>}\n * @private\n */\ngoog.Disposable.instances_ = {};\n\n\n/**\n * @return {!Array<!goog.Disposable>} All `goog.Disposable` objects that\n *     haven't been disposed of.\n */\ngoog.Disposable.getUndisposedObjects = function() {\n  var ret = [];\n  for (var id in goog.Disposable.instances_) {\n    if (goog.Disposable.instances_.hasOwnProperty(id)) {\n      ret.push(goog.Disposable.instances_[Number(id)]);\n    }\n  }\n  return ret;\n};\n\n\n/**\n * Clears the registry of undisposed objects but doesn't dispose of them.\n */\ngoog.Disposable.clearUndisposedObjects = function() {\n  goog.Disposable.instances_ = {};\n};\n\n\n/**\n * Whether the object has been disposed of.\n * @type {boolean}\n * @private\n */\ngoog.Disposable.prototype.disposed_ = false;\n\n\n/**\n * Callbacks to invoke when this object is disposed.\n * @type {Array<!Function>}\n * @private\n */\ngoog.Disposable.prototype.onDisposeCallbacks_;\n\n\n/**\n * @return {boolean} Whether the object has been disposed of.\n * @override\n */\ngoog.Disposable.prototype.isDisposed = function() {\n  return this.disposed_;\n};\n\n\n/**\n * @return {boolean} Whether the object has been disposed of.\n * @deprecated Use {@link #isDisposed} instead.\n */\ngoog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;\n\n\n/**\n * Disposes of the object. If the object hasn't already been disposed of, calls\n * {@link #disposeInternal}. Classes that extend `goog.Disposable` should\n * override {@link #disposeInternal} in order to delete references to COM\n * objects, DOM nodes, and other disposable objects. Reentrant.\n *\n * @return {void} Nothing.\n * @override\n */\ngoog.Disposable.prototype.dispose = function() {\n  if (!this.disposed_) {\n    // Set disposed_ to true first, in case during the chain of disposal this\n    // gets disposed recursively.\n    this.disposed_ = true;\n    this.disposeInternal();\n    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\n      var uid = goog.getUid(this);\n      if (goog.Disposable.MONITORING_MODE ==\n              goog.Disposable.MonitoringMode.PERMANENT &&\n          !goog.Disposable.instances_.hasOwnProperty(uid)) {\n        throw new Error(\n            this + ' did not call the goog.Disposable base ' +\n            'constructor or was disposed of after a clearUndisposedObjects ' +\n            'call');\n      }\n      if (goog.Disposable.MONITORING_MODE !=\n              goog.Disposable.MonitoringMode.OFF &&\n          this.onDisposeCallbacks_ && this.onDisposeCallbacks_.length > 0) {\n        throw new Error(\n            this + ' did not empty its onDisposeCallbacks queue. This ' +\n            'probably means it overrode dispose() or disposeInternal() ' +\n            'without calling the superclass\\' method.');\n      }\n      delete goog.Disposable.instances_[uid];\n    }\n  }\n};\n\n\n/**\n * Associates a disposable object with this object so that they will be disposed\n * together.\n * @param {goog.disposable.IDisposable} disposable that will be disposed when\n *     this object is disposed.\n */\ngoog.Disposable.prototype.registerDisposable = function(disposable) {\n  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));\n};\n\n\n/**\n * Invokes a callback function when this object is disposed. Callbacks are\n * invoked in the order in which they were added. If a callback is added to\n * an already disposed Disposable, it will be called immediately.\n * @param {function(this:T):?} callback The callback function.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @template T\n */\ngoog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {\n  if (this.disposed_) {\n    goog.isDef(opt_scope) ? callback.call(opt_scope) : callback();\n    return;\n  }\n  if (!this.onDisposeCallbacks_) {\n    this.onDisposeCallbacks_ = [];\n  }\n\n  this.onDisposeCallbacks_.push(\n      goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback);\n};\n\n\n/**\n * Deletes or nulls out any references to COM objects, DOM nodes, or other\n * disposable objects. Classes that extend `goog.Disposable` should\n * override this method.\n * Not reentrant. To avoid calling it twice, it must only be called from the\n * subclass' `disposeInternal` method. Everywhere else the public\n * `dispose` method must be used.\n * For example:\n * <pre>\n *   mypackage.MyClass = function() {\n *     mypackage.MyClass.base(this, 'constructor');\n *     // Constructor logic specific to MyClass.\n *     ...\n *   };\n *   goog.inherits(mypackage.MyClass, goog.Disposable);\n *\n *   mypackage.MyClass.prototype.disposeInternal = function() {\n *     // Dispose logic specific to MyClass.\n *     ...\n *     // Call superclass's disposeInternal at the end of the subclass's, like\n *     // in C++, to avoid hard-to-catch issues.\n *     mypackage.MyClass.base(this, 'disposeInternal');\n *   };\n * </pre>\n * @protected\n */\ngoog.Disposable.prototype.disposeInternal = function() {\n  if (this.onDisposeCallbacks_) {\n    while (this.onDisposeCallbacks_.length) {\n      this.onDisposeCallbacks_.shift()();\n    }\n  }\n};\n\n\n/**\n * Returns True if we can verify the object is disposed.\n * Calls `isDisposed` on the argument if it supports it.  If obj\n * is not an object with an isDisposed() method, return false.\n * @param {*} obj The object to investigate.\n * @return {boolean} True if we can verify the object is disposed.\n */\ngoog.Disposable.isDisposed = function(obj) {\n  if (obj && typeof obj.isDisposed == 'function') {\n    return obj.isDisposed();\n  }\n  return false;\n};\n\n\n/**\n * Calls `dispose` on the argument if it supports it. If obj is not an\n *     object with a dispose() method, this is a no-op.\n * @param {*} obj The object to dispose of.\n */\ngoog.dispose = function(obj) {\n  if (obj && typeof obj.dispose == 'function') {\n    obj.dispose();\n  }\n};\n\n\n/**\n * Calls `dispose` on each member of the list that supports it. (If the\n * member is an ArrayLike, then `goog.disposeAll()` will be called\n * recursively on each of its members.) If the member is not an object with a\n * `dispose()` method, then it is ignored.\n * @param {...*} var_args The list.\n */\ngoog.disposeAll = function(var_args) {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    var disposable = arguments[i];\n    if (goog.isArrayLike(disposable)) {\n      goog.disposeAll.apply(null, disposable);\n    } else {\n      goog.dispose(disposable);\n    }\n  }\n};\n","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Useful compiler idioms.\n *\n * @author johnlenz@google.com (John Lenz)\n */\n\ngoog.provide('goog.reflect');\n\n\n/**\n * Syntax for object literal casts.\n * @see http://go/jscompiler-renaming\n * @see https://goo.gl/CRs09P\n *\n * Use this if you have an object literal whose keys need to have the same names\n * as the properties of some class even after they are renamed by the compiler.\n *\n * @param {!Function} type Type to cast to.\n * @param {Object} object Object literal to cast.\n * @return {Object} The object literal.\n */\ngoog.reflect.object = function(type, object) {\n  return object;\n};\n\n/**\n * Syntax for renaming property strings.\n * @see http://go/jscompiler-renaming\n * @see https://goo.gl/CRs09P\n *\n * Use this if you have an need to access a property as a string, but want\n * to also have the property renamed by the compiler. In contrast to\n * goog.reflect.object, this method takes an instance of an object.\n *\n * Properties must be simple names (not qualified names).\n *\n * @param {string} prop Name of the property\n * @param {!Object} object Instance of the object whose type will be used\n *     for renaming\n * @return {string} The renamed property.\n */\ngoog.reflect.objectProperty = function(prop, object) {\n  return prop;\n};\n\n/**\n * To assert to the compiler that an operation is needed when it would\n * otherwise be stripped. For example:\n * <code>\n *     // Force a layout\n *     goog.reflect.sinkValue(dialog.offsetHeight);\n * </code>\n * @param {T} x\n * @return {T}\n * @template T\n */\ngoog.reflect.sinkValue = function(x) {\n  goog.reflect.sinkValue[' '](x);\n  return x;\n};\n\n\n/**\n * The compiler should optimize this function away iff no one ever uses\n * goog.reflect.sinkValue.\n */\ngoog.reflect.sinkValue[' '] = goog.nullFunction;\n\n\n/**\n * Check if a property can be accessed without throwing an exception.\n * @param {Object} obj The owner of the property.\n * @param {string} prop The property name.\n * @return {boolean} Whether the property is accessible. Will also return true\n *     if obj is null.\n */\ngoog.reflect.canAccessProperty = function(obj, prop) {\n\n  try {\n    goog.reflect.sinkValue(obj[prop]);\n    return true;\n  } catch (e) {\n  }\n  return false;\n};\n\n\n/**\n * Retrieves a value from a cache given a key. The compiler provides special\n * consideration for this call such that it is generally considered side-effect\n * free. However, if the `opt_keyFn` or `valueFn` have side-effects\n * then the entire call is considered to have side-effects.\n *\n * Conventionally storing the value on the cache would be considered a\n * side-effect and preclude unused calls from being pruned, ie. even if\n * the value was never used, it would still always be stored in the cache.\n *\n * Providing a side-effect free `valueFn` and `opt_keyFn`\n * allows unused calls to `goog.reflect.cache` to be pruned.\n *\n * @param {!Object<K, V>} cacheObj The object that contains the cached values.\n * @param {?} key The key to lookup in the cache. If it is not string or number\n *     then a `opt_keyFn` should be provided. The key is also used as the\n *     parameter to the `valueFn`.\n * @param {function(?):V} valueFn The value provider to use to calculate the\n *     value to store in the cache. This function should be side-effect free\n *     to take advantage of the optimization.\n * @param {function(?):K=} opt_keyFn The key provider to determine the cache\n *     map key. This should be used if the given key is not a string or number.\n *     If not provided then the given key is used. This function should be\n *     side-effect free to take advantage of the optimization.\n * @return {V} The cached or calculated value.\n * @template K\n * @template V\n */\ngoog.reflect.cache = function(cacheObj, key, valueFn, opt_keyFn) {\n  var storedKey = opt_keyFn ? opt_keyFn(key) : key;\n\n  if (Object.prototype.hasOwnProperty.call(cacheObj, storedKey)) {\n    return cacheObj[storedKey];\n  }\n\n  return (cacheObj[storedKey] = valueFn(key));\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Rendering engine detection.\n * @see <a href=\"http://www.useragentstring.com/\">User agent strings</a>\n * For information on the browser brand (such as Safari versus Chrome), see\n * goog.userAgent.product.\n * @author arv@google.com (Erik Arvidsson)\n * @see ../demos/useragent.html\n */\n\ngoog.provide('goog.userAgent');\n\ngoog.require('goog.labs.userAgent.browser');\ngoog.require('goog.labs.userAgent.engine');\ngoog.require('goog.labs.userAgent.platform');\ngoog.require('goog.labs.userAgent.util');\ngoog.require('goog.reflect');\ngoog.require('goog.string');\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is IE.\n */\ngoog.userAgent.ASSUME_IE = goog.define('goog.userAgent.ASSUME_IE', false);\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is EDGE,\n * referring to EdgeHTML based Edge.\n */\ngoog.userAgent.ASSUME_EDGE = goog.define('goog.userAgent.ASSUME_EDGE', false);\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is GECKO.\n */\ngoog.userAgent.ASSUME_GECKO = goog.define('goog.userAgent.ASSUME_GECKO', false);\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.\n */\ngoog.userAgent.ASSUME_WEBKIT =\n    goog.define('goog.userAgent.ASSUME_WEBKIT', false);\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is a\n *     mobile device running WebKit e.g. iPhone or Android.\n */\ngoog.userAgent.ASSUME_MOBILE_WEBKIT =\n    goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);\n\n\n/**\n * @define {boolean} Whether we know at compile-time that the browser is OPERA,\n * referring to Presto-based Opera.\n */\ngoog.userAgent.ASSUME_OPERA = goog.define('goog.userAgent.ASSUME_OPERA', false);\n\n\n/**\n * @define {boolean} Whether the\n *     `goog.userAgent.isVersionOrHigher`\n *     function will return true for any version.\n */\ngoog.userAgent.ASSUME_ANY_VERSION =\n    goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);\n\n\n/**\n * Whether we know the browser engine at compile-time.\n * @type {boolean}\n * @private\n */\ngoog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE ||\n    goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO ||\n    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT ||\n    goog.userAgent.ASSUME_OPERA;\n\n\n/**\n * Returns the userAgent string for the current browser.\n *\n * @return {string} The userAgent string.\n */\ngoog.userAgent.getUserAgentString = function() {\n  return goog.labs.userAgent.util.getUserAgent();\n};\n\n\n/**\n * @return {?Navigator} The native navigator object.\n */\ngoog.userAgent.getNavigatorTyped = function() {\n  // Need a local navigator reference instead of using the global one,\n  // to avoid the rare case where they reference different objects.\n  // (in a WorkerPool, for example).\n  return goog.global['navigator'] || null;\n};\n\n\n/**\n * TODO(nnaze): Change type to \"Navigator\" and update compilation targets.\n * @return {?Object} The native navigator object.\n */\ngoog.userAgent.getNavigator = function() {\n  return goog.userAgent.getNavigatorTyped();\n};\n\n\n/**\n * Whether the user agent is Presto-based Opera.\n * @type {boolean}\n */\ngoog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?\n    goog.userAgent.ASSUME_OPERA :\n    goog.labs.userAgent.browser.isOpera();\n\n\n/**\n * Whether the user agent is Internet Explorer.\n * @type {boolean}\n */\ngoog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?\n    goog.userAgent.ASSUME_IE :\n    goog.labs.userAgent.browser.isIE();\n\n\n/**\n * Whether the user agent is Microsoft Edge (EdgeHTML based).\n * @type {boolean}\n */\ngoog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ?\n    goog.userAgent.ASSUME_EDGE :\n    goog.labs.userAgent.engine.isEdge();\n\n\n/**\n * Whether the user agent is MS Internet Explorer or MS Edge (EdgeHTML based).\n * @type {boolean}\n */\ngoog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;\n\n\n/**\n * Whether the user agent is Gecko. Gecko is the rendering engine used by\n * Mozilla, Firefox, and others.\n * @type {boolean}\n */\ngoog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?\n    goog.userAgent.ASSUME_GECKO :\n    goog.labs.userAgent.engine.isGecko();\n\n\n/**\n * Whether the user agent is WebKit. WebKit is the rendering engine that\n * Safari, Edge Chromium, Opera Chromium, Android and others use.\n * @type {boolean}\n */\ngoog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?\n    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :\n    goog.labs.userAgent.engine.isWebKit();\n\n\n/**\n * Whether the user agent is running on a mobile device.\n *\n * This is a separate function so that the logic can be tested.\n *\n * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().\n *\n * @return {boolean} Whether the user agent is running on a mobile device.\n * @private\n */\ngoog.userAgent.isMobile_ = function() {\n  return goog.userAgent.WEBKIT &&\n      goog.labs.userAgent.util.matchUserAgent('Mobile');\n};\n\n\n/**\n * Whether the user agent is running on a mobile device.\n *\n * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent\n *   is promoted as the gecko/webkit logic is likely inaccurate.\n *\n * @type {boolean}\n */\ngoog.userAgent.MOBILE =\n    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();\n\n\n/**\n * Used while transitioning code to use WEBKIT instead.\n * @type {boolean}\n * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.\n * TODO(nicksantos): Delete this from goog.userAgent.\n */\ngoog.userAgent.SAFARI = goog.userAgent.WEBKIT;\n\n\n/**\n * @return {string} the platform (operating system) the user agent is running\n *     on. Default to empty string because navigator.platform may not be defined\n *     (on Rhino, for example).\n * @private\n */\ngoog.userAgent.determinePlatform_ = function() {\n  var navigator = goog.userAgent.getNavigatorTyped();\n  return navigator && navigator.platform || '';\n};\n\n\n/**\n * The platform (operating system) the user agent is running on. Default to\n * empty string because navigator.platform may not be defined (on Rhino, for\n * example).\n * @type {string}\n */\ngoog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();\n\n\n/**\n * @define {boolean} Whether the user agent is running on a Macintosh operating\n *     system.\n */\ngoog.userAgent.ASSUME_MAC = goog.define('goog.userAgent.ASSUME_MAC', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on a Windows operating\n *     system.\n */\ngoog.userAgent.ASSUME_WINDOWS =\n    goog.define('goog.userAgent.ASSUME_WINDOWS', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on a Linux operating\n *     system.\n */\ngoog.userAgent.ASSUME_LINUX = goog.define('goog.userAgent.ASSUME_LINUX', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on a X11 windowing\n *     system.\n */\ngoog.userAgent.ASSUME_X11 = goog.define('goog.userAgent.ASSUME_X11', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on Android.\n */\ngoog.userAgent.ASSUME_ANDROID =\n    goog.define('goog.userAgent.ASSUME_ANDROID', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on an iPhone.\n */\ngoog.userAgent.ASSUME_IPHONE =\n    goog.define('goog.userAgent.ASSUME_IPHONE', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on an iPad.\n */\ngoog.userAgent.ASSUME_IPAD = goog.define('goog.userAgent.ASSUME_IPAD', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on an iPod.\n */\ngoog.userAgent.ASSUME_IPOD = goog.define('goog.userAgent.ASSUME_IPOD', false);\n\n\n/**\n * @define {boolean} Whether the user agent is running on KaiOS.\n */\ngoog.userAgent.ASSUME_KAIOS = goog.define('goog.userAgent.ASSUME_KAIOS', false);\n\n/**\n * @define {boolean} Whether the user agent is running on Go2Phone.\n */\ngoog.userAgent.ASSUME_GO2PHONE =\n    goog.define('goog.userAgent.ASSUME_GO2PHONE', false);\n\n\n/**\n * @type {boolean}\n * @private\n */\ngoog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC ||\n    goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX ||\n    goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID ||\n    goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||\n    goog.userAgent.ASSUME_IPOD;\n\n\n/**\n * Whether the user agent is running on a Macintosh operating system.\n * @type {boolean}\n */\ngoog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_MAC :\n    goog.labs.userAgent.platform.isMacintosh();\n\n\n/**\n * Whether the user agent is running on a Windows operating system.\n * @type {boolean}\n */\ngoog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_WINDOWS :\n    goog.labs.userAgent.platform.isWindows();\n\n\n/**\n * Whether the user agent is Linux per the legacy behavior of\n * goog.userAgent.LINUX, which considered ChromeOS to also be\n * Linux.\n * @return {boolean}\n * @private\n */\ngoog.userAgent.isLegacyLinux_ = function() {\n  return goog.labs.userAgent.platform.isLinux() ||\n      goog.labs.userAgent.platform.isChromeOS();\n};\n\n\n/**\n * Whether the user agent is running on a Linux operating system.\n *\n * Note that goog.userAgent.LINUX considers ChromeOS to be Linux,\n * while goog.labs.userAgent.platform considers ChromeOS and\n * Linux to be different OSes.\n *\n * @type {boolean}\n */\ngoog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_LINUX :\n    goog.userAgent.isLegacyLinux_();\n\n\n/**\n * @return {boolean} Whether the user agent is an X11 windowing system.\n * @private\n */\ngoog.userAgent.isX11_ = function() {\n  var navigator = goog.userAgent.getNavigatorTyped();\n  return !!navigator &&\n      goog.string.contains(navigator['appVersion'] || '', 'X11');\n};\n\n\n/**\n * Whether the user agent is running on a X11 windowing system.\n * @type {boolean}\n */\ngoog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_X11 :\n    goog.userAgent.isX11_();\n\n\n/**\n * Whether the user agent is running on Android.\n * @type {boolean}\n */\ngoog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_ANDROID :\n    goog.labs.userAgent.platform.isAndroid();\n\n\n/**\n * Whether the user agent is running on an iPhone.\n * @type {boolean}\n */\ngoog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_IPHONE :\n    goog.labs.userAgent.platform.isIphone();\n\n\n/**\n * Whether the user agent is running on an iPad.\n * @type {boolean}\n */\ngoog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_IPAD :\n    goog.labs.userAgent.platform.isIpad();\n\n\n/**\n * Whether the user agent is running on an iPod.\n * @type {boolean}\n */\ngoog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_IPOD :\n    goog.labs.userAgent.platform.isIpod();\n\n\n/**\n * Whether the user agent is running on iOS.\n * @type {boolean}\n */\ngoog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ?\n    (goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||\n     goog.userAgent.ASSUME_IPOD) :\n    goog.labs.userAgent.platform.isIos();\n\n/**\n * Whether the user agent is running on KaiOS.\n * @type {boolean}\n */\ngoog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_KAIOS :\n    goog.labs.userAgent.platform.isKaiOS();\n\n/**\n * Whether the user agent is running on Go2Phone.\n * @type {boolean}\n */\ngoog.userAgent.GO2PHONE = goog.userAgent.PLATFORM_KNOWN_ ?\n    goog.userAgent.ASSUME_GO2PHONE :\n    goog.labs.userAgent.platform.isGo2Phone();\n\n\n/**\n * @return {string} The string that describes the version number of the user\n *     agent.\n * @private\n */\ngoog.userAgent.determineVersion_ = function() {\n  // All browsers have different ways to detect the version and they all have\n  // different naming schemes.\n  // version is a string rather than a number because it may contain 'b', 'a',\n  // and so on.\n  var version = '';\n  var arr = goog.userAgent.getVersionRegexResult_();\n  if (arr) {\n    version = arr ? arr[1] : '';\n  }\n\n  if (goog.userAgent.IE) {\n    // IE9 can be in document mode 9 but be reporting an inconsistent user agent\n    // version.  If it is identifying as a version lower than 9 we take the\n    // documentMode as the version instead.  IE8 has similar behavior.\n    // It is recommended to set the X-UA-Compatible header to ensure that IE9\n    // uses documentMode 9.\n    var docMode = goog.userAgent.getDocumentMode_();\n    if (docMode != null && docMode > parseFloat(version)) {\n      return String(docMode);\n    }\n  }\n\n  return version;\n};\n\n\n/**\n * @return {?IArrayLike<string>|undefined} The version regex matches from\n *     parsing the user\n *     agent string. These regex statements must be executed inline so they can\n *     be compiled out by the closure compiler with the rest of the useragent\n *     detection logic when ASSUME_* is specified.\n * @private\n */\ngoog.userAgent.getVersionRegexResult_ = function() {\n  var userAgent = goog.userAgent.getUserAgentString();\n  if (goog.userAgent.GECKO) {\n    return /rv\\:([^\\);]+)(\\)|;)/.exec(userAgent);\n  }\n  if (goog.userAgent.EDGE) {\n    return /Edge\\/([\\d\\.]+)/.exec(userAgent);\n  }\n  if (goog.userAgent.IE) {\n    return /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(userAgent);\n  }\n  if (goog.userAgent.WEBKIT) {\n    // WebKit/125.4\n    return /WebKit\\/(\\S+)/.exec(userAgent);\n  }\n  if (goog.userAgent.OPERA) {\n    // If none of the above browsers were detected but the browser is Opera, the\n    // only string that is of interest is 'Version/<number>'.\n    return /(?:Version)[ \\/]?(\\S+)/.exec(userAgent);\n  }\n  return undefined;\n};\n\n\n/**\n * @return {number|undefined} Returns the document mode (for testing).\n * @private\n */\ngoog.userAgent.getDocumentMode_ = function() {\n  // NOTE(user): goog.userAgent may be used in context where there is no DOM.\n  var doc = goog.global['document'];\n  return doc ? doc['documentMode'] : undefined;\n};\n\n\n/**\n * The version of the user agent. This is a string because it might contain\n * 'b' (as in beta) as well as multiple dots.\n * @type {string}\n */\ngoog.userAgent.VERSION = goog.userAgent.determineVersion_();\n\n\n/**\n * Compares two version numbers.\n *\n * @param {string} v1 Version of first item.\n * @param {string} v2 Version of second item.\n *\n * @return {number}  1 if first argument is higher\n *                   0 if arguments are equal\n *                  -1 if second argument is higher.\n * @deprecated Use goog.string.compareVersions.\n */\ngoog.userAgent.compare = function(v1, v2) {\n  return goog.string.compareVersions(v1, v2);\n};\n\n\n/**\n * Cache for {@link goog.userAgent.isVersionOrHigher}.\n * Calls to compareVersions are surprisingly expensive and, as a browser's\n * version number is unlikely to change during a session, we cache the results.\n * @const\n * @private\n */\ngoog.userAgent.isVersionOrHigherCache_ = {};\n\n\n/**\n * Whether the user agent version is higher or the same as the given version.\n * NOTE: When checking the version numbers for Firefox and Safari, be sure to\n * use the engine's version, not the browser's version number.  For example,\n * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.\n * Opera and Internet Explorer versions match the product release number.<br>\n * @see <a href=\"http://en.wikipedia.org/wiki/Safari_version_history\">\n *     Webkit</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/Gecko_engine\">Gecko</a>\n *\n * @param {string|number} version The version to check.\n * @return {boolean} Whether the user agent version is higher or the same as\n *     the given version.\n */\ngoog.userAgent.isVersionOrHigher = function(version) {\n  return goog.userAgent.ASSUME_ANY_VERSION ||\n      goog.reflect.cache(\n          goog.userAgent.isVersionOrHigherCache_, version, function() {\n            return goog.string.compareVersions(\n                       goog.userAgent.VERSION, version) >= 0;\n          });\n};\n\n\n/**\n * Deprecated alias to `goog.userAgent.isVersionOrHigher`.\n * @param {string|number} version The version to check.\n * @return {boolean} Whether the user agent version is higher or the same as\n *     the given version.\n * @deprecated Use goog.userAgent.isVersionOrHigher().\n */\ngoog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;\n\n\n/**\n * Whether the IE effective document mode is higher or the same as the given\n * document mode version.\n * NOTE: Only for IE, return false for another browser.\n *\n * @param {number} documentMode The document mode version to check.\n * @return {boolean} Whether the IE effective document mode is higher or the\n *     same as the given version.\n */\ngoog.userAgent.isDocumentModeOrHigher = function(documentMode) {\n  return Number(goog.userAgent.DOCUMENT_MODE) >= documentMode;\n};\n\n\n/**\n * Deprecated alias to `goog.userAgent.isDocumentModeOrHigher`.\n * @param {number} version The version to check.\n * @return {boolean} Whether the IE effective document mode is higher or the\n *      same as the given version.\n * @deprecated Use goog.userAgent.isDocumentModeOrHigher().\n */\ngoog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;\n\n\n/**\n * For IE version < 7, documentMode is undefined, so attempt to use the\n * CSS1Compat property to see if we are in standards mode. If we are in\n * standards mode, treat the browser version as the document mode. Otherwise,\n * IE is emulating version 5.\n *\n * NOTE(2019/05/31): Support for IE < 7 is long gone, so this is now simplified.\n * It returns document.documentMode for IE and undefined for everything else.\n *\n * @type {number|undefined}\n * @const\n */\ngoog.userAgent.DOCUMENT_MODE = (function() {\n  var doc = goog.global['document'];\n  if (!doc || !goog.userAgent.IE) {\n    return undefined;\n  }\n  return goog.userAgent.getDocumentMode_();\n})();\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Logging and debugging utilities.\n *\n * @see ../demos/debug.html\n */\n\ngoog.provide('goog.debug');\n\ngoog.require('goog.array');\ngoog.require('goog.debug.errorcontext');\ngoog.require('goog.userAgent');\n\n\n/** @define {boolean} Whether logging should be enabled. */\ngoog.debug.LOGGING_ENABLED =\n    goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);\n\n\n/** @define {boolean} Whether to force \"sloppy\" stack building. */\ngoog.debug.FORCE_SLOPPY_STACKS =\n    goog.define('goog.debug.FORCE_SLOPPY_STACKS', false);\n\n\n/**\n * Catches onerror events fired by windows and similar objects.\n * @param {function(Object)} logFunc The function to call with the error\n *    information.\n * @param {boolean=} opt_cancel Whether to stop the error from reaching the\n *    browser.\n * @param {Object=} opt_target Object that fires onerror events.\n * @suppress {strictMissingProperties} onerror is not defined as a property\n *    on Object.\n */\ngoog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {\n  var target = opt_target || goog.global;\n  var oldErrorHandler = target.onerror;\n  var retVal = !!opt_cancel;\n\n  // Chrome interprets onerror return value backwards (http://crbug.com/92062)\n  // until it was fixed in webkit revision r94061 (Webkit 535.3). This\n  // workaround still needs to be skipped in Safari after the webkit change\n  // gets pushed out in Safari.\n  // See https://bugs.webkit.org/show_bug.cgi?id=67119\n  if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher('535.3')) {\n    retVal = !retVal;\n  }\n\n  /**\n   * New onerror handler for this target. This onerror handler follows the spec\n   * according to\n   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors\n   * The spec was changed in August 2013 to support receiving column information\n   * and an error object for all scripts on the same origin or cross origin\n   * scripts with the proper headers. See\n   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n   *\n   * @param {string} message The error message. For cross-origin errors, this\n   *     will be scrubbed to just \"Script error.\". For new browsers that have\n   *     updated to follow the latest spec, errors that come from origins that\n   *     have proper cross origin headers will not be scrubbed.\n   * @param {string} url The URL of the script that caused the error. The URL\n   *     will be scrubbed to \"\" for cross origin scripts unless the script has\n   *     proper cross origin headers and the browser has updated to the latest\n   *     spec.\n   * @param {number} line The line number in the script that the error\n   *     occurred on.\n   * @param {number=} opt_col The optional column number that the error\n   *     occurred on. Only browsers that have updated to the latest spec will\n   *     include this.\n   * @param {Error=} opt_error The optional actual error object for this\n   *     error that should include the stack. Only browsers that have updated\n   *     to the latest spec will inlude this parameter.\n   * @return {boolean} Whether to prevent the error from reaching the browser.\n   */\n  target.onerror = function(message, url, line, opt_col, opt_error) {\n    if (oldErrorHandler) {\n      oldErrorHandler(message, url, line, opt_col, opt_error);\n    }\n    logFunc({\n      message: message,\n      fileName: url,\n      line: line,\n      lineNumber: line,\n      col: opt_col,\n      error: opt_error\n    });\n    return retVal;\n  };\n};\n\n\n/**\n * Creates a string representing an object and all its properties.\n * @param {Object|null|undefined} obj Object to expose.\n * @param {boolean=} opt_showFn Show the functions as well as the properties,\n *     default is false.\n * @return {string} The string representation of `obj`.\n */\ngoog.debug.expose = function(obj, opt_showFn) {\n  if (typeof obj == 'undefined') {\n    return 'undefined';\n  }\n  if (obj == null) {\n    return 'NULL';\n  }\n  var str = [];\n\n  for (var x in obj) {\n    if (!opt_showFn && goog.isFunction(obj[x])) {\n      continue;\n    }\n    var s = x + ' = ';\n\n    try {\n      s += obj[x];\n    } catch (e) {\n      s += '*** ' + e + ' ***';\n    }\n    str.push(s);\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Creates a string representing a given primitive or object, and for an\n * object, all its properties and nested objects. NOTE: The output will include\n * Uids on all objects that were exposed. Any added Uids will be removed before\n * returning.\n * @param {*} obj Object to expose.\n * @param {boolean=} opt_showFn Also show properties that are functions (by\n *     default, functions are omitted).\n * @return {string} A string representation of `obj`.\n */\ngoog.debug.deepExpose = function(obj, opt_showFn) {\n  var str = [];\n\n  // Track any objects where deepExpose added a Uid, so they can be cleaned up\n  // before return. We do this globally, rather than only on ancestors so that\n  // if the same object appears in the output, you can see it.\n  var uidsToCleanup = [];\n  var ancestorUids = {};\n\n  var helper = function(obj, space) {\n    var nestspace = space + '  ';\n\n    var indentMultiline = function(str) {\n      return str.replace(/\\n/g, '\\n' + space);\n    };\n\n\n    try {\n      if (!goog.isDef(obj)) {\n        str.push('undefined');\n      } else if (goog.isNull(obj)) {\n        str.push('NULL');\n      } else if (goog.isString(obj)) {\n        str.push('\"' + indentMultiline(obj) + '\"');\n      } else if (goog.isFunction(obj)) {\n        str.push(indentMultiline(String(obj)));\n      } else if (goog.isObject(obj)) {\n        // Add a Uid if needed. The struct calls implicitly adds them.\n        if (!goog.hasUid(obj)) {\n          uidsToCleanup.push(obj);\n        }\n        var uid = goog.getUid(obj);\n        if (ancestorUids[uid]) {\n          str.push('*** reference loop detected (id=' + uid + ') ***');\n        } else {\n          ancestorUids[uid] = true;\n          str.push('{');\n          for (var x in obj) {\n            if (!opt_showFn && goog.isFunction(obj[x])) {\n              continue;\n            }\n            str.push('\\n');\n            str.push(nestspace);\n            str.push(x + ' = ');\n            helper(obj[x], nestspace);\n          }\n          str.push('\\n' + space + '}');\n          delete ancestorUids[uid];\n        }\n      } else {\n        str.push(obj);\n      }\n    } catch (e) {\n      str.push('*** ' + e + ' ***');\n    }\n  };\n\n  helper(obj, '');\n\n  // Cleanup any Uids that were added by the deepExpose.\n  for (var i = 0; i < uidsToCleanup.length; i++) {\n    goog.removeUid(uidsToCleanup[i]);\n  }\n\n  return str.join('');\n};\n\n\n/**\n * Recursively outputs a nested array as a string.\n * @param {Array<?>} arr The array.\n * @return {string} String representing nested array.\n */\ngoog.debug.exposeArray = function(arr) {\n  var str = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (goog.isArray(arr[i])) {\n      str.push(goog.debug.exposeArray(arr[i]));\n    } else {\n      str.push(arr[i]);\n    }\n  }\n  return '[ ' + str.join(', ') + ' ]';\n};\n\n\n/**\n * Normalizes the error/exception object between browsers.\n * @param {*} err Raw error object.\n * @return {{\n *    message: (?|undefined),\n *    name: (?|undefined),\n *    lineNumber: (?|undefined),\n *    fileName: (?|undefined),\n *    stack: (?|undefined)\n * }} Normalized error object.\n * @suppress {strictMissingProperties} properties not defined on err\n */\ngoog.debug.normalizeErrorObject = function(err) {\n  var href = goog.getObjectByName('window.location.href');\n  if (err == null) {\n    err = 'Unknown Error of type \"null/undefined\"';\n  }\n  if (goog.isString(err)) {\n    return {\n      'message': err,\n      'name': 'Unknown error',\n      'lineNumber': 'Not available',\n      'fileName': href,\n      'stack': 'Not available'\n    };\n  }\n\n  var lineNumber, fileName;\n  var threwError = false;\n\n  try {\n    lineNumber = err.lineNumber || err.line || 'Not available';\n  } catch (e) {\n    // Firefox 2 sometimes throws an error when accessing 'lineNumber':\n    // Message: Permission denied to get property UnnamedClass.lineNumber\n    lineNumber = 'Not available';\n    threwError = true;\n  }\n\n  try {\n    fileName = err.fileName || err.filename || err.sourceURL ||\n        // $googDebugFname may be set before a call to eval to set the filename\n        // that the eval is supposed to present.\n        goog.global['$googDebugFname'] || href;\n  } catch (e) {\n    // Firefox 2 may also throw an error when accessing 'filename'.\n    fileName = 'Not available';\n    threwError = true;\n  }\n\n  // The IE Error object contains only the name and the message.\n  // The Safari Error object uses the line and sourceURL fields.\n  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||\n      !err.message || !err.name) {\n    var message = err.message;\n    if (message == null) {\n      if (err.constructor && err.constructor instanceof Function) {\n        var ctorName = err.constructor.name ?\n            err.constructor.name :\n            goog.debug.getFunctionName(err.constructor);\n        message = 'Unknown Error of type \"' + ctorName + '\"';\n      } else {\n        message = 'Unknown Error of unknown type';\n      }\n    }\n    return {\n      'message': message,\n      'name': err.name || 'UnknownError',\n      'lineNumber': lineNumber,\n      'fileName': fileName,\n      'stack': err.stack || 'Not available'\n    };\n  }\n\n  // Standards error object\n  // Typed !Object. Should be a subtype of the return type, but it's not.\n  return /** @type {?} */ (err);\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * an extra message.\n * @param {*} err The original thrown error, object, or string.\n * @param {string=} opt_message  optional additional message to add to the\n *     error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceError = function(err, opt_message) {\n  var error;\n  if (!(err instanceof Error)) {\n    error = Error(err);\n    if (Error.captureStackTrace) {\n      // Trim this function off the call stack, if we can.\n      Error.captureStackTrace(error, goog.debug.enhanceError);\n    }\n  } else {\n    error = err;\n  }\n\n  if (!error.stack) {\n    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);\n  }\n  if (opt_message) {\n    // find the first unoccupied 'messageX' property\n    var x = 0;\n    while (error['message' + x]) {\n      ++x;\n    }\n    error['message' + x] = String(opt_message);\n  }\n  return error;\n};\n\n\n/**\n * Converts an object to an Error using the object's toString if it's not\n * already an Error, adds a stacktrace if there isn't one, and optionally adds\n * context to the Error, which is reported by the closure error reporter.\n * @param {*} err The original thrown error, object, or string.\n * @param {!Object<string, string>=} opt_context Key-value context to add to the\n *     Error.\n * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,\n *     it is converted to an Error which is enhanced and returned.\n */\ngoog.debug.enhanceErrorWithContext = function(err, opt_context) {\n  var error = goog.debug.enhanceError(err);\n  if (opt_context) {\n    for (var key in opt_context) {\n      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);\n    }\n  }\n  return error;\n};\n\n\n/**\n * Gets the current stack trace. Simple and iterative - doesn't worry about\n * catching circular references or getting the args.\n * @param {number=} opt_depth Optional maximum depth to trace back to.\n * @return {string} A string with the function names of all functions in the\n *     stack, separated by \\n.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktraceSimple = function(opt_depth) {\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);\n    if (stack) {\n      return stack;\n    }\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties.  Fall-through for legacy browser support.\n  }\n\n  var sb = [];\n  var fn = arguments.callee.caller;\n  var depth = 0;\n\n  while (fn && (!opt_depth || depth < opt_depth)) {\n    sb.push(goog.debug.getFunctionName(fn));\n    sb.push('()\\n');\n\n    try {\n      fn = fn.caller;\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n      break;\n    }\n    depth++;\n    if (depth >= goog.debug.MAX_STACK_DEPTH) {\n      sb.push('[...long stack...]');\n      break;\n    }\n  }\n  if (opt_depth && depth >= opt_depth) {\n    sb.push('[...reached max depth limit...]');\n  } else {\n    sb.push('[end]');\n  }\n\n  return sb.join('');\n};\n\n\n/**\n * Max length of stack to try and output\n * @type {number}\n */\ngoog.debug.MAX_STACK_DEPTH = 50;\n\n\n/**\n * @param {Function} fn The function to start getting the trace from.\n * @return {?string}\n * @private\n */\ngoog.debug.getNativeStackTrace_ = function(fn) {\n  var tempErr = new Error();\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(tempErr, fn);\n    return String(tempErr.stack);\n  } else {\n    // IE10, only adds stack traces when an exception is thrown.\n    try {\n      throw tempErr;\n    } catch (e) {\n      tempErr = e;\n    }\n    var stack = tempErr.stack;\n    if (stack) {\n      return String(stack);\n    }\n  }\n  return null;\n};\n\n\n/**\n * Gets the current stack trace, either starting from the caller or starting\n * from a specified function that's currently on the call stack.\n * @param {?Function=} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @return {string} Stack trace.\n * @suppress {es5Strict}\n */\ngoog.debug.getStacktrace = function(fn) {\n  var stack;\n  if (!goog.debug.FORCE_SLOPPY_STACKS) {\n    // Try to get the stack trace from the environment if it is available.\n    var contextFn = fn || goog.debug.getStacktrace;\n    stack = goog.debug.getNativeStackTrace_(contextFn);\n  }\n  if (!stack) {\n    // NOTE: browsers that have strict mode support also have native \"stack\"\n    // properties. This function will throw in strict mode.\n    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);\n  }\n  return stack;\n};\n\n\n/**\n * Private helper for getStacktrace().\n * @param {?Function} fn If provided, when collecting the stack trace all\n *     frames above the topmost call to this function, including that call,\n *     will be left out of the stack trace.\n * @param {Array<!Function>} visited List of functions visited so far.\n * @return {string} Stack trace starting from function fn.\n * @suppress {es5Strict}\n * @private\n */\ngoog.debug.getStacktraceHelper_ = function(fn, visited) {\n  var sb = [];\n\n  // Circular reference, certain functions like bind seem to cause a recursive\n  // loop so we need to catch circular references\n  if (goog.array.contains(visited, fn)) {\n    sb.push('[...circular reference...]');\n\n    // Traverse the call stack until function not found or max depth is reached\n  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {\n    sb.push(goog.debug.getFunctionName(fn) + '(');\n    var args = fn.arguments;\n    // Args may be null for some special functions such as host objects or eval.\n    for (var i = 0; args && i < args.length; i++) {\n      if (i > 0) {\n        sb.push(', ');\n      }\n      var argDesc;\n      var arg = args[i];\n      switch (typeof arg) {\n        case 'object':\n          argDesc = arg ? 'object' : 'null';\n          break;\n\n        case 'string':\n          argDesc = arg;\n          break;\n\n        case 'number':\n          argDesc = String(arg);\n          break;\n\n        case 'boolean':\n          argDesc = arg ? 'true' : 'false';\n          break;\n\n        case 'function':\n          argDesc = goog.debug.getFunctionName(arg);\n          argDesc = argDesc ? argDesc : '[fn]';\n          break;\n\n        case 'undefined':\n        default:\n          argDesc = typeof arg;\n          break;\n      }\n\n      if (argDesc.length > 40) {\n        argDesc = argDesc.substr(0, 40) + '...';\n      }\n      sb.push(argDesc);\n    }\n    visited.push(fn);\n    sb.push(')\\n');\n\n    try {\n      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));\n    } catch (e) {\n      sb.push('[exception trying to get caller]\\n');\n    }\n\n  } else if (fn) {\n    sb.push('[...long stack...]');\n  } else {\n    sb.push('[end]');\n  }\n  return sb.join('');\n};\n\n\n/**\n * Gets a function name\n * @param {Function} fn Function to get name of.\n * @return {string} Function's name.\n */\ngoog.debug.getFunctionName = function(fn) {\n  if (goog.debug.fnNameCache_[fn]) {\n    return goog.debug.fnNameCache_[fn];\n  }\n\n  // Heuristically determine function name based on code.\n  var functionSource = String(fn);\n  if (!goog.debug.fnNameCache_[functionSource]) {\n    var matches = /function\\s+([^\\(]+)/m.exec(functionSource);\n    if (matches) {\n      var method = matches[1];\n      goog.debug.fnNameCache_[functionSource] = method;\n    } else {\n      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';\n    }\n  }\n\n  return goog.debug.fnNameCache_[functionSource];\n};\n\n\n/**\n * Makes whitespace visible by replacing it with printable characters.\n * This is useful in finding diffrences between the expected and the actual\n * output strings of a testcase.\n * @param {string} string whose whitespace needs to be made visible.\n * @return {string} string whose whitespace is made visible.\n */\ngoog.debug.makeWhitespaceVisible = function(string) {\n  return string.replace(/ /g, '[_]')\n      .replace(/\\f/g, '[f]')\n      .replace(/\\n/g, '[n]\\n')\n      .replace(/\\r/g, '[r]')\n      .replace(/\\t/g, '[t]');\n};\n\n\n/**\n * Returns the type of a value. If a constructor is passed, and a suitable\n * string cannot be found, 'unknown type name' will be returned.\n *\n * <p>Forked rather than moved from {@link goog.asserts.getType_}\n * to avoid adding a dependency to goog.asserts.\n * @param {*} value A constructor, object, or primitive.\n * @return {string} The best display name for the value, or 'unknown type name'.\n */\ngoog.debug.runtimeType = function(value) {\n  if (value instanceof Function) {\n    return value.displayName || value.name || 'unknown type name';\n  } else if (value instanceof Object) {\n    return /** @type {string} */ (value.constructor.displayName) ||\n        value.constructor.name || Object.prototype.toString.call(value);\n  } else {\n    return value === null ? 'null' : typeof value;\n  }\n};\n\n\n/**\n * Hash map for storing function names that have already been looked up.\n * @type {Object}\n * @private\n */\ngoog.debug.fnNameCache_ = {};\n\n\n/**\n * Private internal function to support goog.debug.freeze.\n * @param {T} arg\n * @return {T}\n * @template T\n * @private\n */\ngoog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {\n  return arg;\n};\n\n\n/**\n * Freezes the given object, but only in debug mode (and in browsers that\n * support it).  Note that this is a shallow freeze, so for deeply nested\n * objects it must be called at every level to ensure deep immutability.\n * @param {T} arg\n * @return {T}\n * @template T\n */\ngoog.debug.freeze = function(arg) {\n  // NOTE: this compiles to nothing, but hides the possible side effect of\n  // freezeInternal_ from the compiler so that the entire call can be\n  // removed if the result is not used.\n  return {\n    valueOf: function() {\n      return goog.debug.freezeInternal_(arg);\n    }\n  }.valueOf();\n};\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Browser capability checks for the events package.\n *\n */\n\n\ngoog.provide('goog.events.BrowserFeature');\n\ngoog.require('goog.userAgent');\ngoog.scope(function() {\n\n\n\n/**\n * Enum of browser capabilities.\n * @enum {boolean}\n */\ngoog.events.BrowserFeature = {\n  /**\n   * Whether the button attribute of the event is W3C compliant.  False in\n   * Internet Explorer prior to version 9; document-version dependent.\n   */\n  HAS_W3C_BUTTON:\n      !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),\n\n  /**\n   * Whether the browser supports full W3C event model.\n   */\n  HAS_W3C_EVENT_SUPPORT:\n      !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),\n\n  /**\n   * To prevent default in IE7-8 for certain keydown events we need set the\n   * keyCode to -1.\n   */\n  SET_KEY_CODE_TO_PREVENT_DEFAULT:\n      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),\n\n  /**\n   * Whether the `navigator.onLine` property is supported.\n   */\n  HAS_NAVIGATOR_ONLINE_PROPERTY:\n      !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher('528'),\n\n  /**\n   * Whether HTML5 network online/offline events are supported.\n   */\n  HAS_HTML5_NETWORK_EVENT_SUPPORT:\n      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||\n      goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||\n      goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||\n      goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),\n\n  /**\n   * Whether HTML5 network events fire on document.body, or otherwise the\n   * window.\n   */\n  HTML5_NETWORK_EVENTS_FIRE_ON_BODY:\n      goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||\n      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),\n\n  /**\n   * Whether touch is enabled in the browser.\n   */\n  TOUCH_ENABLED:\n      ('ontouchstart' in goog.global ||\n       !!(goog.global['document'] && document.documentElement &&\n          'ontouchstart' in document.documentElement) ||\n       // IE10 uses non-standard touch events, so it has a different check.\n       !!(goog.global['navigator'] &&\n          (goog.global['navigator']['maxTouchPoints'] ||\n           goog.global['navigator']['msMaxTouchPoints']))),\n\n  /**\n   * Whether addEventListener supports W3C standard pointer events.\n   * http://www.w3.org/TR/pointerevents/\n   */\n  POINTER_EVENTS: ('PointerEvent' in goog.global),\n\n  /**\n   * Whether addEventListener supports MSPointer events (only used in IE10).\n   * http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx\n   * http://msdn.microsoft.com/library/hh673557(v=vs.85).aspx\n   */\n  MSPOINTER_EVENTS:\n      ('MSPointerEvent' in goog.global &&\n       !!(goog.global['navigator'] &&\n          goog.global['navigator']['msPointerEnabled'])),\n\n  /**\n   * Whether addEventListener supports {passive: true}.\n   * https://developers.google.com/web/updates/2016/06/passive-event-listeners\n   */\n  PASSIVE_EVENTS: purify(function() {\n    // If we're in a web worker or other custom environment, we can't tell.\n    if (!goog.global.addEventListener || !Object.defineProperty) {  // IE 8\n      return false;\n    }\n\n    var passive = false;\n    var options = Object.defineProperty({}, 'passive', {\n      get: function() {\n        passive = true;\n      }\n    });\n    try {\n      goog.global.addEventListener('test', goog.nullFunction, options);\n      goog.global.removeEventListener('test', goog.nullFunction, options);\n    } catch (e) {\n    }\n\n    return passive;\n  })\n};\n\n\n/**\n * Tricks Closure Compiler into believing that a function is pure.  The compiler\n * assumes that any `valueOf` function is pure, without analyzing its contents.\n *\n * @param {function(): T} fn\n * @return {T}\n * @template T\n */\nfunction purify(fn) {\n  return ({valueOf: fn}).valueOf();\n}\n});  // goog.scope\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A base class for event objects.\n *\n */\n\n\ngoog.provide('goog.events.Event');\ngoog.provide('goog.events.EventLike');\n\n/**\n * goog.events.Event no longer depends on goog.Disposable. Keep requiring\n * goog.Disposable here to not break projects which assume this dependency.\n * @suppress {extraRequire}\n */\ngoog.require('goog.Disposable');\ngoog.require('goog.events.EventId');\n\n\n/**\n * A typedef for event like objects that are dispatchable via the\n * goog.events.dispatchEvent function. strings are treated as the type for a\n * goog.events.Event. Objects are treated as an extension of a new\n * goog.events.Event with the type property of the object being used as the type\n * of the Event.\n * @typedef {string|Object|goog.events.Event|goog.events.EventId}\n */\ngoog.events.EventLike;\n\n\n\n/**\n * A base class for event objects, so that they can support preventDefault and\n * stopPropagation.\n *\n * @suppress {underscore} Several properties on this class are technically\n *     public, but referencing these properties outside this package is strongly\n *     discouraged.\n *\n * @param {string|!goog.events.EventId} type Event Type.\n * @param {Object=} opt_target Reference to the object that is the target of\n *     this event. It has to implement the `EventTarget` interface\n *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.\n * @constructor\n */\ngoog.events.Event = function(type, opt_target) {\n  /**\n   * Event type.\n   * @type {string}\n   */\n  this.type = type instanceof goog.events.EventId ? String(type) : type;\n\n  /**\n   * TODO(tbreisacher): The type should probably be\n   * EventTarget|goog.events.EventTarget.\n   *\n   * Target of the event.\n   * @type {Object|undefined}\n   */\n  this.target = opt_target;\n\n  /**\n   * Object that had the listener attached.\n   * @type {Object|undefined}\n   */\n  this.currentTarget = this.target;\n\n  /**\n   * Whether to cancel the event in internal capture/bubble processing for IE.\n   * @type {boolean}\n   * @public\n   */\n  this.propagationStopped_ = false;\n\n  /**\n   * Whether the default action has been prevented.\n   * This is a property to match the W3C specification at\n   * {@link http://www.w3.org/TR/DOM-Level-3-Events/\n   * #events-event-type-defaultPrevented}.\n   * Must be treated as read-only outside the class.\n   * @type {boolean}\n   */\n  this.defaultPrevented = false;\n\n  /**\n   * Return value for in internal capture/bubble processing for IE.\n   * @type {boolean}\n   * @public\n   */\n  this.returnValue_ = true;\n};\n\n\n/**\n * Stops event propagation.\n */\ngoog.events.Event.prototype.stopPropagation = function() {\n  this.propagationStopped_ = true;\n};\n\n\n/**\n * Prevents the default action, for example a link redirecting to a url.\n */\ngoog.events.Event.prototype.preventDefault = function() {\n  this.defaultPrevented = true;\n  this.returnValue_ = false;\n};\n\n\n/**\n * Stops the propagation of the event. It is equivalent to\n * `e.stopPropagation()`, but can be used as the callback argument of\n * {@link goog.events.listen} without declaring another function.\n * @param {!goog.events.Event} e An event.\n */\ngoog.events.Event.stopPropagation = function(e) {\n  e.stopPropagation();\n};\n\n\n/**\n * Prevents the default action. It is equivalent to\n * `e.preventDefault()`, but can be used as the callback argument of\n * {@link goog.events.listen} without declaring another function.\n * @param {!goog.events.Event} e An event.\n */\ngoog.events.Event.preventDefault = function(e) {\n  e.preventDefault();\n};\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A patched, standardized event object for browser events.\n *\n * <pre>\n * The patched event object contains the following members:\n * - type           {string}    Event type, e.g. 'click'\n * - target         {Object}    The element that actually triggered the event\n * - currentTarget  {Object}    The element the listener is attached to\n * - relatedTarget  {Object}    For mouseover and mouseout, the previous object\n * - offsetX        {number}    X-coordinate relative to target\n * - offsetY        {number}    Y-coordinate relative to target\n * - clientX        {number}    X-coordinate relative to viewport\n * - clientY        {number}    Y-coordinate relative to viewport\n * - screenX        {number}    X-coordinate relative to the edge of the screen\n * - screenY        {number}    Y-coordinate relative to the edge of the screen\n * - button         {number}    Mouse button. Use isButton() to test.\n * - keyCode        {number}    Key-code\n * - ctrlKey        {boolean}   Was ctrl key depressed\n * - altKey         {boolean}   Was alt key depressed\n * - shiftKey       {boolean}   Was shift key depressed\n * - metaKey        {boolean}   Was meta key depressed\n * - pointerId      {number}    Pointer ID\n * - pointerType    {string}    Pointer type, e.g. 'mouse', 'pen', or 'touch'\n * - defaultPrevented {boolean} Whether the default action has been prevented\n * - state          {Object}    History state object\n *\n * NOTE: The keyCode member contains the raw browser keyCode. For normalized\n * key and character code use {@link goog.events.KeyHandler}.\n * </pre>\n *\n * @author arv@google.com (Erik Arvidsson)\n */\n\ngoog.provide('goog.events.BrowserEvent');\ngoog.provide('goog.events.BrowserEvent.MouseButton');\ngoog.provide('goog.events.BrowserEvent.PointerType');\n\ngoog.require('goog.debug');\ngoog.require('goog.events.BrowserFeature');\ngoog.require('goog.events.Event');\ngoog.require('goog.events.EventType');\ngoog.require('goog.reflect');\ngoog.require('goog.userAgent');\n\n/**\n * @define {boolean} If true, use the layerX and layerY properties of a native\n * browser event over the offsetX and offsetY properties, which cause expensive\n * reflow. If layerX or layerY is not defined, offsetX and offsetY will be used\n * as usual.\n */\ngoog.events.USE_LAYER_XY_AS_OFFSET_XY =\n    goog.define('goog.events.USE_LAYER_XY_AS_OFFSET_XY', false);\n\n/**\n * Accepts a browser event object and creates a patched, cross browser event\n * object.\n * The content of this object will not be initialized if no event object is\n * provided. If this is the case, init() needs to be invoked separately.\n * @param {Event=} opt_e Browser event object.\n * @param {EventTarget=} opt_currentTarget Current target for event.\n * @constructor\n * @extends {goog.events.Event}\n */\ngoog.events.BrowserEvent = function(opt_e, opt_currentTarget) {\n  goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');\n\n  /**\n   * Target that fired the event.\n   * @override\n   * @type {?Node}\n   */\n  this.target = null;\n\n  /**\n   * Node that had the listener attached.\n   * @override\n   * @type {?Node|undefined}\n   */\n  this.currentTarget = null;\n\n  /**\n   * For mouseover and mouseout events, the related object for the event.\n   * @type {?Node}\n   */\n  this.relatedTarget = null;\n\n  /**\n   * X-coordinate relative to target.\n   * @type {number}\n   */\n  this.offsetX = 0;\n\n  /**\n   * Y-coordinate relative to target.\n   * @type {number}\n   */\n  this.offsetY = 0;\n\n  /**\n   * X-coordinate relative to the window.\n   * @type {number}\n   */\n  this.clientX = 0;\n\n  /**\n   * Y-coordinate relative to the window.\n   * @type {number}\n   */\n  this.clientY = 0;\n\n  /**\n   * X-coordinate relative to the monitor.\n   * @type {number}\n   */\n  this.screenX = 0;\n\n  /**\n   * Y-coordinate relative to the monitor.\n   * @type {number}\n   */\n  this.screenY = 0;\n\n  /**\n   * Which mouse button was pressed.\n   * @type {number}\n   */\n  this.button = 0;\n\n  /**\n   * Key of key press.\n   * @type {string}\n   */\n  this.key = '';\n\n  /**\n   * Keycode of key press.\n   * @type {number}\n   */\n  this.keyCode = 0;\n\n  /**\n   * Keycode of key press.\n   * @type {number}\n   */\n  this.charCode = 0;\n\n  /**\n   * Whether control was pressed at time of event.\n   * @type {boolean}\n   */\n  this.ctrlKey = false;\n\n  /**\n   * Whether alt was pressed at time of event.\n   * @type {boolean}\n   */\n  this.altKey = false;\n\n  /**\n   * Whether shift was pressed at time of event.\n   * @type {boolean}\n   */\n  this.shiftKey = false;\n\n  /**\n   * Whether the meta key was pressed at time of event.\n   * @type {boolean}\n   */\n  this.metaKey = false;\n\n  /**\n   * History state object, only set for PopState events where it's a copy of the\n   * state object provided to pushState or replaceState.\n   * @type {?Object}\n   */\n  this.state = null;\n\n  /**\n   * Whether the default platform modifier key was pressed at time of event.\n   * (This is control for all platforms except Mac, where it's Meta.)\n   * @type {boolean}\n   */\n  this.platformModifierKey = false;\n\n  /**\n   * @type {number}\n   */\n  this.pointerId = 0;\n\n  /**\n   * @type {string}\n   */\n  this.pointerType = '';\n\n  /**\n   * The browser event object.\n   * @private {?Event}\n   */\n  this.event_ = null;\n\n  if (opt_e) {\n    this.init(opt_e, opt_currentTarget);\n  }\n};\ngoog.inherits(goog.events.BrowserEvent, goog.events.Event);\n\n\n/**\n * Normalized button constants for the mouse.\n * @enum {number}\n */\ngoog.events.BrowserEvent.MouseButton = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2\n};\n\n\n/**\n * Normalized pointer type constants for pointer events.\n * @enum {string}\n */\ngoog.events.BrowserEvent.PointerType = {\n  MOUSE: 'mouse',\n  PEN: 'pen',\n  TOUCH: 'touch'\n};\n\n\n/**\n * Static data for mapping mouse buttons.\n * @type {!Array<number>}\n * @deprecated Use `goog.events.BrowserEvent.IE_BUTTON_MAP` instead.\n */\ngoog.events.BrowserEvent.IEButtonMap = goog.debug.freeze([\n  1,  // LEFT\n  4,  // MIDDLE\n  2   // RIGHT\n]);\n\n\n/**\n * Static data for mapping mouse buttons.\n * @const {!Array<number>}\n */\ngoog.events.BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;\n\n\n/**\n * Static data for mapping MSPointerEvent types to PointerEvent types.\n * @const {!Object<number, goog.events.BrowserEvent.PointerType>}\n */\ngoog.events.BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({\n  2: goog.events.BrowserEvent.PointerType.TOUCH,\n  3: goog.events.BrowserEvent.PointerType.PEN,\n  4: goog.events.BrowserEvent.PointerType.MOUSE\n});\n\n\n/**\n * Accepts a browser event object and creates a patched, cross browser event\n * object.\n * @param {Event} e Browser event object.\n * @param {EventTarget=} opt_currentTarget Current target for event.\n */\ngoog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {\n  var type = this.type = e.type;\n\n  /**\n   * On touch devices use the first \"changed touch\" as the relevant touch.\n   * @type {?Touch}\n   */\n  var relevantTouch =\n      e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;\n\n  // TODO(nicksantos): Change this.target to type EventTarget.\n  this.target = /** @type {Node} */ (e.target) || e.srcElement;\n\n  // TODO(nicksantos): Change this.currentTarget to type EventTarget.\n  this.currentTarget = /** @type {Node} */ (opt_currentTarget);\n\n  var relatedTarget = /** @type {Node} */ (e.relatedTarget);\n  if (relatedTarget) {\n    // There's a bug in FireFox where sometimes, relatedTarget will be a\n    // chrome element, and accessing any property of it will get a permission\n    // denied exception. See:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780\n    if (goog.userAgent.GECKO) {\n      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {\n        relatedTarget = null;\n      }\n    }\n  } else if (type == goog.events.EventType.MOUSEOVER) {\n    relatedTarget = e.fromElement;\n  } else if (type == goog.events.EventType.MOUSEOUT) {\n    relatedTarget = e.toElement;\n  }\n\n  this.relatedTarget = relatedTarget;\n\n  if (relevantTouch) {\n    this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX :\n                                                         relevantTouch.pageX;\n    this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY :\n                                                         relevantTouch.pageY;\n    this.screenX = relevantTouch.screenX || 0;\n    this.screenY = relevantTouch.screenY || 0;\n  } else {\n    if (goog.events.USE_LAYER_XY_AS_OFFSET_XY) {\n      this.offsetX = (e.layerX !== undefined) ? e.layerX : e.offsetX;\n      this.offsetY = (e.layerY !== undefined) ? e.layerY : e.offsetY;\n    } else {\n      // Webkit emits a lame warning whenever layerX/layerY is accessed.\n      // http://code.google.com/p/chromium/issues/detail?id=101733\n      this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?\n          e.offsetX :\n          e.layerX;\n      this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?\n          e.offsetY :\n          e.layerY;\n    }\n    this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;\n    this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;\n    this.screenX = e.screenX || 0;\n    this.screenY = e.screenY || 0;\n  }\n\n  this.button = e.button;\n\n  this.keyCode = e.keyCode || 0;\n  this.key = e.key || '';\n  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);\n  this.ctrlKey = e.ctrlKey;\n  this.altKey = e.altKey;\n  this.shiftKey = e.shiftKey;\n  this.metaKey = e.metaKey;\n  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;\n  this.pointerId = e.pointerId || 0;\n  this.pointerType = goog.events.BrowserEvent.getPointerType_(e);\n  this.state = e.state;\n  this.event_ = e;\n  if (e.defaultPrevented) {\n    this.preventDefault();\n  }\n};\n\n\n/**\n * Tests to see which button was pressed during the event. This is really only\n * useful in IE and Gecko browsers. And in IE, it's only useful for\n * mousedown/mouseup events, because click only fires for the left mouse button.\n *\n * Safari 2 only reports the left button being clicked, and uses the value '1'\n * instead of 0. Opera only reports a mousedown event for the middle button, and\n * no mouse events for the right button. Opera has default behavior for left and\n * middle click that can only be overridden via a configuration setting.\n *\n * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.\n *\n * @param {goog.events.BrowserEvent.MouseButton} button The button\n *     to test for.\n * @return {boolean} True if button was pressed.\n */\ngoog.events.BrowserEvent.prototype.isButton = function(button) {\n  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {\n    if (this.type == 'click') {\n      return button == goog.events.BrowserEvent.MouseButton.LEFT;\n    } else {\n      return !!(\n          this.event_.button & goog.events.BrowserEvent.IE_BUTTON_MAP[button]);\n    }\n  } else {\n    return this.event_.button == button;\n  }\n};\n\n\n/**\n * Whether this has an \"action\"-producing mouse button.\n *\n * By definition, this includes left-click on windows/linux, and left-click\n * without the ctrl key on Macs.\n *\n * @return {boolean} The result.\n */\ngoog.events.BrowserEvent.prototype.isMouseActionButton = function() {\n  // Webkit does not ctrl+click to be a right-click, so we\n  // normalize it to behave like Gecko and Opera.\n  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&\n      !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);\n};\n\n\n/**\n * @override\n */\ngoog.events.BrowserEvent.prototype.stopPropagation = function() {\n  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);\n  if (this.event_.stopPropagation) {\n    this.event_.stopPropagation();\n  } else {\n    this.event_.cancelBubble = true;\n  }\n};\n\n\n/**\n * @override\n */\ngoog.events.BrowserEvent.prototype.preventDefault = function() {\n  goog.events.BrowserEvent.superClass_.preventDefault.call(this);\n  var be = this.event_;\n  if (!be.preventDefault) {\n    be.returnValue = false;\n    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {\n\n      try {\n        // Most keys can be prevented using returnValue. Some special keys\n        // require setting the keyCode to -1 as well:\n        //\n        // In IE7:\n        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)\n        //\n        // In IE8:\n        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)\n        //\n        // We therefore do this for all function keys as well as when Ctrl key\n        // is pressed.\n        var VK_F1 = 112;\n        var VK_F12 = 123;\n        if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {\n          be.keyCode = -1;\n        }\n      } catch (ex) {\n        // IE throws an 'access denied' exception when trying to change\n        // keyCode in some situations (e.g. srcElement is input[type=file],\n        // or srcElement is an anchor tag rewritten by parent's innerHTML).\n        // Do nothing in this case.\n      }\n    }\n  } else {\n    be.preventDefault();\n  }\n};\n\n\n/**\n * @return {Event} The underlying browser event object.\n */\ngoog.events.BrowserEvent.prototype.getBrowserEvent = function() {\n  return this.event_;\n};\n\n\n/**\n * Extracts the pointer type from the given event.\n * @param {!Event} e\n * @return {string} The pointer type, e.g. 'mouse', 'pen', or 'touch'.\n * @private\n */\ngoog.events.BrowserEvent.getPointerType_ = function(e) {\n  if (goog.isString(e.pointerType)) {\n    return e.pointerType;\n  }\n  // IE10 uses integer codes for pointer type.\n  // https://msdn.microsoft.com/en-us/library/hh772359(v=vs.85).aspx\n  return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || '';\n};\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Event Types.\n *\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\ngoog.provide('goog.events.EventType');\ngoog.provide('goog.events.MouseAsMouseEventType');\ngoog.provide('goog.events.MouseEvents');\ngoog.provide('goog.events.PointerAsMouseEventType');\ngoog.provide('goog.events.PointerAsTouchEventType');\ngoog.provide('goog.events.PointerFallbackEventType');\ngoog.provide('goog.events.PointerTouchFallbackEventType');\n\ngoog.require('goog.events.BrowserFeature');\ngoog.require('goog.userAgent');\n\n\n/**\n * Returns a prefixed event name for the current browser.\n * @param {string} eventName The name of the event.\n * @return {string} The prefixed event name.\n * @suppress {missingRequire|missingProvide}\n * @private\n */\ngoog.events.getVendorPrefixedName_ = function(eventName) {\n  return goog.userAgent.WEBKIT ?\n      'webkit' + eventName :\n      (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :\n                              eventName.toLowerCase());\n};\n\n\n/**\n * Constants for event names.\n * @enum {string}\n */\ngoog.events.EventType = {\n  // Mouse events\n  CLICK: 'click',\n  RIGHTCLICK: 'rightclick',\n  DBLCLICK: 'dblclick',\n  AUXCLICK: 'auxclick',\n  MOUSEDOWN: 'mousedown',\n  MOUSEUP: 'mouseup',\n  MOUSEOVER: 'mouseover',\n  MOUSEOUT: 'mouseout',\n  MOUSEMOVE: 'mousemove',\n  MOUSEENTER: 'mouseenter',\n  MOUSELEAVE: 'mouseleave',\n\n  // Non-existent event; will never fire. This exists as a mouse counterpart to\n  // POINTERCANCEL.\n  MOUSECANCEL: 'mousecancel',\n\n  // Selection events.\n  // https://www.w3.org/TR/selection-api/\n  SELECTIONCHANGE: 'selectionchange',\n  SELECTSTART: 'selectstart',  // IE, Safari, Chrome\n\n  // Wheel events\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n  WHEEL: 'wheel',\n\n  // Key events\n  KEYPRESS: 'keypress',\n  KEYDOWN: 'keydown',\n  KEYUP: 'keyup',\n\n  // Focus\n  BLUR: 'blur',\n  FOCUS: 'focus',\n  DEACTIVATE: 'deactivate',  // IE only\n  FOCUSIN: 'focusin',\n  FOCUSOUT: 'focusout',\n\n  // Forms\n  CHANGE: 'change',\n  RESET: 'reset',\n  SELECT: 'select',\n  SUBMIT: 'submit',\n  INPUT: 'input',\n  PROPERTYCHANGE: 'propertychange',  // IE only\n\n  // Drag and drop\n  DRAGSTART: 'dragstart',\n  DRAG: 'drag',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DRAGLEAVE: 'dragleave',\n  DROP: 'drop',\n  DRAGEND: 'dragend',\n\n  // Touch events\n  // Note that other touch events exist, but we should follow the W3C list here.\n  // http://www.w3.org/TR/touch-events/#list-of-touchevent-types\n  TOUCHSTART: 'touchstart',\n  TOUCHMOVE: 'touchmove',\n  TOUCHEND: 'touchend',\n  TOUCHCANCEL: 'touchcancel',\n\n  // Misc\n  BEFOREUNLOAD: 'beforeunload',\n  CONSOLEMESSAGE: 'consolemessage',\n  CONTEXTMENU: 'contextmenu',\n  DEVICECHANGE: 'devicechange',\n  DEVICEMOTION: 'devicemotion',\n  DEVICEORIENTATION: 'deviceorientation',\n  DOMCONTENTLOADED: 'DOMContentLoaded',\n  ERROR: 'error',\n  HELP: 'help',\n  LOAD: 'load',\n  LOSECAPTURE: 'losecapture',\n  ORIENTATIONCHANGE: 'orientationchange',\n  READYSTATECHANGE: 'readystatechange',\n  RESIZE: 'resize',\n  SCROLL: 'scroll',\n  UNLOAD: 'unload',\n\n  // Media events\n  CANPLAY: 'canplay',\n  CANPLAYTHROUGH: 'canplaythrough',\n  DURATIONCHANGE: 'durationchange',\n  EMPTIED: 'emptied',\n  ENDED: 'ended',\n  LOADEDDATA: 'loadeddata',\n  LOADEDMETADATA: 'loadedmetadata',\n  PAUSE: 'pause',\n  PLAY: 'play',\n  PLAYING: 'playing',\n  RATECHANGE: 'ratechange',\n  SEEKED: 'seeked',\n  SEEKING: 'seeking',\n  STALLED: 'stalled',\n  SUSPEND: 'suspend',\n  TIMEUPDATE: 'timeupdate',\n  VOLUMECHANGE: 'volumechange',\n  WAITING: 'waiting',\n\n  // Media Source Extensions events\n  // https://www.w3.org/TR/media-source/#mediasource-events\n  SOURCEOPEN: 'sourceopen',\n  SOURCEENDED: 'sourceended',\n  SOURCECLOSED: 'sourceclosed',\n  // https://www.w3.org/TR/media-source/#sourcebuffer-events\n  ABORT: 'abort',\n  UPDATE: 'update',\n  UPDATESTART: 'updatestart',\n  UPDATEEND: 'updateend',\n\n  // HTML 5 History events\n  // See http://www.w3.org/TR/html5/browsers.html#event-definitions-0\n  HASHCHANGE: 'hashchange',\n  PAGEHIDE: 'pagehide',\n  PAGESHOW: 'pageshow',\n  POPSTATE: 'popstate',\n\n  // Copy and Paste\n  // Support is limited. Make sure it works on your favorite browser\n  // before using.\n  // http://www.quirksmode.org/dom/events/cutcopypaste.html\n  COPY: 'copy',\n  PASTE: 'paste',\n  CUT: 'cut',\n  BEFORECOPY: 'beforecopy',\n  BEFORECUT: 'beforecut',\n  BEFOREPASTE: 'beforepaste',\n\n  // HTML5 online/offline events.\n  // http://www.w3.org/TR/offline-webapps/#related\n  ONLINE: 'online',\n  OFFLINE: 'offline',\n\n  // HTML 5 worker events\n  MESSAGE: 'message',\n  CONNECT: 'connect',\n\n  // Service Worker Events - ServiceWorkerGlobalScope context\n  // See https://w3c.github.io/ServiceWorker/#execution-context-events\n  // Note: message event defined in worker events section\n  INSTALL: 'install',\n  ACTIVATE: 'activate',\n  FETCH: 'fetch',\n  FOREIGNFETCH: 'foreignfetch',\n  MESSAGEERROR: 'messageerror',\n\n  // Service Worker Events - Document context\n  // See https://w3c.github.io/ServiceWorker/#document-context-events\n  STATECHANGE: 'statechange',\n  UPDATEFOUND: 'updatefound',\n  CONTROLLERCHANGE: 'controllerchange',\n\n  // CSS animation events.\n  /** @suppress {missingRequire} */\n  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),\n  /** @suppress {missingRequire} */\n  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),\n  /** @suppress {missingRequire} */\n  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),\n\n  // CSS transition events. Based on the browser support described at:\n  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility\n  /** @suppress {missingRequire} */\n  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),\n\n  // W3C Pointer Events\n  // http://www.w3.org/TR/pointerevents/\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTERCANCEL: 'pointercancel',\n  POINTERMOVE: 'pointermove',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  GOTPOINTERCAPTURE: 'gotpointercapture',\n  LOSTPOINTERCAPTURE: 'lostpointercapture',\n\n  // IE specific events.\n  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx\n  // Note: these events will be supplanted in IE11.\n  MSGESTURECHANGE: 'MSGestureChange',\n  MSGESTUREEND: 'MSGestureEnd',\n  MSGESTUREHOLD: 'MSGestureHold',\n  MSGESTURESTART: 'MSGestureStart',\n  MSGESTURETAP: 'MSGestureTap',\n  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',\n  MSINERTIASTART: 'MSInertiaStart',\n  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',\n  MSPOINTERCANCEL: 'MSPointerCancel',\n  MSPOINTERDOWN: 'MSPointerDown',\n  MSPOINTERENTER: 'MSPointerEnter',\n  MSPOINTERHOVER: 'MSPointerHover',\n  MSPOINTERLEAVE: 'MSPointerLeave',\n  MSPOINTERMOVE: 'MSPointerMove',\n  MSPOINTEROUT: 'MSPointerOut',\n  MSPOINTEROVER: 'MSPointerOver',\n  MSPOINTERUP: 'MSPointerUp',\n\n  // Native IMEs/input tools events.\n  TEXT: 'text',\n  // The textInput event is supported in IE9+, but only in lower case. All other\n  // browsers use the camel-case event name.\n  TEXTINPUT: goog.userAgent.IE ? 'textinput' : 'textInput',\n  COMPOSITIONSTART: 'compositionstart',\n  COMPOSITIONUPDATE: 'compositionupdate',\n  COMPOSITIONEND: 'compositionend',\n\n  // The beforeinput event is initially only supported in Safari. See\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=342670 for Chrome\n  // implementation tracking.\n  BEFOREINPUT: 'beforeinput',\n\n  // Webview tag events\n  // See https://developer.chrome.com/apps/tags/webview\n  EXIT: 'exit',\n  LOADABORT: 'loadabort',\n  LOADCOMMIT: 'loadcommit',\n  LOADREDIRECT: 'loadredirect',\n  LOADSTART: 'loadstart',\n  LOADSTOP: 'loadstop',\n  RESPONSIVE: 'responsive',\n  SIZECHANGED: 'sizechanged',\n  UNRESPONSIVE: 'unresponsive',\n\n  // HTML5 Page Visibility API.  See details at\n  // `goog.labs.dom.PageVisibilityMonitor`.\n  VISIBILITYCHANGE: 'visibilitychange',\n\n  // LocalStorage event.\n  STORAGE: 'storage',\n\n  // DOM Level 2 mutation events (deprecated).\n  DOMSUBTREEMODIFIED: 'DOMSubtreeModified',\n  DOMNODEINSERTED: 'DOMNodeInserted',\n  DOMNODEREMOVED: 'DOMNodeRemoved',\n  DOMNODEREMOVEDFROMDOCUMENT: 'DOMNodeRemovedFromDocument',\n  DOMNODEINSERTEDINTODOCUMENT: 'DOMNodeInsertedIntoDocument',\n  DOMATTRMODIFIED: 'DOMAttrModified',\n  DOMCHARACTERDATAMODIFIED: 'DOMCharacterDataModified',\n\n  // Print events.\n  BEFOREPRINT: 'beforeprint',\n  AFTERPRINT: 'afterprint',\n\n  // Web app manifest events.\n  BEFOREINSTALLPROMPT: 'beforeinstallprompt',\n  APPINSTALLED: 'appinstalled'\n};\n\n\n/**\n * Returns one of the given pointer fallback event names in order of preference:\n *   1. pointerEventName\n *   2. msPointerEventName\n *   3. fallbackEventName\n * @param {string} pointerEventName\n * @param {string} msPointerEventName\n * @param {string} fallbackEventName\n * @return {string} The supported pointer or fallback (mouse or touch) event\n *     name.\n * @private\n */\ngoog.events.getPointerFallbackEventName_ = function(\n    pointerEventName, msPointerEventName, fallbackEventName) {\n  if (goog.events.BrowserFeature.POINTER_EVENTS) {\n    return pointerEventName;\n  }\n  if (goog.events.BrowserFeature.MSPOINTER_EVENTS) {\n    return msPointerEventName;\n  }\n  return fallbackEventName;\n};\n\n\n/**\n * Constants for pointer event names that fall back to corresponding mouse event\n * names on unsupported platforms. These are intended to be drop-in replacements\n * for corresponding values in `goog.events.EventType`.\n * @enum {string}\n */\ngoog.events.PointerFallbackEventType = {\n  POINTERDOWN: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,\n      goog.events.EventType.MOUSEDOWN),\n  POINTERUP: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,\n      goog.events.EventType.MOUSEUP),\n  POINTERCANCEL: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERCANCEL,\n      goog.events.EventType.MSPOINTERCANCEL,\n      // When falling back to mouse events, there is no MOUSECANCEL equivalent\n      // of POINTERCANCEL. In this case POINTERUP already falls back to MOUSEUP\n      // which represents both UP and CANCEL. POINTERCANCEL does not fall back\n      // to MOUSEUP to prevent listening twice on the same event.\n      goog.events.EventType.MOUSECANCEL),\n  POINTERMOVE: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,\n      goog.events.EventType.MOUSEMOVE),\n  POINTEROVER: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTEROVER, goog.events.EventType.MSPOINTEROVER,\n      goog.events.EventType.MOUSEOVER),\n  POINTEROUT: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTEROUT, goog.events.EventType.MSPOINTEROUT,\n      goog.events.EventType.MOUSEOUT),\n  POINTERENTER: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERENTER, goog.events.EventType.MSPOINTERENTER,\n      goog.events.EventType.MOUSEENTER),\n  POINTERLEAVE: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERLEAVE, goog.events.EventType.MSPOINTERLEAVE,\n      goog.events.EventType.MOUSELEAVE)\n};\n\n\n/**\n * Constants for pointer event names that fall back to corresponding touch event\n * names on unsupported platforms. These are intended to be drop-in replacements\n * for corresponding values in `goog.events.EventType`.\n * @enum {string}\n */\ngoog.events.PointerTouchFallbackEventType = {\n  POINTERDOWN: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,\n      goog.events.EventType.TOUCHSTART),\n  POINTERUP: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,\n      goog.events.EventType.TOUCHEND),\n  POINTERCANCEL: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERCANCEL,\n      goog.events.EventType.MSPOINTERCANCEL, goog.events.EventType.TOUCHCANCEL),\n  POINTERMOVE: goog.events.getPointerFallbackEventName_(\n      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,\n      goog.events.EventType.TOUCHMOVE)\n};\n\n\n/**\n * Mapping of mouse event names to underlying browser event names.\n * @typedef {{\n *     MOUSEDOWN: string,\n *     MOUSEUP: string,\n *     MOUSECANCEL:string,\n *     MOUSEMOVE:string,\n *     MOUSEOVER:string,\n *     MOUSEOUT:string,\n *     MOUSEENTER:string,\n *     MOUSELEAVE: string,\n * }}\n */\ngoog.events.MouseEvents;\n\n\n/**\n * An alias for `goog.events.EventType.MOUSE*` event types that is overridden by\n * corresponding `POINTER*` event types.\n * @const {!goog.events.MouseEvents}\n */\ngoog.events.PointerAsMouseEventType = {\n  MOUSEDOWN: goog.events.PointerFallbackEventType.POINTERDOWN,\n  MOUSEUP: goog.events.PointerFallbackEventType.POINTERUP,\n  MOUSECANCEL: goog.events.PointerFallbackEventType.POINTERCANCEL,\n  MOUSEMOVE: goog.events.PointerFallbackEventType.POINTERMOVE,\n  MOUSEOVER: goog.events.PointerFallbackEventType.POINTEROVER,\n  MOUSEOUT: goog.events.PointerFallbackEventType.POINTEROUT,\n  MOUSEENTER: goog.events.PointerFallbackEventType.POINTERENTER,\n  MOUSELEAVE: goog.events.PointerFallbackEventType.POINTERLEAVE\n};\n\n\n/**\n * An alias for `goog.events.EventType.MOUSE*` event types that continue to use\n * mouse events.\n * @const {!goog.events.MouseEvents}\n */\ngoog.events.MouseAsMouseEventType = {\n  MOUSEDOWN: goog.events.EventType.MOUSEDOWN,\n  MOUSEUP: goog.events.EventType.MOUSEUP,\n  MOUSECANCEL: goog.events.EventType.MOUSECANCEL,\n  MOUSEMOVE: goog.events.EventType.MOUSEMOVE,\n  MOUSEOVER: goog.events.EventType.MOUSEOVER,\n  MOUSEOUT: goog.events.EventType.MOUSEOUT,\n  MOUSEENTER: goog.events.EventType.MOUSEENTER,\n  MOUSELEAVE: goog.events.EventType.MOUSELEAVE\n};\n\n\n/**\n * An alias for `goog.events.EventType.TOUCH*` event types that is overridden by\n * corresponding `POINTER*` event types.\n * @enum {string}\n */\ngoog.events.PointerAsTouchEventType = {\n  TOUCHCANCEL: goog.events.PointerTouchFallbackEventType.POINTERCANCEL,\n  TOUCHEND: goog.events.PointerTouchFallbackEventType.POINTERUP,\n  TOUCHMOVE: goog.events.PointerTouchFallbackEventType.POINTERMOVE,\n  TOUCHSTART: goog.events.PointerTouchFallbackEventType.POINTERDOWN\n};\n","// Copyright 2012 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview An interface for a listenable JavaScript object.\n * @author chrishenry@google.com (Chris Henry)\n */\n\ngoog.provide('goog.events.Listenable');\ngoog.provide('goog.events.ListenableKey');\n\n/** @suppress {extraRequire} */\ngoog.require('goog.events.EventId');\n\ngoog.forwardDeclare('goog.events.EventLike');\ngoog.forwardDeclare('goog.events.EventTarget');\n\n\n\n/**\n * A listenable interface. A listenable is an object with the ability\n * to dispatch/broadcast events to \"event listeners\" registered via\n * listen/listenOnce.\n *\n * The interface allows for an event propagation mechanism similar\n * to one offered by native browser event targets, such as\n * capture/bubble mechanism, stopping propagation, and preventing\n * default actions. Capture/bubble mechanism depends on the ancestor\n * tree constructed via `#getParentEventTarget`; this tree\n * must be directed acyclic graph. The meaning of default action(s)\n * in preventDefault is specific to a particular use case.\n *\n * Implementations that do not support capture/bubble or can not have\n * a parent listenable can simply not implement any ability to set the\n * parent listenable (and have `#getParentEventTarget` return\n * null).\n *\n * Implementation of this class can be used with or independently from\n * goog.events.\n *\n * Implementation must call `#addImplementation(implClass)`.\n *\n * @interface\n * @see goog.events\n * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html\n */\ngoog.events.Listenable = function() {};\n\n\n/**\n * An expando property to indicate that an object implements\n * goog.events.Listenable.\n *\n * See addImplementation/isImplementedBy.\n *\n * @type {string}\n * @const\n */\ngoog.events.Listenable.IMPLEMENTED_BY_PROP =\n    'closure_listenable_' + ((Math.random() * 1e6) | 0);\n\n\n/**\n * Marks a given class (constructor) as an implementation of\n * Listenable, so that we can query that fact at runtime. The class\n * must have already implemented the interface.\n * @param {function(new:goog.events.Listenable,...)} cls The class constructor.\n *     The corresponding class must have already implemented the interface.\n */\ngoog.events.Listenable.addImplementation = function(cls) {\n  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;\n};\n\n\n/**\n * @param {Object} obj The object to check.\n * @return {boolean} Whether a given instance implements Listenable. The\n *     class/superclass of the instance must call addImplementation.\n */\ngoog.events.Listenable.isImplementedBy = function(obj) {\n  return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);\n};\n\n\n/**\n * Adds an event listener. A listener can only be added once to an\n * object and if it is added again the key for the listener is\n * returned. Note that if the existing listener is a one-off listener\n * (registered via listenOnce), it will no longer be a one-off\n * listener after a call to listen().\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\n *     method.\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\n *     (defaults to false).\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {!goog.events.ListenableKey} Unique key for the listener.\n * @template SCOPE,EVENTOBJ\n */\ngoog.events.Listenable.prototype.listen;\n\n\n/**\n * Adds an event listener that is removed automatically after the\n * listener fired once.\n *\n * If an existing listener already exists, listenOnce will do\n * nothing. In particular, if the listener was previously registered\n * via listen(), listenOnce() will not turn the listener into a\n * one-off listener. Similarly, if there is already an existing\n * one-off listener, listenOnce does not modify the listeners (it is\n * still a once listener).\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\n *     method.\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\n *     (defaults to false).\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {!goog.events.ListenableKey} Unique key for the listener.\n * @template SCOPE,EVENTOBJ\n */\ngoog.events.Listenable.prototype.listenOnce;\n\n\n/**\n * Removes an event listener which was added with listen() or listenOnce().\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\n *     method.\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\n *     (defaults to false).\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call\n *     the listener.\n * @return {boolean} Whether any listener was removed.\n * @template SCOPE,EVENTOBJ\n */\ngoog.events.Listenable.prototype.unlisten;\n\n\n/**\n * Removes an event listener which was added with listen() by the key\n * returned by listen().\n *\n * @param {!goog.events.ListenableKey} key The key returned by\n *     listen() or listenOnce().\n * @return {boolean} Whether any listener was removed.\n */\ngoog.events.Listenable.prototype.unlistenByKey;\n\n\n/**\n * Dispatches an event (or event like object) and calls all listeners\n * listening for events of this type. The type of the event is decided by the\n * type property on the event object.\n *\n * If any of the listeners returns false OR calls preventDefault then this\n * function will return false.  If one of the capture listeners calls\n * stopPropagation, then the bubble listeners won't fire.\n *\n * @param {goog.events.EventLike} e Event object.\n * @return {boolean} If anyone called preventDefault on the event object (or\n *     if any of the listeners returns false) this will also return false.\n */\ngoog.events.Listenable.prototype.dispatchEvent;\n\n\n/**\n * Removes all listeners from this listenable. If type is specified,\n * it will only remove listeners of the particular type. otherwise all\n * registered listeners will be removed.\n *\n * @param {string=} opt_type Type of event to remove, default is to\n *     remove all types.\n * @return {number} Number of listeners removed.\n */\ngoog.events.Listenable.prototype.removeAllListeners;\n\n\n/**\n * Returns the parent of this event target to use for capture/bubble\n * mechanism.\n *\n * NOTE(chrishenry): The name reflects the original implementation of\n * custom event target (`goog.events.EventTarget`). We decided\n * that changing the name is not worth it.\n *\n * @return {goog.events.Listenable} The parent EventTarget or null if\n *     there is no parent.\n */\ngoog.events.Listenable.prototype.getParentEventTarget;\n\n\n/**\n * Fires all registered listeners in this listenable for the given\n * type and capture mode, passing them the given eventObject. This\n * does not perform actual capture/bubble. Only implementors of the\n * interface should be using this.\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The type of the\n *     listeners to fire.\n * @param {boolean} capture The capture mode of the listeners to fire.\n * @param {EVENTOBJ} eventObject The event object to fire.\n * @return {boolean} Whether all listeners succeeded without\n *     attempting to prevent default behavior. If any listener returns\n *     false or called goog.events.Event#preventDefault, this returns\n *     false.\n * @template EVENTOBJ\n */\ngoog.events.Listenable.prototype.fireListeners;\n\n\n/**\n * Gets all listeners in this listenable for the given type and\n * capture mode.\n *\n * @param {string|!goog.events.EventId} type The type of the listeners to fire.\n * @param {boolean} capture The capture mode of the listeners to fire.\n * @return {!Array<!goog.events.ListenableKey>} An array of registered\n *     listeners.\n * @template EVENTOBJ\n */\ngoog.events.Listenable.prototype.getListeners;\n\n\n/**\n * Gets the goog.events.ListenableKey for the event or null if no such\n * listener is in use.\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The name of the event\n *     without the 'on' prefix.\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The\n *     listener function to get.\n * @param {boolean} capture Whether the listener is a capturing listener.\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {goog.events.ListenableKey} the found listener or null if not found.\n * @template SCOPE,EVENTOBJ\n */\ngoog.events.Listenable.prototype.getListener;\n\n\n/**\n * Whether there is any active listeners matching the specified\n * signature. If either the type or capture parameters are\n * unspecified, the function will match on the remaining criteria.\n *\n * @param {string|!goog.events.EventId<EVENTOBJ>=} opt_type Event type.\n * @param {boolean=} opt_capture Whether to check for capture or bubble\n *     listeners.\n * @return {boolean} Whether there is any active listeners matching\n *     the requested type and/or capture phase.\n * @template EVENTOBJ\n */\ngoog.events.Listenable.prototype.hasListener;\n\n\n\n/**\n * An interface that describes a single registered listener.\n * @interface\n */\ngoog.events.ListenableKey = function() {};\n\n\n/**\n * Counter used to create a unique key\n * @type {number}\n * @private\n */\ngoog.events.ListenableKey.counter_ = 0;\n\n\n/**\n * Reserves a key to be used for ListenableKey#key field.\n * @return {number} A number to be used to fill ListenableKey#key\n *     field.\n */\ngoog.events.ListenableKey.reserveKey = function() {\n  return ++goog.events.ListenableKey.counter_;\n};\n\n\n/**\n * The source event target.\n * @type {Object|goog.events.Listenable|goog.events.EventTarget}\n */\ngoog.events.ListenableKey.prototype.src;\n\n\n/**\n * The event type the listener is listening to.\n * @type {string}\n */\ngoog.events.ListenableKey.prototype.type;\n\n\n/**\n * The listener function.\n * @type {function(?):?|{handleEvent:function(?):?}|null}\n */\ngoog.events.ListenableKey.prototype.listener;\n\n\n/**\n * Whether the listener works on capture phase.\n * @type {boolean}\n */\ngoog.events.ListenableKey.prototype.capture;\n\n\n/**\n * The 'this' object for the listener function's scope.\n * @type {Object|undefined}\n */\ngoog.events.ListenableKey.prototype.handler;\n\n\n/**\n * A globally unique number to identify the key.\n * @type {number}\n */\ngoog.events.ListenableKey.prototype.key;\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Listener object.\n * @see ../demos/events.html\n */\n\ngoog.provide('goog.events.Listener');\n\ngoog.require('goog.events.ListenableKey');\n\n\n\n/**\n * Simple class that stores information about a listener\n * @param {function(?):?} listener Callback function.\n * @param {Function} proxy Wrapper for the listener that patches the event.\n * @param {EventTarget|goog.events.Listenable} src Source object for\n *     the event.\n * @param {string} type Event type.\n * @param {boolean} capture Whether in capture or bubble phase.\n * @param {Object=} opt_handler Object in whose context to execute the callback.\n * @implements {goog.events.ListenableKey}\n * @constructor\n */\ngoog.events.Listener = function(\n    listener, proxy, src, type, capture, opt_handler) {\n  if (goog.events.Listener.ENABLE_MONITORING) {\n    this.creationStack = new Error().stack;\n  }\n\n  /** @override */\n  this.listener = listener;\n\n  /**\n   * A wrapper over the original listener. This is used solely to\n   * handle native browser events (it is used to simulate the capture\n   * phase and to patch the event object).\n   * @type {Function}\n   */\n  this.proxy = proxy;\n\n  /**\n   * Object or node that callback is listening to\n   * @type {EventTarget|goog.events.Listenable}\n   */\n  this.src = src;\n\n  /**\n   * The event type.\n   * @const {string}\n   */\n  this.type = type;\n\n  /**\n   * Whether the listener is being called in the capture or bubble phase\n   * @const {boolean}\n   */\n  this.capture = !!capture;\n\n  /**\n   * Optional object whose context to execute the listener in\n   * @type {Object|undefined}\n   */\n  this.handler = opt_handler;\n\n  /**\n   * The key of the listener.\n   * @const {number}\n   * @override\n   */\n  this.key = goog.events.ListenableKey.reserveKey();\n\n  /**\n   * Whether to remove the listener after it has been called.\n   * @type {boolean}\n   */\n  this.callOnce = false;\n\n  /**\n   * Whether the listener has been removed.\n   * @type {boolean}\n   */\n  this.removed = false;\n};\n\n\n/**\n * @define {boolean} Whether to enable the monitoring of the\n *     goog.events.Listener instances. Switching on the monitoring is only\n *     recommended for debugging because it has a significant impact on\n *     performance and memory usage. If switched off, the monitoring code\n *     compiles down to 0 bytes.\n */\ngoog.events.Listener.ENABLE_MONITORING =\n    goog.define('goog.events.Listener.ENABLE_MONITORING', false);\n\n\n/**\n * If monitoring the goog.events.Listener instances is enabled, stores the\n * creation stack trace of the Disposable instance.\n * @type {string}\n */\ngoog.events.Listener.prototype.creationStack;\n\n\n/**\n * Marks this listener as removed. This also remove references held by\n * this listener object (such as listener and event source).\n */\ngoog.events.Listener.prototype.markAsRemoved = function() {\n  this.removed = true;\n  this.listener = null;\n  this.proxy = null;\n  this.src = null;\n  this.handler = null;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A map of listeners that provides utility functions to\n * deal with listeners on an event target. Used by\n * `goog.events.EventTarget`.\n *\n * WARNING: Do not use this class from outside goog.events package.\n */\n\ngoog.provide('goog.events.ListenerMap');\n\ngoog.require('goog.array');\ngoog.require('goog.events.Listener');\ngoog.require('goog.object');\n\n\n\n/**\n * Creates a new listener map.\n * @param {EventTarget|goog.events.Listenable} src The src object.\n * @constructor\n * @final\n */\ngoog.events.ListenerMap = function(src) {\n  /** @type {EventTarget|goog.events.Listenable} */\n  this.src = src;\n\n  /**\n   * Maps of event type to an array of listeners.\n   * @type {!Object<string, !Array<!goog.events.Listener>>}\n   */\n  this.listeners = {};\n\n  /**\n   * The count of types in this map that have registered listeners.\n   * @private {number}\n   */\n  this.typeCount_ = 0;\n};\n\n\n/**\n * @return {number} The count of event types in this map that actually\n *     have registered listeners.\n */\ngoog.events.ListenerMap.prototype.getTypeCount = function() {\n  return this.typeCount_;\n};\n\n\n/**\n * @return {number} Total number of registered listeners.\n */\ngoog.events.ListenerMap.prototype.getListenerCount = function() {\n  var count = 0;\n  for (var type in this.listeners) {\n    count += this.listeners[type].length;\n  }\n  return count;\n};\n\n\n/**\n * Adds an event listener. A listener can only be added once to an\n * object and if it is added again the key for the listener is\n * returned.\n *\n * Note that a one-off listener will not change an existing listener,\n * if any. On the other hand a normal listener will change existing\n * one-off listener to become a normal listener.\n *\n * @param {string|!goog.events.EventId} type The listener event type.\n * @param {!Function} listener This listener callback method.\n * @param {boolean} callOnce Whether the listener is a one-off\n *     listener.\n * @param {boolean=} opt_useCapture The capture mode of the listener.\n * @param {Object=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {!goog.events.ListenableKey} Unique key for the listener.\n */\ngoog.events.ListenerMap.prototype.add = function(\n    type, listener, callOnce, opt_useCapture, opt_listenerScope) {\n  var typeStr = type.toString();\n  var listenerArray = this.listeners[typeStr];\n  if (!listenerArray) {\n    listenerArray = this.listeners[typeStr] = [];\n    this.typeCount_++;\n  }\n\n  var listenerObj;\n  var index = goog.events.ListenerMap.findListenerIndex_(\n      listenerArray, listener, opt_useCapture, opt_listenerScope);\n  if (index > -1) {\n    listenerObj = listenerArray[index];\n    if (!callOnce) {\n      // Ensure that, if there is an existing callOnce listener, it is no\n      // longer a callOnce listener.\n      listenerObj.callOnce = false;\n    }\n  } else {\n    listenerObj = new goog.events.Listener(\n        listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);\n    listenerObj.callOnce = callOnce;\n    listenerArray.push(listenerObj);\n  }\n  return listenerObj;\n};\n\n\n/**\n * Removes a matching listener.\n * @param {string|!goog.events.EventId} type The listener event type.\n * @param {!Function} listener This listener callback method.\n * @param {boolean=} opt_useCapture The capture mode of the listener.\n * @param {Object=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {boolean} Whether any listener was removed.\n */\ngoog.events.ListenerMap.prototype.remove = function(\n    type, listener, opt_useCapture, opt_listenerScope) {\n  var typeStr = type.toString();\n  if (!(typeStr in this.listeners)) {\n    return false;\n  }\n\n  var listenerArray = this.listeners[typeStr];\n  var index = goog.events.ListenerMap.findListenerIndex_(\n      listenerArray, listener, opt_useCapture, opt_listenerScope);\n  if (index > -1) {\n    var listenerObj = listenerArray[index];\n    listenerObj.markAsRemoved();\n    goog.array.removeAt(listenerArray, index);\n    if (listenerArray.length == 0) {\n      delete this.listeners[typeStr];\n      this.typeCount_--;\n    }\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Removes the given listener object.\n * @param {!goog.events.ListenableKey} listener The listener to remove.\n * @return {boolean} Whether the listener is removed.\n */\ngoog.events.ListenerMap.prototype.removeByKey = function(listener) {\n  var type = listener.type;\n  if (!(type in this.listeners)) {\n    return false;\n  }\n\n  var removed = goog.array.remove(this.listeners[type], listener);\n  if (removed) {\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\n    if (this.listeners[type].length == 0) {\n      delete this.listeners[type];\n      this.typeCount_--;\n    }\n  }\n  return removed;\n};\n\n\n/**\n * Removes all listeners from this map. If opt_type is provided, only\n * listeners that match the given type are removed.\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\n * @return {number} Number of listeners removed.\n */\ngoog.events.ListenerMap.prototype.removeAll = function(opt_type) {\n  var typeStr = opt_type && opt_type.toString();\n  var count = 0;\n  for (var type in this.listeners) {\n    if (!typeStr || type == typeStr) {\n      var listenerArray = this.listeners[type];\n      for (var i = 0; i < listenerArray.length; i++) {\n        ++count;\n        listenerArray[i].markAsRemoved();\n      }\n      delete this.listeners[type];\n      this.typeCount_--;\n    }\n  }\n  return count;\n};\n\n\n/**\n * Gets all listeners that match the given type and capture mode. The\n * returned array is a copy (but the listener objects are not).\n * @param {string|!goog.events.EventId} type The type of the listeners\n *     to retrieve.\n * @param {boolean} capture The capture mode of the listeners to retrieve.\n * @return {!Array<!goog.events.ListenableKey>} An array of matching\n *     listeners.\n */\ngoog.events.ListenerMap.prototype.getListeners = function(type, capture) {\n  var listenerArray = this.listeners[type.toString()];\n  var rv = [];\n  if (listenerArray) {\n    for (var i = 0; i < listenerArray.length; ++i) {\n      var listenerObj = listenerArray[i];\n      if (listenerObj.capture == capture) {\n        rv.push(listenerObj);\n      }\n    }\n  }\n  return rv;\n};\n\n\n/**\n * Gets the goog.events.ListenableKey for the event or null if no such\n * listener is in use.\n *\n * @param {string|!goog.events.EventId} type The type of the listener\n *     to retrieve.\n * @param {!Function} listener The listener function to get.\n * @param {boolean} capture Whether the listener is a capturing listener.\n * @param {Object=} opt_listenerScope Object in whose scope to call the\n *     listener.\n * @return {goog.events.ListenableKey} the found listener or null if not found.\n */\ngoog.events.ListenerMap.prototype.getListener = function(\n    type, listener, capture, opt_listenerScope) {\n  var listenerArray = this.listeners[type.toString()];\n  var i = -1;\n  if (listenerArray) {\n    i = goog.events.ListenerMap.findListenerIndex_(\n        listenerArray, listener, capture, opt_listenerScope);\n  }\n  return i > -1 ? listenerArray[i] : null;\n};\n\n\n/**\n * Whether there is a matching listener. If either the type or capture\n * parameters are unspecified, the function will match on the\n * remaining criteria.\n *\n * @param {string|!goog.events.EventId=} opt_type The type of the listener.\n * @param {boolean=} opt_capture The capture mode of the listener.\n * @return {boolean} Whether there is an active listener matching\n *     the requested type and/or capture phase.\n */\ngoog.events.ListenerMap.prototype.hasListener = function(\n    opt_type, opt_capture) {\n  var hasType = goog.isDef(opt_type);\n  var typeStr = hasType ? opt_type.toString() : '';\n  var hasCapture = goog.isDef(opt_capture);\n\n  return goog.object.some(this.listeners, function(listenerArray, type) {\n    for (var i = 0; i < listenerArray.length; ++i) {\n      if ((!hasType || listenerArray[i].type == typeStr) &&\n          (!hasCapture || listenerArray[i].capture == opt_capture)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\n\n/**\n * Finds the index of a matching goog.events.Listener in the given\n * listenerArray.\n * @param {!Array<!goog.events.Listener>} listenerArray Array of listener.\n * @param {!Function} listener The listener function.\n * @param {boolean=} opt_useCapture The capture flag for the listener.\n * @param {Object=} opt_listenerScope The listener scope.\n * @return {number} The index of the matching listener within the\n *     listenerArray.\n * @private\n */\ngoog.events.ListenerMap.findListenerIndex_ = function(\n    listenerArray, listener, opt_useCapture, opt_listenerScope) {\n  for (var i = 0; i < listenerArray.length; ++i) {\n    var listenerObj = listenerArray[i];\n    if (!listenerObj.removed && listenerObj.listener == listener &&\n        listenerObj.capture == !!opt_useCapture &&\n        listenerObj.handler == opt_listenerScope) {\n      return i;\n    }\n  }\n  return -1;\n};\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview An event manager for both native browser event\n * targets and custom JavaScript event targets\n * (`goog.events.Listenable`). This provides an abstraction\n * over browsers' event systems.\n *\n * It also provides a simulation of W3C event model's capture phase in\n * Internet Explorer (IE 8 and below). Caveat: the simulation does not\n * interact well with listeners registered directly on the elements\n * (bypassing goog.events) or even with listeners registered via\n * goog.events in a separate JS binary. In these cases, we provide\n * no ordering guarantees.\n *\n * The listeners will receive a \"patched\" event object. Such event object\n * contains normalized values for certain event properties that differs in\n * different browsers.\n *\n * Example usage:\n * <pre>\n * goog.events.listen(myNode, 'click', function(e) { alert('woo') });\n * goog.events.listen(myNode, 'mouseover', mouseHandler, true);\n * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);\n * goog.events.removeAll(myNode);\n * </pre>\n *\n *                                            in IE and event object patching]\n * @author arv@google.com (Erik Arvidsson)\n *\n * @see ../demos/events.html\n * @see ../demos/event-propagation.html\n * @see ../demos/stopevent.html\n */\n\n// IMPLEMENTATION NOTES:\n// goog.events stores an auxiliary data structure on each EventTarget\n// source being listened on. This allows us to take advantage of GC,\n// having the data structure GC'd when the EventTarget is GC'd. This\n// GC behavior is equivalent to using W3C DOM Events directly.\n\ngoog.provide('goog.events');\ngoog.provide('goog.events.CaptureSimulationMode');\ngoog.provide('goog.events.Key');\ngoog.provide('goog.events.ListenableType');\n\ngoog.require('goog.asserts');\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.events.BrowserEvent');\ngoog.require('goog.events.BrowserFeature');\ngoog.require('goog.events.Listenable');\ngoog.require('goog.events.ListenerMap');\n\ngoog.forwardDeclare('goog.debug.ErrorHandler');\ngoog.forwardDeclare('goog.events.EventWrapper');\n\n\n/**\n * @typedef {number|goog.events.ListenableKey}\n */\ngoog.events.Key;\n\n\n/**\n * @typedef {EventTarget|goog.events.Listenable}\n */\ngoog.events.ListenableType;\n\n\n/**\n * Property name on a native event target for the listener map\n * associated with the event target.\n * @private @const {string}\n */\ngoog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);\n\n\n/**\n * String used to prepend to IE event types.\n * @const\n * @private\n */\ngoog.events.onString_ = 'on';\n\n\n/**\n * Map of computed \"on<eventname>\" strings for IE event types. Caching\n * this removes an extra object allocation in goog.events.listen which\n * improves IE6 performance.\n * @const\n * @dict\n * @private\n */\ngoog.events.onStringMap_ = {};\n\n\n/**\n * @enum {number} Different capture simulation mode for IE8-.\n */\ngoog.events.CaptureSimulationMode = {\n  /**\n   * Does not perform capture simulation. Will asserts in IE8- when you\n   * add capture listeners.\n   */\n  OFF_AND_FAIL: 0,\n\n  /**\n   * Does not perform capture simulation, silently ignore capture\n   * listeners.\n   */\n  OFF_AND_SILENT: 1,\n\n  /**\n   * Performs capture simulation.\n   */\n  ON: 2\n};\n\n\n/**\n * @define {number} The capture simulation mode for IE8-. By default,\n *     this is ON.\n */\ngoog.events.CAPTURE_SIMULATION_MODE =\n    goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);\n\n\n/**\n * Estimated count of total native listeners.\n * @private {number}\n */\ngoog.events.listenerCountEstimate_ = 0;\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. A listener can only be added once\n * to an object and if it is added again the key for the listener is\n * returned. Note that if the existing listener is a one-off listener\n * (registered via listenOnce), it will no longer be a one-off\n * listener after a call to listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method, or an object with a handleEvent function.\n *     WARNING: passing an Object is now softly deprecated.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listen = function(src, type, listener, opt_options, opt_handler) {\n  if (opt_options && opt_options.once) {\n    return goog.events.listenOnce(\n        src, type, listener, opt_options, opt_handler);\n  }\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listen(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listen(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ false, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target. A listener can only be added once to an object and if it\n * is added again the key for the listener is returned.\n *\n * Note that a one-off listener will not change an existing listener,\n * if any. On the other hand a normal listener will change existing\n * one-off listener to become a normal listener.\n *\n * @param {EventTarget} src The node to listen to events on.\n * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.\n * @param {!Function} listener Callback function.\n * @param {boolean} callOnce Whether the listener is a one-off\n *     listener or otherwise.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} Unique key for the listener.\n * @template EVENTOBJ\n * @private\n */\ngoog.events.listen_ = function(\n    src, type, listener, callOnce, opt_options, opt_handler) {\n  if (!type) {\n    throw new Error('Invalid event type');\n  }\n\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {\n      goog.asserts.fail('Can not register capture listener in IE8-.');\n      return null;\n    } else if (\n        goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {\n      return null;\n    }\n  }\n\n  var listenerMap = goog.events.getListenerMap_(src);\n  if (!listenerMap) {\n    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =\n        new goog.events.ListenerMap(src);\n  }\n\n  var listenerObj = /** @type {goog.events.Listener} */ (\n      listenerMap.add(type, listener, callOnce, capture, opt_handler));\n\n  // If the listenerObj already has a proxy, it has been set up\n  // previously. We simply return.\n  if (listenerObj.proxy) {\n    return listenerObj;\n  }\n\n  var proxy = goog.events.getProxy();\n  listenerObj.proxy = proxy;\n\n  proxy.src = src;\n  proxy.listener = listenerObj;\n\n  // Attach the proxy through the browser's API\n  if (src.addEventListener) {\n    // Don't pass an object as `capture` if the browser doesn't support that.\n    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {\n      opt_options = capture;\n    }\n    // Don't break tests that expect a boolean.\n    if (opt_options === undefined) opt_options = false;\n    src.addEventListener(type.toString(), proxy, opt_options);\n  } else if (src.attachEvent) {\n    // The else if above used to be an unconditional else. It would call\n    // exception on IE11, spoiling the day of some callers. The previous\n    // incarnation of this code, from 2007, indicates that it replaced an\n    // earlier still version that caused excess allocations on IE6.\n    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);\n  } else if (src.addListener && src.removeListener) {\n    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In\n    // Safari, there is no global for the MediaQueryList constructor, so we just\n    // check whether the object \"looks like\" MediaQueryList.\n    goog.asserts.assert(\n        type === 'change', 'MediaQueryList only has a change event');\n    src.addListener(proxy);\n  } else {\n    throw new Error('addEventListener and attachEvent are unavailable.');\n  }\n\n  goog.events.listenerCountEstimate_++;\n  return listenerObj;\n};\n\n\n/**\n * Helper function for returning a proxy function.\n * @return {!Function} A new or reused function object.\n */\ngoog.events.getProxy = function() {\n  var proxyCallbackFunction = goog.events.handleBrowserEvent_;\n  // Use a local var f to prevent one allocation.\n  var f =\n      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {\n        return proxyCallbackFunction.call(f.src, f.listener, eventObject);\n      } : function(eventObject) {\n        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);\n        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if\n        // there is inline event handler which tries to prevent default (for\n        // example <a href=\"...\" onclick=\"return false\">...</a>) in a\n        // descendant element, the prevent default will be overridden\n        // by this listener if this listener were to return true. Hence, we\n        // return undefined.\n        if (!v) return v;\n      };\n  return f;\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. After the event has fired the event\n * listener is removed from the target.\n *\n * If an existing listener already exists, listenOnce will do\n * nothing. In particular, if the listener was previously registered\n * via listen(), listenOnce() will not turn the listener into a\n * one-off listener. Similarly, if there is already an existing\n * one-off listener, listenOnce does not modify the listeners (it is\n * still a once listener).\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listenOnce = function(\n    src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listenOnce(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ true, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener with a specific event wrapper on a DOM Node or an\n * object that has implemented {@link goog.events.Listenable}. A listener can\n * only be added once to an object.\n *\n * @param {EventTarget|goog.events.Listenable} src The target to\n *     listen to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener\n *     Callback method, or an object with a handleEvent function.\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\n *     false).\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @template T\n */\ngoog.events.listenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.listen(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes an event listener which was added with listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types to unlisten to.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {(boolean|!EventListenerOptions)=} opt_options\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {?boolean} indicating whether the listener was there to remove.\n * @template EVENTOBJ\n */\ngoog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.unlisten(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return false;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    var listenerObj = listenerMap.getListener(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n    if (listenerObj) {\n      return goog.events.unlistenByKey(listenerObj);\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Removes an event listener which was added with listen() by the key\n * returned by listen().\n *\n * @param {goog.events.Key} key The key returned by listen() for this\n *     event listener.\n * @return {boolean} indicating whether the listener was there to remove.\n */\ngoog.events.unlistenByKey = function(key) {\n  // TODO(chrishenry): Remove this check when tests that rely on this\n  // are fixed.\n  if (goog.isNumber(key)) {\n    return false;\n  }\n\n  var listener = key;\n  if (!listener || listener.removed) {\n    return false;\n  }\n\n  var src = listener.src;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);\n  }\n\n  var type = listener.type;\n  var proxy = listener.proxy;\n  if (src.removeEventListener) {\n    src.removeEventListener(type, proxy, listener.capture);\n  } else if (src.detachEvent) {\n    src.detachEvent(goog.events.getOnString_(type), proxy);\n  } else if (src.addListener && src.removeListener) {\n    src.removeListener(proxy);\n  }\n  goog.events.listenerCountEstimate_--;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  // TODO(chrishenry): Try to remove this conditional and execute the\n  // first branch always. This should be safe.\n  if (listenerMap) {\n    listenerMap.removeByKey(listener);\n    if (listenerMap.getTypeCount() == 0) {\n      // Null the src, just because this is simple to do (and useful\n      // for IE <= 7).\n      listenerMap.src = null;\n      // We don't use delete here because IE does not allow delete\n      // on a window object.\n      src[goog.events.LISTENER_MAP_PROP_] = null;\n    }\n  } else {\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\n  }\n\n  return true;\n};\n\n\n/**\n * Removes an event listener which was added with listenWithWrapper().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n */\ngoog.events.unlistenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.unlisten(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes all listeners from an object. You can also optionally\n * remove listeners of a particular type.\n *\n * @param {Object|undefined} obj Object to remove listeners from. Must be an\n *     EventTarget or a goog.events.Listenable.\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\n *     Default is all types.\n * @return {number} Number of listeners removed.\n */\ngoog.events.removeAll = function(obj, opt_type) {\n  // TODO(chrishenry): Change the type of obj to\n  // (!EventTarget|!goog.events.Listenable).\n\n  if (!obj) {\n    return 0;\n  }\n\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {?} */ (obj).removeAllListeners(opt_type);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  if (!listenerMap) {\n    return 0;\n  }\n\n  var count = 0;\n  var typeStr = opt_type && opt_type.toString();\n  for (var type in listenerMap.listeners) {\n    if (!typeStr || type == typeStr) {\n      // Clone so that we don't need to worry about unlistenByKey\n      // changing the content of the ListenerMap.\n      var listeners = listenerMap.listeners[type].concat();\n      for (var i = 0; i < listeners.length; ++i) {\n        if (goog.events.unlistenByKey(listeners[i])) {\n          ++count;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n\n/**\n * Gets the listeners for a given object, type and capture phase.\n *\n * @param {Object} obj Object to get listeners for.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Capture phase?.\n * @return {Array<!goog.events.Listener>} Array of listener objects.\n */\ngoog.events.getListeners = function(obj, type, capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).getListeners(\n        type, capture);\n  } else {\n    if (!obj) {\n      // TODO(chrishenry): We should tighten the API to accept\n      // !EventTarget|goog.events.Listenable, and add an assertion here.\n      return [];\n    }\n\n    var listenerMap = goog.events.getListenerMap_(\n        /** @type {!EventTarget} */ (obj));\n    return listenerMap ? listenerMap.getListeners(type, capture) : [];\n  }\n};\n\n\n/**\n * Gets the goog.events.Listener for the event or null if no such listener is\n * in use.\n *\n * @param {EventTarget|goog.events.Listenable} src The target from\n *     which to get listeners.\n * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to get.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *                            whether the listener is fired during the\n *                            capture or bubble phase of the event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} the found listener or null if not found.\n * @template EVENTOBJ\n */\ngoog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {\n  // TODO(chrishenry): Change type from ?string to string, or add assertion.\n  type = /** @type {string} */ (type);\n  listener = goog.events.wrapListener(listener);\n  var capture = !!opt_capt;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.getListener(type, listener, capture, opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return null;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    return listenerMap.getListener(type, listener, capture, opt_handler);\n  }\n  return null;\n};\n\n\n/**\n * Returns whether an event target has any active listeners matching the\n * specified signature. If either the type or capture parameters are\n * unspecified, the function will match on the remaining criteria.\n *\n * @param {EventTarget|goog.events.Listenable} obj Target to get\n *     listeners for.\n * @param {string|!goog.events.EventId=} opt_type Event type.\n * @param {boolean=} opt_capture Whether to check for capture or bubble-phase\n *     listeners.\n * @return {boolean} Whether an event target has one or more listeners matching\n *     the requested type and/or capture phase.\n */\ngoog.events.hasListener = function(obj, opt_type, opt_capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return obj.hasListener(opt_type, opt_capture);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);\n};\n\n\n/**\n * Provides a nice string showing the normalized event objects public members\n * @param {Object} e Event Object.\n * @return {string} String of the public members of the normalized event object.\n */\ngoog.events.expose = function(e) {\n  var str = [];\n  for (var key in e) {\n    if (e[key] && e[key].id) {\n      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');\n    } else {\n      str.push(key + ' = ' + e[key]);\n    }\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Returns a string with on prepended to the specified type. This is used for IE\n * which expects \"on\" to be prepended. This function caches the string in order\n * to avoid extra allocations in steady state.\n * @param {string} type Event type.\n * @return {string} The type string with 'on' prepended.\n * @private\n */\ngoog.events.getOnString_ = function(type) {\n  if (type in goog.events.onStringMap_) {\n    return goog.events.onStringMap_[type];\n  }\n  return goog.events.onStringMap_[type] = goog.events.onString_ + type;\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase\n *\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n */\ngoog.events.fireListeners = function(obj, type, capture, eventObject) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(\n        type, capture, eventObject);\n  }\n\n  return goog.events.fireListeners_(obj, type, capture, eventObject);\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase.\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n * @private\n */\ngoog.events.fireListeners_ = function(obj, type, capture, eventObject) {\n  /** @type {boolean} */\n  var retval = true;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {EventTarget} */ (obj));\n  if (listenerMap) {\n    // TODO(chrishenry): Original code avoids array creation when there\n    // is no listener, so we do the same. If this optimization turns\n    // out to be not required, we can replace this with\n    // listenerMap.getListeners(type, capture) instead, which is simpler.\n    var listenerArray = listenerMap.listeners[type.toString()];\n    if (listenerArray) {\n      listenerArray = listenerArray.concat();\n      for (var i = 0; i < listenerArray.length; i++) {\n        var listener = listenerArray[i];\n        // We might not have a listener if the listener was removed.\n        if (listener && listener.capture == capture && !listener.removed) {\n          var result = goog.events.fireListener(listener, eventObject);\n          retval = retval && (result !== false);\n        }\n      }\n    }\n  }\n  return retval;\n};\n\n\n/**\n * Fires a listener with a set of arguments\n *\n * @param {goog.events.Listener} listener The listener object to call.\n * @param {Object} eventObject The event object to pass to the listener.\n * @return {*} Result of listener.\n */\ngoog.events.fireListener = function(listener, eventObject) {\n  var listenerFn = listener.listener;\n  var listenerHandler = listener.handler || listener.src;\n\n  if (listener.callOnce) {\n    goog.events.unlistenByKey(listener);\n  }\n  return listenerFn.call(listenerHandler, eventObject);\n};\n\n\n/**\n * Gets the total number of listeners currently in the system.\n * @return {number} Number of listeners.\n * @deprecated This returns estimated count, now that Closure no longer\n * stores a central listener registry. We still return an estimation\n * to keep existing listener-related tests passing. In the near future,\n * this function will be removed.\n */\ngoog.events.getTotalListenerCount = function() {\n  return goog.events.listenerCountEstimate_;\n};\n\n\n/**\n * Dispatches an event (or event like object) and calls all listeners\n * listening for events of this type. The type of the event is decided by the\n * type property on the event object.\n *\n * If any of the listeners returns false OR calls preventDefault then this\n * function will return false.  If one of the capture listeners calls\n * stopPropagation, then the bubble listeners won't fire.\n *\n * @param {goog.events.Listenable} src The event target.\n * @param {goog.events.EventLike} e Event object.\n * @return {boolean} If anyone called preventDefault on the event object (or\n *     if any of the handlers returns false) this will also return false.\n *     If there are no handlers, or if all handlers return true, this returns\n *     true.\n */\ngoog.events.dispatchEvent = function(src, e) {\n  goog.asserts.assert(\n      goog.events.Listenable.isImplementedBy(src),\n      'Can not use goog.events.dispatchEvent with ' +\n          'non-goog.events.Listenable instance.');\n  return src.dispatchEvent(e);\n};\n\n\n/**\n * Installs exception protection for the browser event entry point using the\n * given error handler.\n *\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\n *     protect the entry point.\n */\ngoog.events.protectBrowserEventEntryPoint = function(errorHandler) {\n  goog.events.handleBrowserEvent_ =\n      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);\n};\n\n\n/**\n * Handles an event and dispatches it to the correct listeners. This\n * function is a proxy for the real listener the user specified.\n *\n * @param {goog.events.Listener} listener The listener object.\n * @param {Event=} opt_evt Optional event object that gets passed in via the\n *     native event handlers.\n * @return {*} Result of the event handler.\n * @this {EventTarget} The object or Element that fired the event.\n * @private\n */\ngoog.events.handleBrowserEvent_ = function(listener, opt_evt) {\n  if (listener.removed) {\n    return true;\n  }\n\n  // Synthesize event propagation if the browser does not support W3C\n  // event model.\n  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    var ieEvent = opt_evt ||\n        /** @type {Event} */ (goog.getObjectByName('window.event'));\n    var evt = new goog.events.BrowserEvent(ieEvent, this);\n    /** @type {*} */\n    var retval = true;\n\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.ON) {\n      // If we have not marked this event yet, we should perform capture\n      // simulation.\n      if (!goog.events.isMarkedIeEvent_(ieEvent)) {\n        goog.events.markIeEvent_(ieEvent);\n\n        var ancestors = [];\n        for (var parent = evt.currentTarget; parent;\n             parent = parent.parentNode) {\n          ancestors.push(parent);\n        }\n\n        // Fire capture listeners.\n        var type = listener.type;\n        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;\n             i--) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, true, evt);\n          retval = retval && result;\n        }\n\n        // Fire bubble listeners.\n        //\n        // We can technically rely on IE to perform bubble event\n        // propagation. However, it turns out that IE fires events in\n        // opposite order of attachEvent registration, which broke\n        // some code and tests that rely on the order. (While W3C DOM\n        // Level 2 Events TR leaves the event ordering unspecified,\n        // modern browsers and W3C DOM Level 3 Events Working Draft\n        // actually specify the order as the registration order.)\n        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, false, evt);\n          retval = retval && result;\n        }\n      }\n    } else {\n      retval = goog.events.fireListener(listener, evt);\n    }\n    return retval;\n  }\n\n  // Otherwise, simply fire the listener.\n  return goog.events.fireListener(\n      listener, new goog.events.BrowserEvent(opt_evt, this));\n};\n\n\n/**\n * This is used to mark the IE event object so we do not do the Closure pass\n * twice for a bubbling event.\n * @param {Event} e The IE browser event.\n * @private\n */\ngoog.events.markIeEvent_ = function(e) {\n  // Only the keyCode and the returnValue can be changed. We use keyCode for\n  // non keyboard events.\n  // event.returnValue is a bit more tricky. It is undefined by default. A\n  // boolean false prevents the default action. In a window.onbeforeunload and\n  // the returnValue is non undefined it will be alerted. However, we will only\n  // modify the returnValue for keyboard events. We can get a problem if non\n  // closure events sets the keyCode or the returnValue\n\n  var useReturnValue = false;\n\n  if (e.keyCode == 0) {\n    // We cannot change the keyCode in case that srcElement is input[type=file].\n    // We could test that that is the case but that would allocate 3 objects.\n    // If we use try/catch we will only allocate extra objects in the case of a\n    // failure.\n\n    try {\n      e.keyCode = -1;\n      return;\n    } catch (ex) {\n      useReturnValue = true;\n    }\n  }\n\n  if (useReturnValue ||\n      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {\n    e.returnValue = true;\n  }\n};\n\n\n/**\n * This is used to check if an IE event has already been handled by the Closure\n * system so we do not do the Closure pass twice for a bubbling event.\n * @param {Event} e  The IE browser event.\n * @return {boolean} True if the event object has been marked.\n * @private\n */\ngoog.events.isMarkedIeEvent_ = function(e) {\n  return e.keyCode < 0 || e.returnValue != undefined;\n};\n\n\n/**\n * Counter to create unique event ids.\n * @private {number}\n */\ngoog.events.uniqueIdCounter_ = 0;\n\n\n/**\n * Creates a unique event id.\n *\n * @param {string} identifier The identifier.\n * @return {string} A unique identifier.\n * @idGenerator {unique}\n */\ngoog.events.getUniqueId = function(identifier) {\n  return identifier + '_' + goog.events.uniqueIdCounter_++;\n};\n\n\n/**\n * @param {EventTarget} src The source object.\n * @return {goog.events.ListenerMap} A listener map for the given\n *     source object, or null if none exists.\n * @private\n */\ngoog.events.getListenerMap_ = function(src) {\n  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];\n  // IE serializes the property as well (e.g. when serializing outer\n  // HTML). So we must check that the value is of the correct type.\n  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;\n};\n\n\n/**\n * Expando property for listener function wrapper for Object with\n * handleEvent.\n * @private @const {string}\n */\ngoog.events.LISTENER_WRAPPER_PROP_ =\n    '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * @param {Object|Function} listener The listener function or an\n *     object that contains handleEvent method.\n * @return {!Function} Either the original function or a function that\n *     calls obj.handleEvent. If the same listener is passed to this\n *     function more than once, the same function is guaranteed to be\n *     returned.\n */\ngoog.events.wrapListener = function(listener) {\n  goog.asserts.assert(listener, 'Listener can not be null.');\n\n  if (goog.isFunction(listener)) {\n    return listener;\n  }\n\n  goog.asserts.assert(\n      listener.handleEvent, 'An object listener must have handleEvent method.');\n  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {\n    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {\n      return /** @type {?} */ (listener).handleEvent(e);\n    };\n  }\n  return listener[goog.events.LISTENER_WRAPPER_PROP_];\n};\n\n\n// Register the browser event handler as an entry point, so that\n// it can be monitored for exception handling, etc.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) {\n      goog.events.handleBrowserEvent_ =\n          transformer(goog.events.handleBrowserEvent_);\n    });\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A disposable implementation of a custom\n * listenable/event target. See also: documentation for\n * `goog.events.Listenable`.\n *\n * @author arv@google.com (Erik Arvidsson) [Original implementation]\n * @see ../demos/eventtarget.html\n * @see goog.events.Listenable\n */\n\ngoog.provide('goog.events.EventTarget');\n\ngoog.require('goog.Disposable');\ngoog.require('goog.asserts');\ngoog.require('goog.events');\ngoog.require('goog.events.Event');\ngoog.require('goog.events.Listenable');\ngoog.require('goog.events.ListenerMap');\ngoog.require('goog.object');\n\n\n\n/**\n * An implementation of `goog.events.Listenable` with full W3C\n * EventTarget-like support (capture/bubble mechanism, stopping event\n * propagation, preventing default actions).\n *\n * You may subclass this class to turn your class into a Listenable.\n *\n * Unless propagation is stopped, an event dispatched by an\n * EventTarget will bubble to the parent returned by\n * `getParentEventTarget`. To set the parent, call\n * `setParentEventTarget`. Subclasses that don't support\n * changing the parent can override the setter to throw an error.\n *\n * Example usage:\n * <pre>\n *   var source = new goog.events.EventTarget();\n *   function handleEvent(e) {\n *     alert('Type: ' + e.type + '; Target: ' + e.target);\n *   }\n *   source.listen('foo', handleEvent);\n *   // Or: goog.events.listen(source, 'foo', handleEvent);\n *   ...\n *   source.dispatchEvent('foo');  // will call handleEvent\n *   ...\n *   source.unlisten('foo', handleEvent);\n *   // Or: goog.events.unlisten(source, 'foo', handleEvent);\n * </pre>\n *\n * @constructor\n * @extends {goog.Disposable}\n * @implements {goog.events.Listenable}\n */\ngoog.events.EventTarget = function() {\n  goog.Disposable.call(this);\n\n  /**\n   * Maps of event type to an array of listeners.\n   * @private {!goog.events.ListenerMap}\n   */\n  this.eventTargetListeners_ = new goog.events.ListenerMap(this);\n\n  /**\n   * The object to use for event.target. Useful when mixing in an\n   * EventTarget to another object.\n   * @private {!Object}\n   */\n  this.actualEventTarget_ = this;\n\n  /**\n   * Parent event target, used during event bubbling.\n   *\n   * TODO(chrishenry): Change this to goog.events.Listenable. This\n   * currently breaks people who expect getParentEventTarget to return\n   * goog.events.EventTarget.\n   *\n   * @private {?goog.events.EventTarget}\n   */\n  this.parentEventTarget_ = null;\n};\ngoog.inherits(goog.events.EventTarget, goog.Disposable);\ngoog.events.Listenable.addImplementation(goog.events.EventTarget);\n\n\n/**\n * An artificial cap on the number of ancestors you can have. This is mainly\n * for loop detection.\n * @const {number}\n * @private\n */\ngoog.events.EventTarget.MAX_ANCESTORS_ = 1000;\n\n\n/**\n * Returns the parent of this event target to use for bubbling.\n *\n * @return {goog.events.EventTarget} The parent EventTarget or null if\n *     there is no parent.\n * @override\n */\ngoog.events.EventTarget.prototype.getParentEventTarget = function() {\n  return this.parentEventTarget_;\n};\n\n\n/**\n * Sets the parent of this event target to use for capture/bubble\n * mechanism.\n * @param {goog.events.EventTarget} parent Parent listenable (null if none).\n */\ngoog.events.EventTarget.prototype.setParentEventTarget = function(parent) {\n  this.parentEventTarget_ = parent;\n};\n\n\n/**\n * Adds an event listener to the event target. The same handler can only be\n * added once per the type. Even if you add the same handler multiple times\n * using the same type then it will only be called once when the event is\n * dispatched.\n *\n * @param {string|!goog.events.EventId} type The type of the event to listen for\n * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function\n *     to handle the event. The handler can also be an object that implements\n *     the handleEvent method which takes the event object as argument.\n * @param {boolean=} opt_capture In DOM-compliant browsers, this determines\n *     whether the listener is fired during the capture or bubble phase\n *     of the event.\n * @param {Object=} opt_handlerScope Object in whose scope to call\n *     the listener.\n * @deprecated Use `#listen` instead, when possible. Otherwise, use\n *     `goog.events.listen` if you are passing Object\n *     (instead of Function) as handler.\n */\ngoog.events.EventTarget.prototype.addEventListener = function(\n    type, handler, opt_capture, opt_handlerScope) {\n  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);\n};\n\n\n/**\n * Removes an event listener from the event target. The handler must be the\n * same object as the one added. If the handler has not been added then\n * nothing is done.\n *\n * @param {string} type The type of the event to listen for.\n * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function\n *     to handle the event. The handler can also be an object that implements\n *     the handleEvent method which takes the event object as argument.\n * @param {boolean=} opt_capture In DOM-compliant browsers, this determines\n *     whether the listener is fired during the capture or bubble phase\n *     of the event.\n * @param {Object=} opt_handlerScope Object in whose scope to call\n *     the listener.\n * @deprecated Use `#unlisten` instead, when possible. Otherwise, use\n *     `goog.events.unlisten` if you are passing Object\n *     (instead of Function) as handler.\n */\ngoog.events.EventTarget.prototype.removeEventListener = function(\n    type, handler, opt_capture, opt_handlerScope) {\n  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.dispatchEvent = function(e) {\n  this.assertInitialized_();\n\n  var ancestorsTree, ancestor = this.getParentEventTarget();\n  if (ancestor) {\n    ancestorsTree = [];\n    var ancestorCount = 1;\n    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {\n      ancestorsTree.push(ancestor);\n      goog.asserts.assert(\n          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),\n          'infinite loop');\n    }\n  }\n\n  return goog.events.EventTarget.dispatchEventInternal_(\n      this.actualEventTarget_, e, ancestorsTree);\n};\n\n\n/**\n * Removes listeners from this object.  Classes that extend EventTarget may\n * need to override this method in order to remove references to DOM Elements\n * and additional listeners.\n * @override\n * @protected\n */\ngoog.events.EventTarget.prototype.disposeInternal = function() {\n  goog.events.EventTarget.superClass_.disposeInternal.call(this);\n\n  this.removeAllListeners();\n  this.parentEventTarget_ = null;\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.listen = function(\n    type, listener, opt_useCapture, opt_listenerScope) {\n  this.assertInitialized_();\n  return this.eventTargetListeners_.add(\n      String(type), listener, false /* callOnce */, opt_useCapture,\n      opt_listenerScope);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.listenOnce = function(\n    type, listener, opt_useCapture, opt_listenerScope) {\n  return this.eventTargetListeners_.add(\n      String(type), listener, true /* callOnce */, opt_useCapture,\n      opt_listenerScope);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.unlisten = function(\n    type, listener, opt_useCapture, opt_listenerScope) {\n  return this.eventTargetListeners_.remove(\n      String(type), listener, opt_useCapture, opt_listenerScope);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.unlistenByKey = function(key) {\n  return this.eventTargetListeners_.removeByKey(key);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {\n  // TODO(chrishenry): Previously, removeAllListeners can be called on\n  // uninitialized EventTarget, so we preserve that behavior. We\n  // should remove this when usages that rely on that fact are purged.\n  if (!this.eventTargetListeners_) {\n    return 0;\n  }\n  return this.eventTargetListeners_.removeAll(opt_type);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.fireListeners = function(\n    type, capture, eventObject) {\n  // TODO(chrishenry): Original code avoids array creation when there\n  // is no listener, so we do the same. If this optimization turns\n  // out to be not required, we can replace this with\n  // getListeners(type, capture) instead, which is simpler.\n  var listenerArray = this.eventTargetListeners_.listeners[String(type)];\n  if (!listenerArray) {\n    return true;\n  }\n  listenerArray = listenerArray.concat();\n\n  var rv = true;\n  for (var i = 0; i < listenerArray.length; ++i) {\n    var listener = listenerArray[i];\n    // We might not have a listener if the listener was removed.\n    if (listener && !listener.removed && listener.capture == capture) {\n      var listenerFn = listener.listener;\n      var listenerHandler = listener.handler || listener.src;\n\n      if (listener.callOnce) {\n        this.unlistenByKey(listener);\n      }\n      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;\n    }\n  }\n\n  return rv && eventObject.returnValue_ != false;\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.getListeners = function(type, capture) {\n  return this.eventTargetListeners_.getListeners(String(type), capture);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.getListener = function(\n    type, listener, capture, opt_listenerScope) {\n  return this.eventTargetListeners_.getListener(\n      String(type), listener, capture, opt_listenerScope);\n};\n\n\n/** @override */\ngoog.events.EventTarget.prototype.hasListener = function(\n    opt_type, opt_capture) {\n  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;\n  return this.eventTargetListeners_.hasListener(id, opt_capture);\n};\n\n\n/**\n * Sets the target to be used for `event.target` when firing\n * event. Mainly used for testing. For example, see\n * `goog.testing.events.mixinListenable`.\n * @param {!Object} target The target.\n */\ngoog.events.EventTarget.prototype.setTargetForTesting = function(target) {\n  this.actualEventTarget_ = target;\n};\n\n\n/**\n * Asserts that the event target instance is initialized properly.\n * @private\n */\ngoog.events.EventTarget.prototype.assertInitialized_ = function() {\n  goog.asserts.assert(\n      this.eventTargetListeners_,\n      'Event target is not initialized. Did you call the superclass ' +\n          '(goog.events.EventTarget) constructor?');\n};\n\n\n/**\n * Dispatches the given event on the ancestorsTree.\n *\n * @param {!Object} target The target to dispatch on.\n * @param {goog.events.Event|Object|string} e The event object.\n * @param {Array<goog.events.Listenable>=} opt_ancestorsTree The ancestors\n *     tree of the target, in reverse order from the closest ancestor\n *     to the root event target. May be null if the target has no ancestor.\n * @return {boolean} If anyone called preventDefault on the event object (or\n *     if any of the listeners returns false) this will also return false.\n * @private\n */\ngoog.events.EventTarget.dispatchEventInternal_ = function(\n    target, e, opt_ancestorsTree) {\n  /** @suppress {missingProperties} */\n  var type = e.type || /** @type {string} */ (e);\n\n  // If accepting a string or object, create a custom event object so that\n  // preventDefault and stopPropagation work with the event.\n  if (goog.isString(e)) {\n    e = new goog.events.Event(e, target);\n  } else if (!(e instanceof goog.events.Event)) {\n    var oldEvent = e;\n    e = new goog.events.Event(type, target);\n    goog.object.extend(e, oldEvent);\n  } else {\n    e.target = e.target || target;\n  }\n\n  var rv = true, currentTarget;\n\n  // Executes all capture listeners on the ancestors, if any.\n  if (opt_ancestorsTree) {\n    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0;\n         i--) {\n      currentTarget = e.currentTarget = opt_ancestorsTree[i];\n      rv = currentTarget.fireListeners(type, true, e) && rv;\n    }\n  }\n\n  // Executes capture and bubble listeners on the target.\n  if (!e.propagationStopped_) {\n    currentTarget = /** @type {?} */ (e.currentTarget = target);\n    rv = currentTarget.fireListeners(type, true, e) && rv;\n    if (!e.propagationStopped_) {\n      rv = currentTarget.fireListeners(type, false, e) && rv;\n    }\n  }\n\n  // Executes all bubble listeners on the ancestors, if any.\n  if (opt_ancestorsTree) {\n    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {\n      currentTarget = e.currentTarget = opt_ancestorsTree[i];\n      rv = currentTarget.fireListeners(type, false, e) && rv;\n    }\n  }\n\n  return rv;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A timer class to which other classes and objects can listen on.\n * This is only an abstraction above `setInterval`.\n *\n * @see ../demos/timers.html\n */\n\ngoog.provide('goog.Timer');\n\ngoog.require('goog.Promise');\ngoog.require('goog.events.EventTarget');\n\n\n\n/**\n * Class for handling timing events.\n *\n * @param {number=} opt_interval Number of ms between ticks (default: 1ms).\n * @param {Object=} opt_timerObject  An object that has `setTimeout`,\n *     `setInterval`, `clearTimeout` and `clearInterval`\n *     (e.g., `window`).\n * @constructor\n * @extends {goog.events.EventTarget}\n */\ngoog.Timer = function(opt_interval, opt_timerObject) {\n  goog.events.EventTarget.call(this);\n\n  /**\n   * Number of ms between ticks\n   * @private {number}\n   */\n  this.interval_ = opt_interval || 1;\n\n  /**\n   * An object that implements `setTimeout`, `setInterval`,\n   * `clearTimeout` and `clearInterval`. We default to the window\n   * object. Changing this on {@link goog.Timer.prototype} changes the object\n   * for all timer instances which can be useful if your environment has some\n   * other implementation of timers than the `window` object.\n   * @private {{setTimeout:!Function, clearTimeout:!Function}}\n   */\n  this.timerObject_ = /** @type {{setTimeout, clearTimeout}} */ (\n      opt_timerObject || goog.Timer.defaultTimerObject);\n\n  /**\n   * Cached `tick_` bound to the object for later use in the timer.\n   * @private {Function}\n   * @const\n   */\n  this.boundTick_ = goog.bind(this.tick_, this);\n\n  /**\n   * Firefox browser often fires the timer event sooner (sometimes MUCH sooner)\n   * than the requested timeout. So we compare the time to when the event was\n   * last fired, and reschedule if appropriate. See also\n   * {@link goog.Timer.intervalScale}.\n   * @private {number}\n   */\n  this.last_ = goog.now();\n};\ngoog.inherits(goog.Timer, goog.events.EventTarget);\n\n\n/**\n * Maximum timeout value.\n *\n * Timeout values too big to fit into a signed 32-bit integer may cause overflow\n * in FF, Safari, and Chrome, resulting in the timeout being scheduled\n * immediately. It makes more sense simply not to schedule these timeouts, since\n * 24.8 days is beyond a reasonable expectation for the browser to stay open.\n *\n * @private {number}\n * @const\n */\ngoog.Timer.MAX_TIMEOUT_ = 2147483647;\n\n\n/**\n * A timer ID that cannot be returned by any known implementation of\n * `window.setTimeout`. Passing this value to `window.clearTimeout`\n * should therefore be a no-op.\n *\n * @private {number}\n * @const\n */\ngoog.Timer.INVALID_TIMEOUT_ID_ = -1;\n\n\n/**\n * Whether this timer is enabled\n * @type {boolean}\n */\ngoog.Timer.prototype.enabled = false;\n\n\n/**\n * An object that implements `setTimeout`, `setInterval`,\n * `clearTimeout` and `clearInterval`. We default to the global\n * object. Changing `goog.Timer.defaultTimerObject` changes the object for\n * all timer instances which can be useful if your environment has some other\n * implementation of timers you'd like to use.\n * @type {{setTimeout, clearTimeout}}\n */\ngoog.Timer.defaultTimerObject = goog.global;\n\n\n/**\n * Variable that controls the timer error correction. If the timer is called\n * before the requested interval times `intervalScale`, which often\n * happens on Mozilla, the timer is rescheduled.\n * @see {@link #last_}\n * @type {number}\n */\ngoog.Timer.intervalScale = 0.8;\n\n\n/**\n * Variable for storing the result of `setInterval`.\n * @private {?number}\n */\ngoog.Timer.prototype.timer_ = null;\n\n\n/**\n * Gets the interval of the timer.\n * @return {number} interval Number of ms between ticks.\n */\ngoog.Timer.prototype.getInterval = function() {\n  return this.interval_;\n};\n\n\n/**\n * Sets the interval of the timer.\n * @param {number} interval Number of ms between ticks.\n */\ngoog.Timer.prototype.setInterval = function(interval) {\n  this.interval_ = interval;\n  if (this.timer_ && this.enabled) {\n    // Stop and then start the timer to reset the interval.\n    this.stop();\n    this.start();\n  } else if (this.timer_) {\n    this.stop();\n  }\n};\n\n\n/**\n * Callback for the `setTimeout` used by the timer.\n * @private\n */\ngoog.Timer.prototype.tick_ = function() {\n  if (this.enabled) {\n    var elapsed = goog.now() - this.last_;\n    if (elapsed > 0 && elapsed < this.interval_ * goog.Timer.intervalScale) {\n      this.timer_ = this.timerObject_.setTimeout(\n          this.boundTick_, this.interval_ - elapsed);\n      return;\n    }\n\n    // Prevents setInterval from registering a duplicate timeout when called\n    // in the timer event handler.\n    if (this.timer_) {\n      this.timerObject_.clearTimeout(this.timer_);\n      this.timer_ = null;\n    }\n\n    this.dispatchTick();\n    // The timer could be stopped in the timer event handler.\n    if (this.enabled) {\n      // Stop and start to ensure there is always only one timeout even if\n      // start is called in the timer event handler.\n      this.stop();\n      this.start();\n    }\n  }\n};\n\n\n/**\n * Dispatches the TICK event. This is its own method so subclasses can override.\n */\ngoog.Timer.prototype.dispatchTick = function() {\n  this.dispatchEvent(goog.Timer.TICK);\n};\n\n\n/**\n * Starts the timer.\n */\ngoog.Timer.prototype.start = function() {\n  this.enabled = true;\n\n  // If there is no interval already registered, start it now\n  if (!this.timer_) {\n    // IMPORTANT!\n    // window.setInterval in FireFox has a bug - it fires based on\n    // absolute time, rather than on relative time. What this means\n    // is that if a computer is sleeping/hibernating for 24 hours\n    // and the timer interval was configured to fire every 1000ms,\n    // then after the PC wakes up the timer will fire, in rapid\n    // succession, 3600*24 times.\n    // This bug is described here and is already fixed, but it will\n    // take time to propagate, so for now I am switching this over\n    // to setTimeout logic.\n    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643\n    //\n    this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_);\n    this.last_ = goog.now();\n  }\n};\n\n\n/**\n * Stops the timer.\n */\ngoog.Timer.prototype.stop = function() {\n  this.enabled = false;\n  if (this.timer_) {\n    this.timerObject_.clearTimeout(this.timer_);\n    this.timer_ = null;\n  }\n};\n\n\n/** @override */\ngoog.Timer.prototype.disposeInternal = function() {\n  goog.Timer.superClass_.disposeInternal.call(this);\n  this.stop();\n  delete this.timerObject_;\n};\n\n\n/**\n * Constant for the timer's event type.\n * @const\n */\ngoog.Timer.TICK = 'tick';\n\n\n/**\n * Calls the given function once, after the optional pause.\n * <p>\n * The function is always called asynchronously, even if the delay is 0. This\n * is a common trick to schedule a function to run after a batch of browser\n * event processing.\n *\n * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function\n *     or object that has a handleEvent method.\n * @param {number=} opt_delay Milliseconds to wait; default is 0.\n * @param {SCOPE=} opt_handler Object in whose scope to call the listener.\n * @return {number} A handle to the timer ID.\n * @template SCOPE\n */\ngoog.Timer.callOnce = function(listener, opt_delay, opt_handler) {\n  if (goog.isFunction(listener)) {\n    if (opt_handler) {\n      listener = goog.bind(listener, opt_handler);\n    }\n  } else if (listener && typeof listener.handleEvent == 'function') {\n    // using typeof to prevent strict js warning\n    listener = goog.bind(listener.handleEvent, listener);\n  } else {\n    throw new Error('Invalid listener argument');\n  }\n\n  if (Number(opt_delay) > goog.Timer.MAX_TIMEOUT_) {\n    // Timeouts greater than MAX_INT return immediately due to integer\n    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don't\n    // schedule anything at all.\n    return goog.Timer.INVALID_TIMEOUT_ID_;\n  } else {\n    return goog.Timer.defaultTimerObject.setTimeout(listener, opt_delay || 0);\n  }\n};\n\n\n/**\n * Clears a timeout initiated by {@link #callOnce}.\n * @param {?number} timerId A timer ID.\n */\ngoog.Timer.clear = function(timerId) {\n  goog.Timer.defaultTimerObject.clearTimeout(timerId);\n};\n\n\n/**\n * @param {number} delay Milliseconds to wait.\n * @param {(RESULT|goog.Thenable<RESULT>|Thenable)=} opt_result The value\n *     with which the promise will be resolved.\n * @return {!goog.Promise<RESULT>} A promise that will be resolved after\n *     the specified delay, unless it is canceled first.\n * @template RESULT\n */\ngoog.Timer.promise = function(delay, opt_result) {\n  var timerKey = null;\n  return new goog\n      .Promise(function(resolve, reject) {\n        timerKey =\n            goog.Timer.callOnce(function() { resolve(opt_result); }, delay);\n        if (timerKey == goog.Timer.INVALID_TIMEOUT_ID_) {\n          reject(new Error('Failed to schedule timer.'));\n        }\n      })\n      .thenCatch(function(error) {\n        // Clear the timer. The most likely reason is \"cancel\" signal.\n        goog.Timer.clear(timerKey);\n        throw error;\n      });\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Generics method for collection-like classes and objects.\n *\n * @author arv@google.com (Erik Arvidsson)\n *\n * This file contains functions to work with collections. It supports using\n * Map, Set, Array and Object and other classes that implement collection-like\n * methods.\n * @suppress {strictMissingProperties}\n */\n\n\ngoog.provide('goog.structs');\n\ngoog.require('goog.array');\ngoog.require('goog.object');\n\n\n// We treat an object as a dictionary if it has getKeys or it is an object that\n// isn't arrayLike.\n\n\n/**\n * Returns the number of values in the collection-like object.\n * @param {Object} col The collection-like object.\n * @return {number} The number of values in the collection-like object.\n */\ngoog.structs.getCount = function(col) {\n  if (col.getCount && typeof col.getCount == 'function') {\n    return col.getCount();\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return col.length;\n  }\n  return goog.object.getCount(col);\n};\n\n\n/**\n * Returns the values of the collection-like object.\n * @param {Object} col The collection-like object.\n * @return {!Array<?>} The values in the collection-like object.\n */\ngoog.structs.getValues = function(col) {\n  if (col.getValues && typeof col.getValues == 'function') {\n    return col.getValues();\n  }\n  if (goog.isString(col)) {\n    return col.split('');\n  }\n  if (goog.isArrayLike(col)) {\n    var rv = [];\n    var l = col.length;\n    for (var i = 0; i < l; i++) {\n      rv.push(col[i]);\n    }\n    return rv;\n  }\n  return goog.object.getValues(col);\n};\n\n\n/**\n * Returns the keys of the collection. Some collections have no notion of\n * keys/indexes and this function will return undefined in those cases.\n * @param {Object} col The collection-like object.\n * @return {!Array|undefined} The keys in the collection.\n */\ngoog.structs.getKeys = function(col) {\n  if (col.getKeys && typeof col.getKeys == 'function') {\n    return col.getKeys();\n  }\n  // if we have getValues but no getKeys we know this is a key-less collection\n  if (col.getValues && typeof col.getValues == 'function') {\n    return undefined;\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    var rv = [];\n    var l = col.length;\n    for (var i = 0; i < l; i++) {\n      rv.push(i);\n    }\n    return rv;\n  }\n\n  return goog.object.getKeys(col);\n};\n\n\n/**\n * Whether the collection contains the given value. This is O(n) and uses\n * equals (==) to test the existence.\n * @param {Object} col The collection-like object.\n * @param {*} val The value to check for.\n * @return {boolean} True if the map contains the value.\n */\ngoog.structs.contains = function(col, val) {\n  if (col.contains && typeof col.contains == 'function') {\n    return col.contains(val);\n  }\n  if (col.containsValue && typeof col.containsValue == 'function') {\n    return col.containsValue(val);\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.contains(/** @type {!Array<?>} */ (col), val);\n  }\n  return goog.object.containsValue(col, val);\n};\n\n\n/**\n * Whether the collection is empty.\n * @param {Object} col The collection-like object.\n * @return {boolean} True if empty.\n */\ngoog.structs.isEmpty = function(col) {\n  if (col.isEmpty && typeof col.isEmpty == 'function') {\n    return col.isEmpty();\n  }\n\n  // We do not use goog.string.isEmptyOrWhitespace because here we treat the\n  // string as\n  // collection and as such even whitespace matters\n\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.isEmpty(/** @type {!Array<?>} */ (col));\n  }\n  return goog.object.isEmpty(col);\n};\n\n\n/**\n * Removes all the elements from the collection.\n * @param {Object} col The collection-like object.\n */\ngoog.structs.clear = function(col) {\n  // NOTE(arv): This should not contain strings because strings are immutable\n  if (col.clear && typeof col.clear == 'function') {\n    col.clear();\n  } else if (goog.isArrayLike(col)) {\n    goog.array.clear(/** @type {IArrayLike<?>} */ (col));\n  } else {\n    goog.object.clear(col);\n  }\n};\n\n\n/**\n * Calls a function for each value in a collection. The function takes\n * three arguments; the value, the key and the collection.\n *\n * @param {S} col The collection-like object.\n * @param {function(this:T,?,?,S):?} f The function to call for every value.\n *     This function takes\n *     3 arguments (the value, the key or undefined if the collection has no\n *     notion of keys, and the collection) and the return value is irrelevant.\n * @param {T=} opt_obj The object to be used as the value of 'this'\n *     within `f`.\n * @template T,S\n * @deprecated Use a more specific method, e.g. goog.array.forEach,\n *     goog.object.forEach, or for-of.\n */\ngoog.structs.forEach = function(col, f, opt_obj) {\n  if (col.forEach && typeof col.forEach == 'function') {\n    col.forEach(f, opt_obj);\n  } else if (goog.isArrayLike(col) || goog.isString(col)) {\n    goog.array.forEach(/** @type {!Array<?>} */ (col), f, opt_obj);\n  } else {\n    var keys = goog.structs.getKeys(col);\n    var values = goog.structs.getValues(col);\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n      f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col);\n    }\n  }\n};\n\n\n/**\n * Calls a function for every value in the collection. When a call returns true,\n * adds the value to a new collection (Array is returned by default).\n *\n * @param {S} col The collection-like object.\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\n *     value. This function takes\n *     3 arguments (the value, the key or undefined if the collection has no\n *     notion of keys, and the collection) and should return a Boolean. If the\n *     return value is true the value is added to the result collection. If it\n *     is false the value is not included.\n * @param {T=} opt_obj The object to be used as the value of 'this'\n *     within `f`.\n * @return {!Object|!Array<?>} A new collection where the passed values are\n *     present. If col is a key-less collection an array is returned.  If col\n *     has keys and values a plain old JS object is returned.\n * @template T,S\n */\ngoog.structs.filter = function(col, f, opt_obj) {\n  if (typeof col.filter == 'function') {\n    return col.filter(f, opt_obj);\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.filter(/** @type {!Array<?>} */ (col), f, opt_obj);\n  }\n\n  var rv;\n  var keys = goog.structs.getKeys(col);\n  var values = goog.structs.getValues(col);\n  var l = values.length;\n  if (keys) {\n    rv = {};\n    for (var i = 0; i < l; i++) {\n      if (f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col)) {\n        rv[keys[i]] = values[i];\n      }\n    }\n  } else {\n    // We should not use goog.array.filter here since we want to make sure that\n    // the index is undefined as well as make sure that col is passed to the\n    // function.\n    rv = [];\n    for (var i = 0; i < l; i++) {\n      if (f.call(opt_obj, values[i], undefined, col)) {\n        rv.push(values[i]);\n      }\n    }\n  }\n  return rv;\n};\n\n\n/**\n * Calls a function for every value in the collection and adds the result into a\n * new collection (defaults to creating a new Array).\n *\n * @param {S} col The collection-like object.\n * @param {function(this:T,?,?,S):V} f The function to call for every value.\n *     This function takes 3 arguments (the value, the key or undefined if the\n *     collection has no notion of keys, and the collection) and should return\n *     something. The result will be used as the value in the new collection.\n * @param {T=} opt_obj  The object to be used as the value of 'this'\n *     within `f`.\n * @return {!Object<V>|!Array<V>} A new collection with the new values.  If\n *     col is a key-less collection an array is returned.  If col has keys and\n *     values a plain old JS object is returned.\n * @template T,S,V\n */\ngoog.structs.map = function(col, f, opt_obj) {\n  if (typeof col.map == 'function') {\n    return col.map(f, opt_obj);\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.map(/** @type {!Array<?>} */ (col), f, opt_obj);\n  }\n\n  var rv;\n  var keys = goog.structs.getKeys(col);\n  var values = goog.structs.getValues(col);\n  var l = values.length;\n  if (keys) {\n    rv = {};\n    for (var i = 0; i < l; i++) {\n      rv[keys[i]] = f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col);\n    }\n  } else {\n    // We should not use goog.array.map here since we want to make sure that\n    // the index is undefined as well as make sure that col is passed to the\n    // function.\n    rv = [];\n    for (var i = 0; i < l; i++) {\n      rv[i] = f.call(/** @type {?} */ (opt_obj), values[i], undefined, col);\n    }\n  }\n  return rv;\n};\n\n\n/**\n * Calls f for each value in a collection. If any call returns true this returns\n * true (without checking the rest). If all returns false this returns false.\n *\n * @param {S} col The collection-like object.\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\n *     value. This function takes 3 arguments (the value, the key or undefined\n *     if the collection has no notion of keys, and the collection) and should\n *     return a boolean.\n * @param {T=} opt_obj  The object to be used as the value of 'this'\n *     within `f`.\n * @return {boolean} True if any value passes the test.\n * @template T,S\n */\ngoog.structs.some = function(col, f, opt_obj) {\n  if (typeof col.some == 'function') {\n    return col.some(f, opt_obj);\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.some(/** @type {!Array<?>} */ (col), f, opt_obj);\n  }\n  var keys = goog.structs.getKeys(col);\n  var values = goog.structs.getValues(col);\n  var l = values.length;\n  for (var i = 0; i < l; i++) {\n    if (f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Calls f for each value in a collection. If all calls return true this return\n * true this returns true. If any returns false this returns false at this point\n *  and does not continue to check the remaining values.\n *\n * @param {S} col The collection-like object.\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\n *     value. This function takes 3 arguments (the value, the key or\n *     undefined if the collection has no notion of keys, and the collection)\n *     and should return a boolean.\n * @param {T=} opt_obj  The object to be used as the value of 'this'\n *     within `f`.\n * @return {boolean} True if all key-value pairs pass the test.\n * @template T,S\n */\ngoog.structs.every = function(col, f, opt_obj) {\n  if (typeof col.every == 'function') {\n    return col.every(f, opt_obj);\n  }\n  if (goog.isArrayLike(col) || goog.isString(col)) {\n    return goog.array.every(/** @type {!Array<?>} */ (col), f, opt_obj);\n  }\n  var keys = goog.structs.getKeys(col);\n  var values = goog.structs.getValues(col);\n  var l = values.length;\n  for (var i = 0; i < l; i++) {\n    if (!f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {\n      return false;\n    }\n  }\n  return true;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Datastructure: Hash Map.\n *\n * @author arv@google.com (Erik Arvidsson)\n *\n * This file contains an implementation of a Map structure. It implements a lot\n * of the methods used in goog.structs so those functions work on hashes. This\n * is best suited for complex key types. For simple keys such as numbers and\n * strings consider using the lighter-weight utilities in goog.object.\n */\n\n\ngoog.provide('goog.structs.Map');\n\ngoog.require('goog.iter.Iterator');\ngoog.require('goog.iter.StopIteration');\n\n\n\n/**\n * Class for Hash Map datastructure.\n * @param {*=} opt_map Map or Object to initialize the map with.\n * @param {...*} var_args If 2 or more arguments are present then they\n *     will be used as key-value pairs.\n * @constructor\n * @template K, V\n * @deprecated This type is misleading: use ES6 Map instead.\n */\ngoog.structs.Map = function(opt_map, var_args) {\n\n  /**\n   * Underlying JS object used to implement the map.\n   * @private {!Object}\n   */\n  this.map_ = {};\n\n  /**\n   * An array of keys. This is necessary for two reasons:\n   *   1. Iterating the keys using for (var key in this.map_) allocates an\n   *      object for every key in IE which is really bad for IE6 GC perf.\n   *   2. Without a side data structure, we would need to escape all the keys\n   *      as that would be the only way we could tell during iteration if the\n   *      key was an internal key or a property of the object.\n   *\n   * This array can contain deleted keys so it's necessary to check the map\n   * as well to see if the key is still in the map (this doesn't require a\n   * memory allocation in IE).\n   * @private {!Array<string>}\n   */\n  this.keys_ = [];\n\n  /**\n   * The number of key value pairs in the map.\n   * @private {number}\n   */\n  this.count_ = 0;\n\n  /**\n   * Version used to detect changes while iterating.\n   * @private {number}\n   */\n  this.version_ = 0;\n\n  var argLength = arguments.length;\n\n  if (argLength > 1) {\n    if (argLength % 2) {\n      throw new Error('Uneven number of arguments');\n    }\n    for (var i = 0; i < argLength; i += 2) {\n      this.set(arguments[i], arguments[i + 1]);\n    }\n  } else if (opt_map) {\n    this.addAll(/** @type {!Object} */ (opt_map));\n  }\n};\n\n\n/**\n * @return {number} The number of key-value pairs in the map.\n */\ngoog.structs.Map.prototype.getCount = function() {\n  return this.count_;\n};\n\n\n/**\n * Returns the values of the map.\n * @return {!Array<V>} The values in the map.\n */\ngoog.structs.Map.prototype.getValues = function() {\n  this.cleanupKeysArray_();\n\n  var rv = [];\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    rv.push(this.map_[key]);\n  }\n  return rv;\n};\n\n\n/**\n * Returns the keys of the map.\n * @return {!Array<string>} Array of string values.\n */\ngoog.structs.Map.prototype.getKeys = function() {\n  this.cleanupKeysArray_();\n  return /** @type {!Array<string>} */ (this.keys_.concat());\n};\n\n\n/**\n * Whether the map contains the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the map contains the key.\n */\ngoog.structs.Map.prototype.containsKey = function(key) {\n  return goog.structs.Map.hasKey_(this.map_, key);\n};\n\n\n/**\n * Whether the map contains the given value. This is O(n).\n * @param {V} val The value to check for.\n * @return {boolean} Whether the map contains the value.\n */\ngoog.structs.Map.prototype.containsValue = function(val) {\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Whether this map is equal to the argument map.\n * @param {goog.structs.Map} otherMap The map against which to test equality.\n * @param {function(V, V): boolean=} opt_equalityFn Optional equality function\n *     to test equality of values. If not specified, this will test whether\n *     the values contained in each map are identical objects.\n * @return {boolean} Whether the maps are equal.\n */\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\n  if (this === otherMap) {\n    return true;\n  }\n\n  if (this.count_ != otherMap.getCount()) {\n    return false;\n  }\n\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\n\n  this.cleanupKeysArray_();\n  for (var key, i = 0; key = this.keys_[i]; i++) {\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\n/**\n * Default equality test for values.\n * @param {*} a The first value.\n * @param {*} b The second value.\n * @return {boolean} Whether a and b reference the same object.\n */\ngoog.structs.Map.defaultEquals = function(a, b) {\n  return a === b;\n};\n\n\n/**\n * @return {boolean} Whether the map is empty.\n */\ngoog.structs.Map.prototype.isEmpty = function() {\n  return this.count_ == 0;\n};\n\n\n/**\n * Removes all key-value pairs from the map.\n */\ngoog.structs.Map.prototype.clear = function() {\n  this.map_ = {};\n  this.keys_.length = 0;\n  this.count_ = 0;\n  this.version_ = 0;\n};\n\n\n/**\n * Removes a key-value pair based on the key. This is O(logN) amortized due to\n * updating the keys array whenever the count becomes half the size of the keys\n * in the keys array.\n * @param {*} key  The key to remove.\n * @return {boolean} Whether object was removed.\n */\ngoog.structs.Map.prototype.remove = function(key) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    delete this.map_[key];\n    this.count_--;\n    this.version_++;\n\n    // clean up the keys array if the threshold is hit\n    if (this.keys_.length > 2 * this.count_) {\n      this.cleanupKeysArray_();\n    }\n\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Cleans up the temp keys array by removing entries that are no longer in the\n * map.\n * @private\n */\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\n  if (this.count_ != this.keys_.length) {\n    // First remove keys that are no longer in the map.\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\n        this.keys_[destIndex++] = key;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n\n  if (this.count_ != this.keys_.length) {\n    // If the count still isn't correct, that means we have duplicates. This can\n    // happen when the same key is added and removed multiple times. Now we have\n    // to allocate one extra Object to remove the duplicates. This could have\n    // been done in the first pass, but in the common case, we can avoid\n    // allocating an extra object by only doing this when necessary.\n    var seen = {};\n    var srcIndex = 0;\n    var destIndex = 0;\n    while (srcIndex < this.keys_.length) {\n      var key = this.keys_[srcIndex];\n      if (!(goog.structs.Map.hasKey_(seen, key))) {\n        this.keys_[destIndex++] = key;\n        seen[key] = 1;\n      }\n      srcIndex++;\n    }\n    this.keys_.length = destIndex;\n  }\n};\n\n\n/**\n * Returns the value for the given key.  If the key is not found and the default\n * value is not given this will return `undefined`.\n * @param {*} key The key to get the value for.\n * @param {DEFAULT=} opt_val The value to return if no item is found for the\n *     given key, defaults to undefined.\n * @return {V|DEFAULT} The value for the given key.\n * @template DEFAULT\n */\ngoog.structs.Map.prototype.get = function(key, opt_val) {\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\n    return this.map_[key];\n  }\n  return opt_val;\n};\n\n\n/**\n * Adds a key-value pair to the map.\n * @param {*} key The key.\n * @param {V} value The value to add.\n * @return {*} Some subclasses return a value.\n */\ngoog.structs.Map.prototype.set = function(key, value) {\n  if (!(goog.structs.Map.hasKey_(this.map_, key))) {\n    this.count_++;\n    // TODO(johnlenz): This class lies, it claims to return an array of string\n    // keys, but instead returns the original object used.\n    this.keys_.push(/** @type {?} */ (key));\n    // Only change the version if we add a new key.\n    this.version_++;\n  }\n  this.map_[key] = value;\n};\n\n\n/**\n * Adds multiple key-value pairs from another goog.structs.Map or Object.\n * @param {?Object} map Object containing the data to add.\n */\ngoog.structs.Map.prototype.addAll = function(map) {\n  if (map instanceof goog.structs.Map) {\n    var keys = map.getKeys();\n    for (var i = 0; i < keys.length; i++) {\n      this.set(keys[i], map.get(keys[i]));\n    }\n  } else {\n    for (var key in map) {\n      this.set(key, map[key]);\n    }\n  }\n};\n\n\n/**\n * Calls the given function on each entry in the map.\n * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f\n * @param {T=} opt_obj The value of \"this\" inside f.\n * @template T\n */\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\n  var keys = this.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this.get(key);\n    f.call(opt_obj, value, key, this);\n  }\n};\n\n\n/**\n * Clones a map and returns a new map.\n * @return {!goog.structs.Map} A new map with the same key-value pairs.\n */\ngoog.structs.Map.prototype.clone = function() {\n  return new goog.structs.Map(this);\n};\n\n\n/**\n * Returns a new map in which all the keys and values are interchanged\n * (keys become values and values become keys). If multiple keys map to the\n * same value, the chosen transposed value is implementation-dependent.\n *\n * It acts very similarly to {goog.object.transpose(Object)}.\n *\n * @return {!goog.structs.Map} The transposed map.\n */\ngoog.structs.Map.prototype.transpose = function() {\n  var transposed = new goog.structs.Map();\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    var value = this.map_[key];\n    transposed.set(value, key);\n  }\n\n  return transposed;\n};\n\n\n/**\n * @return {!Object} Object representation of the map.\n */\ngoog.structs.Map.prototype.toObject = function() {\n  this.cleanupKeysArray_();\n  var obj = {};\n  for (var i = 0; i < this.keys_.length; i++) {\n    var key = this.keys_[i];\n    obj[key] = this.map_[key];\n  }\n  return obj;\n};\n\n\n/**\n * Returns an iterator that iterates over the keys in the map.  Removal of keys\n * while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the keys in the map.\n */\ngoog.structs.Map.prototype.getKeyIterator = function() {\n  return this.__iterator__(true);\n};\n\n\n/**\n * Returns an iterator that iterates over the values in the map.  Removal of\n * keys while iterating might have undesired side effects.\n * @return {!goog.iter.Iterator} An iterator over the values in the map.\n */\ngoog.structs.Map.prototype.getValueIterator = function() {\n  return this.__iterator__(false);\n};\n\n\n/**\n * Returns an iterator that iterates over the values or the keys in the map.\n * This throws an exception if the map was mutated since the iterator was\n * created.\n * @param {boolean=} opt_keys True to iterate over the keys. False to iterate\n *     over the values.  The default value is false.\n * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.\n */\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\n  // Clean up keys to minimize the risk of iterating over dead keys.\n  this.cleanupKeysArray_();\n\n  var i = 0;\n  var version = this.version_;\n  var selfObj = this;\n\n  var newIter = new goog.iter.Iterator;\n  newIter.next = function() {\n    if (version != selfObj.version_) {\n      throw new Error('The map has changed since the iterator was created');\n    }\n    if (i >= selfObj.keys_.length) {\n      throw goog.iter.StopIteration;\n    }\n    var key = selfObj.keys_[i++];\n    return opt_keys ? key : selfObj.map_[key];\n  };\n  return newIter;\n};\n\n\n/**\n * Safe way to test for hasOwnProperty.  It even allows testing for\n * 'hasOwnProperty'.\n * @param {!Object} obj The object to test for presence of the given key.\n * @param {*} key The key to check for.\n * @return {boolean} Whether the object has the key.\n * @private\n */\ngoog.structs.Map.hasKey_ = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n","// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Simple utilities for dealing with URI strings.\n *\n * This is intended to be a lightweight alternative to constructing goog.Uri\n * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless\n * of how much of its functionality you use, this is designed to be a set of\n * mostly-independent utilities so that the compiler includes only what is\n * necessary for the task.  Estimated savings of porting is 5k pre-gzip and\n * 1.5k post-gzip.  To ensure the savings remain, future developers should\n * avoid adding new functionality to existing functions, but instead create\n * new ones and factor out shared code.\n *\n * Many of these utilities have limited functionality, tailored to common\n * cases.  The query parameter utilities assume that the parameter keys are\n * already encoded, since most keys are compile-time alphanumeric strings.  The\n * query parameter mutation utilities also do not tolerate fragment identifiers.\n *\n * By design, these functions can be slower than goog.Uri equivalents.\n * Repeated calls to some of functions may be quadratic in behavior for IE,\n * although the effect is somewhat limited given the 2kb limit.\n *\n * One advantage of the limited functionality here is that this approach is\n * less sensitive to differences in URI encodings than goog.Uri, since these\n * functions operate on strings directly, rather than decoding them and\n * then re-encoding.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n *\n * @author gboyer@google.com (Garrett Boyer) - The \"lightened\" design.\n * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\ngoog.provide('goog.uri.utils.QueryArray');\ngoog.provide('goog.uri.utils.QueryValue');\ngoog.provide('goog.uri.utils.StandardQueryParam');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.string');\n\n\n/**\n * Character codes inlined to avoid object allocations due to charCode.\n * @enum {number}\n * @private\n */\ngoog.uri.utils.CharCode_ = {\n  AMPERSAND: 38,\n  EQUAL: 61,\n  HASH: 35,\n  QUESTION: 63\n};\n\n\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?string=} opt_scheme The scheme such as 'http'.\n * @param {?string=} opt_userInfo The user name before the '@'.\n * @param {?string=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {(string|number|null)=} opt_port The port number.\n * @param {?string=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?string=} opt_queryData The URI-encoded query data.\n * @param {?string=} opt_fragment The URI-encoded fragment identifier.\n * @return {string} The fully combined URI.\n */\ngoog.uri.utils.buildFromEncodedParts = function(\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,\n    opt_fragment) {\n  var out = '';\n\n  if (opt_scheme) {\n    out += opt_scheme + ':';\n  }\n\n  if (opt_domain) {\n    out += '//';\n\n    if (opt_userInfo) {\n      out += opt_userInfo + '@';\n    }\n\n    out += opt_domain;\n\n    if (opt_port) {\n      out += ':' + opt_port;\n    }\n  }\n\n  if (opt_path) {\n    out += opt_path;\n  }\n\n  if (opt_queryData) {\n    out += '?' + opt_queryData;\n  }\n\n  if (opt_fragment) {\n    out += '#' + opt_fragment;\n  }\n\n  return out;\n};\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n    '([^:/?#.]+)' +  // scheme - ignore special characters\n                     // used by other URL parts such as :,\n                     // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +  // userInfo\n    '([^/#?]*?)' +       // domain\n    '(?::([0-9]+))?' +   // port\n    '(?=[/#?]|$)' +      // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +          // path\n    '(?:\\\\?([^#]*))?' +    // query\n    '(?:#([\\\\s\\\\S]*))?' +  // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n\n\n/**\n * @param {?string} uri A possibly null string.\n * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986\n *     reserved characters will not be removed.\n * @return {?string} The string URI-decoded, or null if uri is null.\n * @private\n */\ngoog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {\n  if (!uri) {\n    return uri;\n  }\n\n  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);\n};\n\n\n/**\n * Gets a URI component by index.\n *\n * It is preferred to use the getPathEncoded() variety of functions ahead,\n * since they are more readable.\n *\n * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.\n * @param {string} uri The URI to examine.\n * @return {?string} The still-encoded component, or null if the component\n *     is not present.\n * @private\n */\ngoog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {\n  // Convert undefined, null, and empty string into null.\n  return goog.uri.utils.split(uri)[componentIndex] || null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The protocol or scheme, or null if none.  Does not\n *     include trailing colons or slashes.\n */\ngoog.uri.utils.getScheme = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.SCHEME, uri);\n};\n\n\n/**\n * Gets the effective scheme for the URL.  If the URL is relative then the\n * scheme is derived from the page's location.\n * @param {string} uri The URI to examine.\n * @return {string} The protocol or scheme, always lower case.\n */\ngoog.uri.utils.getEffectiveScheme = function(uri) {\n  var scheme = goog.uri.utils.getScheme(uri);\n  if (!scheme && goog.global.self && goog.global.self.location) {\n    var protocol = goog.global.self.location.protocol;\n    scheme = protocol.substr(0, protocol.length - 1);\n  }\n  // NOTE: When called from a web worker in Firefox 3.5, location may be null.\n  // All other browsers with web workers support self.location from the worker.\n  return scheme ? scheme.toLowerCase() : '';\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The user name still encoded, or null if none.\n */\ngoog.uri.utils.getUserInfoEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.USER_INFO, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded user info, or null if none.\n */\ngoog.uri.utils.getUserInfo = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getUserInfoEncoded(uri));\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The domain name still encoded, or null if none.\n */\ngoog.uri.utils.getDomainEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.DOMAIN, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded domain, or null if none.\n */\ngoog.uri.utils.getDomain = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?number} The port number, or null if none.\n */\ngoog.uri.utils.getPort = function(uri) {\n  // Coerce to a number.  If the result of getComponentByIndex_ is null or\n  // non-numeric, the number coersion yields NaN.  This will then return\n  // null for all non-numeric cases (though also zero, which isn't a relevant\n  // port number).\n  return Number(\n             goog.uri.utils.getComponentByIndex_(\n                 goog.uri.utils.ComponentIndex.PORT, uri)) ||\n      null;\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The path still encoded, or null if none. Includes the\n *     leading slash, if any.\n */\ngoog.uri.utils.getPathEncoded = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.PATH, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded path, or null if none.  Includes the leading\n *     slash, if any.\n */\ngoog.uri.utils.getPath = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The query data still encoded, or null if none.  Does not\n *     include the question mark itself.\n */\ngoog.uri.utils.getQueryData = function(uri) {\n  return goog.uri.utils.getComponentByIndex_(\n      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The fragment identifier, or null if none.  Does not\n *     include the hash mark itself.\n */\ngoog.uri.utils.getFragmentEncoded = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @param {?string} fragment The encoded fragment identifier, or null if none.\n *     Does not include the hash mark itself.\n * @return {string} The URI with the fragment set.\n */\ngoog.uri.utils.setFragmentEncoded = function(uri, fragment) {\n  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');\n};\n\n\n/**\n * @param {string} uri The URI to examine.\n * @return {?string} The decoded fragment identifier, or null if none.  Does\n *     not include the hash mark.\n */\ngoog.uri.utils.getFragment = function(uri) {\n  return goog.uri.utils.decodeIfPossible_(\n      goog.uri.utils.getFragmentEncoded(uri));\n};\n\n\n/**\n * Extracts everything up to the port of the URI.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getHost = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME],\n      pieces[goog.uri.utils.ComponentIndex.USER_INFO],\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Returns the origin for a given URL.\n * @param {string} uri The URI string.\n * @return {string} Everything up to and including the port.\n */\ngoog.uri.utils.getOrigin = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,\n      pieces[goog.uri.utils.ComponentIndex.DOMAIN],\n      pieces[goog.uri.utils.ComponentIndex.PORT]);\n};\n\n\n/**\n * Extracts the path of the URL and everything after.\n * @param {string} uri The URI string.\n * @return {string} The URI, starting at the path and including the query\n *     parameters and fragment identifier.\n */\ngoog.uri.utils.getPathAndAfter = function(uri) {\n  var pieces = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],\n      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Gets the URI with the fragment identifier removed.\n * @param {string} uri The URI to examine.\n * @return {string} Everything preceding the hash mark.\n */\ngoog.uri.utils.removeFragment = function(uri) {\n  // The hash mark may not appear in any other part of the URL.\n  var hashIndex = uri.indexOf('#');\n  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);\n};\n\n\n/**\n * Ensures that two URI's have the exact same domain, scheme, and port.\n *\n * Unlike the version in goog.Uri, this checks protocol, and therefore is\n * suitable for checking against the browser's same-origin policy.\n *\n * @param {string} uri1 The first URI.\n * @param {string} uri2 The second URI.\n * @return {boolean} Whether they have the same scheme, domain and port.\n */\ngoog.uri.utils.haveSameDomain = function(uri1, uri2) {\n  var pieces1 = goog.uri.utils.split(uri1);\n  var pieces2 = goog.uri.utils.split(uri2);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\n      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==\n      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\n\n\n/**\n * Asserts that there are no fragment or query identifiers, only in uncompiled\n * mode.\n * @param {string} uri The URI to examine.\n * @private\n */\ngoog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {\n  goog.asserts.assert(\n      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,\n      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',\n      uri);\n};\n\n\n/**\n * Supported query parameter values by the parameter serializing utilities.\n *\n * If a value is null or undefined, the key-value pair is skipped, as an easy\n * way to omit parameters conditionally.  Non-array parameters are converted\n * to a string and URI encoded.  Array values are expanded into multiple\n * &key=value pairs, with each element stringized and URI-encoded.\n *\n * @typedef {*}\n */\ngoog.uri.utils.QueryValue;\n\n\n/**\n * An array representing a set of query parameters with alternating keys\n * and values.\n *\n * Keys are assumed to be URI encoded already and live at even indices.  See\n * goog.uri.utils.QueryValue for details on how parameter values are encoded.\n *\n * Example:\n * <pre>\n * var data = [\n *   // Simple param: ?name=BobBarker\n *   'name', 'BobBarker',\n *   // Conditional param -- may be omitted entirely.\n *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,\n *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null\n *   'house', ['LosAngeles', 'NewYork', null]\n * ];\n * </pre>\n *\n * @typedef {!Array<string|goog.uri.utils.QueryValue>}\n */\ngoog.uri.utils.QueryArray;\n\n\n/**\n * Parses encoded query parameters and calls callback function for every\n * parameter found in the string.\n *\n * Missing value of parameter (e.g. &key&) is treated as if the value was an\n * empty string.  Keys may be empty strings (e.g. &=value&) which also means\n * that &=& and && will result in an empty key and value.\n *\n * @param {string} encodedQuery Encoded query string excluding question mark at\n *     the beginning.\n * @param {function(string, string)} callback Function called for every\n *     parameter found in query string.  The first argument (name) will not be\n *     urldecoded (so the function is consistent with buildQueryData), but the\n *     second will.  If the parameter has no value (i.e. = was not present)\n *     the second argument (value) will be an empty string.\n */\ngoog.uri.utils.parseQueryData = function(encodedQuery, callback) {\n  if (!encodedQuery) {\n    return;\n  }\n  var pairs = encodedQuery.split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var indexOfEquals = pairs[i].indexOf('=');\n    var name = null;\n    var value = null;\n    if (indexOfEquals >= 0) {\n      name = pairs[i].substring(0, indexOfEquals);\n      value = pairs[i].substring(indexOfEquals + 1);\n    } else {\n      name = pairs[i];\n    }\n    callback(name, value ? goog.string.urlDecode(value) : '');\n  }\n};\n\n\n/**\n * Split the URI into 3 parts where the [1] is the queryData without a leading\n * '?'. For example, the URI http://foo.com/bar?a=b#abc returns\n * ['http://foo.com/bar','a=b','#abc'].\n * @param {string} uri The URI to parse.\n * @return {!Array<string>} An array representation of uri of length 3 where the\n *     middle value is the queryData without a leading '?'.\n * @private\n */\ngoog.uri.utils.splitQueryData_ = function(uri) {\n  // Find the query data and hash.\n  var hashIndex = uri.indexOf('#');\n  if (hashIndex < 0) {\n    hashIndex = uri.length;\n  }\n  var questionIndex = uri.indexOf('?');\n  var queryData;\n  if (questionIndex < 0 || questionIndex > hashIndex) {\n    questionIndex = hashIndex;\n    queryData = '';\n  } else {\n    queryData = uri.substring(questionIndex + 1, hashIndex);\n  }\n  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];\n};\n\n\n/**\n * Join an array created by splitQueryData_ back into a URI.\n * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.\n * @return {string} The joined URI.\n * @private\n */\ngoog.uri.utils.joinQueryData_ = function(parts) {\n  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];\n};\n\n\n/**\n * @param {string} queryData\n * @param {string} newData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryData_ = function(queryData, newData) {\n  if (!newData) {\n    return queryData;\n  }\n  return queryData ? queryData + '&' + newData : newData;\n};\n\n\n/**\n * @param {string} uri\n * @param {string} queryData\n * @return {string}\n * @private\n */\ngoog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {\n  if (!queryData) {\n    return uri;\n  }\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Appends key=value pairs to an array, supporting multi-valued objects.\n * @param {*} key The key prefix.\n * @param {goog.uri.utils.QueryValue} value The value to serialize.\n * @param {!Array<string>} pairs The array to which the 'key=value' strings\n *     should be appended.\n * @private\n */\ngoog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {\n  goog.asserts.assertString(key);\n  if (goog.isArray(value)) {\n    // Convince the compiler it's an array.\n    goog.asserts.assertArray(value);\n    for (var j = 0; j < value.length; j++) {\n      // Convert to string explicitly, to short circuit the null and array\n      // logic in this function -- this ensures that null and undefined get\n      // written as literal 'null' and 'undefined', and arrays don't get\n      // expanded out but instead encoded in the default way.\n      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);\n    }\n  } else if (value != null) {\n    // Skip a top-level null or undefined entirely.\n    pairs.push(\n        key +\n        // Check for empty string. Zero gets encoded into the url as literal\n        // strings.  For empty string, skip the equal sign, to be consistent\n        // with UriBuilder.java.\n        (value === '' ? '' : '=' + goog.string.urlEncode(value)));\n  }\n};\n\n\n/**\n * Builds a query data string from a sequence of alternating keys and values.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues\n *     Alternating keys and values. See the QueryArray typedef.\n * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {\n  goog.asserts.assert(\n      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,\n      'goog.uri.utils: Key/value lists must be even in length.');\n\n  var params = [];\n  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {\n    var key = /** @type {string} */ (keysAndValues[i]);\n    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Builds a query data string from a map.\n * Currently generates \"&key&\" for empty args.\n *\n * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys\n *     are URI-encoded parameter keys, and the values are arbitrary types\n *     or arrays. Keys with a null value are dropped.\n * @return {string} The encoded query string, in the form 'a=1&b=2'.\n */\ngoog.uri.utils.buildQueryDataFromMap = function(map) {\n  var params = [];\n  for (var key in map) {\n    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);\n  }\n  return params.join('&');\n};\n\n\n/**\n * Appends URI parameters to an existing URI.\n *\n * The variable arguments may contain alternating keys and values.  Keys are\n * assumed to be already URI encoded.  The values should not be URI-encoded,\n * and will instead be encoded by this function.\n * <pre>\n * appendParams('http://www.foo.com?existing=true',\n *     'key1', 'value1',\n *     'key2', 'value?willBeEncoded',\n *     'key3', ['valueA', 'valueB', 'valueC'],\n *     'key4', null);\n * result: 'http://www.foo.com?existing=true&' +\n *     'key1=value1&' +\n *     'key2=value%3FwillBeEncoded&' +\n *     'key3=valueA&key3=valueB&key3=valueC'\n * </pre>\n *\n * A single call to this function will not exhibit quadratic behavior in IE,\n * whereas multiple repeated calls may, although the effect is limited by\n * fact that URL's generally can't exceed 2kb.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}\n * var_args\n *     An array or argument list conforming to goog.uri.utils.QueryArray.\n * @return {string} The URI with all query parameters added.\n */\ngoog.uri.utils.appendParams = function(uri, var_args) {\n  var queryData = arguments.length == 2 ?\n      goog.uri.utils.buildQueryData(arguments[1], 0) :\n      goog.uri.utils.buildQueryData(arguments, 1);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends query parameters from a map.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are\n *     URI-encoded parameter keys, and the values are arbitrary types or arrays.\n *     Keys with a null value are dropped.\n * @return {string} The new parameters.\n */\ngoog.uri.utils.appendParamsFromMap = function(uri, map) {\n  var queryData = goog.uri.utils.buildQueryDataFromMap(map);\n  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);\n};\n\n\n/**\n * Appends a single URI parameter.\n *\n * Repeated calls to this can exhibit quadratic behavior in IE6 due to the\n * way string append works, though it should be limited given the 2kb limit.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} key The key, which must already be URI encoded.\n * @param {*=} opt_value The value, which will be stringized and encoded\n *     (assumed not already to be encoded).  If omitted, undefined, or null, the\n *     key will be added as a valueless parameter.\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.appendParam = function(uri, key, opt_value) {\n  var value = goog.isDefAndNotNull(opt_value) ?\n      '=' + goog.string.urlEncode(opt_value) :\n      '';\n  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);\n};\n\n\n/**\n * Finds the next instance of a query parameter with the specified name.\n *\n * Does not instantiate any objects.\n *\n * @param {string} uri The URI to search.  May contain a fragment identifier\n *     if opt_hashIndex is specified.\n * @param {number} startIndex The index to begin searching for the key at.  A\n *     match may be found even if this is one character after the ampersand.\n * @param {string} keyEncoded The URI-encoded key.\n * @param {number} hashOrEndIndex Index to stop looking at.  If a hash\n *     mark is present, it should be its index, otherwise it should be the\n *     length of the string.\n * @return {number} The position of the first character in the key's name,\n *     immediately after either a question mark or a dot.\n * @private\n */\ngoog.uri.utils.findParam_ = function(\n    uri, startIndex, keyEncoded, hashOrEndIndex) {\n  var index = startIndex;\n  var keyLength = keyEncoded.length;\n\n  // Search for the key itself and post-filter for surronuding punctuation,\n  // rather than expensively building a regexp.\n  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&\n         index < hashOrEndIndex) {\n    var precedingChar = uri.charCodeAt(index - 1);\n    // Ensure that the preceding character is '&' or '?'.\n    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n        precedingChar == goog.uri.utils.CharCode_.QUESTION) {\n      // Ensure the following character is '&', '=', '#', or NaN\n      // (end of string).\n      var followingChar = uri.charCodeAt(index + keyLength);\n      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||\n          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||\n          followingChar == goog.uri.utils.CharCode_.HASH) {\n        return index;\n      }\n    }\n    index += keyLength + 1;\n  }\n\n  return -1;\n};\n\n\n/**\n * Regular expression for finding a hash mark or end of string.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.hashOrEndRe_ = /#|$/;\n\n\n/**\n * Determines if the URI contains a specific key.\n *\n * Performs no object instantiations.\n *\n * @param {string} uri The URI to process.  May contain a fragment\n *     identifier.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {boolean} Whether the key is present.\n */\ngoog.uri.utils.hasParam = function(uri, keyEncoded) {\n  return goog.uri.utils.findParam_(\n             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;\n};\n\n\n/**\n * Gets the first value of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {?string} The first value of the parameter (URI-decoded), or null\n *     if the parameter is not found.\n */\ngoog.uri.utils.getParamValue = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var foundIndex =\n      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);\n\n  if (foundIndex < 0) {\n    return null;\n  } else {\n    var endPosition = uri.indexOf('&', foundIndex);\n    if (endPosition < 0 || endPosition > hashOrEndIndex) {\n      endPosition = hashOrEndIndex;\n    }\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > endPosition.\n    return goog.string.urlDecode(\n        uri.substr(foundIndex, endPosition - foundIndex));\n  }\n};\n\n\n/**\n * Gets all values of a query parameter.\n * @param {string} uri The URI to process.  May contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.\n * @return {!Array<string>} All URI-decoded values with the given key.\n *     If the key is not found, this will have length 0, but never be null.\n */\ngoog.uri.utils.getParamValues = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var result = [];\n\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Find where this parameter ends, either the '&' or the end of the\n    // query parameters.\n    position = uri.indexOf('&', foundIndex);\n    if (position < 0 || position > hashOrEndIndex) {\n      position = hashOrEndIndex;\n    }\n\n    // Progress forth to the end of the \"key=\" or \"key&\" substring.\n    foundIndex += keyEncoded.length + 1;\n    // Use substr, because it (unlike substring) will return empty string\n    // if foundIndex > position.\n    result.push(\n        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));\n  }\n\n  return result;\n};\n\n\n/**\n * Regexp to find trailing question marks and ampersands.\n * @type {RegExp}\n * @private\n */\ngoog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;\n\n\n/**\n * Removes all instances of a query parameter.\n * @param {string} uri The URI to process.  Must not contain a fragment.\n * @param {string} keyEncoded The URI-encoded key.\n * @return {string} The URI with all instances of the parameter removed.\n */\ngoog.uri.utils.removeParam = function(uri, keyEncoded) {\n  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);\n  var position = 0;\n  var foundIndex;\n  var buffer = [];\n\n  // Look for a query parameter.\n  while ((foundIndex = goog.uri.utils.findParam_(\n              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {\n    // Get the portion of the query string up to, but not including, the ?\n    // or & starting the parameter.\n    buffer.push(uri.substring(position, foundIndex));\n    // Progress to immediately after the '&'.  If not found, go to the end.\n    // Avoid including the hash mark.\n    position = Math.min(\n        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);\n  }\n\n  // Append everything that is remaining.\n  buffer.push(uri.substr(position));\n\n  // Join the buffer, and remove trailing punctuation that remains.\n  return buffer.join('').replace(\n      goog.uri.utils.trailingQueryPunctuationRe_, '$1');\n};\n\n\n/**\n * Replaces all existing definitions of a parameter with a single definition.\n *\n * Repeated calls to this can exhibit quadratic behavior due to the need to\n * find existing instances and reconstruct the string, though it should be\n * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap\n * to update multiple parameters in bulk.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {string} keyEncoded The key, which must already be URI encoded.\n * @param {*} value The value, which will be stringized and encoded (assumed\n *     not already to be encoded).\n * @return {string} The URI with the query parameter added.\n */\ngoog.uri.utils.setParam = function(uri, keyEncoded, value) {\n  return goog.uri.utils.appendParam(\n      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);\n};\n\n\n/**\n * Effeciently set or remove multiple query parameters in a URI. Order of\n * unchanged parameters will not be modified, all updated parameters will be\n * appended to the end of the query. Params with values of null or undefined are\n * removed.\n *\n * @param {string} uri The URI to process.\n * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of\n *     parameters to update. If null or undefined, the param will be removed.\n * @return {string} An updated URI where the query data has been updated with\n *     the params.\n */\ngoog.uri.utils.setParamsFromMap = function(uri, params) {\n  var parts = goog.uri.utils.splitQueryData_(uri);\n  var queryData = parts[1];\n  var buffer = [];\n  if (queryData) {\n    goog.array.forEach(queryData.split('&'), function(pair) {\n      var indexOfEquals = pair.indexOf('=');\n      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;\n      if (!params.hasOwnProperty(name)) {\n        buffer.push(pair);\n      }\n    });\n  }\n  parts[1] = goog.uri.utils.appendQueryData_(\n      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));\n  return goog.uri.utils.joinQueryData_(parts);\n};\n\n\n/**\n * Generates a URI path using a given URI and a path with checks to\n * prevent consecutive \"//\". The baseUri passed in must not contain\n * query or fragment identifiers. The path to append may not contain query or\n * fragment identifiers.\n *\n * @param {string} baseUri URI to use as the base.\n * @param {string} path Path to append.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.appendPath = function(baseUri, path) {\n  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);\n\n  // Remove any trailing '/'\n  if (goog.string.endsWith(baseUri, '/')) {\n    baseUri = baseUri.substr(0, baseUri.length - 1);\n  }\n  // Remove any leading '/'\n  if (goog.string.startsWith(path, '/')) {\n    path = path.substr(1);\n  }\n  return goog.string.buildString(baseUri, '/', path);\n};\n\n\n/**\n * Replaces the path.\n * @param {string} uri URI to use as the base.\n * @param {string} path New path.\n * @return {string} Updated URI.\n */\ngoog.uri.utils.setPath = function(uri, path) {\n  // Add any missing '/'.\n  if (!goog.string.startsWith(path, '/')) {\n    path = '/' + path;\n  }\n  var parts = goog.uri.utils.split(uri);\n  return goog.uri.utils.buildFromEncodedParts(\n      parts[goog.uri.utils.ComponentIndex.SCHEME],\n      parts[goog.uri.utils.ComponentIndex.USER_INFO],\n      parts[goog.uri.utils.ComponentIndex.DOMAIN],\n      parts[goog.uri.utils.ComponentIndex.PORT], path,\n      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],\n      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);\n};\n\n\n/**\n * Standard supported query parameters.\n * @enum {string}\n */\ngoog.uri.utils.StandardQueryParam = {\n\n  /** Unused parameter for unique-ifying. */\n  RANDOM: 'zx'\n};\n\n\n/**\n * Sets the zx parameter of a URI to a random value.\n * @param {string} uri Any URI.\n * @return {string} That URI with the \"zx\" parameter added or replaced to\n *     contain a random string.\n */\ngoog.uri.utils.makeUnique = function(uri) {\n  return goog.uri.utils.setParam(\n      uri, goog.uri.utils.StandardQueryParam.RANDOM,\n      goog.string.getRandomString());\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Class for parsing and formatting URIs.\n *\n * Use goog.Uri(string) to parse a URI string.  Use goog.Uri.create(...) to\n * create a new instance of the goog.Uri object from Uri parts.\n *\n * e.g: <code>var myUri = new goog.Uri(window.location);</code>\n *\n * Implements RFC 3986 for parsing/formatting URIs.\n * http://www.ietf.org/rfc/rfc3986.txt\n *\n * Some changes have been made to the interface (more like .NETs), though the\n * internal representation is now of un-encoded parts, this will change the\n * behavior slightly.\n *\n * @author msamuel@google.com (Mike Samuel)\n */\n\ngoog.provide('goog.Uri');\ngoog.provide('goog.Uri.QueryData');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.string');\ngoog.require('goog.structs');\ngoog.require('goog.structs.Map');\ngoog.require('goog.uri.utils');\ngoog.require('goog.uri.utils.ComponentIndex');\ngoog.require('goog.uri.utils.StandardQueryParam');\n\n\n\n/**\n * This class contains setters and getters for the parts of the URI.\n * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part\n * -- so<code>goog.Uri.parse('/foo%20bar').getPath()</code> will return the\n * decoded path, <code>/foo bar</code>.\n *\n * Reserved characters (see RFC 3986 section 2.2) can be present in\n * their percent-encoded form in scheme, domain, and path URI components and\n * will not be auto-decoded. For example:\n * <code>goog.Uri.parse('rel%61tive/path%2fto/resource').getPath()</code> will\n * return <code>relative/path%2fto/resource</code>.\n *\n * The constructor accepts an optional unparsed, raw URI string.  The parser\n * is relaxed, so special characters that aren't escaped but don't cause\n * ambiguities will not cause parse failures.\n *\n * All setters return <code>this</code> and so may be chained, a la\n * <code>goog.Uri.parse('/foo').setFragment('part').toString()</code>.\n *\n * @param {*=} opt_uri Optional string URI to parse\n *        (use goog.Uri.create() to create a URI from parts), or if\n *        a goog.Uri is passed, a clone is created.\n * @param {boolean=} opt_ignoreCase If true, #getParameterValue will ignore\n * the case of the parameter name.\n *\n * @throws URIError If opt_uri is provided and URI is malformed (that is,\n *     if decodeURIComponent fails on any of the URI components).\n * @constructor\n * @struct\n */\ngoog.Uri = function(opt_uri, opt_ignoreCase) {\n  /**\n   * Scheme such as \"http\".\n   * @private {string}\n   */\n  this.scheme_ = '';\n\n  /**\n   * User credentials in the form \"username:password\".\n   * @private {string}\n   */\n  this.userInfo_ = '';\n\n  /**\n   * Domain part, e.g. \"www.google.com\".\n   * @private {string}\n   */\n  this.domain_ = '';\n\n  /**\n   * Port, e.g. 8080.\n   * @private {?number}\n   */\n  this.port_ = null;\n\n  /**\n   * Path, e.g. \"/tests/img.png\".\n   * @private {string}\n   */\n  this.path_ = '';\n\n  /**\n   * The fragment without the #.\n   * @private {string}\n   */\n  this.fragment_ = '';\n\n  /**\n   * Whether or not this Uri should be treated as Read Only.\n   * @private {boolean}\n   */\n  this.isReadOnly_ = false;\n\n  /**\n   * Whether or not to ignore case when comparing query params.\n   * @private {boolean}\n   */\n  this.ignoreCase_ = false;\n\n  /**\n   * Object representing query data.\n   * @private {!goog.Uri.QueryData}\n   */\n  this.queryData_;\n\n  // Parse in the uri string\n  var m;\n  if (opt_uri instanceof goog.Uri) {\n    this.ignoreCase_ =\n        goog.isDef(opt_ignoreCase) ? opt_ignoreCase : opt_uri.getIgnoreCase();\n    this.setScheme(opt_uri.getScheme());\n    this.setUserInfo(opt_uri.getUserInfo());\n    this.setDomain(opt_uri.getDomain());\n    this.setPort(opt_uri.getPort());\n    this.setPath(opt_uri.getPath());\n    this.setQueryData(opt_uri.getQueryData().clone());\n    this.setFragment(opt_uri.getFragment());\n  } else if (opt_uri && (m = goog.uri.utils.split(String(opt_uri)))) {\n    this.ignoreCase_ = !!opt_ignoreCase;\n\n    // Set the parts -- decoding as we do so.\n    // COMPATIBILITY NOTE - In IE, unmatched fields may be empty strings,\n    // whereas in other browsers they will be undefined.\n    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);\n    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);\n    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);\n    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);\n    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);\n    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);\n    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);\n\n  } else {\n    this.ignoreCase_ = !!opt_ignoreCase;\n    this.queryData_ = new goog.Uri.QueryData(null, null, this.ignoreCase_);\n  }\n};\n\n\n/**\n * Parameter name added to stop caching.\n * @type {string}\n */\ngoog.Uri.RANDOM_PARAM = goog.uri.utils.StandardQueryParam.RANDOM;\n\n\n/**\n * @return {string} The string form of the url.\n * @override\n */\ngoog.Uri.prototype.toString = function() {\n  var out = [];\n\n  var scheme = this.getScheme();\n  if (scheme) {\n    out.push(\n        goog.Uri.encodeSpecialChars_(\n            scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true),\n        ':');\n  }\n\n  var domain = this.getDomain();\n  if (domain || scheme == 'file') {\n    out.push('//');\n\n    var userInfo = this.getUserInfo();\n    if (userInfo) {\n      out.push(\n          goog.Uri.encodeSpecialChars_(\n              userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true),\n          '@');\n    }\n\n    out.push(goog.Uri.removeDoubleEncoding_(goog.string.urlEncode(domain)));\n\n    var port = this.getPort();\n    if (port != null) {\n      out.push(':', String(port));\n    }\n  }\n\n  var path = this.getPath();\n  if (path) {\n    if (this.hasDomain() && path.charAt(0) != '/') {\n      out.push('/');\n    }\n    out.push(\n        goog.Uri.encodeSpecialChars_(\n            path, path.charAt(0) == '/' ? goog.Uri.reDisallowedInAbsolutePath_ :\n                                          goog.Uri.reDisallowedInRelativePath_,\n            true));\n  }\n\n  var query = this.getEncodedQuery();\n  if (query) {\n    out.push('?', query);\n  }\n\n  var fragment = this.getFragment();\n  if (fragment) {\n    out.push(\n        '#', goog.Uri.encodeSpecialChars_(\n                 fragment, goog.Uri.reDisallowedInFragment_));\n  }\n  return out.join('');\n};\n\n\n/**\n * Resolves the given relative URI (a goog.Uri object), using the URI\n * represented by this instance as the base URI.\n *\n * There are several kinds of relative URIs:<br>\n * 1. foo - replaces the last part of the path, the whole query and fragment<br>\n * 2. /foo - replaces the path, the query and fragment<br>\n * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>\n * 4. ?foo - replace the query and fragment<br>\n * 5. #foo - replace the fragment only\n *\n * Additionally, if relative URI has a non-empty path, all \"..\" and \".\"\n * segments will be resolved, as described in RFC 3986.\n *\n * @param {!goog.Uri} relativeUri The relative URI to resolve.\n * @return {!goog.Uri} The resolved URI.\n */\ngoog.Uri.prototype.resolve = function(relativeUri) {\n\n  var absoluteUri = this.clone();\n\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setScheme(relativeUri.getScheme());\n  } else {\n    overridden = relativeUri.hasUserInfo();\n  }\n\n  if (overridden) {\n    absoluteUri.setUserInfo(relativeUri.getUserInfo());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setDomain(relativeUri.getDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var path = relativeUri.getPath();\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n  } else {\n    overridden = relativeUri.hasPath();\n    if (overridden) {\n      // resolve path properly\n      if (path.charAt(0) != '/') {\n        // path is relative\n        if (this.hasDomain() && !this.hasPath()) {\n          // RFC 3986, section 5.2.3, case 1\n          path = '/' + path;\n        } else {\n          // RFC 3986, section 5.2.3, case 2\n          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');\n          if (lastSlashIndex != -1) {\n            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;\n          }\n        }\n      }\n      path = goog.Uri.removeDotSegments(path);\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setPath(path);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setQueryData(relativeUri.getQueryData().clone());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setFragment(relativeUri.getFragment());\n  }\n\n  return absoluteUri;\n};\n\n\n/**\n * Clones the URI instance.\n * @return {!goog.Uri} New instance of the URI object.\n */\ngoog.Uri.prototype.clone = function() {\n  return new goog.Uri(this);\n};\n\n\n/**\n * @return {string} The encoded scheme/protocol for the URI.\n */\ngoog.Uri.prototype.getScheme = function() {\n  return this.scheme_;\n};\n\n\n/**\n * Sets the scheme/protocol.\n * @throws URIError If opt_decode is true and newScheme is malformed (that is,\n *     if decodeURIComponent fails).\n * @param {string} newScheme New scheme value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setScheme = function(newScheme, opt_decode) {\n  this.enforceReadOnly();\n  this.scheme_ =\n      opt_decode ? goog.Uri.decodeOrEmpty_(newScheme, true) : newScheme;\n\n  // remove an : at the end of the scheme so somebody can pass in\n  // window.location.protocol\n  if (this.scheme_) {\n    this.scheme_ = this.scheme_.replace(/:$/, '');\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the scheme has been set.\n */\ngoog.Uri.prototype.hasScheme = function() {\n  return !!this.scheme_;\n};\n\n\n/**\n * @return {string} The decoded user info.\n */\ngoog.Uri.prototype.getUserInfo = function() {\n  return this.userInfo_;\n};\n\n\n/**\n * Sets the userInfo.\n * @throws URIError If opt_decode is true and newUserInfo is malformed (that is,\n *     if decodeURIComponent fails).\n * @param {string} newUserInfo New userInfo value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setUserInfo = function(newUserInfo, opt_decode) {\n  this.enforceReadOnly();\n  this.userInfo_ =\n      opt_decode ? goog.Uri.decodeOrEmpty_(newUserInfo) : newUserInfo;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the user info has been set.\n */\ngoog.Uri.prototype.hasUserInfo = function() {\n  return !!this.userInfo_;\n};\n\n\n/**\n * @return {string} The decoded domain.\n */\ngoog.Uri.prototype.getDomain = function() {\n  return this.domain_;\n};\n\n\n/**\n * Sets the domain.\n * @throws URIError If opt_decode is true and newDomain is malformed (that is,\n *     if decodeURIComponent fails).\n * @param {string} newDomain New domain value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setDomain = function(newDomain, opt_decode) {\n  this.enforceReadOnly();\n  this.domain_ =\n      opt_decode ? goog.Uri.decodeOrEmpty_(newDomain, true) : newDomain;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the domain has been set.\n */\ngoog.Uri.prototype.hasDomain = function() {\n  return !!this.domain_;\n};\n\n\n/**\n * @return {?number} The port number.\n */\ngoog.Uri.prototype.getPort = function() {\n  return this.port_;\n};\n\n\n/**\n * Sets the port number.\n * @param {*} newPort Port number. Will be explicitly casted to a number.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPort = function(newPort) {\n  this.enforceReadOnly();\n\n  if (newPort) {\n    newPort = Number(newPort);\n    if (isNaN(newPort) || newPort < 0) {\n      throw new Error('Bad port number ' + newPort);\n    }\n    this.port_ = newPort;\n  } else {\n    this.port_ = null;\n  }\n\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the port has been set.\n */\ngoog.Uri.prototype.hasPort = function() {\n  return this.port_ != null;\n};\n\n\n/**\n  * @return {string} The decoded path.\n */\ngoog.Uri.prototype.getPath = function() {\n  return this.path_;\n};\n\n\n/**\n * Sets the path.\n * @throws URIError If opt_decode is true and newPath is malformed (that is,\n *     if decodeURIComponent fails).\n * @param {string} newPath New path value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPath = function(newPath, opt_decode) {\n  this.enforceReadOnly();\n  this.path_ = opt_decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the path has been set.\n */\ngoog.Uri.prototype.hasPath = function() {\n  return !!this.path_;\n};\n\n\n/**\n * @return {boolean} Whether the query string has been set.\n */\ngoog.Uri.prototype.hasQuery = function() {\n  return this.queryData_.toString() !== '';\n};\n\n\n/**\n * Sets the query data.\n * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n *     Applies only if queryData is a string.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQueryData = function(queryData, opt_decode) {\n  this.enforceReadOnly();\n\n  if (queryData instanceof goog.Uri.QueryData) {\n    this.queryData_ = queryData;\n    this.queryData_.setIgnoreCase(this.ignoreCase_);\n  } else {\n    if (!opt_decode) {\n      // QueryData accepts encoded query string, so encode it if\n      // opt_decode flag is not true.\n      queryData = goog.Uri.encodeSpecialChars_(\n          queryData, goog.Uri.reDisallowedInQuery_);\n    }\n    this.queryData_ = new goog.Uri.QueryData(queryData, null, this.ignoreCase_);\n  }\n\n  return this;\n};\n\n\n/**\n * Sets the URI query.\n * @param {string} newQuery New query value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQuery = function(newQuery, opt_decode) {\n  return this.setQueryData(newQuery, opt_decode);\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getEncodedQuery = function() {\n  return this.queryData_.toString();\n};\n\n\n/**\n * @return {string} The decoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getDecodedQuery = function() {\n  return this.queryData_.toDecodedString();\n};\n\n\n/**\n * Returns the query data.\n * @return {!goog.Uri.QueryData} QueryData object.\n */\ngoog.Uri.prototype.getQueryData = function() {\n  return this.queryData_;\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n *\n * Warning: This method, unlike other getter methods, returns encoded\n * value, instead of decoded one.\n */\ngoog.Uri.prototype.getQuery = function() {\n  return this.getEncodedQuery();\n};\n\n\n/**\n * Sets the value of the named query parameters, clearing previous values for\n * that key.\n *\n * @param {string} key The parameter to set.\n * @param {*} value The new value. Value does not need to be encoded.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setParameterValue = function(key, value) {\n  this.enforceReadOnly();\n  this.queryData_.set(key, value);\n  return this;\n};\n\n\n/**\n * Sets the values of the named query parameters, clearing previous values for\n * that key.  Not new values will currently be moved to the end of the query\n * string.\n *\n * So, <code>goog.Uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])\n * </code> yields <tt>foo?a=b&e=f&c=new</tt>.</p>\n *\n * @param {string} key The parameter to set.\n * @param {*} values The new values. If values is a single\n *     string then it will be treated as the sole value. Values do not need to\n *     be encoded.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setParameterValues = function(key, values) {\n  this.enforceReadOnly();\n\n  if (!goog.isArray(values)) {\n    values = [String(values)];\n  }\n\n  this.queryData_.setValues(key, values);\n\n  return this;\n};\n\n\n/**\n * Returns the value<b>s</b> for a given cgi parameter as a list of decoded\n * query parameter values.\n * @param {string} name The parameter to get values for.\n * @return {!Array<?>} The values for a given cgi parameter as a list of\n *     decoded query parameter values.\n */\ngoog.Uri.prototype.getParameterValues = function(name) {\n  return this.queryData_.getValues(name);\n};\n\n\n/**\n * Returns the first value for a given cgi parameter or undefined if the given\n * parameter name does not appear in the query string.\n * @param {string} paramName Unescaped parameter name.\n * @return {string|undefined} The first value for a given cgi parameter or\n *     undefined if the given parameter name does not appear in the query\n *     string.\n */\ngoog.Uri.prototype.getParameterValue = function(paramName) {\n  return /** @type {string|undefined} */ (this.queryData_.get(paramName));\n};\n\n\n/**\n * @return {string} The URI fragment, not including the #.\n */\ngoog.Uri.prototype.getFragment = function() {\n  return this.fragment_;\n};\n\n\n/**\n * Sets the URI fragment.\n * @throws URIError If opt_decode is true and newFragment is malformed (that is,\n *     if decodeURIComponent fails).\n * @param {string} newFragment New fragment value.\n * @param {boolean=} opt_decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setFragment = function(newFragment, opt_decode) {\n  this.enforceReadOnly();\n  this.fragment_ =\n      opt_decode ? goog.Uri.decodeOrEmpty_(newFragment) : newFragment;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI has a fragment set.\n */\ngoog.Uri.prototype.hasFragment = function() {\n  return !!this.fragment_;\n};\n\n\n/**\n * Returns true if this has the same domain as that of uri2.\n * @param {!goog.Uri} uri2 The URI object to compare to.\n * @return {boolean} true if same domain; false otherwise.\n */\ngoog.Uri.prototype.hasSameDomainAs = function(uri2) {\n  return ((!this.hasDomain() && !uri2.hasDomain()) ||\n          this.getDomain() == uri2.getDomain()) &&\n      ((!this.hasPort() && !uri2.hasPort()) ||\n       this.getPort() == uri2.getPort());\n};\n\n\n/**\n * Adds a random parameter to the Uri.\n * @return {!goog.Uri} Reference to this Uri object.\n */\ngoog.Uri.prototype.makeUnique = function() {\n  this.enforceReadOnly();\n  this.setParameterValue(goog.Uri.RANDOM_PARAM, goog.string.getRandomString());\n\n  return this;\n};\n\n\n/**\n * Removes the named query parameter.\n *\n * @param {string} key The parameter to remove.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.removeParameter = function(key) {\n  this.enforceReadOnly();\n  this.queryData_.remove(key);\n  return this;\n};\n\n\n/**\n * Sets whether Uri is read only. If this goog.Uri is read-only,\n * enforceReadOnly_ will be called at the start of any function that may modify\n * this Uri.\n * @param {boolean} isReadOnly whether this goog.Uri should be read only.\n * @return {!goog.Uri} Reference to this Uri object.\n */\ngoog.Uri.prototype.setReadOnly = function(isReadOnly) {\n  this.isReadOnly_ = isReadOnly;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI is read only.\n */\ngoog.Uri.prototype.isReadOnly = function() {\n  return this.isReadOnly_;\n};\n\n\n/**\n * Checks if this Uri has been marked as read only, and if so, throws an error.\n * This should be called whenever any modifying function is called.\n */\ngoog.Uri.prototype.enforceReadOnly = function() {\n  if (this.isReadOnly_) {\n    throw new Error('Tried to modify a read-only Uri');\n  }\n};\n\n\n/**\n * Sets whether to ignore case.\n * NOTE: If there are already key/value pairs in the QueryData, and\n * ignoreCase_ is set to false, the keys will all be lower-cased.\n * @param {boolean} ignoreCase whether this goog.Uri should ignore case.\n * @return {!goog.Uri} Reference to this Uri object.\n */\ngoog.Uri.prototype.setIgnoreCase = function(ignoreCase) {\n  this.ignoreCase_ = ignoreCase;\n  if (this.queryData_) {\n    this.queryData_.setIgnoreCase(ignoreCase);\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether to ignore case.\n */\ngoog.Uri.prototype.getIgnoreCase = function() {\n  return this.ignoreCase_;\n};\n\n\n//==============================================================================\n// Static members\n//==============================================================================\n\n\n/**\n * Creates a uri from the string form.  Basically an alias of new goog.Uri().\n * If a Uri object is passed to parse then it will return a clone of the object.\n *\n * @throws URIError If parsing the URI is malformed. The passed URI components\n *     should all be parseable by decodeURIComponent.\n * @param {*} uri Raw URI string or instance of Uri\n *     object.\n * @param {boolean=} opt_ignoreCase Whether to ignore the case of parameter\n * names in #getParameterValue.\n * @return {!goog.Uri} The new URI object.\n */\ngoog.Uri.parse = function(uri, opt_ignoreCase) {\n  return uri instanceof goog.Uri ? uri.clone() :\n                                   new goog.Uri(uri, opt_ignoreCase);\n};\n\n\n/**\n * Creates a new goog.Uri object from unencoded parts.\n *\n * @param {?string=} opt_scheme Scheme/protocol or full URI to parse.\n * @param {?string=} opt_userInfo username:password.\n * @param {?string=} opt_domain www.google.com.\n * @param {?number=} opt_port 9830.\n * @param {?string=} opt_path /some/path/to/a/file.html.\n * @param {string|goog.Uri.QueryData=} opt_query a=1&b=2.\n * @param {?string=} opt_fragment The fragment without the #.\n * @param {boolean=} opt_ignoreCase Whether to ignore parameter name case in\n *     #getParameterValue.\n *\n * @return {!goog.Uri} The new URI object.\n */\ngoog.Uri.create = function(\n    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_query,\n    opt_fragment, opt_ignoreCase) {\n\n  var uri = new goog.Uri(null, opt_ignoreCase);\n\n  // Only set the parts if they are defined and not empty strings.\n  opt_scheme && uri.setScheme(opt_scheme);\n  opt_userInfo && uri.setUserInfo(opt_userInfo);\n  opt_domain && uri.setDomain(opt_domain);\n  opt_port && uri.setPort(opt_port);\n  opt_path && uri.setPath(opt_path);\n  opt_query && uri.setQueryData(opt_query);\n  opt_fragment && uri.setFragment(opt_fragment);\n\n  return uri;\n};\n\n\n/**\n * Resolves a relative Uri against a base Uri, accepting both strings and\n * Uri objects.\n *\n * @param {*} base Base Uri.\n * @param {*} rel Relative Uri.\n * @return {!goog.Uri} Resolved uri.\n */\ngoog.Uri.resolve = function(base, rel) {\n  if (!(base instanceof goog.Uri)) {\n    base = goog.Uri.parse(base);\n  }\n\n  if (!(rel instanceof goog.Uri)) {\n    rel = goog.Uri.parse(rel);\n  }\n\n  return base.resolve(rel);\n};\n\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {string} path A non-empty path component.\n * @return {string} Path component with removed dot segments.\n */\ngoog.Uri.removeDotSegments = function(path) {\n  if (path == '..' || path == '.') {\n    return '';\n\n  } else if (\n      !goog.string.contains(path, './') && !goog.string.contains(path, '/.')) {\n    // This optimization detects uris which do not contain dot-segments,\n    // and as a consequence do not require any processing.\n    return path;\n\n  } else {\n    var leadingSlash = goog.string.startsWith(path, '/');\n    var segments = path.split('/');\n    var out = [];\n\n    for (var pos = 0; pos < segments.length;) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else if (segment == '..') {\n        if (out.length > 1 || out.length == 1 && out[0] != '') {\n          out.pop();\n        }\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join('/');\n  }\n};\n\n\n/**\n * Decodes a value or returns the empty string if it isn't defined or empty.\n * @throws URIError If decodeURIComponent fails to decode val.\n * @param {string|undefined} val Value to decode.\n * @param {boolean=} opt_preserveReserved If true, restricted characters will\n *     not be decoded.\n * @return {string} Decoded value.\n * @private\n */\ngoog.Uri.decodeOrEmpty_ = function(val, opt_preserveReserved) {\n  // Don't use UrlDecode() here because val is not a query parameter.\n  if (!val) {\n    return '';\n  }\n\n  // decodeURI has the same output for '%2f' and '%252f'. We double encode %25\n  // so that we can distinguish between the 2 inputs. This is later undone by\n  // removeDoubleEncoding_.\n  return opt_preserveReserved ? decodeURI(val.replace(/%25/g, '%2525')) :\n                                decodeURIComponent(val);\n};\n\n\n/**\n * If unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param {*} unescapedPart The string to encode.\n * @param {RegExp} extra A character set of characters in [\\01-\\177].\n * @param {boolean=} opt_removeDoubleEncoding If true, remove double percent\n *     encoding.\n * @return {?string} null iff unescapedPart == null.\n * @private\n */\ngoog.Uri.encodeSpecialChars_ = function(\n    unescapedPart, extra, opt_removeDoubleEncoding) {\n  if (goog.isString(unescapedPart)) {\n    var encoded = encodeURI(unescapedPart).replace(extra, goog.Uri.encodeChar_);\n    if (opt_removeDoubleEncoding) {\n      // encodeURI double-escapes %XX sequences used to represent restricted\n      // characters in some URI components, remove the double escaping here.\n      encoded = goog.Uri.removeDoubleEncoding_(encoded);\n    }\n    return encoded;\n  }\n  return null;\n};\n\n\n/**\n * Converts a character in [\\01-\\177] to its unicode character equivalent.\n * @param {string} ch One character string.\n * @return {string} Encoded string.\n * @private\n */\ngoog.Uri.encodeChar_ = function(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);\n};\n\n\n/**\n * Removes double percent-encoding from a string.\n * @param  {string} doubleEncodedString String\n * @return {string} String with double encoding removed.\n * @private\n */\ngoog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {\n  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');\n};\n\n\n/**\n * Regular expression for characters that are disallowed in the scheme or\n * userInfo part of the URI.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\\/\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in a relative path.\n * Colon is included due to RFC 3986 3.3.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInRelativePath_ = /[\\#\\?:]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in an absolute path.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInAbsolutePath_ = /[\\#\\?]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the query.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInQuery_ = /[\\#\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the fragment.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInFragment_ = /#/g;\n\n\n/**\n * Checks whether two URIs have the same domain.\n * @param {string} uri1String First URI string.\n * @param {string} uri2String Second URI string.\n * @return {boolean} true if the two URIs have the same domain; false otherwise.\n */\ngoog.Uri.haveSameDomain = function(uri1String, uri2String) {\n  // Differs from goog.uri.utils.haveSameDomain, since this ignores scheme.\n  // TODO(gboyer): Have this just call goog.uri.util.haveSameDomain.\n  var pieces1 = goog.uri.utils.split(uri1String);\n  var pieces2 = goog.uri.utils.split(uri2String);\n  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==\n      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&\n      pieces1[goog.uri.utils.ComponentIndex.PORT] ==\n      pieces2[goog.uri.utils.ComponentIndex.PORT];\n};\n\n\n\n/**\n * Class used to represent URI query parameters.  It is essentially a hash of\n * name-value pairs, though a name can be present more than once.\n *\n * Has the same interface as the collections in goog.structs.\n *\n * @param {?string=} opt_query Optional encoded query string to parse into\n *     the object.\n * @param {goog.Uri=} opt_uri Optional uri object that should have its\n *     cache invalidated when this object updates. Deprecated -- this\n *     is no longer required.\n * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter\n *     name in #get.\n * @constructor\n * @struct\n * @final\n */\ngoog.Uri.QueryData = function(opt_query, opt_uri, opt_ignoreCase) {\n  /**\n   * The map containing name/value or name/array-of-values pairs.\n   * May be null if it requires parsing from the query string.\n   *\n   * We need to use a Map because we cannot guarantee that the key names will\n   * not be problematic for IE.\n   *\n   * @private {?goog.structs.Map<string, !Array<*>>}\n   */\n  this.keyMap_ = null;\n\n  /**\n   * The number of params, or null if it requires computing.\n   * @private {?number}\n   */\n  this.count_ = null;\n\n  /**\n   * Encoded query string, or null if it requires computing from the key map.\n   * @private {?string}\n   */\n  this.encodedQuery_ = opt_query || null;\n\n  /**\n   * If true, ignore the case of the parameter name in #get.\n   * @private {boolean}\n   */\n  this.ignoreCase_ = !!opt_ignoreCase;\n};\n\n\n/**\n * If the underlying key map is not yet initialized, it parses the\n * query string and fills the map with parsed data.\n * @private\n */\ngoog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {\n  if (!this.keyMap_) {\n    this.keyMap_ = new goog.structs.Map();\n    this.count_ = 0;\n    if (this.encodedQuery_) {\n      var self = this;\n      goog.uri.utils.parseQueryData(this.encodedQuery_, function(name, value) {\n        self.add(goog.string.urlDecode(name), value);\n      });\n    }\n  }\n};\n\n\n/**\n * Creates a new query data instance from a map of names and values.\n *\n * @param {!goog.structs.Map<string, ?>|!Object} map Map of string parameter\n *     names to parameter value. If parameter value is an array, it is\n *     treated as if the key maps to each individual value in the\n *     array.\n * @param {goog.Uri=} opt_uri URI object that should have its cache\n *     invalidated when this object updates.\n * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter\n *     name in #get.\n * @return {!goog.Uri.QueryData} The populated query data instance.\n */\ngoog.Uri.QueryData.createFromMap = function(map, opt_uri, opt_ignoreCase) {\n  var keys = goog.structs.getKeys(map);\n  if (typeof keys == 'undefined') {\n    throw new Error('Keys are undefined');\n  }\n\n  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);\n  var values = goog.structs.getValues(map);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = values[i];\n    if (!goog.isArray(value)) {\n      queryData.add(key, value);\n    } else {\n      queryData.setValues(key, value);\n    }\n  }\n  return queryData;\n};\n\n\n/**\n * Creates a new query data instance from parallel arrays of parameter names\n * and values. Allows for duplicate parameter names. Throws an error if the\n * lengths of the arrays differ.\n *\n * @param {!Array<string>} keys Parameter names.\n * @param {!Array<?>} values Parameter values.\n * @param {goog.Uri=} opt_uri URI object that should have its cache\n *     invalidated when this object updates.\n * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter\n *     name in #get.\n * @return {!goog.Uri.QueryData} The populated query data instance.\n */\ngoog.Uri.QueryData.createFromKeysValues = function(\n    keys, values, opt_uri, opt_ignoreCase) {\n  if (keys.length != values.length) {\n    throw new Error('Mismatched lengths for keys/values');\n  }\n  var queryData = new goog.Uri.QueryData(null, null, opt_ignoreCase);\n  for (var i = 0; i < keys.length; i++) {\n    queryData.add(keys[i], values[i]);\n  }\n  return queryData;\n};\n\n\n/**\n * @return {?number} The number of parameters.\n */\ngoog.Uri.QueryData.prototype.getCount = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_;\n};\n\n\n/**\n * Adds a key value pair.\n * @param {string} key Name.\n * @param {*} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.add = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  this.invalidateCache_();\n\n  key = this.getKeyName_(key);\n  var values = this.keyMap_.get(key);\n  if (!values) {\n    this.keyMap_.set(key, (values = []));\n  }\n  values.push(value);\n  this.count_ = goog.asserts.assertNumber(this.count_) + 1;\n  return this;\n};\n\n\n/**\n * Removes all the params with the given key.\n * @param {string} key Name.\n * @return {boolean} Whether any parameter was removed.\n */\ngoog.Uri.QueryData.prototype.remove = function(key) {\n  this.ensureKeyMapInitialized_();\n\n  key = this.getKeyName_(key);\n  if (this.keyMap_.containsKey(key)) {\n    this.invalidateCache_();\n\n    // Decrement parameter count.\n    this.count_ =\n        goog.asserts.assertNumber(this.count_) - this.keyMap_.get(key).length;\n    return this.keyMap_.remove(key);\n  }\n  return false;\n};\n\n\n/**\n * Clears the parameters.\n */\ngoog.Uri.QueryData.prototype.clear = function() {\n  this.invalidateCache_();\n  this.keyMap_ = null;\n  this.count_ = 0;\n};\n\n\n/**\n * @return {boolean} Whether we have any parameters.\n */\ngoog.Uri.QueryData.prototype.isEmpty = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_ == 0;\n};\n\n\n/**\n * Whether there is a parameter with the given name\n * @param {string} key The parameter name to check for.\n * @return {boolean} Whether there is a parameter with the given name.\n */\ngoog.Uri.QueryData.prototype.containsKey = function(key) {\n  this.ensureKeyMapInitialized_();\n  key = this.getKeyName_(key);\n  return this.keyMap_.containsKey(key);\n};\n\n\n/**\n * Whether there is a parameter with the given value.\n * @param {*} value The value to check for.\n * @return {boolean} Whether there is a parameter with the given value.\n */\ngoog.Uri.QueryData.prototype.containsValue = function(value) {\n  // NOTE(arv): This solution goes through all the params even if it was the\n  // first param. We can get around this by not reusing code or by switching to\n  // iterators.\n  var vals = this.getValues();\n  return goog.array.contains(vals, value);\n};\n\n\n/**\n * Runs a callback on every key-value pair in the map, including duplicate keys.\n * This won't maintain original order when duplicate keys are interspersed (like\n * getKeys() / getValues()).\n * @param {function(this:SCOPE, ?, string, !goog.Uri.QueryData)} f\n * @param {SCOPE=} opt_scope The value of \"this\" inside f.\n * @template SCOPE\n */\ngoog.Uri.QueryData.prototype.forEach = function(f, opt_scope) {\n  this.ensureKeyMapInitialized_();\n  this.keyMap_.forEach(function(values, key) {\n    goog.array.forEach(values, function(value) {\n      f.call(opt_scope, value, key, this);\n    }, this);\n  }, this);\n};\n\n\n/**\n * Returns all the keys of the parameters. If a key is used multiple times\n * it will be included multiple times in the returned array\n * @return {!Array<string>} All the keys of the parameters.\n */\ngoog.Uri.QueryData.prototype.getKeys = function() {\n  this.ensureKeyMapInitialized_();\n  // We need to get the values to know how many keys to add.\n  var vals = this.keyMap_.getValues();\n  var keys = this.keyMap_.getKeys();\n  var rv = [];\n  for (var i = 0; i < keys.length; i++) {\n    var val = vals[i];\n    for (var j = 0; j < val.length; j++) {\n      rv.push(keys[i]);\n    }\n  }\n  return rv;\n};\n\n\n/**\n * Returns all the values of the parameters with the given name. If the query\n * data has no such key this will return an empty array. If no key is given\n * all values wil be returned.\n * @param {string=} opt_key The name of the parameter to get the values for.\n * @return {!Array<?>} All the values of the parameters with the given name.\n */\ngoog.Uri.QueryData.prototype.getValues = function(opt_key) {\n  this.ensureKeyMapInitialized_();\n  var rv = [];\n  if (goog.isString(opt_key)) {\n    if (this.containsKey(opt_key)) {\n      rv = goog.array.concat(rv, this.keyMap_.get(this.getKeyName_(opt_key)));\n    }\n  } else {\n    // Return all values.\n    var values = this.keyMap_.getValues();\n    for (var i = 0; i < values.length; i++) {\n      rv = goog.array.concat(rv, values[i]);\n    }\n  }\n  return rv;\n};\n\n\n/**\n * Sets a key value pair and removes all other keys with the same value.\n *\n * @param {string} key Name.\n * @param {*} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.set = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  this.invalidateCache_();\n\n  // TODO(chrishenry): This could be better written as\n  // this.remove(key), this.add(key, value), but that would reorder\n  // the key (since the key is first removed and then added at the\n  // end) and we would have to fix unit tests that depend on key\n  // ordering.\n  key = this.getKeyName_(key);\n  if (this.containsKey(key)) {\n    this.count_ =\n        goog.asserts.assertNumber(this.count_) - this.keyMap_.get(key).length;\n  }\n  this.keyMap_.set(key, [value]);\n  this.count_ = goog.asserts.assertNumber(this.count_) + 1;\n  return this;\n};\n\n\n/**\n * Returns the first value associated with the key. If the query data has no\n * such key this will return undefined or the optional default.\n * @param {string} key The name of the parameter to get the value for.\n * @param {*=} opt_default The default value to return if the query data\n *     has no such key.\n * @return {*} The first string value associated with the key, or opt_default\n *     if there's no value.\n */\ngoog.Uri.QueryData.prototype.get = function(key, opt_default) {\n  if (!key) {\n    return opt_default;\n  }\n  var values = this.getValues(key);\n  return values.length > 0 ? String(values[0]) : opt_default;\n};\n\n\n/**\n * Sets the values for a key. If the key already exists, this will\n * override all of the existing values that correspond to the key.\n * @param {string} key The key to set values for.\n * @param {!Array<?>} values The values to set.\n */\ngoog.Uri.QueryData.prototype.setValues = function(key, values) {\n  this.remove(key);\n\n  if (values.length > 0) {\n    this.invalidateCache_();\n    this.keyMap_.set(this.getKeyName_(key), goog.array.clone(values));\n    this.count_ = goog.asserts.assertNumber(this.count_) + values.length;\n  }\n};\n\n\n/**\n * @return {string} Encoded query string.\n * @override\n */\ngoog.Uri.QueryData.prototype.toString = function() {\n  if (this.encodedQuery_) {\n    return this.encodedQuery_;\n  }\n\n  if (!this.keyMap_) {\n    return '';\n  }\n\n  var sb = [];\n\n  // In the past, we use this.getKeys() and this.getVals(), but that\n  // generates a lot of allocations as compared to simply iterating\n  // over the keys.\n  var keys = this.keyMap_.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var encodedKey = goog.string.urlEncode(key);\n    var val = this.getValues(key);\n    for (var j = 0; j < val.length; j++) {\n      var param = encodedKey;\n      // Ensure that null and undefined are encoded into the url as\n      // literal strings.\n      if (val[j] !== '') {\n        param += '=' + goog.string.urlEncode(val[j]);\n      }\n      sb.push(param);\n    }\n  }\n\n  return this.encodedQuery_ = sb.join('&');\n};\n\n\n/**\n * @throws URIError If URI is malformed (that is, if decodeURIComponent fails on\n *     any of the URI components).\n * @return {string} Decoded query string.\n */\ngoog.Uri.QueryData.prototype.toDecodedString = function() {\n  return goog.Uri.decodeOrEmpty_(this.toString());\n};\n\n\n/**\n * Invalidate the cache.\n * @private\n */\ngoog.Uri.QueryData.prototype.invalidateCache_ = function() {\n  this.encodedQuery_ = null;\n};\n\n\n/**\n * Removes all keys that are not in the provided list. (Modifies this object.)\n * @param {Array<string>} keys The desired keys.\n * @return {!goog.Uri.QueryData} a reference to this object.\n */\ngoog.Uri.QueryData.prototype.filterKeys = function(keys) {\n  this.ensureKeyMapInitialized_();\n  this.keyMap_.forEach(function(value, key) {\n    if (!goog.array.contains(keys, key)) {\n      this.remove(key);\n    }\n  }, this);\n  return this;\n};\n\n\n/**\n * Clone the query data instance.\n * @return {!goog.Uri.QueryData} New instance of the QueryData object.\n */\ngoog.Uri.QueryData.prototype.clone = function() {\n  var rv = new goog.Uri.QueryData();\n  rv.encodedQuery_ = this.encodedQuery_;\n  if (this.keyMap_) {\n    rv.keyMap_ = this.keyMap_.clone();\n    rv.count_ = this.count_;\n  }\n  return rv;\n};\n\n\n/**\n * Helper function to get the key name from a JavaScript object. Converts\n * the object to a string, and to lower case if necessary.\n * @private\n * @param {*} arg The object to get a key name from.\n * @return {string} valid key name which can be looked up in #keyMap_.\n */\ngoog.Uri.QueryData.prototype.getKeyName_ = function(arg) {\n  var keyName = String(arg);\n  if (this.ignoreCase_) {\n    keyName = keyName.toLowerCase();\n  }\n  return keyName;\n};\n\n\n/**\n * Ignore case in parameter names.\n * NOTE: If there are already key/value pairs in the QueryData, and\n * ignoreCase_ is set to false, the keys will all be lower-cased.\n * @param {boolean} ignoreCase whether this goog.Uri should ignore case.\n */\ngoog.Uri.QueryData.prototype.setIgnoreCase = function(ignoreCase) {\n  var resetKeys = ignoreCase && !this.ignoreCase_;\n  if (resetKeys) {\n    this.ensureKeyMapInitialized_();\n    this.invalidateCache_();\n    this.keyMap_.forEach(function(value, key) {\n      var lowerCase = key.toLowerCase();\n      if (key != lowerCase) {\n        this.remove(key);\n        this.setValues(lowerCase, value);\n      }\n    }, this);\n  }\n  this.ignoreCase_ = ignoreCase;\n};\n\n\n/**\n * Extends a query data object with another query data or map like object. This\n * operates 'in-place', it does not create a new QueryData object.\n *\n * @param {...(?goog.Uri.QueryData|?goog.structs.Map<?, ?>|?Object)} var_args\n *     The object from which key value pairs will be copied. Note: does not\n *     accept null.\n * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different\n * types of parameters.\n */\ngoog.Uri.QueryData.prototype.extend = function(var_args) {\n  for (var i = 0; i < arguments.length; i++) {\n    var data = arguments[i];\n    goog.structs.forEach(\n        data, function(value, key) { this.add(key, value); }, this);\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines fireauth.iframeclient.IfcHandler used to communicate\n * with the serverless widget.\n */\n\ngoog.provide('fireauth.iframeclient.IfcHandler');\ngoog.provide('fireauth.iframeclient.IframeUrlBuilder');\ngoog.provide('fireauth.iframeclient.OAuthUrlBuilder');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.AuthProvider');\ngoog.require('fireauth.InvalidOriginError');\ngoog.require('fireauth.OAuthSignInHandler');\ngoog.require('fireauth.RpcHandler');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.iframeclient.IframeWrapper');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\ngoog.require('goog.Uri');\ngoog.require('goog.array');\ngoog.require('goog.object');\n\n\n/**\n * The OAuth handler and iframe prototcol.\n * @const {string}\n * @suppress {const|duplicate}\n */\nfireauth.iframeclient.SCHEME = 'https';\n\n\n\n/**\n * The OAuth handler and iframe port number.\n * @const {?number}\n * @suppress {const|duplicate}\n */\nfireauth.iframeclient.PORT_NUMBER = null;\n\n\n\n/**\n * The iframe URL builder used to build the iframe widget URL.\n * @param {string} authDomain The application authDomain.\n * @param {string} apiKey The API key.\n * @param {string} appName The App name.\n * @constructor\n */\nfireauth.iframeclient.IframeUrlBuilder = function(authDomain, apiKey, appName) {\n  /** @private {string} The application authDomain. */\n  this.authDomain_ = authDomain;\n  /** @private {string} The API key. */\n  this.apiKey_ = apiKey;\n  /** @private {string} The App name. */\n  this.appName_ = appName;\n  /** @private {?string|undefined} The client version. */\n  this.v_ = null;\n  /**\n   * @private {!goog.Uri} The URI object used to build the iframe URL.\n   */\n  this.uri_ = goog.Uri.create(\n      fireauth.iframeclient.SCHEME,\n      null,\n      this.authDomain_,\n      fireauth.iframeclient.PORT_NUMBER,\n      '/__/auth/iframe',\n      null,\n      null);\n  this.uri_.setParameterValue('apiKey', this.apiKey_);\n  this.uri_.setParameterValue('appName', this.appName_);\n  /** @private {?string|undefined} The endpoint ID. */\n  this.endpointId_ = null;\n  /** @private {!Array<string>} The list of framework IDs. */\n  this.frameworks_ = [];\n};\n\n\n/**\n * Sets the client version.\n * @param {?string|undefined} v The client version.\n * @return {!fireauth.iframeclient.IframeUrlBuilder} The current iframe URL\n *     builder instance.\n */\nfireauth.iframeclient.IframeUrlBuilder.prototype.setVersion = function(v) {\n  this.v_ = v;\n  return this;\n};\n\n\n/**\n * Sets the endpoint ID.\n * @param {?string|undefined} eid The endpoint ID (staging, test Gaia, etc).\n * @return {!fireauth.iframeclient.IframeUrlBuilder} The current iframe URL\n *     builder instance.\n */\nfireauth.iframeclient.IframeUrlBuilder.prototype.setEndpointId = function(eid) {\n  this.endpointId_ = eid;\n  return this;\n};\n\n\n/**\n * Sets the list of frameworks to pass to the iframe.\n * @param {?Array<string>|undefined} frameworks The list of frameworks to log.\n * @return {!fireauth.iframeclient.IframeUrlBuilder} The current iframe URL\n *     builder instance.\n */\nfireauth.iframeclient.IframeUrlBuilder.prototype.setFrameworks =\n    function(frameworks) {\n  this.frameworks_ = goog.array.clone(frameworks || []);\n  return this;\n};\n\n\n/**\n * Modifes the URI with the relevant Auth provider parameters.\n * @return {string} The constructed OAuth URL string.\n * @override\n */\nfireauth.iframeclient.IframeUrlBuilder.prototype.toString = function() {\n  // Pass the client version if available.\n  if (this.v_) {\n    this.uri_.setParameterValue('v', this.v_);\n  } else {\n    this.uri_.removeParameter('v');\n  }\n  // Pass the endpoint ID if available.\n  if (this.endpointId_) {\n    this.uri_.setParameterValue('eid', this.endpointId_);\n  } else {\n    this.uri_.removeParameter('eid');\n  }\n  // Pass the list of frameworks if available.\n  if (this.frameworks_.length) {\n    this.uri_.setParameterValue('fw', this.frameworks_.join(','));\n  } else {\n    this.uri_.removeParameter('fw');\n  }\n  return this.uri_.toString();\n};\n\n\n\n/**\n * The OAuth URL builder used to build the OAuth handler widget URL.\n * @param {string} authDomain The application authDomain.\n * @param {string} apiKey The API key.\n * @param {string} appName The App name.\n * @param {string} authType The Auth operation type.\n * @param {!fireauth.AuthProvider} provider The Auth provider that the OAuth\n *     handler request is built to sign in to.\n * @constructor\n */\nfireauth.iframeclient.OAuthUrlBuilder =\n    function(authDomain, apiKey, appName, authType, provider) {\n  /** @private {string} The application authDomain. */\n  this.authDomain_ = authDomain;\n  /** @private {string} The API key. */\n  this.apiKey_ = apiKey;\n  /** @private {string} The App name. */\n  this.appName_ = appName;\n  /** @private {string} The Auth operation type. */\n  this.authType_ = authType;\n  /**\n   * @private {?string|undefined} The redirect URL used in redirect operations.\n   */\n  this.redirectUrl_ = null;\n  /** @private {?string|undefined} The event ID. */\n  this.eventId_ = null;\n  /** @private {?string|undefined} The client version. */\n  this.v_ = null;\n  /**\n   * @private {!fireauth.AuthProvider} The Firebase Auth provider that the OAuth\n   *     handler request is built to sign in to.\n   */\n  this.provider_ = provider;\n  /** @private {?string|undefined} The endpoint ID. */\n  this.endpointId_ = null;\n  /** @private {?string|undefined} The tenant ID. */\n  this.tenantId_ = null;\n};\n\n\n/**\n * Sets the redirect URL.\n * @param {?string|undefined} redirectUrl The redirect URL used in redirect\n *     operations.\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setRedirectUrl =\n    function(redirectUrl) {\n  this.redirectUrl_ = redirectUrl;\n  return this;\n};\n\n\n/**\n * Sets the event ID.\n * @param {?string|undefined} eventId The event ID.\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setEventId = function(eventId) {\n  this.eventId_ = eventId;\n  return this;\n};\n\n\n/**\n * Sets the tenant ID.\n * @param {?string|undefined} tenantId The event ID.\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setTenantId =\n    function(tenantId) {\n  this.tenantId_ = tenantId;\n  return this;\n};\n\n\n/**\n * Sets the client version.\n * @param {?string|undefined} v The client version.\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setVersion = function(v) {\n  this.v_ = v;\n  return this;\n};\n\n\n/**\n * Sets the endpoint ID.\n * @param {?string|undefined} eid The endpoint ID (staging, test Gaia, etc).\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setEndpointId = function(eid) {\n  this.endpointId_ = eid;\n  return this;\n};\n\n\n/**\n * Sets any additional optional parameters. This will overwrite any previously\n * set additional parameters.\n * @param {?Object<string, string>|undefined} additionalParams The optional\n *     additional parameters.\n * @return {!fireauth.iframeclient.OAuthUrlBuilder} The current OAuth URL\n *     builder instance.\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.setAdditionalParameters =\n    function(additionalParams) {\n  this.additionalParams_ = goog.object.clone(additionalParams || null);\n  return this;\n};\n\n\n/**\n * Modifies the URI with the relevant Auth provider parameters.\n * @return {string} The constructed OAuth URL string.\n * @override\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.toString = function() {\n  var uri = goog.Uri.create(\n      fireauth.iframeclient.SCHEME,\n      null,\n      this.authDomain_,\n      fireauth.iframeclient.PORT_NUMBER,\n      '/__/auth/handler',\n      null,\n      null);\n  uri.setParameterValue('apiKey', this.apiKey_);\n  uri.setParameterValue('appName', this.appName_);\n  uri.setParameterValue('authType', this.authType_);\n\n  // Add custom parameters for OAuth1/OAuth2 providers.\n  if (this.provider_['isOAuthProvider']) {\n    // Set default language if available and no language already set.\n    /** @type {!fireauth.FederatedProvider} */ (this.provider_)\n        .setDefaultLanguage(this.getAuthLanguage_());\n    uri.setParameterValue('providerId', this.provider_['providerId']);\n    var customParameters = /** @type {!fireauth.FederatedProvider} */ (\n        this.provider_).getCustomParameters();\n    if (!goog.object.isEmpty(customParameters)) {\n      uri.setParameterValue(\n          'customParameters',\n          /** @type {string} */ (fireauth.util.stringifyJSON(customParameters))\n          );\n    }\n  }\n\n  // Add scopes for OAuth2 providers.\n  if (typeof this.provider_.getScopes === 'function') {\n    var scopes = this.provider_.getScopes();\n    if (scopes.length) {\n      uri.setParameterValue('scopes', scopes.join(','));\n    }\n  }\n\n  if (this.redirectUrl_) {\n    uri.setParameterValue('redirectUrl', this.redirectUrl_);\n  } else {\n    uri.removeParameter('redirectUrl');\n  }\n  if (this.eventId_) {\n    uri.setParameterValue('eventId', this.eventId_);\n  } else {\n    uri.removeParameter('eventId');\n  }\n  // Pass the client version if available.\n  if (this.v_) {\n    uri.setParameterValue('v', this.v_);\n  } else {\n    uri.removeParameter('v');\n  }\n  if (this.additionalParams_) {\n    for (var key in this.additionalParams_) {\n      if (this.additionalParams_.hasOwnProperty(key) &&\n          // Don't overwrite other existing parameters.\n          !uri.getParameterValue(key)) {\n        uri.setParameterValue(key, this.additionalParams_[key]);\n      }\n    }\n  }\n  // Pass the tenant ID if available.\n  if (this.tenantId_) {\n    uri.setParameterValue('tid', this.tenantId_);\n  } else {\n    uri.removeParameter('tid');\n  }\n  // Pass the endpoint ID if available.\n  if (this.endpointId_) {\n    uri.setParameterValue('eid', this.endpointId_);\n  } else {\n    uri.removeParameter('eid');\n  }\n  // Append any framework IDs to the handler URL to log in handler RPC requests.\n  var frameworks = this.getAuthFrameworks_();\n  if (frameworks.length) {\n    uri.setParameterValue('fw', frameworks.join(','));\n  }\n  return uri.toString();\n};\n\n\n/**\n * Returns the current Auth instance's language code.\n * @return {?string} The corresponding language code.\n * @private\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.getAuthLanguage_ = function() {\n  try {\n    // Get the Auth instance for the current App identified by the App name.\n    // This could fail if, for example, the App instance was deleted.\n    return firebase['app'](this.appName_)['auth']().getLanguageCode();\n  } catch (e) {\n    return null;\n  }\n};\n\n\n/**\n * Returns the list of Firebase frameworks used for logging purposes.\n * @return {!Array<string>} The list of corresponding Firebase frameworks.\n * @private\n */\nfireauth.iframeclient.OAuthUrlBuilder.prototype.getAuthFrameworks_ =\n    function() {\n  return fireauth.iframeclient.OAuthUrlBuilder.getAuthFrameworksForApp_(\n      this.appName_);\n};\n\n\n/**\n * Returns the list of Firebase frameworks used for logging purposes\n * corresponding to the Firebase App name provided.\n * @param {string} appName The Firebase App name.\n * @return {!Array<string>} The list of corresponding Firebase frameworks.\n * @private\n */\nfireauth.iframeclient.OAuthUrlBuilder.getAuthFrameworksForApp_ =\n    function(appName) {\n  try {\n    // Get the Auth instance's list of Firebase framework IDs for the current\n    // App identified by the App name.\n    // This could fail if, for example, the App instance was deleted.\n    return firebase['app'](appName)['auth']().getFramework();\n  } catch (e) {\n    return [];\n  }\n};\n\n\n\n/**\n * Initializes the ifcHandler which provides the mechanism to listen to Auth\n * events on the hidden iframe.\n * @param {string} authDomain The firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The App ID for the Auth instance that triggered this\n *     request.\n * @param {?string=} opt_clientVersion The optional client version string.\n * @param {?string=} opt_endpointId The endpoint ID (staging, test Gaia, etc).\n * @constructor\n * @implements {fireauth.OAuthSignInHandler}\n */\nfireauth.iframeclient.IfcHandler = function(authDomain, apiKey, appName,\n    opt_clientVersion, opt_endpointId) {\n  /** @private {string} The Auth domain. */\n  this.authDomain_ = authDomain;\n  /** @private {string} The API key. */\n  this.apiKey_ = apiKey;\n  /** @private {string} The App name. */\n  this.appName_ = appName;\n  /** @private {?string} The client version. */\n  this.clientVersion_ = opt_clientVersion || null;\n  /** @private {?string} The Auth endpoint ID. */\n  this.endpointId_ = opt_endpointId || null;\n  // Delay RPC handler and iframe URL initialization until needed to ensure\n  // logged frameworks are propagated to the iframe.\n  /** @private {?string} The full client version string. */\n  this.fullClientVersion_ = null;\n  /** @private {?string} The iframe URL. */\n  this.iframeUrl_ = null;\n  /** @private {?fireauth.RpcHandler} The RPC handler for provided API key. */\n  this.rpcHandler_ = null;\n  /**\n   * @private {!Array<!function(?fireauth.AuthEvent)>} The Auth event\n   *     listeners.\n   */\n  this.authEventListeners_ = [];\n  // Delay origin validator determination until needed, so the error is not\n  // thrown in the background. This will also prevent the getProjectConfig RPC\n  // until it is required.\n  /** @private {?goog.Promise} The origin validator. */\n  this.originValidator_ = null;\n  /** @private {?goog.Promise} The initialization promise. */\n  this.isInitialized_ = null;\n};\n\n\n/**\n * Validates the provided URL.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler used to validate the\n *     requested origin.\n * @param {string=} opt_origin The optional page origin. If not provided, the\n *     window.location.href value is used.\n * @return {!goog.Promise} The promise that resolves if the provided origin is\n *     valid.\n * @private\n */\nfireauth.iframeclient.IfcHandler.getOriginValidator_ =\n    function(rpcHandler, opt_origin) {\n  var origin = opt_origin || fireauth.util.getCurrentUrl();\n  return rpcHandler.getAuthorizedDomains().then(function(authorizedDomains) {\n    if (!fireauth.util.isAuthorizedDomain(authorizedDomains, origin)) {\n      throw new fireauth.InvalidOriginError(fireauth.util.getCurrentUrl());\n    }\n  });\n};\n\n\n/**\n * Initializes the iframe client wrapper.\n * @return {!goog.Promise} The promise that resolves on initialization.\n */\nfireauth.iframeclient.IfcHandler.prototype.initialize = function() {\n  // Already initialized.\n  if (this.isInitialized_) {\n    return this.isInitialized_;\n  }\n  var self = this;\n  this.isInitialized_ = fireauth.util.onDomReady().then(function() {\n    /**\n     * @private {!fireauth.iframeclient.IframeWrapper} The iframe wrapper\n     *     instance.\n     */\n    self.iframeWrapper_ = new fireauth.iframeclient.IframeWrapper(\n        self.getIframeUrl());\n    // Register all event listeners to Auth event messages sent from Auth\n    // iframe.\n    self.registerEvents_();\n  });\n  return this.isInitialized_;\n};\n\n\n/**\n * Waits for popup window to close. When closed start timeout listener for popup\n * pending promise. If in the process, it was detected that the iframe does not\n * support web storage, the popup is closed and the web storage unsupported\n * error is thrown.\n * @param {!Window} popupWin The popup window.\n * @param {!function(!fireauth.AuthError)} onError The on error callback.\n * @param {number} timeoutDuration The time to wait in ms after the popup is\n *     closed before triggering the popup closed by user error.\n * @return {!goog.Promise}\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.startPopupTimeout =\n    function(popupWin, onError, timeoutDuration) {\n  // Expire pending timeout promise for popup operation.\n  var popupClosedByUserError = new fireauth.AuthError(\n      fireauth.authenum.Error.POPUP_CLOSED_BY_USER);\n  // If web storage is disabled in the iframe, expire popup timeout quickly with\n  // this error.\n  var webStorageNotSupportedError = new fireauth.AuthError(\n      fireauth.authenum.Error.WEB_STORAGE_UNSUPPORTED);\n  var self = this;\n  var isResolved = false;\n  // Wait for the iframe to be ready first.\n  return this.initializeAndWait().then(function() {\n    // We do not return isWebStorageSupported() to ensure that this is backward\n    // compatible.\n    // Pushing the following client changes before updating the iframe to\n    // respond to these events would continue to work.\n    // The downside is that the popup could be closed before this resolves.\n    // In that case, they would get an error that the popup was closed and not\n    // the error that web storage is not supported, though that is unlikely\n    // as isWebStorageSupported should execute faster than the popup timeout.\n    // If web storage is not supported in the iframe, fail quickly.\n    self.isWebStorageSupported().then(function(isSupported) {\n      if (!isSupported) {\n        // If not supported, close window.\n        if (popupWin) {\n          fireauth.util.closeWindow(popupWin);\n        }\n        onError(webStorageNotSupportedError);\n        isResolved = true;\n      }\n    });\n  }).thenCatch(function(error) {\n    // Ignore any possible error in iframe embedding.\n    // These types of errors will be handled in processPopup which will close\n    // the popup too if that happens.\n    return;\n  }).then(function() {\n    // Skip if already resolved.\n    if (isResolved) {\n      return;\n    }\n    // After the iframe is ready, wait for popup to close and then start timeout\n    // check.\n    return fireauth.util.onPopupClose(popupWin);\n  }).then(function() {\n    // Skip if already resolved.\n    if (isResolved) {\n      return;\n    }\n    return goog.Timer.promise(timeoutDuration).then(function() {\n      // If this is already resolved or rejected, this will do nothing.\n      onError(popupClosedByUserError);\n    });\n  });\n};\n\n\n/**\n * @return {boolean} Whether the handler should be initialized early.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.shouldBeInitializedEarly =\n    function() {\n  var ua = fireauth.util.getUserAgentString();\n  // Cannot run in the background (can't wait for iframe to be embedded\n  // before triggering popup redirect) and is Safari (can only detect\n  // localStorage in iframe via change event) => embed iframe ASAP.\n  // Do the same for mobile browsers on iOS devices as they use the same\n  // Safari implementation underneath.\n  return !fireauth.util.runsInBackground(ua) &&\n         !fireauth.util.iframeCanSyncWebStorage(ua);\n};\n\n\n/**\n * @return {boolean} Whether the sign-in handler in the current environment\n *     has volatile session storage.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.hasVolatileStorage = function() {\n  // Web environment with web storage enabled has stable sessionStorage.\n  return false;\n};\n\n\n/**\n * Processes the popup request. The popup instance must be provided externally\n * and on error, the requestor must close the window.\n * @param {?Window} popupWin The popup window reference.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {function()} onInitialize The function to call on initialization.\n * @param {function(*)} onError The function to call on error.\n * @param {string=} opt_eventId The optional event ID.\n * @param {boolean=} opt_alreadyRedirected Whether popup is already redirected\n *     to final destination.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise} The popup window promise.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.processPopup = function(\n    popupWin,\n    mode,\n    provider,\n    onInitialize,\n    onError,\n    opt_eventId,\n    opt_alreadyRedirected,\n    opt_tenantId) {\n  // processPopup is failing since it tries to access popup win when tab can\n  // not run in background. For now bypass processPopup which runs\n  // additional origin check not accounted above. Besides, iframe will never\n  // hand result to parent if origin not whitelisted.\n  // Error thrown by browser: Unable to establish a connection with the\n  // popup. It may have been blocked by the browser.\n  // If popup is null, startPopupTimeout will catch it without having the\n  // above error getting triggered due to popup access from opener.\n\n  // Reject immediately if the popup is blocked.\n  if (!popupWin) {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.POPUP_BLOCKED));\n  }\n  // Already redirected and cannot run in the background, resolve quickly while\n  // initializing.\n  if (opt_alreadyRedirected && !fireauth.util.runsInBackground()) {\n    // Initialize first before resolving.\n    this.initializeAndWait().thenCatch(function(error) {\n      fireauth.util.closeWindow(popupWin);\n      onError(error);\n    });\n    onInitialize();\n    // Already redirected.\n    return goog.Promise.resolve();\n  }\n  // If origin validator not determined yet.\n  if (!this.originValidator_) {\n    this.originValidator_ =\n        fireauth.iframeclient.IfcHandler.getOriginValidator_(\n            this.getRpcHandler_());\n  }\n  var self = this;\n  return this.originValidator_.then(function() {\n    // After origin validation, wait for iframe to be ready before redirecting.\n    var onReady = self.initializeAndWait().thenCatch(function(error) {\n      fireauth.util.closeWindow(popupWin);\n      onError(error);\n      throw error;\n    });\n    onInitialize();\n    return onReady;\n  }).then(function() {\n    // Popup and redirect operations work for OAuth providers only.\n    fireauth.AuthProvider.checkIfOAuthSupported(provider);\n    // Already redirected to intended destination, no need to redirect again.\n    if (opt_alreadyRedirected) {\n      return;\n    }\n    var oauthHelperWidgetUrl =\n        fireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl(\n            self.authDomain_,\n            self.apiKey_,\n            self.appName_,\n            mode,\n            provider,\n            null,\n            opt_eventId,\n            self.clientVersion_,\n            undefined,\n            self.endpointId_,\n            opt_tenantId);\n    // Redirect popup to OAuth helper widget URL.\n    fireauth.util.goTo(oauthHelperWidgetUrl, /** @type {!Window} */ (popupWin));\n  }).thenCatch(function(e) {\n    // Force another origin validation.\n    if (e.code == 'auth/network-request-failed') {\n      self.originValidator_ = null;\n    }\n    throw e;\n  });\n};\n\n\n/**\n * @return {!fireauth.RpcHandler} The RPC handler instance with the relevant\n *     endpoints, version and frameworks.\n * @private\n */\nfireauth.iframeclient.IfcHandler.prototype.getRpcHandler_ = function() {\n  if (!this.rpcHandler_) {\n    this.fullClientVersion_ = this.clientVersion_ ?\n        fireauth.util.getClientVersion(\n            fireauth.util.ClientImplementation.JSCORE,\n            this.clientVersion_,\n            fireauth.iframeclient.OAuthUrlBuilder.getAuthFrameworksForApp_(\n                this.appName_)) :\n        null;\n    this.rpcHandler_ = new fireauth.RpcHandler(\n        this.apiKey_,\n        // Get the client Auth endpoint used.\n        fireauth.constants.getEndpointConfig(this.endpointId_),\n        this.fullClientVersion_);\n  }\n  return this.rpcHandler_;\n};\n\n\n/**\n * Processes the redirect request.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {?string=} opt_eventId The optional event ID.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise}\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.processRedirect =\n    function(mode, provider, opt_eventId, opt_tenantId) {\n  // If origin validator not determined yet.\n  if (!this.originValidator_) {\n    this.originValidator_ =\n        fireauth.iframeclient.IfcHandler.getOriginValidator_(\n            this.getRpcHandler_());\n  }\n  var self = this;\n  // Make sure origin is validated.\n  return this.originValidator_.then(function() {\n    fireauth.AuthProvider.checkIfOAuthSupported(provider);\n    var oauthHelperWidgetUrl =\n        fireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl(\n            self.authDomain_,\n            self.apiKey_,\n            self.appName_,\n            mode,\n            provider,\n            fireauth.util.getCurrentUrl(),\n            opt_eventId,\n            self.clientVersion_,\n            undefined,\n            self.endpointId_,\n            opt_tenantId);\n    // Redirect to OAuth helper widget URL.\n    fireauth.util.goTo(oauthHelperWidgetUrl);\n  }).thenCatch(function(e) {\n    // Force another origin validation on network errors.\n    if (e.code == 'auth/network-request-failed') {\n      self.originValidator_ = null;\n    }\n    throw e;\n  });\n};\n\n\n/** @return {string} The iframe URL. */\nfireauth.iframeclient.IfcHandler.prototype.getIframeUrl = function() {\n  if (!this.iframeUrl_) {\n    this.iframeUrl_ = fireauth.iframeclient.IfcHandler.getAuthIframeUrl(\n        this.authDomain_, this.apiKey_, this.appName_, this.clientVersion_,\n        this.endpointId_,\n        fireauth.iframeclient.OAuthUrlBuilder.getAuthFrameworksForApp_(\n            this.appName_));\n  }\n  return this.iframeUrl_;\n};\n\n\n/**\n * @return {!goog.Promise} The promise that resolves when the iframe is ready.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.initializeAndWait = function() {\n  // Initialize if not initialized yet.\n  var self = this;\n  return this.initialize().then(function() {\n    return self.iframeWrapper_.onReady();\n  }).thenCatch(function(error) {\n    // Reset origin validator.\n    self.originValidator_ = null;\n    // Reject iframe ready promise with network error.\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.NETWORK_REQUEST_FAILED);\n  });\n};\n\n\n/**\n * @return {boolean} Whether the handler will unload the current page on\n *     redirect operations.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.unloadsOnRedirect = function() {\n  return true;\n};\n\n\n/**\n * @param {string} authDomain The Firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The App ID for the Auth instance that triggered this\n *     request.\n * @param {?string=} opt_clientVersion The optional client version string.\n * @param {?string=} opt_endpointId The endpoint ID (staging, test Gaia, etc).\n * @param {?Array<string>=} opt_frameworks The optional list of framework IDs.\n * @return {string} The data iframe src URL.\n */\nfireauth.iframeclient.IfcHandler.getAuthIframeUrl = function(authDomain, apiKey,\n    appName, opt_clientVersion, opt_endpointId, opt_frameworks) {\n  // OAuth helper iframe URL.\n  var builder = new fireauth.iframeclient.IframeUrlBuilder(\n      authDomain, apiKey, appName);\n  return builder\n      .setVersion(opt_clientVersion)\n      .setEndpointId(opt_endpointId)\n      .setFrameworks(opt_frameworks)\n      .toString();\n};\n\n\n/**\n * @param {string} authDomain The Firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The App ID for the Auth instance that triggered this\n *     request.\n * @param {string} authType The type of operation that depends on OAuth sign in.\n * @param {!fireauth.AuthProvider} provider The provider to sign in to.\n * @param {?string=} opt_redirectUrl The optional URL to redirect to on OAuth\n *     sign in completion.\n * @param {?string=} opt_eventId The optional event ID to identify on receipt.\n * @param {?string=} opt_clientVersion The optional client version string.\n * @param {?Object<string, string>=} opt_additionalParams The optional\n *     additional parameters.\n * @param {?string=} opt_endpointId The endpoint ID (staging, test Gaia, etc).\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {string} The OAuth helper widget URL.\n */\nfireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl = function(\n    authDomain,\n    apiKey,\n    appName,\n    authType,\n    provider,\n    opt_redirectUrl,\n    opt_eventId,\n    opt_clientVersion,\n    opt_additionalParams,\n    opt_endpointId,\n    opt_tenantId) {\n  // OAuth helper widget URL.\n  var builder = new fireauth.iframeclient.OAuthUrlBuilder(\n      authDomain, apiKey, appName, authType, provider);\n  return builder\n      .setRedirectUrl(opt_redirectUrl)\n      .setEventId(opt_eventId)\n      .setVersion(opt_clientVersion)\n      .setAdditionalParameters(opt_additionalParams)\n      .setEndpointId(opt_endpointId)\n      .setTenantId(opt_tenantId)\n      .toString();\n};\n\n\n/**\n * Post message receiver event names.\n * @enum {string}\n */\nfireauth.iframeclient.IfcHandler.ReceiverEvent = {\n  AUTH_EVENT: 'authEvent'\n};\n\n\n/**\n * Post message sender event names.\n * @enum {string}\n */\nfireauth.iframeclient.IfcHandler.SenderEvent = {\n  WEB_STORAGE_SUPPORT_EVENT: 'webStorageSupport'\n};\n\n\n/**\n * Post message response field names.\n * @enum {string}\n */\nfireauth.iframeclient.IfcHandler.Response = {\n  STATUS: 'status',\n  AUTH_EVENT: 'authEvent',\n  WEB_STORAGE_SUPPORT: 'webStorageSupport'\n};\n\n\n/**\n * Post message status values.\n * @enum {string}\n */\nfireauth.iframeclient.IfcHandler.Status = {\n  ACK: 'ACK',\n  ERROR: 'ERROR'\n};\n\n\n/**\n * Registers all event listeners.\n * @private\n */\nfireauth.iframeclient.IfcHandler.prototype.registerEvents_ = function() {\n  // Should be run in initialization.\n  if (!this.iframeWrapper_) {\n    throw new Error('IfcHandler must be initialized!');\n  }\n  var self = this;\n  // Listen to Auth change events emitted from iframe.\n  this.iframeWrapper_.registerEvent(\n      fireauth.iframeclient.IfcHandler.ReceiverEvent.AUTH_EVENT,\n      function(response) {\n        var resolveResponse = {};\n        if (response &&\n            response[fireauth.iframeclient.IfcHandler.Response.AUTH_EVENT]) {\n          var isHandled = false;\n          // Get Auth event (plain object).\n          var authEvent = fireauth.AuthEvent.fromPlainObject(\n              response[fireauth.iframeclient.IfcHandler.Response.AUTH_EVENT]);\n          // Trigger Auth change on all listeners.\n          for (var i = 0; i < self.authEventListeners_.length; i++) {\n            isHandled = self.authEventListeners_[i](authEvent) || isHandled;\n          }\n          // Return ack response to notify sender of success.\n          resolveResponse = {};\n          resolveResponse[fireauth.iframeclient.IfcHandler.Response.STATUS] =\n              isHandled ? fireauth.iframeclient.IfcHandler.Status.ACK :\n                  fireauth.iframeclient.IfcHandler.Status.ERROR;\n          return goog.Promise.resolve(resolveResponse);\n        }\n        // Return error status if the response is invalid.\n        resolveResponse[fireauth.iframeclient.IfcHandler.Response.STATUS] =\n            fireauth.iframeclient.IfcHandler.Status.ERROR;\n        return goog.Promise.resolve(resolveResponse);\n      });\n};\n\n\n/**\n * @return {!goog.Promise<boolean>} Whether web storage is supported in the\n *     iframe.\n */\nfireauth.iframeclient.IfcHandler.prototype.isWebStorageSupported = function() {\n  var webStorageSupportEvent =\n      fireauth.iframeclient.IfcHandler.SenderEvent.WEB_STORAGE_SUPPORT_EVENT;\n  var message = {\n    'type': webStorageSupportEvent\n  };\n  var self = this;\n  // Initialize if not initialized yet.\n  return this.initialize().then(function() {\n    return self.iframeWrapper_.sendMessage(message);\n  }).then(function(response) {\n    // Parse the response and return the passed web storage support status.\n    var key = fireauth.iframeclient.IfcHandler.Response.WEB_STORAGE_SUPPORT;\n    if (response &&\n        response.length &&\n        typeof response[0][key] !== 'undefined') {\n      return response[0][key];\n    }\n    // Internal error.\n    throw new Error;\n  });\n};\n\n\n/**\n * @param {!function(?fireauth.AuthEvent):boolean} listener The Auth event\n *     listener to add.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.addAuthEventListener =\n    function(listener) {\n  this.authEventListeners_.push(listener);\n};\n\n\n/**\n * @param {!function(?fireauth.AuthEvent):boolean} listener The Auth event\n *     listener to remove.\n * @override\n */\nfireauth.iframeclient.IfcHandler.prototype.removeAuthEventListener =\n    function(listener) {\n  goog.array.removeAllIf(this.authEventListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Browser capability checks for the dom package.\n *\n */\n\n\ngoog.provide('goog.dom.BrowserFeature');\n\ngoog.require('goog.userAgent');\n\n\n/**\n * Enum of browser capabilities.\n * @enum {boolean}\n */\ngoog.dom.BrowserFeature = {\n  /**\n   * Whether attributes 'name' and 'type' can be added to an element after it's\n   * created. False in Internet Explorer prior to version 9.\n   */\n  CAN_ADD_NAME_OR_TYPE_ATTRIBUTES:\n      !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),\n\n  /**\n   * Whether we can use element.children to access an element's Element\n   * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment\n   * nodes in the collection.)\n   */\n  CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||\n      goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||\n      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),\n\n  /**\n   * Opera, Safari 3, and Internet Explorer 9 all support innerText but they\n   * include text nodes in script and style tags. Not document-mode-dependent.\n   */\n  CAN_USE_INNER_TEXT:\n      (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),\n\n  /**\n   * MSIE, Opera, and Safari>=4 support element.parentElement to access an\n   * element's parent if it is an Element.\n   */\n  CAN_USE_PARENT_ELEMENT_PROPERTY:\n      goog.userAgent.IE || goog.userAgent.OPERA || goog.userAgent.WEBKIT,\n\n  /**\n   * Whether NoScope elements need a scoped element written before them in\n   * innerHTML.\n   * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1\n   */\n  INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE,\n\n  /**\n   * Whether we use legacy IE range API.\n   */\n  LEGACY_IE_RANGES:\n      goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for manipulating the browser's Document Object Model\n * Inspiration taken *heavily* from mochikit (http://mochikit.com/).\n *\n * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer\n * to a different document object.  This is useful if you are working with\n * frames or multiple windows.\n *\n * @author arv@google.com (Erik Arvidsson)\n * @suppress {strictMissingProperties}\n */\n\n\n// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem\n// is that getTextContent should mimic the DOM3 textContent. We should add a\n// getInnerText (or getText) which tries to return the visible text, innerText.\n\n\ngoog.provide('goog.dom');\ngoog.provide('goog.dom.Appendable');\ngoog.provide('goog.dom.DomHelper');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.dom.BrowserFeature');\ngoog.require('goog.dom.NodeType');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.safe');\ngoog.require('goog.html.SafeHtml');\ngoog.require('goog.html.uncheckedconversions');\ngoog.require('goog.math.Coordinate');\ngoog.require('goog.math.Size');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.string.Unicode');\ngoog.require('goog.userAgent');\n\n\n/**\n * @define {boolean} Whether we know at compile time that the browser is in\n * quirks mode.\n */\ngoog.dom.ASSUME_QUIRKS_MODE = goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);\n\n\n/**\n * @define {boolean} Whether we know at compile time that the browser is in\n * standards compliance mode.\n */\ngoog.dom.ASSUME_STANDARDS_MODE =\n    goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);\n\n\n/**\n * Whether we know the compatibility mode at compile time.\n * @type {boolean}\n * @private\n */\ngoog.dom.COMPAT_MODE_KNOWN_ =\n    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;\n\n\n/**\n * Gets the DomHelper object for the document where the element resides.\n * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this\n *     element.\n * @return {!goog.dom.DomHelper} The DomHelper.\n */\ngoog.dom.getDomHelper = function(opt_element) {\n  return opt_element ?\n      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :\n      (goog.dom.defaultDomHelper_ ||\n       (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));\n};\n\n\n/**\n * Cached default DOM helper.\n * @type {!goog.dom.DomHelper|undefined}\n * @private\n */\ngoog.dom.defaultDomHelper_;\n\n\n/**\n * Gets the document object being used by the dom library.\n * @return {!Document} Document object.\n */\ngoog.dom.getDocument = function() {\n  return document;\n};\n\n\n/**\n * Gets an element from the current document by element id.\n *\n * If an Element is passed in, it is returned.\n *\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n */\ngoog.dom.getElement = function(element) {\n  return goog.dom.getElementHelper_(document, element);\n};\n\n\n/**\n * Gets an element by id from the given document (if present).\n * If an element is given, it is returned.\n * @param {!Document} doc\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The resulting element.\n * @private\n */\ngoog.dom.getElementHelper_ = function(doc, element) {\n  return goog.isString(element) ? doc.getElementById(element) : element;\n};\n\n\n/**\n * Gets an element by id, asserting that the element is found.\n *\n * This is used when an element is expected to exist, and should fail with\n * an assertion error if it does not (if assertions are enabled).\n *\n * @param {string} id Element ID.\n * @return {!Element} The element with the given ID, if it exists.\n */\ngoog.dom.getRequiredElement = function(id) {\n  return goog.dom.getRequiredElementHelper_(document, id);\n};\n\n\n/**\n * Helper function for getRequiredElementHelper functions, both static and\n * on DomHelper.  Asserts the element with the given id exists.\n * @param {!Document} doc\n * @param {string} id\n * @return {!Element} The element with the given ID, if it exists.\n * @private\n */\ngoog.dom.getRequiredElementHelper_ = function(doc, id) {\n  // To prevent users passing in Elements as is permitted in getElement().\n  goog.asserts.assertString(id);\n  var element = goog.dom.getElementHelper_(doc, id);\n  element =\n      goog.asserts.assertElement(element, 'No element found with id: ' + id);\n  return element;\n};\n\n\n/**\n * Alias for getElement.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n * @deprecated Use {@link goog.dom.getElement} instead.\n */\ngoog.dom.$ = goog.dom.getElement;\n\n\n/**\n * Gets elements by tag name.\n * @param {!goog.dom.TagName<T>} tagName\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\n *     look for elements. Defaults to document.\n * @return {!NodeList<R>} List of elements. The members of the list are\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementsByTagName = function(tagName, opt_parent) {\n  var parent = opt_parent || document;\n  return parent.getElementsByTagName(String(tagName));\n};\n\n\n/**\n * Looks up elements by both tag and class name, using browser native functions\n * (`querySelectorAll`, `getElementsByTagName` or\n * `getElementsByClassName`) where possible. This function\n * is a useful, if limited, way of collecting a list of DOM elements\n * with certain characteristics.  `querySelectorAll` offers a\n * more powerful and general solution which allows matching on CSS3\n * selector expressions.\n *\n * Note that tag names are case sensitive in the SVG namespace, and this\n * function converts opt_tag to uppercase for comparisons. For queries in the\n * SVG namespace you should use querySelector or querySelectorAll instead.\n * https://bugzilla.mozilla.org/show_bug.cgi?id=963870\n * https://bugs.webkit.org/show_bug.cgi?id=83438\n *\n * @see {https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll}\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementsByTagNameAndClass_(\n      document, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Gets the first element matching the tag and the class.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementByTagNameAndClass_(\n      document, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Returns a static, array-like list of the elements with the provided\n * className.\n *\n * @param {string} className the name of the class to look for.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\n */\ngoog.dom.getElementsByClass = function(className, opt_el) {\n  var parent = opt_el || document;\n  if (goog.dom.canUseQuerySelector_(parent)) {\n    return parent.querySelectorAll('.' + className);\n  }\n  return goog.dom.getElementsByTagNameAndClass_(\n      document, '*', className, opt_el);\n};\n\n\n/**\n * Returns the first element with the provided className.\n *\n * @param {string} className the name of the class to look for.\n * @param {Element|Document=} opt_el Optional element to look in.\n * @return {Element} The first item with the class name provided.\n */\ngoog.dom.getElementByClass = function(className, opt_el) {\n  var parent = opt_el || document;\n  var retVal = null;\n  if (parent.getElementsByClassName) {\n    retVal = parent.getElementsByClassName(className)[0];\n  } else {\n    retVal =\n        goog.dom.getElementByTagNameAndClass_(document, '*', className, opt_el);\n  }\n  return retVal || null;\n};\n\n\n/**\n * Ensures an element with the given className exists, and then returns the\n * first element with the provided className.\n *\n * @param {string} className the name of the class to look for.\n * @param {!Element|!Document=} opt_root Optional element or document to look\n *     in.\n * @return {!Element} The first item with the class name provided.\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\n */\ngoog.dom.getRequiredElementByClass = function(className, opt_root) {\n  var retValue = goog.dom.getElementByClass(className, opt_root);\n  return goog.asserts.assert(\n      retValue, 'No element found with className: ' + className);\n};\n\n\n/**\n * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and\n * fast W3C Selectors API.\n * @param {!(Element|Document)} parent The parent document object.\n * @return {boolean} whether or not we can use parent.querySelector* APIs.\n * @private\n */\ngoog.dom.canUseQuerySelector_ = function(parent) {\n  return !!(parent.querySelectorAll && parent.querySelector);\n};\n\n\n/**\n * Helper for `getElementsByTagNameAndClass`.\n * @param {!Document} doc The document to get the elements in.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.getElementsByTagNameAndClass_ = function(\n    doc, opt_tag, opt_class, opt_el) {\n  var parent = opt_el || doc;\n  var tagName =\n      (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\n\n  if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {\n    var query = tagName + (opt_class ? '.' + opt_class : '');\n    return parent.querySelectorAll(query);\n  }\n\n  // Use the native getElementsByClassName if available, under the assumption\n  // that even when the tag name is specified, there will be fewer elements to\n  // filter through when going by class than by tag name\n  if (opt_class && parent.getElementsByClassName) {\n    var els = parent.getElementsByClassName(opt_class);\n\n    if (tagName) {\n      var arrayLike = {};\n      var len = 0;\n\n      // Filter for specific tags if requested.\n      for (var i = 0, el; el = els[i]; i++) {\n        if (tagName == el.nodeName) {\n          arrayLike[len++] = el;\n        }\n      }\n      arrayLike.length = len;\n\n      return /** @type {!IArrayLike<!Element>} */ (arrayLike);\n    } else {\n      return els;\n    }\n  }\n\n  var els = parent.getElementsByTagName(tagName || '*');\n\n  if (opt_class) {\n    var arrayLike = {};\n    var len = 0;\n    for (var i = 0, el; el = els[i]; i++) {\n      var className = el.className;\n      // Check if className has a split function since SVG className does not.\n      if (typeof className.split == 'function' &&\n          goog.array.contains(className.split(/\\s+/), opt_class)) {\n        arrayLike[len++] = el;\n      }\n    }\n    arrayLike.length = len;\n    return /** @type {!IArrayLike<!Element>} */ (arrayLike);\n  } else {\n    return els;\n  }\n};\n\n\n/**\n * Helper for goog.dom.getElementByTagNameAndClass.\n *\n * @param {!Document} doc The document to get the elements in.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.getElementByTagNameAndClass_ = function(\n    doc, opt_tag, opt_class, opt_el) {\n  var parent = opt_el || doc;\n  var tag = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';\n  if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {\n    return parent.querySelector(tag + (opt_class ? '.' + opt_class : ''));\n  }\n  var elements =\n      goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);\n  return elements[0] || null;\n};\n\n\n\n/**\n * Alias for `getElementsByTagNameAndClass`.\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {Element=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.\n */\ngoog.dom.$$ = goog.dom.getElementsByTagNameAndClass;\n\n\n/**\n * Sets multiple properties, and sometimes attributes, on an element. Note that\n * properties are simply object properties on the element instance, while\n * attributes are visible in the DOM. Many properties map to attributes with the\n * same names, some with different names, and there are also unmappable cases.\n *\n * This method sets properties by default (which means that custom attributes\n * are not supported). These are the exeptions (some of which is legacy):\n * - \"style\": Even though this is an attribute name, it is translated to a\n *   property, \"style.cssText\". Note that this property sanitizes and formats\n *   its value, unlike the attribute.\n * - \"class\": This is an attribute name, it is translated to the \"className\"\n *   property.\n * - \"for\": This is an attribute name, it is translated to the \"htmlFor\"\n *   property.\n * - Entries in {@see goog.dom.DIRECT_ATTRIBUTE_MAP_} are set as attributes,\n *   this is probably due to browser quirks.\n * - \"aria-*\", \"data-*\": Always set as attributes, they have no property\n *   counterparts.\n *\n * @param {Element} element DOM node to set properties on.\n * @param {Object} properties Hash of property:value pairs.\n *     Property values can be strings or goog.string.TypedString values (such as\n *     goog.html.SafeUrl).\n */\ngoog.dom.setProperties = function(element, properties) {\n  goog.object.forEach(properties, function(val, key) {\n    if (val && typeof val == 'object' && val.implementsGoogStringTypedString) {\n      val = val.getTypedStringValue();\n    }\n    if (key == 'style') {\n      element.style.cssText = val;\n    } else if (key == 'class') {\n      element.className = val;\n    } else if (key == 'for') {\n      element.htmlFor = val;\n    } else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {\n      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);\n    } else if (\n        goog.string.startsWith(key, 'aria-') ||\n        goog.string.startsWith(key, 'data-')) {\n      element.setAttribute(key, val);\n    } else {\n      element[key] = val;\n    }\n  });\n};\n\n\n/**\n * Map of attributes that should be set using\n * element.setAttribute(key, val) instead of element[key] = val.  Used\n * by goog.dom.setProperties.\n *\n * @private {!Object<string, string>}\n * @const\n */\ngoog.dom.DIRECT_ATTRIBUTE_MAP_ = {\n  'cellpadding': 'cellPadding',\n  'cellspacing': 'cellSpacing',\n  'colspan': 'colSpan',\n  'frameborder': 'frameBorder',\n  'height': 'height',\n  'maxlength': 'maxLength',\n  'nonce': 'nonce',\n  'role': 'role',\n  'rowspan': 'rowSpan',\n  'type': 'type',\n  'usemap': 'useMap',\n  'valign': 'vAlign',\n  'width': 'width'\n};\n\n\n/**\n * Gets the dimensions of the viewport.\n *\n * Gecko Standards mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of body element.\n *\n * docEl.clientHeight Height of viewport excluding scrollbar.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of document.\n *\n * Gecko Backwards compatible mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight Height of document.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * IE6/7 Standards mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Undefined.\n * body.clientWidth   Width of body element.\n *\n * docEl.clientHeight Height of viewport excluding scrollbar.\n * win.innerHeight    Undefined.\n * body.clientHeight  Height of document element.\n *\n * IE5 + IE6/7 Backwards compatible mode:\n * docEl.clientWidth  0.\n * win.innerWidth     Undefined.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight 0.\n * win.innerHeight    Undefined.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * Opera 9 Standards and backwards compatible mode:\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * win.innerWidth     Width of viewport including scrollbar.\n * body.clientWidth   Width of viewport excluding scrollbar.\n *\n * docEl.clientHeight Height of document.\n * win.innerHeight    Height of viewport including scrollbar.\n * body.clientHeight  Height of viewport excluding scrollbar.\n *\n * WebKit:\n * Safari 2\n * docEl.clientHeight Same as scrollHeight.\n * docEl.clientWidth  Same as innerWidth.\n * win.innerWidth     Width of viewport excluding scrollbar.\n * win.innerHeight    Height of the viewport including scrollbar.\n * frame.innerHeight  Height of the viewport exluding scrollbar.\n *\n * Safari 3 (tested in 522)\n *\n * docEl.clientWidth  Width of viewport excluding scrollbar.\n * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.\n * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.\n *\n * @param {Window=} opt_window Optional window element to test.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n */\ngoog.dom.getViewportSize = function(opt_window) {\n  // TODO(arv): This should not take an argument\n  return goog.dom.getViewportSize_(opt_window || window);\n};\n\n\n/**\n * Helper for `getViewportSize`.\n * @param {Window} win The window to get the view port size for.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n * @private\n */\ngoog.dom.getViewportSize_ = function(win) {\n  var doc = win.document;\n  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;\n  return new goog.math.Size(el.clientWidth, el.clientHeight);\n};\n\n\n/**\n * Calculates the height of the document.\n *\n * @return {number} The height of the current document.\n */\ngoog.dom.getDocumentHeight = function() {\n  return goog.dom.getDocumentHeight_(window);\n};\n\n/**\n * Calculates the height of the document of the given window.\n *\n * @param {!Window} win The window whose document height to retrieve.\n * @return {number} The height of the document of the given window.\n */\ngoog.dom.getDocumentHeightForWindow = function(win) {\n  return goog.dom.getDocumentHeight_(win);\n};\n\n/**\n * Calculates the height of the document of the given window.\n *\n * Function code copied from the opensocial gadget api:\n *   gadgets.window.adjustHeight(opt_height)\n *\n * @private\n * @param {!Window} win The window whose document height to retrieve.\n * @return {number} The height of the document of the given window.\n */\ngoog.dom.getDocumentHeight_ = function(win) {\n  // NOTE(eae): This method will return the window size rather than the document\n  // size in webkit quirks mode.\n  var doc = win.document;\n  var height = 0;\n\n  if (doc) {\n    // Calculating inner content height is hard and different between\n    // browsers rendering in Strict vs. Quirks mode.  We use a combination of\n    // three properties within document.body and document.documentElement:\n    // - scrollHeight\n    // - offsetHeight\n    // - clientHeight\n    // These values differ significantly between browsers and rendering modes.\n    // But there are patterns.  It just takes a lot of time and persistence\n    // to figure out.\n\n    var body = doc.body;\n    var docEl = /** @type {!HTMLElement} */ (doc.documentElement);\n    if (!(docEl && body)) {\n      return 0;\n    }\n\n    // Get the height of the viewport\n    var vh = goog.dom.getViewportSize_(win).height;\n    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {\n      // In Strict mode:\n      // The inner content height is contained in either:\n      //    document.documentElement.scrollHeight\n      //    document.documentElement.offsetHeight\n      // Based on studying the values output by different browsers,\n      // use the value that's NOT equal to the viewport height found above.\n      height =\n          docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;\n    } else {\n      // In Quirks mode:\n      // documentElement.clientHeight is equal to documentElement.offsetHeight\n      // except in IE.  In most browsers, document.documentElement can be used\n      // to calculate the inner content height.\n      // However, in other browsers (e.g. IE), document.body must be used\n      // instead.  How do we know which one to use?\n      // If document.documentElement.clientHeight does NOT equal\n      // document.documentElement.offsetHeight, then use document.body.\n      var sh = docEl.scrollHeight;\n      var oh = docEl.offsetHeight;\n      if (docEl.clientHeight != oh) {\n        sh = body.scrollHeight;\n        oh = body.offsetHeight;\n      }\n\n      // Detect whether the inner content height is bigger or smaller\n      // than the bounding box (viewport).  If bigger, take the larger\n      // value.  If smaller, take the smaller value.\n      if (sh > vh) {\n        // Content is larger\n        height = sh > oh ? sh : oh;\n      } else {\n        // Content is smaller\n        height = sh < oh ? sh : oh;\n      }\n    }\n  }\n\n  return height;\n};\n\n\n/**\n * Gets the page scroll distance as a coordinate object.\n *\n * @param {Window=} opt_window Optional window element to test.\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n * @deprecated Use {@link goog.dom.getDocumentScroll} instead.\n */\ngoog.dom.getPageScroll = function(opt_window) {\n  var win = opt_window || goog.global || window;\n  return goog.dom.getDomHelper(win.document).getDocumentScroll();\n};\n\n\n/**\n * Gets the document scroll distance as a coordinate object.\n *\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n */\ngoog.dom.getDocumentScroll = function() {\n  return goog.dom.getDocumentScroll_(document);\n};\n\n\n/**\n * Helper for `getDocumentScroll`.\n *\n * @param {!Document} doc The document to get the scroll for.\n * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.\n * @private\n */\ngoog.dom.getDocumentScroll_ = function(doc) {\n  var el = goog.dom.getDocumentScrollElement_(doc);\n  var win = goog.dom.getWindow_(doc);\n  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&\n      win.pageYOffset != el.scrollTop) {\n    // The keyboard on IE10 touch devices shifts the page using the pageYOffset\n    // without modifying scrollTop. For this case, we want the body scroll\n    // offsets.\n    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);\n  }\n  return new goog.math.Coordinate(\n      win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);\n};\n\n\n/**\n * Gets the document scroll element.\n * @return {!Element} Scrolling element.\n */\ngoog.dom.getDocumentScrollElement = function() {\n  return goog.dom.getDocumentScrollElement_(document);\n};\n\n\n/**\n * Helper for `getDocumentScrollElement`.\n * @param {!Document} doc The document to get the scroll element for.\n * @return {!Element} Scrolling element.\n * @private\n */\ngoog.dom.getDocumentScrollElement_ = function(doc) {\n  // Old WebKit needs body.scrollLeft in both quirks mode and strict mode. We\n  // also default to the documentElement if the document does not have a body\n  // (e.g. a SVG document).\n  // Uses http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement to\n  // avoid trying to guess about browser behavior from the UA string.\n  if (doc.scrollingElement) {\n    return doc.scrollingElement;\n  }\n  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {\n    return doc.documentElement;\n  }\n  return doc.body || doc.documentElement;\n};\n\n\n/**\n * Gets the window object associated with the given document.\n *\n * @param {Document=} opt_doc  Document object to get window for.\n * @return {!Window} The window associated with the given document.\n */\ngoog.dom.getWindow = function(opt_doc) {\n  // TODO(arv): This should not take an argument.\n  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;\n};\n\n\n/**\n * Helper for `getWindow`.\n *\n * @param {!Document} doc  Document object to get window for.\n * @return {!Window} The window associated with the given document.\n * @private\n */\ngoog.dom.getWindow_ = function(doc) {\n  return /** @type {!Window} */ (doc.parentWindow || doc.defaultView);\n};\n\n\n/**\n * Returns a dom node with a set of attributes.  This function accepts varargs\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\n * first node as childNodes.\n *\n * So:\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\n * paragraphs\n *\n * This function uses {@link goog.dom.setProperties} to set attributes: the\n * `opt_attributes` parameter follows the same rules.\n *\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\n *     DOM nodes or strings for text nodes. If one of the var_args is an array\n *     or NodeList, its elements will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.createDom = function(tagName, opt_attributes, var_args) {\n  return goog.dom.createDom_(document, arguments);\n};\n\n\n/**\n * Helper for `createDom`.\n * @param {!Document} doc The document to create the DOM in.\n * @param {!Arguments} args Argument object passed from the callers. See\n *     `goog.dom.createDom` for details.\n * @return {!Element} Reference to a DOM node.\n * @private\n */\ngoog.dom.createDom_ = function(doc, args) {\n  var tagName = String(args[0]);\n  var attributes = args[1];\n\n  // Internet Explorer is dumb:\n  // name: https://msdn.microsoft.com/en-us/library/ms534184(v=vs.85).aspx\n  // type: https://msdn.microsoft.com/en-us/library/ms534700(v=vs.85).aspx\n  // Also does not allow setting of 'type' attribute on 'input' or 'button'.\n  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&\n      (attributes.name || attributes.type)) {\n    var tagNameArr = ['<', tagName];\n    if (attributes.name) {\n      tagNameArr.push(' name=\"', goog.string.htmlEscape(attributes.name), '\"');\n    }\n    if (attributes.type) {\n      tagNameArr.push(' type=\"', goog.string.htmlEscape(attributes.type), '\"');\n\n      // Clone attributes map to remove 'type' without mutating the input.\n      var clone = {};\n      goog.object.extend(clone, attributes);\n\n      // JSCompiler can't see how goog.object.extend added this property,\n      // because it was essentially added by reflection.\n      // So it needs to be quoted.\n      delete clone['type'];\n\n      attributes = clone;\n    }\n    tagNameArr.push('>');\n    tagName = tagNameArr.join('');\n  }\n\n  var element = doc.createElement(tagName);\n\n  if (attributes) {\n    if (goog.isString(attributes)) {\n      element.className = attributes;\n    } else if (goog.isArray(attributes)) {\n      element.className = attributes.join(' ');\n    } else {\n      goog.dom.setProperties(element, attributes);\n    }\n  }\n\n  if (args.length > 2) {\n    goog.dom.append_(doc, element, args, 2);\n  }\n\n  return element;\n};\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Document} doc The document to create new nodes in.\n * @param {!Node} parent The node to append nodes to.\n * @param {!Arguments} args The values to add. See `goog.dom.append`.\n * @param {number} startIndex The index of the array to start from.\n * @private\n */\ngoog.dom.append_ = function(doc, parent, args, startIndex) {\n  function childHandler(child) {\n    // TODO(user): More coercion, ala MochiKit?\n    if (child) {\n      parent.appendChild(\n          goog.isString(child) ? doc.createTextNode(child) : child);\n    }\n  }\n\n  for (var i = startIndex; i < args.length; i++) {\n    var arg = args[i];\n    // TODO(attila): Fix isArrayLike to return false for a text node.\n    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {\n      // If the argument is a node list, not a real array, use a clone,\n      // because forEach can't be used to mutate a NodeList.\n      goog.array.forEach(\n          goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg,\n          childHandler);\n    } else {\n      childHandler(arg);\n    }\n  }\n};\n\n\n/**\n * Alias for `createDom`.\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further\n *     DOM nodes or strings for text nodes. If one of the var_args is an array,\n *     its children will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.createDom} instead.\n */\ngoog.dom.$dom = goog.dom.createDom;\n\n\n/**\n * Creates a new element.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.createElement = function(name) {\n  return goog.dom.createElement_(document, name);\n};\n\n\n/**\n * Creates a new element.\n * @param {!Document} doc The document to create the element in.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @private\n */\ngoog.dom.createElement_ = function(doc, name) {\n  return doc.createElement(String(name));\n};\n\n\n/**\n * Creates a new text node.\n * @param {number|string} content Content.\n * @return {!Text} The new text node.\n */\ngoog.dom.createTextNode = function(content) {\n  return document.createTextNode(String(content));\n};\n\n\n/**\n * Create a table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!Element} The created table.\n */\ngoog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {\n  // TODO(mlourenco): Return HTMLTableElement, also in prototype function.\n  // Callers need to be updated to e.g. not assign numbers to table.cellSpacing.\n  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);\n};\n\n\n/**\n * Create a table.\n * @param {!Document} doc Document object to use to create the table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean} fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!HTMLTableElement} The created table.\n * @private\n */\ngoog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {\n  var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);\n  var tbody =\n      table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));\n  for (var i = 0; i < rows; i++) {\n    var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);\n    for (var j = 0; j < columns; j++) {\n      var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);\n      // IE <= 9 will create a text node if we set text content to the empty\n      // string, so we avoid doing it unless necessary. This ensures that the\n      // same DOM tree is returned on all browsers.\n      if (fillWithNbsp) {\n        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);\n      }\n      tr.appendChild(td);\n    }\n    tbody.appendChild(tr);\n  }\n  return table;\n};\n\n\n\n/**\n * Creates a new Node from constant strings of HTML markup.\n * @param {...!goog.string.Const} var_args The HTML strings to concatenate then\n *     convert into a node.\n * @return {!Node}\n */\ngoog.dom.constHtmlToNode = function(var_args) {\n  var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);\n  var safeHtml =\n      goog.html.uncheckedconversions\n          .safeHtmlFromStringKnownToSatisfyTypeContract(\n              goog.string.Const.from(\n                  'Constant HTML string, that gets turned into a ' +\n                  'Node later, so it will be automatically balanced.'),\n              stringArray.join(''));\n  return goog.dom.safeHtmlToNode(safeHtml);\n};\n\n\n/**\n * Converts HTML markup into a node. This is a safe version of\n * `goog.dom.htmlToDocumentFragment` which is now deleted.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n */\ngoog.dom.safeHtmlToNode = function(html) {\n  return goog.dom.safeHtmlToNode_(document, html);\n};\n\n\n/**\n * Helper for `safeHtmlToNode`.\n * @param {!Document} doc The document.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n * @private\n */\ngoog.dom.safeHtmlToNode_ = function(doc, html) {\n  var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {\n    goog.dom.safe.setInnerHtml(\n        tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));\n    tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    goog.dom.safe.setInnerHtml(tempDiv, html);\n  }\n  return goog.dom.childrenToNode_(doc, tempDiv);\n};\n\n\n/**\n * Helper for `safeHtmlToNode_`.\n * @param {!Document} doc The document.\n * @param {!Node} tempDiv The input node.\n * @return {!Node} The resulting node.\n * @private\n */\ngoog.dom.childrenToNode_ = function(doc, tempDiv) {\n  if (tempDiv.childNodes.length == 1) {\n    return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));\n  } else {\n    var fragment = doc.createDocumentFragment();\n    while (tempDiv.firstChild) {\n      fragment.appendChild(tempDiv.firstChild);\n    }\n    return fragment;\n  }\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @return {boolean} True if in CSS1-compatible mode.\n */\ngoog.dom.isCss1CompatMode = function() {\n  return goog.dom.isCss1CompatMode_(document);\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @param {!Document} doc The document to check.\n * @return {boolean} True if in CSS1-compatible mode.\n * @private\n */\ngoog.dom.isCss1CompatMode_ = function(doc) {\n  if (goog.dom.COMPAT_MODE_KNOWN_) {\n    return goog.dom.ASSUME_STANDARDS_MODE;\n  }\n\n  return doc.compatMode == 'CSS1Compat';\n};\n\n\n/**\n * Determines if the given node can contain children, intended to be used for\n * HTML generation.\n *\n * IE natively supports node.canHaveChildren but has inconsistent behavior.\n * Prior to IE8 the base tag allows children and in IE9 all nodes return true\n * for canHaveChildren.\n *\n * In practice all non-IE browsers allow you to add children to any node, but\n * the behavior is inconsistent:\n *\n * <pre>\n *   var a = goog.dom.createElement(goog.dom.TagName.BR);\n *   a.appendChild(document.createTextNode('foo'));\n *   a.appendChild(document.createTextNode('bar'));\n *   console.log(a.childNodes.length);  // 2\n *   console.log(a.innerHTML);  // Chrome: \"\", IE9: \"foobar\", FF3.5: \"foobar\"\n * </pre>\n *\n * For more information, see:\n * http://dev.w3.org/html5/markup/syntax.html#syntax-elements\n *\n * TODO(user): Rename shouldAllowChildren() ?\n *\n * @param {Node} node The node to check.\n * @return {boolean} Whether the node can contain children.\n */\ngoog.dom.canHaveChildren = function(node) {\n  if (node.nodeType != goog.dom.NodeType.ELEMENT) {\n    return false;\n  }\n  switch (/** @type {!Element} */ (node).tagName) {\n    case String(goog.dom.TagName.APPLET):\n    case String(goog.dom.TagName.AREA):\n    case String(goog.dom.TagName.BASE):\n    case String(goog.dom.TagName.BR):\n    case String(goog.dom.TagName.COL):\n    case String(goog.dom.TagName.COMMAND):\n    case String(goog.dom.TagName.EMBED):\n    case String(goog.dom.TagName.FRAME):\n    case String(goog.dom.TagName.HR):\n    case String(goog.dom.TagName.IMG):\n    case String(goog.dom.TagName.INPUT):\n    case String(goog.dom.TagName.IFRAME):\n    case String(goog.dom.TagName.ISINDEX):\n    case String(goog.dom.TagName.KEYGEN):\n    case String(goog.dom.TagName.LINK):\n    case String(goog.dom.TagName.NOFRAMES):\n    case String(goog.dom.TagName.NOSCRIPT):\n    case String(goog.dom.TagName.META):\n    case String(goog.dom.TagName.OBJECT):\n    case String(goog.dom.TagName.PARAM):\n    case String(goog.dom.TagName.SCRIPT):\n    case String(goog.dom.TagName.SOURCE):\n    case String(goog.dom.TagName.STYLE):\n    case String(goog.dom.TagName.TRACK):\n    case String(goog.dom.TagName.WBR):\n      return false;\n  }\n  return true;\n};\n\n\n/**\n * Appends a child to a node.\n * @param {Node} parent Parent.\n * @param {Node} child Child.\n */\ngoog.dom.appendChild = function(parent, child) {\n  goog.asserts.assert(\n      parent != null && child != null,\n      'goog.dom.appendChild expects non-null arguments');\n  parent.appendChild(child);\n};\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Node} parent The node to append nodes to.\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\n *     If this is a Node it is appended as is.\n *     If this is a string then a text node is appended.\n *     If this is an array like object then fields 0 to length - 1 are appended.\n */\ngoog.dom.append = function(parent, var_args) {\n  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);\n};\n\n\n/**\n * Removes all the child nodes on a DOM node.\n * @param {Node} node Node to remove children from.\n */\ngoog.dom.removeChildren = function(node) {\n  // Note: Iterations over live collections can be slow, this is the fastest\n  // we could find. The double parenthesis are used to prevent JsCompiler and\n  // strict warnings.\n  var child;\n  while ((child = node.firstChild)) {\n    node.removeChild(child);\n  }\n};\n\n\n/**\n * Inserts a new node before an existing reference node (i.e. as the previous\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert before.\n */\ngoog.dom.insertSiblingBefore = function(newNode, refNode) {\n  goog.asserts.assert(\n      newNode != null && refNode != null,\n      'goog.dom.insertSiblingBefore expects non-null arguments');\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode);\n  }\n};\n\n\n/**\n * Inserts a new node after an existing reference node (i.e. as the next\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert after.\n */\ngoog.dom.insertSiblingAfter = function(newNode, refNode) {\n  goog.asserts.assert(\n      newNode != null && refNode != null,\n      'goog.dom.insertSiblingAfter expects non-null arguments');\n  if (refNode.parentNode) {\n    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);\n  }\n};\n\n\n/**\n * Insert a child at a given index. If index is larger than the number of child\n * nodes that the parent currently has, the node is inserted as the last child\n * node.\n * @param {Element} parent The element into which to insert the child.\n * @param {Node} child The element to insert.\n * @param {number} index The index at which to insert the new child node. Must\n *     not be negative.\n */\ngoog.dom.insertChildAt = function(parent, child, index) {\n  // Note that if the second argument is null, insertBefore\n  // will append the child at the end of the list of children.\n  goog.asserts.assert(\n      parent != null, 'goog.dom.insertChildAt expects a non-null parent');\n  parent.insertBefore(child, parent.childNodes[index] || null);\n};\n\n\n/**\n * Removes a node from its parent.\n * @param {Node} node The node to remove.\n * @return {Node} The node removed if removed; else, null.\n */\ngoog.dom.removeNode = function(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n};\n\n\n/**\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\n * parent.\n * @param {Node} newNode Node to insert.\n * @param {Node} oldNode Node to replace.\n */\ngoog.dom.replaceNode = function(newNode, oldNode) {\n  goog.asserts.assert(\n      newNode != null && oldNode != null,\n      'goog.dom.replaceNode expects non-null arguments');\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n};\n\n\n/**\n * Flattens an element. That is, removes it and replace it with its children.\n * Does nothing if the element is not in the document.\n * @param {Element} element The element to flatten.\n * @return {Element|undefined} The original element, detached from the document\n *     tree, sans children; or undefined, if the element was not in the document\n *     to begin with.\n */\ngoog.dom.flattenElement = function(element) {\n  var child, parent = element.parentNode;\n  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {\n    // Use IE DOM method (supported by Opera too) if available\n    if (element.removeNode) {\n      return /** @type {Element} */ (element.removeNode(false));\n    } else {\n      // Move all children of the original node up one level.\n      while ((child = element.firstChild)) {\n        parent.insertBefore(child, element);\n      }\n\n      // Detach the original element.\n      return /** @type {Element} */ (goog.dom.removeNode(element));\n    }\n  }\n};\n\n\n/**\n * Returns an array containing just the element children of the given element.\n * @param {Element} element The element whose element children we want.\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\n *     of just the element children of the given element.\n */\ngoog.dom.getChildren = function(element) {\n  // We check if the children attribute is supported for child elements\n  // since IE8 misuses the attribute by also including comments.\n  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&\n      element.children != undefined) {\n    return element.children;\n  }\n  // Fall back to manually filtering the element's child nodes.\n  return goog.array.filter(element.childNodes, function(node) {\n    return node.nodeType == goog.dom.NodeType.ELEMENT;\n  });\n};\n\n\n/**\n * Returns the first child node that is an element.\n * @param {Node} node The node to get the first child element of.\n * @return {Element} The first child node of `node` that is an element.\n */\ngoog.dom.getFirstElementChild = function(node) {\n  if (goog.isDef(node.firstElementChild)) {\n    return /** @type {!Element} */ (node).firstElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.firstChild, true);\n};\n\n\n/**\n * Returns the last child node that is an element.\n * @param {Node} node The node to get the last child element of.\n * @return {Element} The last child node of `node` that is an element.\n */\ngoog.dom.getLastElementChild = function(node) {\n  if (goog.isDef(node.lastElementChild)) {\n    return /** @type {!Element} */ (node).lastElementChild;\n  }\n  return goog.dom.getNextElementNode_(node.lastChild, false);\n};\n\n\n/**\n * Returns the first next sibling that is an element.\n * @param {Node} node The node to get the next sibling element of.\n * @return {Element} The next sibling of `node` that is an element.\n */\ngoog.dom.getNextElementSibling = function(node) {\n  if (goog.isDef(node.nextElementSibling)) {\n    return /** @type {!Element} */ (node).nextElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.nextSibling, true);\n};\n\n\n/**\n * Returns the first previous sibling that is an element.\n * @param {Node} node The node to get the previous sibling element of.\n * @return {Element} The first previous sibling of `node` that is\n *     an element.\n */\ngoog.dom.getPreviousElementSibling = function(node) {\n  if (goog.isDef(node.previousElementSibling)) {\n    return /** @type {!Element} */ (node).previousElementSibling;\n  }\n  return goog.dom.getNextElementNode_(node.previousSibling, false);\n};\n\n\n/**\n * Returns the first node that is an element in the specified direction,\n * starting with `node`.\n * @param {Node} node The node to get the next element from.\n * @param {boolean} forward Whether to look forwards or backwards.\n * @return {Element} The first element.\n * @private\n */\ngoog.dom.getNextElementNode_ = function(node, forward) {\n  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {\n    node = forward ? node.nextSibling : node.previousSibling;\n  }\n\n  return /** @type {Element} */ (node);\n};\n\n\n/**\n * Returns the next node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The next node in the DOM tree, or null if this was the last\n *     node.\n */\ngoog.dom.getNextNode = function(node) {\n  if (!node) {\n    return null;\n  }\n\n  if (node.firstChild) {\n    return node.firstChild;\n  }\n\n  while (node && !node.nextSibling) {\n    node = node.parentNode;\n  }\n\n  return node ? node.nextSibling : null;\n};\n\n\n/**\n * Returns the previous node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The previous node in the DOM tree, or null if this was the\n *     first node.\n */\ngoog.dom.getPreviousNode = function(node) {\n  if (!node) {\n    return null;\n  }\n\n  if (!node.previousSibling) {\n    return node.parentNode;\n  }\n\n  node = node.previousSibling;\n  while (node && node.lastChild) {\n    node = node.lastChild;\n  }\n\n  return node;\n};\n\n\n/**\n * Whether the object looks like a DOM node.\n * @param {?} obj The object being tested for node likeness.\n * @return {boolean} Whether the object looks like a DOM node.\n */\ngoog.dom.isNodeLike = function(obj) {\n  return goog.isObject(obj) && obj.nodeType > 0;\n};\n\n\n/**\n * Whether the object looks like an Element.\n * @param {?} obj The object being tested for Element likeness.\n * @return {boolean} Whether the object looks like an Element.\n */\ngoog.dom.isElement = function(obj) {\n  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;\n};\n\n\n/**\n * Returns true if the specified value is a Window object. This includes the\n * global window for HTML pages, and iframe windows.\n * @param {?} obj Variable to test.\n * @return {boolean} Whether the variable is a window.\n */\ngoog.dom.isWindow = function(obj) {\n  return goog.isObject(obj) && obj['window'] == obj;\n};\n\n\n/**\n * Returns an element's parent, if it's an Element.\n * @param {Element} element The DOM element.\n * @return {Element} The parent, or null if not an Element.\n */\ngoog.dom.getParentElement = function(element) {\n  var parent;\n  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {\n    var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher('9') &&\n        !goog.userAgent.isVersionOrHigher('10');\n    // SVG elements in IE9 can't use the parentElement property.\n    // goog.global['SVGElement'] is not defined in IE9 quirks mode.\n    if (!(isIe9 && goog.global['SVGElement'] &&\n          element instanceof goog.global['SVGElement'])) {\n      parent = element.parentElement;\n      if (parent) {\n        return parent;\n      }\n    }\n  }\n  parent = element.parentNode;\n  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;\n};\n\n\n/**\n * Whether a node contains another node.\n * @param {?Node|undefined} parent The node that should contain the other node.\n * @param {?Node|undefined} descendant The node to test presence of.\n * @return {boolean} Whether the parent node contains the descendant node.\n */\ngoog.dom.contains = function(parent, descendant) {\n  if (!parent || !descendant) {\n    return false;\n  }\n  // We use browser specific methods for this if available since it is faster\n  // that way.\n\n  // IE DOM\n  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {\n    return parent == descendant || parent.contains(descendant);\n  }\n\n  // W3C DOM Level 3\n  if (typeof parent.compareDocumentPosition != 'undefined') {\n    return parent == descendant ||\n        Boolean(parent.compareDocumentPosition(descendant) & 16);\n  }\n\n  // W3C DOM Level 1\n  while (descendant && parent != descendant) {\n    descendant = descendant.parentNode;\n  }\n  return descendant == parent;\n};\n\n\n/**\n * Compares the document order of two nodes, returning 0 if they are the same\n * node, a negative number if node1 is before node2, and a positive number if\n * node2 is before node1.  Note that we compare the order the tags appear in the\n * document so in the tree <b><i>text</i></b> the B node is considered to be\n * before the I node.\n *\n * @param {Node} node1 The first node to compare.\n * @param {Node} node2 The second node to compare.\n * @return {number} 0 if the nodes are the same node, a negative number if node1\n *     is before node2, and a positive number if node2 is before node1.\n */\ngoog.dom.compareNodeOrder = function(node1, node2) {\n  // Fall out quickly for equality.\n  if (node1 == node2) {\n    return 0;\n  }\n\n  // Use compareDocumentPosition where available\n  if (node1.compareDocumentPosition) {\n    // 4 is the bitmask for FOLLOWS.\n    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;\n  }\n\n  // Special case for document nodes on IE 7 and 8.\n  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {\n    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return -1;\n    }\n    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {\n      return 1;\n    }\n  }\n\n  // Process in IE using sourceIndex - we check to see if the first node has\n  // a source index or if its parent has one.\n  if ('sourceIndex' in node1 ||\n      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {\n    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;\n    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;\n\n    if (isElement1 && isElement2) {\n      return node1.sourceIndex - node2.sourceIndex;\n    } else {\n      var parent1 = node1.parentNode;\n      var parent2 = node2.parentNode;\n\n      if (parent1 == parent2) {\n        return goog.dom.compareSiblingOrder_(node1, node2);\n      }\n\n      if (!isElement1 && goog.dom.contains(parent1, node2)) {\n        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);\n      }\n\n\n      if (!isElement2 && goog.dom.contains(parent2, node1)) {\n        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);\n      }\n\n      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -\n          (isElement2 ? node2.sourceIndex : parent2.sourceIndex);\n    }\n  }\n\n  // For Safari, we compare ranges.\n  var doc = goog.dom.getOwnerDocument(node1);\n\n  var range1, range2;\n  range1 = doc.createRange();\n  range1.selectNode(node1);\n  range1.collapse(true);\n\n  range2 = doc.createRange();\n  range2.selectNode(node2);\n  range2.collapse(true);\n\n  return range1.compareBoundaryPoints(\n      goog.global['Range'].START_TO_END, range2);\n};\n\n\n/**\n * Utility function to compare the position of two nodes, when\n * `textNode`'s parent is an ancestor of `node`.  If this entry\n * condition is not met, this function will attempt to reference a null object.\n * @param {!Node} textNode The textNode to compare.\n * @param {Node} node The node to compare.\n * @return {number} -1 if node is before textNode, +1 otherwise.\n * @private\n */\ngoog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {\n  var parent = textNode.parentNode;\n  if (parent == node) {\n    // If textNode is a child of node, then node comes first.\n    return -1;\n  }\n  var sibling = node;\n  while (sibling.parentNode != parent) {\n    sibling = sibling.parentNode;\n  }\n  return goog.dom.compareSiblingOrder_(sibling, textNode);\n};\n\n\n/**\n * Utility function to compare the position of two nodes known to be non-equal\n * siblings.\n * @param {Node} node1 The first node to compare.\n * @param {!Node} node2 The second node to compare.\n * @return {number} -1 if node1 is before node2, +1 otherwise.\n * @private\n */\ngoog.dom.compareSiblingOrder_ = function(node1, node2) {\n  var s = node2;\n  while ((s = s.previousSibling)) {\n    if (s == node1) {\n      // We just found node1 before node2.\n      return -1;\n    }\n  }\n\n  // Since we didn't find it, node1 must be after node2.\n  return 1;\n};\n\n\n/**\n * Find the deepest common ancestor of the given nodes.\n * @param {...Node} var_args The nodes to find a common ancestor of.\n * @return {Node} The common ancestor of the nodes, or null if there is none.\n *     null will only be returned if two or more of the nodes are from different\n *     documents.\n */\ngoog.dom.findCommonAncestor = function(var_args) {\n  var i, count = arguments.length;\n  if (!count) {\n    return null;\n  } else if (count == 1) {\n    return arguments[0];\n  }\n\n  var paths = [];\n  var minLength = Infinity;\n  for (i = 0; i < count; i++) {\n    // Compute the list of ancestors.\n    var ancestors = [];\n    var node = arguments[i];\n    while (node) {\n      ancestors.unshift(node);\n      node = node.parentNode;\n    }\n\n    // Save the list for comparison.\n    paths.push(ancestors);\n    minLength = Math.min(minLength, ancestors.length);\n  }\n  var output = null;\n  for (i = 0; i < minLength; i++) {\n    var first = paths[0][i];\n    for (var j = 1; j < count; j++) {\n      if (first != paths[j][i]) {\n        return output;\n      }\n    }\n    output = first;\n  }\n  return output;\n};\n\n\n/**\n * Returns whether node is in a document or detached. Throws an error if node\n * itself is a document. This specifically handles two cases beyond naive use of\n * builtins: (1) it works correctly in IE, and (2) it works for elements from\n * different documents/iframes. If neither of these considerations are relevant\n * then a simple `document.contains(node)` may be used instead.\n * @param {!Node} node\n * @return {boolean}\n */\ngoog.dom.isInDocument = function(node) {\n  return (node.ownerDocument.compareDocumentPosition(node) & 16) == 16;\n};\n\n\n/**\n * Returns the owner document for a node.\n * @param {Node|Window} node The node to get the document for.\n * @return {!Document} The document owning the node.\n */\ngoog.dom.getOwnerDocument = function(node) {\n  // TODO(nnaze): Update param signature to be non-nullable.\n  goog.asserts.assert(node, 'Node cannot be null or undefined.');\n  return /** @type {!Document} */ (\n      node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument ||\n              node.document);\n};\n\n\n/**\n * Cross-browser function for getting the document element of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {!Document} The frame content document.\n */\ngoog.dom.getFrameContentDocument = function(frame) {\n  return frame.contentDocument ||\n      /** @type {!HTMLFrameElement} */ (frame).contentWindow.document;\n};\n\n\n/**\n * Cross-browser function for getting the window of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {Window} The window associated with the given frame, or null if none\n *     exists.\n */\ngoog.dom.getFrameContentWindow = function(frame) {\n  try {\n    return frame.contentWindow ||\n        (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) :\n                                 null);\n  } catch (e) {\n    // NOTE(user): In IE8, checking the contentWindow or contentDocument\n    // properties will throw a \"Unspecified Error\" exception if the iframe is\n    // not inserted in the DOM. If we get this we can be sure that no window\n    // exists, so return null.\n  }\n  return null;\n};\n\n\n/**\n * Sets the text content of a node, with cross-browser support.\n * @param {Node} node The node to change the text content of.\n * @param {string|number} text The value that should replace the node's content.\n */\ngoog.dom.setTextContent = function(node, text) {\n  goog.asserts.assert(\n      node != null,\n      'goog.dom.setTextContent expects a non-null value for node');\n\n  if ('textContent' in node) {\n    node.textContent = text;\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\n    /** @type {!Text} */ (node).data = String(text);\n  } else if (\n      node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {\n    // If the first child is a text node we just change its data and remove the\n    // rest of the children.\n    while (node.lastChild != node.firstChild) {\n      node.removeChild(goog.asserts.assert(node.lastChild));\n    }\n    /** @type {!Text} */ (node.firstChild).data = String(text);\n  } else {\n    goog.dom.removeChildren(node);\n    var doc = goog.dom.getOwnerDocument(node);\n    node.appendChild(doc.createTextNode(String(text)));\n  }\n};\n\n\n/**\n * Gets the outerHTML of a node, which is like innerHTML, except that it\n * actually contains the HTML of the node itself.\n * @param {Element} element The element to get the HTML of.\n * @return {string} The outerHTML of the given element.\n */\ngoog.dom.getOuterHtml = function(element) {\n  goog.asserts.assert(\n      element !== null,\n      'goog.dom.getOuterHtml expects a non-null value for element');\n  // IE, Opera and WebKit all have outerHTML.\n  if ('outerHTML' in element) {\n    return element.outerHTML;\n  } else {\n    var doc = goog.dom.getOwnerDocument(element);\n    var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);\n    div.appendChild(element.cloneNode(true));\n    return div.innerHTML;\n  }\n};\n\n\n/**\n * Finds the first descendant node that matches the filter function, using depth\n * first search. This function offers the most general purpose way of finding a\n * matching element.\n *\n * Prefer using `querySelector` if the matching criteria can be expressed as a\n * CSS selector, or `goog.dom.findElement` if you would filter for `nodeType ==\n * Node.ELEMENT_NODE`.\n *\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Node|undefined} The found node or undefined if none is found.\n */\ngoog.dom.findNode = function(root, p) {\n  var rv = [];\n  var found = goog.dom.findNodes_(root, p, rv, true);\n  return found ? rv[0] : undefined;\n};\n\n\n/**\n * Finds all the descendant nodes that match the filter function, using depth\n * first search. This function offers the most general-purpose way\n * of finding a set of matching elements.\n *\n * Prefer using `querySelectorAll` if the matching criteria can be expressed as\n * a CSS selector, or `goog.dom.findElements` if you would filter for\n * `nodeType == Node.ELEMENT_NODE`.\n *\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {!Array<!Node>} The found nodes or an empty array if none are found.\n */\ngoog.dom.findNodes = function(root, p) {\n  var rv = [];\n  goog.dom.findNodes_(root, p, rv, false);\n  return rv;\n};\n\n\n/**\n * Finds the first or all the descendant nodes that match the filter function,\n * using a depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @param {!Array<!Node>} rv The found nodes are added to this array.\n * @param {boolean} findOne If true we exit after the first found node.\n * @return {boolean} Whether the search is complete or not. True in case findOne\n *     is true and the node is found. False otherwise.\n * @private\n */\ngoog.dom.findNodes_ = function(root, p, rv, findOne) {\n  if (root != null) {\n    var child = root.firstChild;\n    while (child) {\n      if (p(child)) {\n        rv.push(child);\n        if (findOne) {\n          return true;\n        }\n      }\n      if (goog.dom.findNodes_(child, p, rv, findOne)) {\n        return true;\n      }\n      child = child.nextSibling;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Finds the first descendant element (excluding `root`) that matches the filter\n * function, using depth first search. Prefer using `querySelector` if the\n * matching criteria can be expressed as a CSS selector.\n *\n * @param {!Element | !Document} root\n * @param {function(!Element): boolean} pred Filter function.\n * @return {?Element} First matching element or null if there is none.\n */\ngoog.dom.findElement = function(root, pred) {\n  var stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) return next;\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return null;\n};\n\n\n/**\n * Finds all the descendant elements (excluding `root`) that match the filter\n * function, using depth first search. Prefer using `querySelectorAll` if the\n * matching criteria can be expressed as a CSS selector.\n *\n * @param {!Element | !Document} root\n * @param {function(!Element): boolean} pred Filter function.\n * @return {!Array<!Element>}\n */\ngoog.dom.findElements = function(root, pred) {\n  var result = [], stack = goog.dom.getChildrenReverse_(root);\n  while (stack.length > 0) {\n    var next = stack.pop();\n    if (pred(next)) result.push(next);\n    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {\n      stack.push(c);\n    }\n  }\n  return result;\n};\n\n\n/**\n * @param {!Element | !Document} node\n * @return {!Array<!Element>} node's child elements in reverse order.\n * @private\n */\ngoog.dom.getChildrenReverse_ = function(node) {\n  // document.lastElementChild doesn't exist in IE9; fall back to\n  // documentElement.\n  if (node.nodeType == goog.dom.NodeType.DOCUMENT) {\n    return [node.documentElement];\n  } else {\n    var children = [];\n    for (var c = node.lastElementChild; c; c = c.previousElementSibling) {\n      children.push(c);\n    }\n    return children;\n  }\n};\n\n\n/**\n * Map of tags whose content to ignore when calculating text length.\n * @private {!Object<string, number>}\n * @const\n */\ngoog.dom.TAGS_TO_IGNORE_ = {\n  'SCRIPT': 1,\n  'STYLE': 1,\n  'HEAD': 1,\n  'IFRAME': 1,\n  'OBJECT': 1\n};\n\n\n/**\n * Map of tags which have predefined values with regard to whitespace.\n * @private {!Object<string, string>}\n * @const\n */\ngoog.dom.PREDEFINED_TAG_VALUES_ = {\n  'IMG': ' ',\n  'BR': '\\n'\n};\n\n\n/**\n * Returns true if the element has a tab index that allows it to receive\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\n * natively support keyboard focus, even if they have no tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a tab index that allows keyboard\n *     focus.\n */\ngoog.dom.isFocusableTabIndex = function(element) {\n  return goog.dom.hasSpecifiedTabIndex_(element) &&\n      goog.dom.isTabIndexFocusable_(element);\n};\n\n\n/**\n * Enables or disables keyboard focus support on the element via its tab index.\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\n * (or elements that natively support keyboard focus, like form elements) can\n * receive keyboard focus.  See http://go/tabindex for more info.\n * @param {Element} element Element whose tab index is to be changed.\n * @param {boolean} enable Whether to set or remove a tab index on the element\n *     that supports keyboard focus.\n */\ngoog.dom.setFocusableTabIndex = function(element, enable) {\n  if (enable) {\n    element.tabIndex = 0;\n  } else {\n    // Set tabIndex to -1 first, then remove it. This is a workaround for\n    // Safari (confirmed in version 4 on Windows). When removing the attribute\n    // without setting it to -1 first, the element remains keyboard focusable\n    // despite not having a tabIndex attribute anymore.\n    element.tabIndex = -1;\n    element.removeAttribute('tabIndex');  // Must be camelCase!\n  }\n};\n\n\n/**\n * Returns true if the element can be focused, i.e. it has a tab index that\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\n * that natively supports keyboard focus.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element allows keyboard focus.\n */\ngoog.dom.isFocusable = function(element) {\n  var focusable;\n  // Some elements can have unspecified tab index and still receive focus.\n  if (goog.dom.nativelySupportsFocus_(element)) {\n    // Make sure the element is not disabled ...\n    focusable = !element.disabled &&\n        // ... and if a tab index is specified, it allows focus.\n        (!goog.dom.hasSpecifiedTabIndex_(element) ||\n         goog.dom.isTabIndexFocusable_(element));\n  } else {\n    focusable = goog.dom.isFocusableTabIndex(element);\n  }\n\n  // IE requires elements to be visible in order to focus them.\n  return focusable && goog.userAgent.IE ?\n      goog.dom.hasNonZeroBoundingRect_(/** @type {!HTMLElement} */ (element)) :\n      focusable;\n};\n\n\n/**\n * Returns true if the element has a specified tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a specified tab index.\n * @private\n */\ngoog.dom.hasSpecifiedTabIndex_ = function(element) {\n  // IE8 and below don't support hasAttribute(), instead check whether the\n  // 'tabindex' attributeNode is specified. Otherwise check hasAttribute().\n  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')) {\n    var attrNode = element.getAttributeNode('tabindex');  // Must be lowercase!\n    return goog.isDefAndNotNull(attrNode) && attrNode.specified;\n  } else {\n    return element.hasAttribute('tabindex');\n  }\n};\n\n\n/**\n * Returns true if the element's tab index allows the element to be focused.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element's tab index allows focus.\n * @private\n */\ngoog.dom.isTabIndexFocusable_ = function(element) {\n  var index = /** @type {!HTMLElement} */ (element).tabIndex;\n  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.\n  return goog.isNumber(index) && index >= 0 && index < 32768;\n};\n\n\n/**\n * Returns true if the element is focusable even when tabIndex is not set.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element natively supports focus.\n * @private\n */\ngoog.dom.nativelySupportsFocus_ = function(element) {\n  return (\n      element.tagName == goog.dom.TagName.A && element.hasAttribute('href') ||\n      element.tagName == goog.dom.TagName.INPUT ||\n      element.tagName == goog.dom.TagName.TEXTAREA ||\n      element.tagName == goog.dom.TagName.SELECT ||\n      element.tagName == goog.dom.TagName.BUTTON);\n};\n\n\n/**\n * Returns true if the element has a bounding rectangle that would be visible\n * (i.e. its width and height are greater than zero).\n * @param {!HTMLElement} element Element to check.\n * @return {boolean} Whether the element has a non-zero bounding rectangle.\n * @private\n */\ngoog.dom.hasNonZeroBoundingRect_ = function(element) {\n  var rect;\n  if (!goog.isFunction(element['getBoundingClientRect']) ||\n      // In IE, getBoundingClientRect throws on detached nodes.\n      (goog.userAgent.IE && element.parentElement == null)) {\n    rect = {'height': element.offsetHeight, 'width': element.offsetWidth};\n  } else {\n    rect = element.getBoundingClientRect();\n  }\n  return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;\n};\n\n\n/**\n * Returns the text content of the current node, without markup and invisible\n * symbols. New lines are stripped and whitespace is collapsed,\n * such that each character would be visible.\n *\n * In browsers that support it, innerText is used.  Other browsers attempt to\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The text content.\n */\ngoog.dom.getTextContent = function(node) {\n  var textContent;\n  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include\n  // text nodes in script tags. So we revert to use a user agent test here.\n  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null &&\n      ('innerText' in node)) {\n    textContent = goog.string.canonicalizeNewlines(node.innerText);\n    // Unfortunately .innerText() returns text with &shy; symbols\n    // We need to filter it out and then remove duplicate whitespaces\n  } else {\n    var buf = [];\n    goog.dom.getTextContent_(node, buf, true);\n    textContent = buf.join('');\n  }\n\n  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.\n  textContent = textContent.replace(/ \\xAD /g, ' ').replace(/\\xAD/g, '');\n  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.\n  textContent = textContent.replace(/\\u200B/g, '');\n\n  // Skip this replacement on old browsers with working innerText, which\n  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading\n  // innerText.\n  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {\n    textContent = textContent.replace(/ +/g, ' ');\n  }\n  if (textContent != ' ') {\n    textContent = textContent.replace(/^\\s*/, '');\n  }\n\n  return textContent;\n};\n\n\n/**\n * Returns the text content of the current node, without markup.\n *\n * Unlike `getTextContent` this method does not collapse whitespaces\n * or normalize lines breaks.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The raw text content.\n */\ngoog.dom.getRawTextContent = function(node) {\n  var buf = [];\n  goog.dom.getTextContent_(node, buf, false);\n\n  return buf.join('');\n};\n\n\n/**\n * Recursive support function for text content retrieval.\n *\n * @param {Node} node The node from which we are getting content.\n * @param {Array<string>} buf string buffer.\n * @param {boolean} normalizeWhitespace Whether to normalize whitespace.\n * @private\n */\ngoog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {\n  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n    // ignore certain tags\n  } else if (node.nodeType == goog.dom.NodeType.TEXT) {\n    if (normalizeWhitespace) {\n      buf.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      buf.push(node.nodeValue);\n    }\n  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);\n  } else {\n    var child = node.firstChild;\n    while (child) {\n      goog.dom.getTextContent_(child, buf, normalizeWhitespace);\n      child = child.nextSibling;\n    }\n  }\n};\n\n\n/**\n * Returns the text length of the text contained in a node, without markup. This\n * is equivalent to the selection length if the node was selected, or the number\n * of cursor movements to traverse the node. Images & BRs take one space.  New\n * lines are ignored.\n *\n * @param {Node} node The node whose text content length is being calculated.\n * @return {number} The length of `node`'s text content.\n */\ngoog.dom.getNodeTextLength = function(node) {\n  return goog.dom.getTextContent(node).length;\n};\n\n\n/**\n * Returns the text offset of a node relative to one of its ancestors. The text\n * length is the same as the length calculated by goog.dom.getNodeTextLength.\n *\n * @param {Node} node The node whose offset is being calculated.\n * @param {Node=} opt_offsetParent The node relative to which the offset will\n *     be calculated. Defaults to the node's owner document's body.\n * @return {number} The text offset.\n */\ngoog.dom.getNodeTextOffset = function(node, opt_offsetParent) {\n  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;\n  var buf = [];\n  while (node && node != root) {\n    var cur = node;\n    while ((cur = cur.previousSibling)) {\n      buf.unshift(goog.dom.getTextContent(cur));\n    }\n    node = node.parentNode;\n  }\n  // Trim left to deal with FF cases when there might be line breaks and empty\n  // nodes at the front of the text\n  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;\n};\n\n\n/**\n * Returns the node at a given offset in a parent node.  If an object is\n * provided for the optional third parameter, the node and the remainder of the\n * offset will stored as properties of this object.\n * @param {Node} parent The parent node.\n * @param {number} offset The offset into the parent node.\n * @param {Object=} opt_result Object to be used to store the return value. The\n *     return value will be stored in the form {node: Node, remainder: number}\n *     if this object is provided.\n * @return {Node} The node at the given offset.\n */\ngoog.dom.getNodeAtOffset = function(parent, offset, opt_result) {\n  var stack = [parent], pos = 0, cur = null;\n  while (stack.length > 0 && pos < offset) {\n    cur = stack.pop();\n    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {\n      // ignore certain tags\n    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {\n      var text = cur.nodeValue.replace(/(\\r\\n|\\r|\\n)/g, '').replace(/ +/g, ' ');\n      pos += text.length;\n    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {\n      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;\n    } else {\n      for (var i = cur.childNodes.length - 1; i >= 0; i--) {\n        stack.push(cur.childNodes[i]);\n      }\n    }\n  }\n  if (goog.isObject(opt_result)) {\n    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;\n    opt_result.node = cur;\n  }\n\n  return cur;\n};\n\n\n/**\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\n * the object must have a numeric length property and an item function (which\n * has type 'string' on IE for some reason).\n * @param {Object} val Object to test.\n * @return {boolean} Whether the object is a NodeList.\n */\ngoog.dom.isNodeList = function(val) {\n  // TODO(attila): Now the isNodeList is part of goog.dom we can use\n  // goog.userAgent to make this simpler.\n  // A NodeList must have a length property of type 'number' on all platforms.\n  if (val && typeof val.length == 'number') {\n    // A NodeList is an object everywhere except Safari, where it's a function.\n    if (goog.isObject(val)) {\n      // A NodeList must have an item function (on non-IE platforms) or an item\n      // property of type 'string' (on IE).\n      return typeof val.item == 'function' || typeof val.item == 'string';\n    } else if (goog.isFunction(val)) {\n      // On Safari, a NodeList is a function with an item property that is also\n      // a function.\n      return typeof /** @type {?} */ (val.item) == 'function';\n    }\n  }\n\n  // Not a NodeList.\n  return false;\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * tag name and/or class name. If the passed element matches the specified\n * criteria, the element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\n *     null/undefined to match only based on class name).\n * @param {?string=} opt_class The class name to match (or null/undefined to\n *     match only based on tag name).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {?R} The first ancestor that matches the passed criteria, or\n *     null if no match is found. The return type is {?Element} if opt_tag is\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.getAncestorByTagNameAndClass = function(\n    element, opt_tag, opt_class, opt_maxSearchSteps) {\n  if (!opt_tag && !opt_class) {\n    return null;\n  }\n  var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;\n  return /** @type {Element} */ (goog.dom.getAncestor(element, function(node) {\n    return (!tagName || node.nodeName == tagName) &&\n        (!opt_class ||\n         goog.isString(node.className) &&\n             goog.array.contains(node.className.split(/\\s+/), opt_class));\n  }, true, opt_maxSearchSteps));\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * class name. If the passed element matches the specified criteria, the\n * element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {string} className The class name to match.\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Element} The first ancestor that matches the passed criteria, or\n *     null if none match.\n */\ngoog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {\n  return goog.dom.getAncestorByTagNameAndClass(\n      element, null, className, opt_maxSearchSteps);\n};\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that passes the\n * matcher function.\n * @param {Node} element The DOM node to start with.\n * @param {function(Node) : boolean} matcher A function that returns true if the\n *     passed node matches the desired criteria.\n * @param {boolean=} opt_includeNode If true, the node itself is included in\n *     the search (the first call to the matcher will pass startElement as\n *     the node to test).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Node} DOM node that matched the matcher, or null if there was\n *     no match.\n */\ngoog.dom.getAncestor = function(\n    element, matcher, opt_includeNode, opt_maxSearchSteps) {\n  if (element && !opt_includeNode) {\n    element = element.parentNode;\n  }\n  var steps = 0;\n  while (element &&\n         (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {\n    goog.asserts.assert(element.name != 'parentNode');\n    if (matcher(element)) {\n      return element;\n    }\n    element = element.parentNode;\n    steps++;\n  }\n  // Reached the root of the DOM without a match\n  return null;\n};\n\n\n/**\n * Determines the active element in the given document.\n * @param {Document} doc The document to look in.\n * @return {Element} The active element.\n */\ngoog.dom.getActiveElement = function(doc) {\n  // While in an iframe, IE9 will throw \"Unspecified error\" when accessing\n  // activeElement.\n  try {\n    var activeElement = doc && doc.activeElement;\n    // While not in an iframe, IE9-11 sometimes gives null.\n    // While in an iframe, IE11 sometimes returns an empty object.\n    return activeElement && activeElement.nodeName ? activeElement : null;\n  } catch (e) {\n    return null;\n  }\n};\n\n\n/**\n * Gives the current devicePixelRatio.\n *\n * By default, this is the value of window.devicePixelRatio (which should be\n * preferred if present).\n *\n * If window.devicePixelRatio is not present, the ratio is calculated with\n * window.matchMedia, if present. Otherwise, gives 1.0.\n *\n * Some browsers (including Chrome) consider the browser zoom level in the pixel\n * ratio, so the value may change across multiple calls.\n *\n * @return {number} The number of actual pixels per virtual pixel.\n */\ngoog.dom.getPixelRatio = function() {\n  var win = goog.dom.getWindow();\n  if (goog.isDef(win.devicePixelRatio)) {\n    return win.devicePixelRatio;\n  } else if (win.matchMedia) {\n    // Should be for IE10 and FF6-17 (this basically clamps to lower)\n    // Note that the order of these statements is important\n    return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) ||\n           goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) ||\n           .75;\n  }\n  return 1;\n};\n\n\n/**\n * Calculates a mediaQuery to check if the current device supports the\n * given actual to virtual pixel ratio.\n * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.\n * @return {number} pixelRatio if applicable, otherwise 0.\n * @private\n */\ngoog.dom.matchesPixelRatio_ = function(pixelRatio) {\n  var win = goog.dom.getWindow();\n  /**\n   * Due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to\n   * 96dpi.\n   * @const {number}\n   */\n  var dpiPerDppx = 96;\n  var query =\n      // FF16-17\n      '(min-resolution: ' + pixelRatio + 'dppx),' +\n      // FF6-15\n      '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +\n      // IE10 (this works for the two browsers above too but I don't want to\n      // trust the 1:96 fixed ratio magic)\n      '(min-resolution: ' + (pixelRatio * dpiPerDppx) + 'dpi)';\n  return win.matchMedia(query).matches ? pixelRatio : 0;\n};\n\n\n/**\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\n * type information.\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n */\ngoog.dom.getCanvasContext2D = function(canvas) {\n  return /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n};\n\n\n\n/**\n * Create an instance of a DOM helper with a new document object.\n * @param {Document=} opt_document Document object to associate with this\n *     DOM helper.\n * @constructor\n */\ngoog.dom.DomHelper = function(opt_document) {\n  /**\n   * Reference to the document object to use\n   * @type {!Document}\n   * @private\n   */\n  this.document_ = opt_document || goog.global.document || document;\n};\n\n\n/**\n * Gets the dom helper object for the document where the element resides.\n * @param {Node=} opt_node If present, gets the DomHelper for this node.\n * @return {!goog.dom.DomHelper} The DomHelper.\n */\ngoog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;\n\n\n/**\n * Sets the document object.\n * @param {!Document} document Document object.\n */\ngoog.dom.DomHelper.prototype.setDocument = function(document) {\n  this.document_ = document;\n};\n\n\n/**\n * Gets the document object being used by the dom library.\n * @return {!Document} Document object.\n */\ngoog.dom.DomHelper.prototype.getDocument = function() {\n  return this.document_;\n};\n\n\n/**\n * Alias for `getElementById`. If a DOM node is passed in then we just\n * return that.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n */\ngoog.dom.DomHelper.prototype.getElement = function(element) {\n  return goog.dom.getElementHelper_(this.document_, element);\n};\n\n\n/**\n * Gets an element by id, asserting that the element is found.\n *\n * This is used when an element is expected to exist, and should fail with\n * an assertion error if it does not (if assertions are enabled).\n *\n * @param {string} id Element ID.\n * @return {!Element} The element with the given ID, if it exists.\n */\ngoog.dom.DomHelper.prototype.getRequiredElement = function(id) {\n  return goog.dom.getRequiredElementHelper_(this.document_, id);\n};\n\n\n/**\n * Alias for `getElement`.\n * @param {string|Element} element Element ID or a DOM node.\n * @return {Element} The element with the given ID, or the node passed in.\n * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.\n */\ngoog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;\n\n\n/**\n * Gets elements by tag name.\n * @param {!goog.dom.TagName<T>} tagName\n * @param {(!Document|!Element)=} opt_parent Parent element or document where to\n *     look for elements. Defaults to document of this DomHelper.\n * @return {!NodeList<R>} List of elements. The members of the list are\n *     {!Element} if tagName is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementsByTagName =\n    function(tagName, opt_parent) {\n  var parent = opt_parent || this.document_;\n  return parent.getElementsByTagName(String(tagName));\n};\n\n\n/**\n * Looks up elements by both tag and class name, using browser native functions\n * (`querySelectorAll`, `getElementsByTagName` or\n * `getElementsByClassName`) where possible. The returned array is a live\n * NodeList or a static list depending on the code path taken.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name or * for all\n *     tags.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more\n *     specific types if it is (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(\n    opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementsByTagNameAndClass_(\n      this.document_, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Gets the first element matching the tag and the class.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {(Document|Element)=} opt_el Optional element to look in.\n * @return {?R} Reference to a DOM node. The return type is {?Element} if\n *     tagName is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(\n    opt_tag, opt_class, opt_el) {\n  return goog.dom.getElementByTagNameAndClass_(\n      this.document_, opt_tag, opt_class, opt_el);\n};\n\n\n/**\n * Returns an array of all the elements with the provided className.\n * @param {string} className the name of the class to look for.\n * @param {Element|Document=} opt_el Optional element to look in.\n * @return {!IArrayLike<!Element>} The items found with the class name provided.\n */\ngoog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementsByClass(className, doc);\n};\n\n\n/**\n * Returns the first element we find matching the provided class name.\n * @param {string} className the name of the class to look for.\n * @param {(Element|Document)=} opt_el Optional element to look in.\n * @return {Element} The first item found with the class name provided.\n */\ngoog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {\n  var doc = opt_el || this.document_;\n  return goog.dom.getElementByClass(className, doc);\n};\n\n\n/**\n * Ensures an element with the given className exists, and then returns the\n * first element with the provided className.\n * @param {string} className the name of the class to look for.\n * @param {(!Element|!Document)=} opt_root Optional element or document to look\n *     in.\n * @return {!Element} The first item found with the class name provided.\n * @throws {goog.asserts.AssertionError} Thrown if no element is found.\n */\ngoog.dom.DomHelper.prototype.getRequiredElementByClass = function(\n    className, opt_root) {\n  var root = opt_root || this.document_;\n  return goog.dom.getRequiredElementByClass(className, root);\n};\n\n\n/**\n * Alias for `getElementsByTagNameAndClass`.\n * @deprecated Use DomHelper getElementsByTagNameAndClass.\n *\n * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.\n * @param {?string=} opt_class Optional class name.\n * @param {Element=} opt_el Optional element to look in.\n * @return {!IArrayLike<R>} Array-like list of elements (only a length property\n *     and numerical indices are guaranteed to exist). The members of the array\n *     are {!Element} if opt_tag is a string or more specific types if it is\n *     a member of goog.dom.TagName (e.g. {!HTMLAnchorElement} for\n *     goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.$$ =\n    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;\n\n\n/**\n * Sets a number of properties on a node.\n * @param {Element} element DOM node to set properties on.\n * @param {Object} properties Hash of property:value pairs.\n */\ngoog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;\n\n\n/**\n * Gets the dimensions of the viewport.\n * @param {Window=} opt_window Optional window element to test. Defaults to\n *     the window of the Dom Helper.\n * @return {!goog.math.Size} Object with values 'width' and 'height'.\n */\ngoog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {\n  // TODO(arv): This should not take an argument. That breaks the rule of a\n  // a DomHelper representing a single frame/window/document.\n  return goog.dom.getViewportSize(opt_window || this.getWindow());\n};\n\n\n/**\n * Calculates the height of the document.\n *\n * @return {number} The height of the document.\n */\ngoog.dom.DomHelper.prototype.getDocumentHeight = function() {\n  return goog.dom.getDocumentHeight_(this.getWindow());\n};\n\n\n/**\n * Typedef for use with goog.dom.createDom and goog.dom.append.\n * @typedef {Object|string|Array|NodeList}\n */\ngoog.dom.Appendable;\n\n\n/**\n * Returns a dom node with a set of attributes.  This function accepts varargs\n * for subsequent nodes to be added.  Subsequent nodes will be added to the\n * first node as childNodes.\n *\n * So:\n * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),\n * createDom(goog.dom.TagName.P));</code> would return a div with two child\n * paragraphs\n *\n * An easy way to move all child nodes of an existing element to a new parent\n * element is:\n * <code>createDom(goog.dom.TagName.DIV, null, oldElement.childNodes);</code>\n * which will remove all child nodes from the old element and add them as\n * child nodes of the new DIV.\n *\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\n *     strings for text nodes. If one of the var_args is an array or\n *     NodeList, its elements will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.createDom = function(\n    tagName, opt_attributes, var_args) {\n  return goog.dom.createDom_(this.document_, arguments);\n};\n\n\n/**\n * Alias for `createDom`.\n * @param {string|!goog.dom.TagName<T>} tagName Tag to create.\n * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map\n *     of name-value pairs for attributes. If a string, then this is the\n *     className of the new element. If an array, the elements will be joined\n *     together as the className of the new element.\n * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or\n *     strings for text nodes.  If one of the var_args is an array, its children\n *     will be added as childNodes instead.\n * @return {R} Reference to a DOM node. The return type is {!Element} if tagName\n *     is a string or a more specific type if it is a member of\n *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.\n */\ngoog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;\n\n\n/**\n * Creates a new element.\n * @param {string|!goog.dom.TagName<T>} name Tag to create.\n * @return {R} The new element. The return type is {!Element} if name is\n *     a string or a more specific type if it is a member of goog.dom.TagName\n *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.createElement = function(name) {\n  return goog.dom.createElement_(this.document_, name);\n};\n\n\n/**\n * Creates a new text node.\n * @param {number|string} content Content.\n * @return {!Text} The new text node.\n */\ngoog.dom.DomHelper.prototype.createTextNode = function(content) {\n  return this.document_.createTextNode(String(content));\n};\n\n\n/**\n * Create a table.\n * @param {number} rows The number of rows in the table.  Must be >= 1.\n * @param {number} columns The number of columns in the table.  Must be >= 1.\n * @param {boolean=} opt_fillWithNbsp If true, fills table entries with\n *     `goog.string.Unicode.NBSP` characters.\n * @return {!HTMLElement} The created table.\n */\ngoog.dom.DomHelper.prototype.createTable = function(\n    rows, columns, opt_fillWithNbsp) {\n  return goog.dom.createTable_(\n      this.document_, rows, columns, !!opt_fillWithNbsp);\n};\n\n\n/**\n * Converts an HTML into a node or a document fragment. A single Node is used if\n * `html` only generates a single node. If `html` generates multiple\n * nodes then these are put inside a `DocumentFragment`. This is a safe\n * version of `goog.dom.DomHelper#htmlToDocumentFragment` which is now\n * deleted.\n * @param {!goog.html.SafeHtml} html The HTML markup to convert.\n * @return {!Node} The resulting node.\n */\ngoog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {\n  return goog.dom.safeHtmlToNode_(this.document_, html);\n};\n\n\n/**\n * Returns true if the browser is in \"CSS1-compatible\" (standards-compliant)\n * mode, false otherwise.\n * @return {boolean} True if in CSS1-compatible mode.\n */\ngoog.dom.DomHelper.prototype.isCss1CompatMode = function() {\n  return goog.dom.isCss1CompatMode_(this.document_);\n};\n\n\n/**\n * Gets the window object associated with the document.\n * @return {!Window} The window associated with the given document.\n */\ngoog.dom.DomHelper.prototype.getWindow = function() {\n  return goog.dom.getWindow_(this.document_);\n};\n\n\n/**\n * Gets the document scroll element.\n * @return {!Element} Scrolling element.\n */\ngoog.dom.DomHelper.prototype.getDocumentScrollElement = function() {\n  return goog.dom.getDocumentScrollElement_(this.document_);\n};\n\n\n/**\n * Gets the document scroll distance as a coordinate object.\n * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.\n */\ngoog.dom.DomHelper.prototype.getDocumentScroll = function() {\n  return goog.dom.getDocumentScroll_(this.document_);\n};\n\n\n/**\n * Determines the active element in the given document.\n * @param {Document=} opt_doc The document to look in.\n * @return {Element} The active element.\n */\ngoog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {\n  return goog.dom.getActiveElement(opt_doc || this.document_);\n};\n\n\n/**\n * Appends a child to a node.\n * @param {Node} parent Parent.\n * @param {Node} child Child.\n */\ngoog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;\n\n\n/**\n * Appends a node with text or other nodes.\n * @param {!Node} parent The node to append nodes to.\n * @param {...goog.dom.Appendable} var_args The things to append to the node.\n *     If this is a Node it is appended as is.\n *     If this is a string then a text node is appended.\n *     If this is an array like object then fields 0 to length - 1 are appended.\n */\ngoog.dom.DomHelper.prototype.append = goog.dom.append;\n\n\n/**\n * Determines if the given node can contain children, intended to be used for\n * HTML generation.\n *\n * @param {Node} node The node to check.\n * @return {boolean} Whether the node can contain children.\n */\ngoog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;\n\n\n/**\n * Removes all the child nodes on a DOM node.\n * @param {Node} node Node to remove children from.\n */\ngoog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;\n\n\n/**\n * Inserts a new node before an existing reference node (i.e., as the previous\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert before.\n */\ngoog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;\n\n\n/**\n * Inserts a new node after an existing reference node (i.e., as the next\n * sibling). If the reference node has no parent, then does nothing.\n * @param {Node} newNode Node to insert.\n * @param {Node} refNode Reference node to insert after.\n */\ngoog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;\n\n\n/**\n * Insert a child at a given index. If index is larger than the number of child\n * nodes that the parent currently has, the node is inserted as the last child\n * node.\n * @param {Element} parent The element into which to insert the child.\n * @param {Node} child The element to insert.\n * @param {number} index The index at which to insert the new child node. Must\n *     not be negative.\n */\ngoog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;\n\n\n/**\n * Removes a node from its parent.\n * @param {Node} node The node to remove.\n * @return {Node} The node removed if removed; else, null.\n */\ngoog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;\n\n\n/**\n * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no\n * parent.\n * @param {Node} newNode Node to insert.\n * @param {Node} oldNode Node to replace.\n */\ngoog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;\n\n\n/**\n * Flattens an element. That is, removes it and replace it with its children.\n * @param {Element} element The element to flatten.\n * @return {Element|undefined} The original element, detached from the document\n *     tree, sans children, or undefined if the element was already not in the\n *     document.\n */\ngoog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;\n\n\n/**\n * Returns an array containing just the element children of the given element.\n * @param {Element} element The element whose element children we want.\n * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list\n *     of just the element children of the given element.\n */\ngoog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;\n\n\n/**\n * Returns the first child node that is an element.\n * @param {Node} node The node to get the first child element of.\n * @return {Element} The first child node of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getFirstElementChild =\n    goog.dom.getFirstElementChild;\n\n\n/**\n * Returns the last child node that is an element.\n * @param {Node} node The node to get the last child element of.\n * @return {Element} The last child node of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;\n\n\n/**\n * Returns the first next sibling that is an element.\n * @param {Node} node The node to get the next sibling element of.\n * @return {Element} The next sibling of `node` that is an element.\n */\ngoog.dom.DomHelper.prototype.getNextElementSibling =\n    goog.dom.getNextElementSibling;\n\n\n/**\n * Returns the first previous sibling that is an element.\n * @param {Node} node The node to get the previous sibling element of.\n * @return {Element} The first previous sibling of `node` that is\n *     an element.\n */\ngoog.dom.DomHelper.prototype.getPreviousElementSibling =\n    goog.dom.getPreviousElementSibling;\n\n\n/**\n * Returns the next node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The next node in the DOM tree, or null if this was the last\n *     node.\n */\ngoog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;\n\n\n/**\n * Returns the previous node in source order from the given node.\n * @param {Node} node The node.\n * @return {Node} The previous node in the DOM tree, or null if this was the\n *     first node.\n */\ngoog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;\n\n\n/**\n * Whether the object looks like a DOM node.\n * @param {?} obj The object being tested for node likeness.\n * @return {boolean} Whether the object looks like a DOM node.\n */\ngoog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;\n\n\n/**\n * Whether the object looks like an Element.\n * @param {?} obj The object being tested for Element likeness.\n * @return {boolean} Whether the object looks like an Element.\n */\ngoog.dom.DomHelper.prototype.isElement = goog.dom.isElement;\n\n\n/**\n * Returns true if the specified value is a Window object. This includes the\n * global window for HTML pages, and iframe windows.\n * @param {?} obj Variable to test.\n * @return {boolean} Whether the variable is a window.\n */\ngoog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;\n\n\n/**\n * Returns an element's parent, if it's an Element.\n * @param {Element} element The DOM element.\n * @return {Element} The parent, or null if not an Element.\n */\ngoog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;\n\n\n/**\n * Whether a node contains another node.\n * @param {Node} parent The node that should contain the other node.\n * @param {Node} descendant The node to test presence of.\n * @return {boolean} Whether the parent node contains the descendant node.\n */\ngoog.dom.DomHelper.prototype.contains = goog.dom.contains;\n\n\n/**\n * Compares the document order of two nodes, returning 0 if they are the same\n * node, a negative number if node1 is before node2, and a positive number if\n * node2 is before node1.  Note that we compare the order the tags appear in the\n * document so in the tree <b><i>text</i></b> the B node is considered to be\n * before the I node.\n *\n * @param {Node} node1 The first node to compare.\n * @param {Node} node2 The second node to compare.\n * @return {number} 0 if the nodes are the same node, a negative number if node1\n *     is before node2, and a positive number if node2 is before node1.\n */\ngoog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;\n\n\n/**\n * Find the deepest common ancestor of the given nodes.\n * @param {...Node} var_args The nodes to find a common ancestor of.\n * @return {Node} The common ancestor of the nodes, or null if there is none.\n *     null will only be returned if two or more of the nodes are from different\n *     documents.\n */\ngoog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;\n\n\n/**\n * Returns the owner document for a node.\n * @param {Node} node The node to get the document for.\n * @return {!Document} The document owning the node.\n */\ngoog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;\n\n\n/**\n * Cross browser function for getting the document element of an iframe.\n * @param {Element} iframe Iframe element.\n * @return {!Document} The frame content document.\n */\ngoog.dom.DomHelper.prototype.getFrameContentDocument =\n    goog.dom.getFrameContentDocument;\n\n\n/**\n * Cross browser function for getting the window of a frame or iframe.\n * @param {Element} frame Frame element.\n * @return {Window} The window associated with the given frame.\n */\ngoog.dom.DomHelper.prototype.getFrameContentWindow =\n    goog.dom.getFrameContentWindow;\n\n\n/**\n * Sets the text content of a node, with cross-browser support.\n * @param {Node} node The node to change the text content of.\n * @param {string|number} text The value that should replace the node's content.\n */\ngoog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;\n\n\n/**\n * Gets the outerHTML of a node, which islike innerHTML, except that it\n * actually contains the HTML of the node itself.\n * @param {Element} element The element to get the HTML of.\n * @return {string} The outerHTML of the given element.\n */\ngoog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;\n\n\n/**\n * Finds the first descendant node that matches the filter function. This does\n * a depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Node|undefined} The found node or undefined if none is found.\n */\ngoog.dom.DomHelper.prototype.findNode = goog.dom.findNode;\n\n\n/**\n * Finds all the descendant nodes that matches the filter function. This does a\n * depth first search.\n * @param {Node} root The root of the tree to search.\n * @param {function(Node) : boolean} p The filter function.\n * @return {Array<Node>} The found nodes or an empty array if none are found.\n */\ngoog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;\n\n\n/**\n * Returns true if the element has a tab index that allows it to receive\n * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements\n * natively support keyboard focus, even if they have no tab index.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element has a tab index that allows keyboard\n *     focus.\n */\ngoog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;\n\n\n/**\n * Enables or disables keyboard focus support on the element via its tab index.\n * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true\n * (or elements that natively support keyboard focus, like form elements) can\n * receive keyboard focus.  See http://go/tabindex for more info.\n * @param {Element} element Element whose tab index is to be changed.\n * @param {boolean} enable Whether to set or remove a tab index on the element\n *     that supports keyboard focus.\n */\ngoog.dom.DomHelper.prototype.setFocusableTabIndex =\n    goog.dom.setFocusableTabIndex;\n\n\n/**\n * Returns true if the element can be focused, i.e. it has a tab index that\n * allows it to receive keyboard focus (tabIndex >= 0), or it is an element\n * that natively supports keyboard focus.\n * @param {!Element} element Element to check.\n * @return {boolean} Whether the element allows keyboard focus.\n */\ngoog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;\n\n\n/**\n * Returns the text contents of the current node, without markup. New lines are\n * stripped and whitespace is collapsed, such that each character would be\n * visible.\n *\n * In browsers that support it, innerText is used.  Other browsers attempt to\n * simulate it via node traversal.  Line breaks are canonicalized in IE.\n *\n * @param {Node} node The node from which we are getting content.\n * @return {string} The text content.\n */\ngoog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;\n\n\n/**\n * Returns the text length of the text contained in a node, without markup. This\n * is equivalent to the selection length if the node was selected, or the number\n * of cursor movements to traverse the node. Images & BRs take one space.  New\n * lines are ignored.\n *\n * @param {Node} node The node whose text content length is being calculated.\n * @return {number} The length of `node`'s text content.\n */\ngoog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;\n\n\n/**\n * Returns the text offset of a node relative to one of its ancestors. The text\n * length is the same as the length calculated by\n * `goog.dom.getNodeTextLength`.\n *\n * @param {Node} node The node whose offset is being calculated.\n * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.\n * @return {number} The text offset.\n */\ngoog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;\n\n\n/**\n * Returns the node at a given offset in a parent node.  If an object is\n * provided for the optional third parameter, the node and the remainder of the\n * offset will stored as properties of this object.\n * @param {Node} parent The parent node.\n * @param {number} offset The offset into the parent node.\n * @param {Object=} opt_result Object to be used to store the return value. The\n *     return value will be stored in the form {node: Node, remainder: number}\n *     if this object is provided.\n * @return {Node} The node at the given offset.\n */\ngoog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;\n\n\n/**\n * Returns true if the object is a `NodeList`.  To qualify as a NodeList,\n * the object must have a numeric length property and an item function (which\n * has type 'string' on IE for some reason).\n * @param {Object} val Object to test.\n * @return {boolean} Whether the object is a NodeList.\n */\ngoog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * tag name and/or class name. If the passed element matches the specified\n * criteria, the element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or\n *     null/undefined to match only based on class name).\n * @param {?string=} opt_class The class name to match (or null/undefined to\n *     match only based on tag name).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {?R} The first ancestor that matches the passed criteria, or\n *     null if no match is found. The return type is {?Element} if opt_tag is\n *     not a member of goog.dom.TagName or a more specific type if it is (e.g.\n *     {?HTMLAnchorElement} for goog.dom.TagName.A).\n * @template T\n * @template R := cond(isUnknown(T), 'Element', T) =:\n */\ngoog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =\n    goog.dom.getAncestorByTagNameAndClass;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that has the passed\n * class name. If the passed element matches the specified criteria, the\n * element itself is returned.\n * @param {Node} element The DOM node to start with.\n * @param {string} class The class name to match.\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Element} The first ancestor that matches the passed criteria, or\n *     null if none match.\n */\ngoog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;\n\n\n/**\n * Walks up the DOM hierarchy returning the first ancestor that passes the\n * matcher function.\n * @param {Node} element The DOM node to start with.\n * @param {function(Node) : boolean} matcher A function that returns true if the\n *     passed node matches the desired criteria.\n * @param {boolean=} opt_includeNode If true, the node itself is included in\n *     the search (the first call to the matcher will pass startElement as\n *     the node to test).\n * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the\n *     dom.\n * @return {Node} DOM node that matched the matcher, or null if there was\n *     no match.\n */\ngoog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;\n\n\n/**\n * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a\n * type information.\n * @param {!HTMLCanvasElement} canvas\n * @return {!CanvasRenderingContext2D}\n */\ngoog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview JSON utility functions.\n * @author arv@google.com (Erik Arvidsson)\n */\n\n\ngoog.provide('goog.json');\ngoog.provide('goog.json.Replacer');\ngoog.provide('goog.json.Reviver');\ngoog.provide('goog.json.Serializer');\n\n\n/**\n * @define {boolean} If true, use the native JSON parsing API.\n * NOTE: The default `goog.json.parse` implementation is able to handle\n * invalid JSON. JSPB used to produce invalid JSON which is not the case\n * anymore so this is safe to enable for parsing JSPB. Using native JSON is\n * faster and safer than the default implementation using `eval`.\n */\ngoog.json.USE_NATIVE_JSON = goog.define('goog.json.USE_NATIVE_JSON', false);\n\n/**\n * @define {boolean} If true, try the native JSON parsing API first. If it\n * fails, log an error and use `eval` instead. This is useful when\n * transitioning to `goog.json.USE_NATIVE_JSON`. The error logger needs to\n * be set by `goog.json.setErrorLogger`. If it is not set then the error\n * is ignored.\n */\ngoog.json.TRY_NATIVE_JSON = goog.define('goog.json.TRY_NATIVE_JSON', false);\n\n\n/**\n * Tests if a string is an invalid JSON string. This only ensures that we are\n * not using any invalid characters\n * @param {string} s The string to test.\n * @return {boolean} True if the input is a valid JSON string.\n */\ngoog.json.isValid = function(s) {\n  // All empty whitespace is not valid.\n  if (/^\\s*$/.test(s)) {\n    return false;\n  }\n\n  // This is taken from http://www.json.org/json2.js which is released to the\n  // public domain.\n  // Changes: We dissallow \\u2028 Line separator and \\u2029 Paragraph separator\n  // inside strings.  We also treat \\u2028 and \\u2029 as whitespace which they\n  // are in the RFC but IE and Safari does not match \\s to these so we need to\n  // include them in the reg exps in all places where whitespace is allowed.\n  // We allowed \\x7f inside strings because some tools don't escape it,\n  // e.g. http://www.json.org/java/org/json/JSONObject.java\n\n  // Parsing happens in three stages. In the first stage, we run the text\n  // against regular expressions that look for non-JSON patterns. We are\n  // especially concerned with '()' and 'new' because they can cause invocation,\n  // and '=' because it can cause mutation. But just to be safe, we want to\n  // reject all unexpected forms.\n\n  // We split the first stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace all backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters, but only when followed\n  // by a colon, comma, closing bracket or end of string. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n  // Don't make these static since they have the global flag.\n  var backslashesRe = /\\\\[\"\\\\\\/bfnrtu]/g;\n  var simpleValuesRe =\n      /(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g;\n  var openBracketsRe = /(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g;\n  var remainderRe = /^[\\],:{}\\s\\u2028\\u2029]*$/;\n\n  return remainderRe.test(\n      s.replace(backslashesRe, '@')\n          .replace(simpleValuesRe, ']')\n          .replace(openBracketsRe, ''));\n};\n\n/**\n * Logs a parsing error in `JSON.parse` solvable by using `eval`\n * if `goog.json.TRY_NATIVE_JSON` is enabled.\n * @private {function(string, !Error)} The first parameter is the error message,\n *     the second is the exception thrown by `JSON.parse`.\n */\ngoog.json.errorLogger_ = goog.nullFunction;\n\n\n/**\n * Sets an error logger to use if there's a recoverable parsing error and\n * `goog.json.TRY_NATIVE_JSON` is enabled.\n * @param {function(string, !Error)} errorLogger The first parameter is the\n *     error message, the second is the exception thrown by `JSON.parse`.\n */\ngoog.json.setErrorLogger = function(errorLogger) {\n  goog.json.errorLogger_ = errorLogger;\n};\n\n\n/**\n * Parses a JSON string and returns the result. This throws an exception if\n * the string is an invalid JSON string.\n *\n * Note that this is very slow on large strings. Use JSON.parse if possible.\n *\n * @param {*} s The JSON string to parse.\n * @throws Error if s is invalid JSON.\n * @return {Object} The object generated from the JSON string, or null.\n * @deprecated Use JSON.parse.\n */\ngoog.json.parse = goog.json.USE_NATIVE_JSON ?\n    /** @type {function(*):Object} */ (goog.global['JSON']['parse']) :\n    function(s) {\n      var error;\n      if (goog.json.TRY_NATIVE_JSON) {\n        try {\n          return goog.global['JSON']['parse'](s);\n        } catch (ex) {\n          error = ex;\n        }\n      }\n      var o = String(s);\n      if (goog.json.isValid(o)) {\n\n        try {\n          var result = /** @type {?Object} */ (eval('(' + o + ')'));\n          if (error) {\n            goog.json.errorLogger_('Invalid JSON: ' + o, error);\n          }\n          return result;\n        } catch (ex) {\n        }\n      }\n      throw new Error('Invalid JSON string: ' + o);\n    };\n\n\n/**\n * JSON replacer, as defined in Section 15.12.3 of the ES5 spec.\n * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3\n *\n * TODO(nicksantos): Array should also be a valid replacer.\n *\n * @typedef {function(this:Object, string, *): *}\n */\ngoog.json.Replacer;\n\n\n/**\n * JSON reviver, as defined in Section 15.12.2 of the ES5 spec.\n * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3\n *\n * @typedef {function(this:Object, string, *): *}\n */\ngoog.json.Reviver;\n\n\n/**\n * Serializes an object or a value to a JSON string.\n *\n * @param {*} object The object to serialize.\n * @param {?goog.json.Replacer=} opt_replacer A replacer function\n *     called for each (key, value) pair that determines how the value\n *     should be serialized. By defult, this just returns the value\n *     and allows default serialization to kick in.\n * @throws Error if there are loops in the object graph.\n * @return {string} A JSON string representation of the input.\n */\ngoog.json.serialize = goog.json.USE_NATIVE_JSON ?\n    /** @type {function(*, ?goog.json.Replacer=):string} */\n    (goog.global['JSON']['stringify']) :\n    function(object, opt_replacer) {\n      // NOTE(nicksantos): Currently, we never use JSON.stringify.\n      //\n      // The last time I evaluated this, JSON.stringify had subtle bugs and\n      // behavior differences on all browsers, and the performance win was not\n      // large enough to justify all the issues. This may change in the future\n      // as browser implementations get better.\n      //\n      // assertSerialize in json_test contains if branches for the cases\n      // that fail.\n      return new goog.json.Serializer(opt_replacer).serialize(object);\n    };\n\n\n\n/**\n * Class that is used to serialize JSON objects to a string.\n * @param {?goog.json.Replacer=} opt_replacer Replacer.\n * @constructor\n */\ngoog.json.Serializer = function(opt_replacer) {\n  /**\n   * @type {goog.json.Replacer|null|undefined}\n   * @private\n   */\n  this.replacer_ = opt_replacer;\n};\n\n\n/**\n * Serializes an object or a value to a JSON string.\n *\n * @param {*} object The object to serialize.\n * @throws Error if there are loops in the object graph.\n * @return {string} A JSON string representation of the input.\n */\ngoog.json.Serializer.prototype.serialize = function(object) {\n  var sb = [];\n  this.serializeInternal(object, sb);\n  return sb.join('');\n};\n\n\n/**\n * Serializes a generic value to a JSON string\n * @protected\n * @param {*} object The object to serialize.\n * @param {Array<string>} sb Array used as a string builder.\n * @throws Error if there are loops in the object graph.\n */\ngoog.json.Serializer.prototype.serializeInternal = function(object, sb) {\n  if (object == null) {\n    // undefined == null so this branch covers undefined as well as null\n    sb.push('null');\n    return;\n  }\n\n  if (typeof object == 'object') {\n    if (goog.isArray(object)) {\n      this.serializeArray(object, sb);\n      return;\n    } else if (\n        object instanceof String || object instanceof Number ||\n        object instanceof Boolean) {\n      object = object.valueOf();\n      // Fall through to switch below.\n    } else {\n      this.serializeObject_(/** @type {!Object} */ (object), sb);\n      return;\n    }\n  }\n\n  switch (typeof object) {\n    case 'string':\n      this.serializeString_(object, sb);\n      break;\n    case 'number':\n      this.serializeNumber_(object, sb);\n      break;\n    case 'boolean':\n      sb.push(String(object));\n      break;\n    case 'function':\n      sb.push('null');\n      break;\n    default:\n      throw new Error('Unknown type: ' + typeof object);\n  }\n};\n\n\n/**\n * Character mappings used internally for goog.string.quote\n * @private\n * @type {!Object}\n */\ngoog.json.Serializer.charToJsonCharCache_ = {\n  '\\\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  '/': '\\\\/',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n\n  '\\x0B': '\\\\u000b'  // '\\v' is not supported in JScript\n};\n\n\n/**\n * Regular expression used to match characters that need to be replaced.\n * The S60 browser has a bug where unicode characters are not matched by\n * regular expressions. The condition below detects such behaviour and\n * adjusts the regular expression accordingly.\n * @private\n * @type {!RegExp}\n */\ngoog.json.Serializer.charsToReplace_ = /\\uffff/.test('\\uffff') ?\n    /[\\\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g :\n    /[\\\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\n\n\n/**\n * Serializes a string to a JSON string\n * @private\n * @param {string} s The string to serialize.\n * @param {Array<string>} sb Array used as a string builder.\n */\ngoog.json.Serializer.prototype.serializeString_ = function(s, sb) {\n  // The official JSON implementation does not work with international\n  // characters.\n  sb.push('\"', s.replace(goog.json.Serializer.charsToReplace_, function(c) {\n    // caching the result improves performance by a factor 2-3\n    var rv = goog.json.Serializer.charToJsonCharCache_[c];\n    if (!rv) {\n      rv = '\\\\u' + (c.charCodeAt(0) | 0x10000).toString(16).substr(1);\n      goog.json.Serializer.charToJsonCharCache_[c] = rv;\n    }\n    return rv;\n  }), '\"');\n};\n\n\n/**\n * Serializes a number to a JSON string\n * @private\n * @param {number} n The number to serialize.\n * @param {Array<string>} sb Array used as a string builder.\n */\ngoog.json.Serializer.prototype.serializeNumber_ = function(n, sb) {\n  sb.push(isFinite(n) && !isNaN(n) ? String(n) : 'null');\n};\n\n\n/**\n * Serializes an array to a JSON string\n * @param {Array<string>} arr The array to serialize.\n * @param {Array<string>} sb Array used as a string builder.\n * @protected\n */\ngoog.json.Serializer.prototype.serializeArray = function(arr, sb) {\n  var l = arr.length;\n  sb.push('[');\n  var sep = '';\n  for (var i = 0; i < l; i++) {\n    sb.push(sep);\n\n    var value = arr[i];\n    this.serializeInternal(\n        this.replacer_ ? this.replacer_.call(arr, String(i), value) : value,\n        sb);\n\n    sep = ',';\n  }\n  sb.push(']');\n};\n\n\n/**\n * Serializes an object to a JSON string\n * @private\n * @param {!Object} obj The object to serialize.\n * @param {Array<string>} sb Array used as a string builder.\n */\ngoog.json.Serializer.prototype.serializeObject_ = function(obj, sb) {\n  sb.push('{');\n  var sep = '';\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var value = obj[key];\n      // Skip functions.\n      if (typeof value != 'function') {\n        sb.push(sep);\n        this.serializeString_(key, sb);\n        sb.push(':');\n\n        this.serializeInternal(\n            this.replacer_ ? this.replacer_.call(obj, key, value) : value, sb);\n\n        sep = ',';\n      }\n    }\n  }\n  sb.push('}');\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines utility and helper functions.\n */\n\ngoog.provide('fireauth.util');\n\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\ngoog.require('goog.Uri');\ngoog.require('goog.dom');\ngoog.require('goog.events');\ngoog.require('goog.events.EventType');\ngoog.require('goog.html.SafeUrl');\ngoog.require('goog.json');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.userAgent');\ngoog.require('goog.window');\n\n\n/** @suppress {duplicate} Suppress variable 'angular' first declared. */\nvar angular;\n\n/**\n * Checks whether the user agent is IE11.\n * @return {boolean} True if it is IE11.\n */\nfireauth.util.isIe11 = function() {\n  return goog.userAgent.IE &&\n      !!goog.userAgent.DOCUMENT_MODE &&\n      goog.userAgent.DOCUMENT_MODE == 11;\n};\n\n\n/**\n * Checks whether the user agent is IE10.\n * @return {boolean} True if it is IE10.\n */\nfireauth.util.isIe10 = function() {\n  return goog.userAgent.IE &&\n      !!goog.userAgent.DOCUMENT_MODE &&\n      goog.userAgent.DOCUMENT_MODE == 10;\n};\n\n\n/**\n * Checks whether the user agent is Edge.\n * @param {string} userAgent The browser user agent string.\n * @return {boolean} True if it is Edge.\n */\nfireauth.util.isEdge = function(userAgent) {\n  return /Edge\\/\\d+/.test(userAgent);\n};\n\n\n/**\n * @param {?string=} opt_userAgent The navigator user agent.\n * @return {boolean} Whether local storage is not synchronized between an iframe\n *     and a popup of the same domain.\n */\nfireauth.util.isLocalStorageNotSynchronized = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  return fireauth.util.isIe11() || fireauth.util.isEdge(ua);\n};\n\n\n/** @return {string} The current URL. */\nfireauth.util.getCurrentUrl = function() {\n  return (goog.global['window'] && goog.global['window']['location']['href']) ||\n      // Check for worker environments.\n      (self && self['location'] && self['location']['href']) || '';\n};\n\n\n/**\n * @param {string} requestUri The request URI to send in verifyAssertion\n *     request.\n * @return {string} The sanitized URI, in this case it undoes the hashbang\n *     angularJs routing changes to request URI.\n */\nfireauth.util.sanitizeRequestUri = function(requestUri) {\n  // If AngularJS is included.\n  if (typeof angular != 'undefined') {\n    // Remove hashbang modifications from URL.\n    requestUri = requestUri.replace('#/', '#').replace('#!/', '#');\n  }\n  return requestUri;\n};\n\n\n/**\n * @param {?string} url The target URL. When !url, redirects to a blank page.\n * @param {!Window=} opt_window The optional window to redirect to target URL.\n * @param {boolean=} opt_bypassCheck Whether to bypass check. Used for custom\n *     scheme redirects.\n */\nfireauth.util.goTo = function(url, opt_window, opt_bypassCheck) {\n  var win = opt_window || goog.global['window'];\n  // No URL, redirect to blank page.\n  var finalUrl = 'about:blank';\n  // Popping up a window and then assigning its URL seems to cause some weird\n  // error. Fixed by setting win.location.href for now in IE browsers.\n  // Bug was detected in Edge and IE9.\n  if (url && !opt_bypassCheck) {\n    // We cannot use goog.dom.safe.setLocationHref since it tries to read\n    // popup.location from a different origin, which is an error in IE.\n    // (In Chrome, popup.location is just an empty Location object)\n    finalUrl = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(url));\n  }\n  win.location.href = finalUrl;\n};\n\n\n/**\n * @param {string} url The target URL.\n * @param {!Window=} opt_window The optional window to replace with target URL.\n * @param {boolean=} opt_bypassCheck Whether to bypass check. Used for custom\n *     scheme redirects.\n */\nfireauth.util.replaceCurrentUrl = function(url, opt_window, opt_bypassCheck) {\n  var win = opt_window || goog.global['window'];\n  if (!opt_bypassCheck) {\n    win.location.replace(\n        goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(url)));\n  } else {\n    win.location.replace(url);\n  }\n};\n\n\n/**\n * Deep comparison of two objects.\n * @param {!Object} a The first object.\n * @param {!Object} b The second object.\n * @return {!Array<string>} The list of keys that are different between both\n *     objects provided.\n */\nfireauth.util.getKeyDiff = function(a, b) {\n  var diff = [];\n  for (var k in a) {\n    if (!(k in b)) {\n      diff.push(k);\n    } else if (typeof a[k] != typeof b[k]) {\n      diff.push(k);\n    } else if (typeof a[k] == 'object' && a[k] != null && b[k] != null) {\n      if (fireauth.util.getKeyDiff(\n          a[k], b[k]).length > 0) {\n        diff.push(k);\n      }\n    } else if (a[k] !== b[k]) {\n      diff.push(k);\n    }\n  }\n  for (var k in b) {\n    if (!(k in a)) {\n      diff.push(k);\n    }\n  }\n  return diff;\n};\n\n\n/**\n * @param {?string=} opt_userAgent The navigator user agent.\n * @return {?number} The Chrome version, null if the user agent is not Chrome.\n */\nfireauth.util.getChromeVersion = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  var browserName = fireauth.util.getBrowserName(ua);\n  // Confirm current browser is Chrome.\n  if (browserName != fireauth.util.BrowserName.CHROME) {\n    return null;\n  }\n  var matches = ua.match(/\\sChrome\\/(\\d+)/i);\n  if (matches && matches.length == 2) {\n    return parseInt(matches[1], 10);\n  }\n  return null;\n};\n\n\n/**\n * Detects CORS support.\n * @param {?string=} opt_userAgent The navigator user agent.\n * @return {boolean} True if the browser supports CORS.\n */\nfireauth.util.supportsCors = function(opt_userAgent) {\n  // Chrome 7 has CORS issues, pick 30 as upper limit.\n  var chromeVersion = fireauth.util.getChromeVersion(opt_userAgent);\n  if (chromeVersion && chromeVersion < 30) {\n    return false;\n  }\n  // Among all other supported browsers, only IE8 and IE9 don't support CORS.\n  return !goog.userAgent.IE || // Not IE.\n      !goog.userAgent.DOCUMENT_MODE || // No document mode == IE Edge.\n      goog.userAgent.DOCUMENT_MODE > 9;\n};\n\n\n/**\n * Detects whether browser is running on a mobile device.\n * @param {?string=} opt_userAgent The navigator user agent.\n * @return {boolean} True if the browser is running on a mobile device.\n */\nfireauth.util.isMobileBrowser = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  var uaLower = ua.toLowerCase();\n  // TODO: implement getBrowserName equivalent for OS.\n  if (uaLower.match(/android/) ||\n      uaLower.match(/webos/) ||\n      uaLower.match(/iphone|ipad|ipod/) ||\n      uaLower.match(/blackberry/) ||\n      uaLower.match(/windows phone/) ||\n      uaLower.match(/iemobile/)) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Closes the provided window.\n * @param {?Window=} opt_window The optional window to close. The current window\n *     is used if none is provided.\n */\nfireauth.util.closeWindow = function(opt_window) {\n  var win = opt_window || goog.global['window'];\n  // In some browsers, in certain cases after the window closes, as seen in\n  // Samsung Galaxy S3 Android 4.4.2 stock browser, the win object here is an\n  // empty object {}. Try to catch the failure and ignore it.\n  try {\n    win.close();\n  } catch(e) {}\n};\n\n\n/**\n * Opens a popup window.\n * @param {?string=} opt_url initial URL of the popup window\n * @param {string=} opt_name title of the popup\n * @param {?number=} opt_width width of the popup\n * @param {?number=} opt_height height of the popup\n * @return {?Window} Returns the window object that was opened. This returns\n *                   null if a popup blocker prevented the window from being\n *                   opened.\n */\nfireauth.util.popup = function(opt_url, opt_name, opt_width, opt_height) {\n  var width = opt_width || 500;\n  var height = opt_height || 600;\n  var top = (window.screen.availHeight - height) / 2;\n  var left = (window.screen.availWidth - width) / 2;\n  var options = {\n    'width': width,\n    'height': height,\n    'top': top > 0 ? top : 0,\n    'left': left > 0 ? left : 0,\n    'location': true,\n    'resizable': true,\n    'statusbar': true,\n    'toolbar': false\n  };\n  // Chrome iOS 7 and 8 is returning an undefined popup win when target is\n  // specified, even though the popup is not necessarily blocked.\n  var ua = fireauth.util.getUserAgentString().toLowerCase();\n  if (opt_name) {\n    options['target'] = opt_name;\n    // This will force a new window on each call, achieving the same effect as\n    // passing a random name on each call.\n    if (goog.string.contains(ua, 'crios/')) {\n      options['target'] = '_blank';\n    }\n  }\n  var browserName = fireauth.util.getBrowserName(\n      fireauth.util.getUserAgentString());\n  if (browserName == fireauth.util.BrowserName.FIREFOX) {\n    // Firefox complains when invalid URLs are popped out. Hacky way to bypass.\n    opt_url = opt_url || 'http://localhost';\n    // Firefox disables by default scrolling on popup windows, which can create\n    // issues when the user has many Google accounts, for instance.\n    options['scrollbars'] = true;\n  }\n  // about:blank getting sanitized causing browsers like IE/Edge to display\n  // brief error message before redirecting to handler.\n  var newWin = goog.window.open(opt_url || '', options);\n  if (newWin) {\n    // Flaky on IE edge, encapsulate with a try and catch.\n    try {\n      newWin.focus();\n    } catch (e) {}\n  }\n  return newWin;\n};\n\n\n/**\n * The default value for the popup wait cycle in ms.\n * @const {number}\n * @private\n */\nfireauth.util.POPUP_WAIT_CYCLE_MS_ = 2000;\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the popup requires a delay before closing itself.\n */\nfireauth.util.requiresPopupDelay = function(opt_userAgent) {\n  // TODO: remove this hack when CriOS behavior is fixed in iOS.\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  // Was observed in iOS 10.2 Chrome version 55.0.2883.79.\n  // Apply to Chrome 55+ iOS 10+ to ensure future Chrome versions or iOS 10\n  // minor updates do not suddenly resurface this bug. Revisit this check on\n  // next CriOS update.\n  var matches = ua.match(/OS (\\d+)_.*CriOS\\/(\\d+)\\./i);\n  if (matches && matches.length > 2) {\n    // iOS 10+ && chrome 55+.\n    return parseInt(matches[1], 10) >= 10 && parseInt(matches[2], 10) >= 55;\n  }\n  return false;\n};\n\n\n/**\n * @param {?Window} win The popup window to check.\n * @param {number=} opt_stepDuration The duration of each wait cycle before\n *     checking that window is closed.\n * @return {!goog.Promise<undefined>} The promise to resolve when window is\n *     closed.\n */\nfireauth.util.onPopupClose = function(win, opt_stepDuration) {\n  var stepDuration = opt_stepDuration || fireauth.util.POPUP_WAIT_CYCLE_MS_;\n  return new goog.Promise(function(resolve, reject) {\n    // Function to repeat each stepDuration.\n    var repeat = function() {\n      goog.Timer.promise(stepDuration).then(function() {\n        // After wait, check if window is closed.\n        if (!win || win.closed) {\n          // If so, resolve.\n          resolve();\n        } else {\n          // Call repeat again.\n          return repeat();\n        }\n      });\n    };\n    return repeat();\n  });\n};\n\n\n/**\n * @param {!Array<string>} authorizedDomains List of authorized domains.\n * @param {string} url The URL to check.\n * @return {boolean} Whether the passed domain is an authorized one.\n */\nfireauth.util.isAuthorizedDomain = function(authorizedDomains, url) {\n  var uri = goog.Uri.parse(url);\n  var scheme = uri.getScheme();\n  var domain = uri.getDomain();\n  for (var i = 0; i < authorizedDomains.length; i++) {\n    // Currently this corresponds to: domain.com = *://*.domain.com:* or\n    // exact domain match.\n    // In the case of Chrome extensions, the authorizedDomain will be formatted\n    // as 'chrome-extension://abcdefghijklmnopqrstuvwxyz123456'.\n    // The URL to check must have a chrome extension scheme and the domain\n    // must be an exact match domain == 'abcdefghijklmnopqrstuvwxyz123456'.\n    if (fireauth.util.matchDomain(authorizedDomains[i], domain, scheme)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Represents the dimensions of an entity (width and height).\n * @typedef {{\n *   width: number,\n *   height: number\n * }}\n */\nfireauth.util.Dimensions;\n\n\n/**\n * @param {?Window=} opt_window The optional window whose dimensions are to be\n *     returned. The current window is used if not found.\n * @return {?fireauth.util.Dimensions} The requested window dimensions if\n *     available.\n */\nfireauth.util.getWindowDimensions = function(opt_window) {\n  var win = opt_window || goog.global['window'];\n  if (win && win['innerWidth'] && win['innerHeight']) {\n    return {\n      'width': parseFloat(win['innerWidth']),\n      'height': parseFloat(win['innerHeight'])\n    };\n  }\n  return null;\n};\n\n\n/**\n * RegExp to detect if the domain given is an IP address. This is only used\n * for validating http and https schemes.\n *\n * It does not strictly validate if the IP is a real IP address, but as the\n * matchDomain method tests against a set of valid domains (extracted from the\n * window's current URL), it is sufficient.\n *\n * @const {!RegExp}\n * @private\n */\nfireauth.util.IP_ADDRESS_REGEXP_ = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n\n\n/**\n * @param {string} domainPattern The domain pattern to match.\n * @param {string} domain The domain to check. It is assumed that it is a valid\n *     domain, not a user provided one.\n * @param {string} scheme The scheme of the domain to check.\n * @return {boolean} Whether the provided domain matches the domain pattern.\n */\nfireauth.util.matchDomain = function(domainPattern, domain, scheme) {\n  // Chrome extension matching.\n  if (domainPattern.indexOf('chrome-extension://') == 0) {\n    var chromeExtUri = goog.Uri.parse(domainPattern);\n    // Domain must match and the current scheme must be a Chrome extension.\n    return chromeExtUri.getDomain() == domain && scheme == 'chrome-extension';\n  } else if (scheme != 'http' && scheme != 'https') {\n    // Any other scheme that is not http or https cannot be whitelisted.\n    return false;\n  } else {\n    // domainPattern must not contain a scheme and the current scheme must be\n    // either http or https.\n    // Check if authorized domain pattern is an IP address.\n    if (fireauth.util.IP_ADDRESS_REGEXP_.test(domainPattern)) {\n      // The domain has to be exactly equal to the pattern, as an IP domain will\n      // only contain the IP, no extra character.\n      return domain == domainPattern;\n    }\n    // Dots in pattern should be escaped.\n    var escapedDomainPattern = domainPattern.split('.').join('\\\\.');\n    // Non ip address domains.\n    // domain.com = *.domain.com OR domain.com\n    var re = new RegExp(\n        '^(.+\\\\.' + escapedDomainPattern + '|' +\n        escapedDomainPattern + ')$', 'i');\n    return re.test(domain);\n  }\n};\n\n\n/**\n * RegExp to detect if the email address given is valid.\n * @const {!RegExp}\n * @private\n */\nfireauth.util.EMAIL_ADDRESS_REGEXP_ = /^[^@]+@[^@]+$/;\n\n\n/**\n * Determines if it is a valid email address.\n * @param {*} email The email address.\n * @return {boolean} Whether the email address is valid.\n */\nfireauth.util.isValidEmailAddress = function(email) {\n  return goog.isString(email) &&\n      fireauth.util.EMAIL_ADDRESS_REGEXP_.test(email);\n};\n\n\n/**\n * @return {!goog.Promise<void>} A promise that resolves when DOM is ready.\n */\nfireauth.util.onDomReady = function() {\n  var resolver = null;\n  return new goog.Promise(function(resolve, reject) {\n    var doc = goog.global.document;\n    // If document already loaded, resolve immediately.\n    if (doc.readyState == 'complete') {\n      resolve();\n    } else {\n      // Document not ready, wait for load before resolving.\n      // Save resolver, so we can remove listener in case it was externally\n      // cancelled.\n      resolver = function() {\n        resolve();\n      };\n      goog.events.listenOnce(window, goog.events.EventType.LOAD, resolver);\n    }\n  }).thenCatch(function(error) {\n    // In case this promise was cancelled, make sure it unlistens to load.\n    goog.events.unlisten(window, goog.events.EventType.LOAD, resolver);\n    throw error;\n  });\n};\n\n\n/** @return {boolean} Whether environment supports DOM. */\nfireauth.util.isDOMSupported = function() {\n  return !!goog.global.document;\n};\n\n\n/**\n * The default ondeviceready Cordova timeout in ms.\n * @const {number}\n * @private\n */\nfireauth.util.CORDOVA_ONDEVICEREADY_TIMEOUT_MS_ = 1000;\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @param {number=} opt_timeout The optional timeout in ms for deviceready\n *     event to resolve.\n * @return {!goog.Promise} A promise that resolves if the current environment is\n *     a Cordova environment.\n */\nfireauth.util.checkIfCordova = function(opt_userAgent, opt_timeout) {\n  // Errors generated are internal and should be converted if needed to\n  // developer facing Firebase errors.\n  // Only supported in Android/iOS environment.\n  if (fireauth.util.isAndroidOrIosFileEnvironment(opt_userAgent)) {\n    return fireauth.util.onDomReady().then(function() {\n      return new goog.Promise(function(resolve, reject) {\n        var doc = goog.global.document;\n        var timeoutId = setTimeout(function() {\n          reject(new Error('Cordova framework is not ready.'));\n        }, opt_timeout || fireauth.util.CORDOVA_ONDEVICEREADY_TIMEOUT_MS_);\n        // This should resolve immediately after DOM ready.\n        doc.addEventListener('deviceready', function() {\n          clearTimeout(timeoutId);\n          resolve();\n        }, false);\n      });\n    });\n  }\n  return goog.Promise.reject(\n      new Error('Cordova must run in an Android or iOS file scheme.'));\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the app is rendered in a mobile iOS or Android file\n *     environment.\n */\nfireauth.util.isAndroidOrIosFileEnvironment = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  return !!(fireauth.util.getCurrentScheme() === 'file:' &&\n            ua.toLowerCase().match(/iphone|ipad|ipod|android/));\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the app is rendered in a mobile iOS 7 or 8 browser.\n */\nfireauth.util.isIOS7Or8 = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  return !!(ua.match(/(iPad|iPhone|iPod).*OS 7_\\d/i) ||\n            ua.match(/(iPad|iPhone|iPod).*OS 8_\\d/i));\n};\n\n\n/**\n * @return {boolean} Whether browser is Safari or an iOS browser and page is\n *     embedded in an iframe. Local Storage does not synchronize with an iframe\n *     embedded on a page in a different domain but will still trigger storage\n *     event with storage changes.\n */\nfireauth.util.isSafariLocalStorageNotSynced = function() {\n  var ua = fireauth.util.getUserAgentString();\n  // Safari or iOS browser and embedded in an iframe.\n  if (!fireauth.util.iframeCanSyncWebStorage(ua) && fireauth.util.isIframe()) {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * @param {?Window=} opt_win Optional window to check whether it is an iframe.\n *     If not provided, the current window is checked.\n * @return {boolean} Whether web page is running in an iframe.\n */\nfireauth.util.isIframe = function(opt_win) {\n  var win = opt_win || goog.global['window'];\n  try {\n    // Check that the current window is not the top window.\n    // If so, return true.\n    return !!(win && win != win['top']);\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * @param {?Window=} opt_win Optional window to check whether it has an opener\n *     that is an iframe.\n * @return {boolean} Whether the web page was opened from an iframe.\n */\nfireauth.util.isOpenerAnIframe = function(opt_win) {\n  var win = opt_win || goog.global['window'];\n  try {\n    // Get the opener if available.\n    var opener = win && win['opener'];\n    // Check if the opener is an iframe. If so, return true.\n    // Confirm opener is available, otherwise the current window is checked\n    // instead.\n    return !!(opener && fireauth.util.isIframe(opener));\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * @param {?Object=} global The optional global scope.\n * @return {boolean} Whether current environment is a worker.\n */\nfireauth.util.isWorker = function(global) {\n  var scope = global || goog.global;\n  // WorkerGlobalScope only defined in worker environment.\n  return typeof scope['WorkerGlobalScope'] !== 'undefined' &&\n         typeof scope['importScripts'] === 'function';\n};\n\n\n/**\n * @param {?Object=} opt_global The optional global scope.\n * @return {boolean} Whether current environment supports fetch API and other\n *     APIs it depends on.\n */\nfireauth.util.isFetchSupported = function(opt_global) {\n  // Required by fetch API calls.\n  var scope = opt_global || goog.global;\n  return typeof scope['fetch'] !== 'undefined' &&\n         typeof scope['Headers'] !== 'undefined' &&\n         typeof scope['Request'] !== 'undefined';\n};\n\n\n/**\n * Enum for the runtime environment.\n * @enum {string}\n */\nfireauth.util.Env = {\n  BROWSER: 'Browser',\n  NODE: 'Node',\n  REACT_NATIVE: 'ReactNative',\n  WORKER: 'Worker'\n};\n\n\n/**\n * @return {!fireauth.util.Env} The current runtime environment.\n */\nfireauth.util.getEnvironment = function() {\n  if (firebase.INTERNAL.hasOwnProperty('reactNative')) {\n    return fireauth.util.Env.REACT_NATIVE;\n  } else if (firebase.INTERNAL.hasOwnProperty('node')) {\n    // browserify seems to keep the process property in some cases even though\n    // the library is browser only. Use this check instead to reliably detect\n    // a Node.js environment.\n    return fireauth.util.Env.NODE;\n  } else if (fireauth.util.isWorker()) {\n    // Worker environment.\n    return fireauth.util.Env.WORKER;\n  }\n  // The default is a browser environment.\n  return fireauth.util.Env.BROWSER;\n};\n\n\n/**\n * @return {boolean} Whether the environment is a native environment, where\n *     CORS checks do not apply.\n */\nfireauth.util.isNativeEnvironment = function() {\n  var environment = fireauth.util.getEnvironment();\n  return environment === fireauth.util.Env.REACT_NATIVE ||\n      environment === fireauth.util.Env.NODE;\n};\n\n\n/**\n * The separator for storage keys to concatenate App name and API key.\n * @const {string}\n * @private\n */\nfireauth.util.STORAGE_KEY_SEPARATOR_ = ':';\n\n\n/**\n * @param {string} apiKey The API Key of the app.\n * @param {string} appName The App name.\n * @return {string} The key used for identifying the app owner of the user.\n */\nfireauth.util.createStorageKey = function(apiKey, appName) {\n  return apiKey + fireauth.util.STORAGE_KEY_SEPARATOR_ + appName;\n};\n\n\n/** @return {string} a long random character string. */\nfireauth.util.generateRandomString = function() {\n  return Math.floor(Math.random() * 1000000000).toString();\n};\n\n\n/**\n * Generates a random alpha numeric string.\n * @param {number} numOfChars The number of random characters within the string.\n * @return {string} A string with a specific number of random characters.\n */\nfireauth.util.generateRandomAlphaNumericString = function(numOfChars) {\n  var chars = [];\n  var allowedChars =\n      '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  while (numOfChars > 0) {\n    chars.push(\n        allowedChars.charAt(\n            Math.floor(Math.random() * allowedChars.length)));\n    numOfChars--;\n  }\n  return chars.join('');\n};\n\n\n/**\n * Enums for Browser name.\n * @enum {string}\n */\nfireauth.util.BrowserName = {\n  ANDROID: 'Android',\n  BLACKBERRY: 'Blackberry',\n  EDGE: 'Edge',\n  FIREFOX: 'Firefox',\n  IE: 'IE',\n  IEMOBILE: 'IEMobile',\n  OPERA: 'Opera',\n  OTHER: 'Other',\n  CHROME: 'Chrome',\n  SAFARI: 'Safari',\n  SILK: 'Silk',\n  WEBOS: 'Webos'\n};\n\n\n/**\n * @param {string} userAgent The navigator user agent string.\n * @return {string} The browser name, eg Safari, Firefox, etc.\n */\nfireauth.util.getBrowserName = function(userAgent) {\n  var ua = userAgent.toLowerCase();\n  if (goog.string.contains(ua, 'opera/') ||\n      goog.string.contains(ua, 'opr/') ||\n      goog.string.contains(ua, 'opios/')) {\n    return fireauth.util.BrowserName.OPERA;\n  } else if (goog.string.contains(ua, 'iemobile')) {\n    // Windows phone IEMobile browser.\n    return fireauth.util.BrowserName.IEMOBILE;\n  } else if (goog.string.contains(ua, 'msie') ||\n             goog.string.contains(ua, 'trident/')) {\n    return fireauth.util.BrowserName.IE;\n  } else if (goog.string.contains(ua, 'edge/')) {\n    return fireauth.util.BrowserName.EDGE;\n  } else if (goog.string.contains(ua, 'firefox/')) {\n    return fireauth.util.BrowserName.FIREFOX;\n  } else if (goog.string.contains(ua, 'silk/')) {\n    return fireauth.util.BrowserName.SILK;\n  } else if (goog.string.contains(ua, 'blackberry')) {\n    // Blackberry browser.\n    return fireauth.util.BrowserName.BLACKBERRY;\n  } else if (goog.string.contains(ua, 'webos')) {\n    // WebOS default browser.\n    return fireauth.util.BrowserName.WEBOS;\n  } else if (goog.string.contains(ua, 'safari/') &&\n             !goog.string.contains(ua, 'chrome/') &&\n             !goog.string.contains(ua, 'crios/') &&\n             !goog.string.contains(ua, 'android')) {\n    return fireauth.util.BrowserName.SAFARI;\n  } else if ((goog.string.contains(ua, 'chrome/') ||\n              goog.string.contains(ua, 'crios/')) &&\n             !goog.string.contains(ua, 'edge/')) {\n    return fireauth.util.BrowserName.CHROME;\n  } else if (goog.string.contains(ua, 'android')) {\n    // Android stock browser.\n    return fireauth.util.BrowserName.ANDROID;\n  } else {\n    // Most modern browsers have name/version at end of user agent string.\n    var re = new RegExp('([a-zA-Z\\\\d\\\\.]+)\\/[a-zA-Z\\\\d\\\\.]*$');\n    var matches = userAgent.match(re);\n    if (matches && matches.length == 2) {\n      return matches[1];\n    }\n  }\n  return fireauth.util.BrowserName.OTHER;\n};\n\n\n/**\n * Enums for client implementation name.\n * @enum {string}\n */\nfireauth.util.ClientImplementation = {\n  JSCORE: 'JsCore',\n  OAUTH_HANDLER: 'Handler',\n  OAUTH_IFRAME: 'Iframe'\n};\n\n\n/**\n * Enums for the framework ID to be logged in RPC header.\n * Future frameworks to possibly add: angularfire, polymerfire, reactfire, etc.\n * @enum {string}.\n */\nfireauth.util.Framework = {\n  // No other framework used.\n  DEFAULT: 'FirebaseCore-web',\n  // Firebase Auth used with FirebaseUI-web.\n  FIREBASEUI: 'FirebaseUI-web'\n};\n\n\n/**\n * @param {!Array<string>} providedFrameworks List of framework ID strings.\n * @return {!Array<!fireauth.util.Framework>} List of supported framework IDs\n *     with no duplicates.\n */\nfireauth.util.getFrameworkIds = function(providedFrameworks) {\n  var frameworkVersion = [];\n  var frameworkSet = {};\n  for (var key in fireauth.util.Framework) {\n    frameworkSet[fireauth.util.Framework[key]] = true;\n  }\n  for (var i = 0; i < providedFrameworks.length; i++) {\n    if (typeof frameworkSet[providedFrameworks[i]] !== 'undefined') {\n      // Delete it from set to prevent duplications.\n      delete frameworkSet[providedFrameworks[i]];\n      frameworkVersion.push(providedFrameworks[i]);\n    }\n  }\n  // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n  // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n  frameworkVersion.sort();\n  return frameworkVersion;\n};\n\n\n/**\n * @param {!fireauth.util.ClientImplementation} clientImplementation The client\n *     implementation.\n * @param {string} clientVersion The client version.\n * @param {?Array<string>=} opt_frameworkVersion The framework version.\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {string} The full client SDK version.\n */\nfireauth.util.getClientVersion = function(clientImplementation, clientVersion,\n    opt_frameworkVersion, opt_userAgent) {\n  var frameworkVersion = fireauth.util.getFrameworkIds(\n      opt_frameworkVersion || []);\n  if (!frameworkVersion.length) {\n    frameworkVersion = [fireauth.util.Framework.DEFAULT];\n  }\n  var environment = fireauth.util.getEnvironment();\n  var reportedEnvironment = '';\n  if (environment === fireauth.util.Env.BROWSER) {\n    // In a browser environment, report the browser name.\n    var userAgent = opt_userAgent || fireauth.util.getUserAgentString();\n    reportedEnvironment = fireauth.util.getBrowserName(userAgent);\n  } else if (environment === fireauth.util.Env.WORKER) {\n    // Technically a worker runs from a browser but we need to differentiate a\n    // worker from a browser.\n    // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n    var userAgent = opt_userAgent || fireauth.util.getUserAgentString();\n    reportedEnvironment = fireauth.util.getBrowserName(userAgent) + '-' +\n        environment;\n  } else {\n    // Otherwise, just report the environment name.\n    reportedEnvironment = environment;\n  }\n  // The format to be followed:\n  // ${browserName}/${clientImplementation}/${clientVersion}/${frameworkVersion}\n  // As multiple Firebase frameworks/libraries can be used, join their IDs with\n  // a comma.\n  return reportedEnvironment + '/' + clientImplementation +\n      '/' + clientVersion + '/' + frameworkVersion.join(',');\n};\n\n\n/**\n * @return {string} The user agent string reported by the environment, or the\n *     empty string if not available.\n */\nfireauth.util.getUserAgentString = function() {\n  return (goog.global['navigator'] && goog.global['navigator']['userAgent']) ||\n      '';\n};\n\n\n/**\n * @param {string} varStrName The variable string name.\n * @param {?Object=} opt_scope The optional scope where to look in. The default\n *     is window.\n * @return {*} The reference if found.\n */\nfireauth.util.getObjectRef = function(varStrName, opt_scope) {\n  var pieces = varStrName.split('.');\n  var last = opt_scope || goog.global;\n  for (var i = 0;\n       i < pieces.length && typeof last == 'object' && last != null;\n       i++) {\n    last = last[pieces[i]];\n  }\n  // Last hasn't reached the end yet, return undefined.\n  if (i != pieces.length) {\n    last = undefined;\n  }\n  return last;\n};\n\n\n/** @return {boolean} Whether web storage is supported. */\nfireauth.util.isWebStorageSupported = function() {\n  try {\n    var storage = goog.global['localStorage'];\n    var key = fireauth.util.generateEventId();\n    if (storage) {\n      // setItem will throw an exception if we cannot access WebStorage (e.g.,\n      // Safari in private mode).\n      storage['setItem'](key, '1');\n      storage['removeItem'](key);\n      // For browsers where iframe web storage does not synchronize with a popup\n      // of the same domain, indexedDB is used for persistent storage. These\n      // browsers include IE11 and Edge.\n      // Make sure it is supported (IE11 and Edge private mode does not support\n      // that).\n      if (fireauth.util.isLocalStorageNotSynchronized()) {\n        // In such browsers, if indexedDB is not supported, an iframe cannot be\n        // notified of the popup sign in result.\n        return !!goog.global['indexedDB'];\n      }\n      return true;\n    }\n  } catch (e) {\n    // localStorage is not available from a worker. Test availability of\n    // indexedDB.\n    return fireauth.util.isWorker() && !!goog.global['indexedDB'];\n  }\n  return false;\n};\n\n\n/**\n * This guards against leaking Cordova support before official launch.\n * This field will be removed or updated to return true when the new feature is\n * ready for launch.\n * @return {boolean} Whether Cordova OAuth support is enabled.\n */\nfireauth.util.isCordovaOAuthEnabled = function() {\n  return false;\n};\n\n\n/**\n * @return {boolean} Whether popup and redirect operations are supported in the\n *     current environment.\n */\nfireauth.util.isPopupRedirectSupported = function() {\n  // Popup and redirect are supported in an environment where the container\n  // origin can be securely whitelisted.\n  return (fireauth.util.isHttpOrHttps() ||\n          fireauth.util.isChromeExtension() ||\n          fireauth.util.isAndroidOrIosFileEnvironment()) &&\n         // React Native with remote debugging reports its location.protocol as\n         // http.\n         !fireauth.util.isNativeEnvironment() &&\n         // Local storage has to be supported for browser popup and redirect\n         // operations to work.\n         fireauth.util.isWebStorageSupported() &&\n         // DOM, popups and redirects are not supported within a worker.\n         !fireauth.util.isWorker();\n};\n\n\n/**\n * @return {boolean} Whether the current environment is http or https.\n */\nfireauth.util.isHttpOrHttps = function() {\n  return fireauth.util.getCurrentScheme() === 'http:' ||\n       fireauth.util.getCurrentScheme() === 'https:';\n};\n\n\n/** @return {?string} The current URL scheme. */\nfireauth.util.getCurrentScheme = function() {\n  return (goog.global['location'] && goog.global['location']['protocol']) ||\n      null;\n};\n\n\n/**\n * Checks whether the current page is a Chrome extension.\n * @return {boolean} Whether the current page is a Chrome extension.\n */\nfireauth.util.isChromeExtension = function() {\n  return fireauth.util.getCurrentScheme() === 'chrome-extension:';\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the current browser is running in an iOS\n *     environment.\n */\nfireauth.util.isIOS = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  return !!ua.toLowerCase().match(/iphone|ipad|ipod/);\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the current browser is running in an Android\n *     environment.\n */\nfireauth.util.isAndroid = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  return !!ua.toLowerCase().match(/android/);\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether the opener of a popup cannot communicate with the\n *     popup while it is in the foreground.\n */\nfireauth.util.runsInBackground = function(opt_userAgent) {\n  // TODO: split this check into 2, one check that opener can access\n  // popup, another check that storage synchronizes between popup and opener.\n  // Popup events fail in iOS version 7 (lowest version we currently support)\n  // browsers. When the popup is triggered, the opener is unable to redirect\n  // the popup url, close the popup and in some cases will miss the storage\n  // event triggered when localStorage is changed.\n  // Extend this to all mobile devices. This behavior is more likely to work\n  // cross mobile platforms.\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  if (fireauth.util.isMobileBrowser(ua)) {\n    return false;\n  } else if (fireauth.util.getBrowserName(ua) ==\n             fireauth.util.BrowserName.FIREFOX) {\n    // Latest version of Firefox 47.0 does not allow you to access properties on\n    // the popup window from the opener.\n    return false;\n  }\n  return true;\n};\n\n\n/**\n * Stringifies an object, retuning null if the object is not defined.\n * @param {*} obj The raw object.\n * @return {?string} The JSON-serialized object.\n */\nfireauth.util.stringifyJSON = function(obj) {\n  if (typeof obj === 'undefined') {\n    return null;\n  }\n  return goog.json.serialize(obj);\n};\n\n\n/**\n * @param {!Object} obj The original object.\n * @return {!Object} A copy of the original object with all entries that are\n *     null or undefined removed.\n */\nfireauth.util.copyWithoutNullsOrUndefined = function(obj) {\n  // The processed copy to return.\n  var trimmedObj = {};\n  // Remove all empty fields from data, allow zero and false booleans.\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) &&\n        obj[key] !== null &&\n        obj[key] !== undefined) {\n      trimmedObj[key] = obj[key];\n    }\n  }\n  return trimmedObj;\n};\n\n\n/**\n * Removes all key/pairs with the specified keys from the given object.\n * @param {!Object} obj The object to process.\n * @param {!Array<string>} keys The list of keys to remove.\n * @return {!Object} The object with the keys removed.\n */\nfireauth.util.removeEntriesWithKeys = function(obj, keys) {\n  // Clone object.\n  var copy = goog.object.clone(obj);\n  // Traverse keys.\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    // If key found in object, remove it.\n    if (key in copy) {\n      delete copy[key];\n    }\n  }\n  // Returned filtered copy.\n  return copy;\n};\n\n\n/**\n * Parses a JSON string, returning undefined if null is passed.\n * @param {?string} json The JSON-serialized object.\n * @return {*} The raw object.\n */\nfireauth.util.parseJSON = function(json) {\n  if (goog.isNull(json)) {\n    return undefined;\n  }\n\n  // Do not use goog.json.parse since it uses eval underneath to support old\n  // browsers that do not provide JSON.parse. The recommended Content Security\n  // Policy does not allow unsafe-eval in some environments like Chrome\n  // extensions. Usage of eval is not recommend in Chrome in general.\n  // Use native parsing instead via JSON.parse. This is provided in our list\n  // of supported browsers.\n  return JSON.parse(json);\n};\n\n\n/**\n * @param {?string=} opt_prefix An optional prefix string to prepend to ID.\n * @return {string} The generated event ID used to identify a generic event.\n */\nfireauth.util.generateEventId = function(opt_prefix) {\n  return opt_prefix ? opt_prefix : '' +\n      Math.floor(Math.random() * 1000000000).toString();\n};\n\n\n/**\n * @param {?string=} opt_userAgent The optional user agent.\n * @return {boolean} Whether an embedded iframe can sync to web storage changes.\n *     Web storage sync fails in Safari desktop browsers and iOS mobile\n *     browsers.\n */\nfireauth.util.iframeCanSyncWebStorage = function(opt_userAgent) {\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  if (fireauth.util.getBrowserName(ua) == fireauth.util.BrowserName.SAFARI ||\n      ua.toLowerCase().match(/iphone|ipad|ipod/)) {\n    return false;\n  }\n  return true;\n};\n\n\n/**\n * Reset unlaoded GApi modules. If gapi.load fails due to a network error,\n * it will stop working after a retrial. This is a hack to fix this issue.\n */\nfireauth.util.resetUnloadedGapiModules = function() {\n  // Clear last failed gapi.load state to force next gapi.load to first\n  // load the failed gapi.iframes module.\n  // Get gapix.beacon context.\n  var beacon = goog.global['___jsl'];\n  // Get current hint.\n  if (beacon && beacon['H']) {\n    // Get gapi hint.\n    for (var hint in beacon['H']) {\n      // Requested modules.\n      beacon['H'][hint]['r'] = beacon['H'][hint]['r'] || [];\n      // Loaded modules.\n      beacon['H'][hint]['L'] = beacon['H'][hint]['L'] || [];\n      // Set requested modules to a copy of the loaded modules.\n      beacon['H'][hint]['r'] = beacon['H'][hint]['L'].concat();\n      // Clear pending callbacks.\n      if (beacon['CP']) {\n        for (var i = 0; i < beacon['CP'].length; i++) {\n          // Remove all failed pending callbacks.\n          beacon['CP'][i] = null;\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * Returns whether the current device is a mobile device. Mobile browsers and\n * React-Native environments are considered mobile devices.\n * @param {?string=} opt_userAgent The optional navigator user agent.\n * @param {?fireauth.util.Env=} opt_env The optional environment.\n * @return {boolean} Whether the current device is a mobile device or not.\n */\nfireauth.util.isMobileDevice = function(opt_userAgent, opt_env) {\n  // Get user agent.\n  var ua = opt_userAgent || fireauth.util.getUserAgentString();\n  // Get environment.\n  var environment = opt_env || fireauth.util.getEnvironment();\n  return fireauth.util.isMobileBrowser(ua) ||\n      environment === fireauth.util.Env.REACT_NATIVE;\n};\n\n\n/**\n * @param {?Object=} opt_navigator The optional navigator object typically used\n *     for testing.\n * @return {boolean} Whether the app is currently online. If offline, false is\n *     returned. If this cannot be determined, true is returned.\n */\nfireauth.util.isOnline = function(opt_navigator) {\n  var navigator = opt_navigator || goog.global['navigator'];\n  if (navigator &&\n      typeof navigator['onLine'] === 'boolean' &&\n      // Apply only for traditional web apps and Chrome extensions.\n      // This is especially true for Cordova apps which have unreliable\n      // navigator.onLine behavior unless cordova-plugin-network-information is\n      // installed which overwrites the native navigator.onLine value and\n      // defines navigator.connection.\n      (fireauth.util.isHttpOrHttps() ||\n       fireauth.util.isChromeExtension() ||\n       typeof navigator['connection'] !== 'undefined')) {\n    return navigator['onLine'];\n  }\n  // If we can't determine the state, assume it is online.\n  return true;\n};\n\n\n/**\n * @param {?Object=} opt_navigator The object with navigator data, defaulting\n *     to window.navigator if unspecified.\n * @return {?string} The user's preferred language. Returns null if\n */\nfireauth.util.getUserLanguage = function(opt_navigator) {\n  var navigator = opt_navigator || goog.global['navigator'];\n  if (!navigator) {\n    return null;\n  }\n  return (\n      // Most reliable, but only supported in Chrome/Firefox.\n      navigator['languages'] && navigator['languages'][0] ||\n      // Supported in most browsers, but returns the language of the browser\n      // UI, not the language set in browser settings.\n      navigator['language'] ||\n      // IE <= 10.\n      navigator['userLanguage'] ||\n      // Couldn't determine language.\n      null\n  );\n};\n\n\n/**\n * A structure to help pick between a range of long and short delay durations\n * depending on the current environment. In general, the long delay is used for\n * mobile environments whereas short delays are used for desktop environments.\n * @param {number} shortDelay The short delay duration.\n * @param {number} longDelay The long delay duration.\n * @param {?string=} opt_userAgent The optional navigator user agent.\n * @param {?fireauth.util.Env=} opt_env The optional environment.\n * @constructor\n */\nfireauth.util.Delay = function(shortDelay, longDelay, opt_userAgent, opt_env) {\n  // Internal error when improperly initialized.\n  if (shortDelay > longDelay) {\n    throw new Error('Short delay should be less than long delay!');\n  }\n  /**\n   * @private @const {number} The short duration delay used for desktop\n   *     environments.\n   */\n  this.shortDelay_ = shortDelay;\n  /**\n   * @private @const {number} The long duration delay used for mobile\n   *     environments.\n   */\n  this.longDelay_ = longDelay;\n  /** @private @const {boolean} Whether the environment is a mobile one. */\n  this.isMobile_ = fireauth.util.isMobileDevice(opt_userAgent, opt_env);\n};\n\n\n/**\n * The default value for the offline delay timeout in ms.\n * @const {number}\n * @private\n */\nfireauth.util.Delay.OFFLINE_DELAY_MS_ = 5000;\n\n\n/**\n * @return {number} The delay that matches with the current environment.\n */\nfireauth.util.Delay.prototype.get = function() {\n  // navigator.onLine is unreliable in some cases.\n  // Failing hard in those cases may make it impossible to recover for end user.\n  // Waiting for the regular full duration when there is no network can result\n  // in a bad experience.\n  // Instead return a short timeout duration. If there is no network connection,\n  // the user would wait 5 seconds to detect that. If there is a connection\n  // (false alert case), the user still has the ability to try to send the\n  // request. If it fails (timeout too short), they can still retry.\n  if (!fireauth.util.isOnline()) {\n    // Pick the shorter timeout.\n    return Math.min(fireauth.util.Delay.OFFLINE_DELAY_MS_, this.shortDelay_);\n  }\n  // If running in a mobile environment, return the long delay, otherwise\n  // return the short delay.\n  // This could be improved in the future to dynamically change based on other\n  // variables instead of just reading the current environment.\n  return this.isMobile_ ? this.longDelay_ : this.shortDelay_;\n};\n\n\n/**\n * @return {boolean} Whether the app is visible in the foreground. This uses\n *     document.visibilityState. For browsers that do not support it, this is\n *     always true.\n */\nfireauth.util.isAppVisible = function() {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState\n  var doc = goog.global.document;\n  // Check if supported.\n  if (doc && typeof doc['visibilityState'] !== 'undefined') {\n    // Check if visible.\n    return doc['visibilityState'] == 'visible';\n  }\n  // API not supported in current browser, default to true.\n  return true;\n};\n\n\n/**\n * @return {!goog.Promise} A promise that resolves when the app is visible in\n *     the foreground.\n */\nfireauth.util.onAppVisible = function() {\n  var doc = goog.global.document;\n  // Visibility change listener reference.\n  var onVisibilityChange = null;\n  if (fireauth.util.isAppVisible() || !doc) {\n    // Visible or non browser environment.\n    return goog.Promise.resolve();\n  } else {\n    // Invisible and in browser environment.\n    return new goog.Promise(function(resolve, reject) {\n      // On visibility change listener.\n      onVisibilityChange = function(event) {\n        // App is visible.\n        if (fireauth.util.isAppVisible()) {\n          // Unregister event listener.\n          doc.removeEventListener(\n              'visibilitychange', onVisibilityChange, false);\n          // Resolve promise.\n          resolve();\n        }\n      };\n      // Listen to visibility change.\n      doc.addEventListener('visibilitychange', onVisibilityChange, false);\n    }).thenCatch(function(error) {\n      // In case this promise was cancelled, make sure it unlistens to\n      // visibilitychange event.\n      doc.removeEventListener('visibilitychange', onVisibilityChange, false);\n      // Rethrow the same error.\n      throw error;\n    });\n  }\n};\n\n\n/**\n * Logs a warning message to the console, if the console is available.\n * @param {string} message\n */\nfireauth.util.consoleWarn = function(message) {\n  if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n    console.warn(message);\n  }\n};\n\n\n/**\n * Parses a UTC time stamp string or number and returns the corresponding UTC\n * date string if valid. Otherwise, returns null.\n * @param {?string|number} utcTimestamp The UTC timestamp number or string.\n * @return {?string} The corresponding UTC date string. Null if invalid.\n */\nfireauth.util.utcTimestampToDateString = function(utcTimestamp) {\n  try {\n    // Convert to date object.\n    var date = new Date(parseInt(utcTimestamp, 10));\n    // Test date is valid.\n    if (!isNaN(date.getTime()) &&\n        // Confirm that utcTimestamp is numeric.\n        goog.string.isNumeric(utcTimestamp)) {\n      // Convert to UTC date string.\n      return date.toUTCString();\n    }\n  } catch (e) {\n    // Do nothing. null will be returned.\n  }\n  return null;\n};\n\n\n/** @return {boolean} Whether indexedDB is available. */\nfireauth.util.isIndexedDBAvailable = function() {\n  return !!goog.global['indexedDB'];\n};\n\n\n/** @return {boolean} Whether current mode is Auth handler or iframe. */\nfireauth.util.isAuthHandlerOrIframe = function() {\n  return !!(fireauth.util.getObjectRef('fireauth.oauthhelper', goog.global) ||\n            fireauth.util.getObjectRef('fireauth.iframe', goog.global));\n};\n\n\n/** @return {boolean} Whether indexedDB is used to persist storage. */\nfireauth.util.persistsStorageWithIndexedDB = function() {\n  // This will cover:\n  // IE11, Edge when indexedDB is available (this is unavailable in InPrivate\n  // mode). (SDK, OAuth handler and iframe)\n  // Any environment where indexedDB is available (SDK only).\n\n  // In a browser environment, when an iframe and a popup web storage are not\n  // synchronized, use the indexedDB fireauth.storage.Storage implementation.\n  return (fireauth.util.isLocalStorageNotSynchronized() ||\n          !fireauth.util.isAuthHandlerOrIframe()) &&\n         fireauth.util.isIndexedDBAvailable();\n};\n\n\n/** Sets the no-referrer meta tag in the document head if applicable. */\nfireauth.util.setNoReferrer = function() {\n  var doc = goog.global.document;\n  if (doc) {\n    try {\n      var meta = goog.dom.createDom(goog.dom.TagName.META, {\n        'name': 'referrer',\n        'content': 'no-referrer'\n      });\n      var headCollection = goog.dom.getElementsByTagName(goog.dom.TagName.HEAD);\n      // Append meta tag to head.\n      if (headCollection.length) {\n        headCollection[0].appendChild(meta);\n      }\n    } catch (e) {\n      // Best effort approach.\n    }\n  }\n};\n\n\n/** @return {?ServiceWorker} The servicerWorker controller if available. */\nfireauth.util.getServiceWorkerController = function() {\n  var navigator = goog.global['navigator'];\n  return (navigator &&\n          navigator.serviceWorker &&\n          navigator.serviceWorker.controller) || null;\n};\n\n\n/** @return {?WorkerGlobalScope} The worker global scope if available. */\nfireauth.util.getWorkerGlobalScope = function() {\n  return fireauth.util.isWorker() ? /** @type {!WorkerGlobalScope} */ (self) :\n      null;\n};\n\n/**\n * @return {!goog.Promise<?ServiceWorker>} A promise that resolves with the\n *     service worker. This will resolve only when a service worker becomes\n *     available. If no service worker is supported, it will resolve with null.\n */\nfireauth.util.getActiveServiceWorker = function() {\n  var navigator = goog.global['navigator'];\n  if (navigator && navigator.serviceWorker) {\n    return goog.Promise.resolve()\n        .then(function() {\n          return navigator.serviceWorker.ready;\n        })\n        .then(function(registration) {\n          return /** @type {?ServiceWorker} */ (registration.active || null);\n        })\n        .thenCatch(function(error) {\n          return null;\n        });\n  }\n  return goog.Promise.resolve(/** @type {?ServiceWorker} */ (null));\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for window manipulation.\n */\n\n\ngoog.provide('goog.window');\n\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.safe');\ngoog.require('goog.html.SafeUrl');\ngoog.require('goog.html.uncheckedconversions');\ngoog.require('goog.labs.userAgent.platform');\ngoog.require('goog.string');\ngoog.require('goog.string.Const');\ngoog.require('goog.userAgent');\n\n\n/**\n * Default height for popup windows\n * @type {number}\n */\ngoog.window.DEFAULT_POPUP_HEIGHT = 500;\n\n\n/**\n * Default width for popup windows\n * @type {number}\n */\ngoog.window.DEFAULT_POPUP_WIDTH = 690;\n\n\n/**\n * Default target for popup windows\n * @type {string}\n */\ngoog.window.DEFAULT_POPUP_TARGET = 'google_popup';\n\n\n/**\n * @return {!Window}\n * @suppress {checkTypes}\n * @private\n */\ngoog.window.createFakeWindow_ = function() {\n  return /** @type {!Window} */ ({});\n};\n\n/**\n * Opens a new window.\n *\n * @param {!goog.html.SafeUrl|string|!Object|null} linkRef If an Object with an\n *     'href' attribute (such as HTMLAnchorElement) is passed then the value of\n *     'href' is used, otherwise its toString method is called. Note that if a\n *     string|Object is used, it will be sanitized with SafeUrl.sanitize().\n *\n * @param {?Object=} opt_options supports the following options:\n *  'target': (string) target (window name). If null, linkRef.target will\n *      be used.\n *  'width': (number) window width.\n *  'height': (number) window height.\n *  'top': (number) distance from top of screen\n *  'left': (number) distance from left of screen\n *  'toolbar': (boolean) show toolbar\n *  'scrollbars': (boolean) show scrollbars\n *  'location': (boolean) show location\n *  'statusbar': (boolean) show statusbar\n *  'menubar': (boolean) show menubar\n *  'resizable': (boolean) resizable\n *  'noreferrer': (boolean) whether to attempt to remove the referrer header\n *      from the request headers. Does this by opening a blank window that\n *      then redirects to the target url, so users may see some flickering.\n *  'noopener': (boolean) whether to remove the `opener` property from the\n *      window object of the newly created window. The property contains a\n *      reference to the original window, and can be used to launch a\n *      reverse tabnabbing attack.\n *\n * @param {?Window=} opt_parentWin Parent window that should be used to open the\n *                 new window.\n *\n * @return {?Window} Returns the window object that was opened. This returns\n *                  null if a popup blocker prevented the window from being\n *                  opened. In case when a new window is opened in a different\n *                  browser sandbox (such as iOS standalone mode), the returned\n *                  object is a emulated Window object that functions as if\n *                  a cross-origin window has been opened.\n */\ngoog.window.open = function(linkRef, opt_options, opt_parentWin) {\n  if (!opt_options) {\n    opt_options = {};\n  }\n  var parentWin = opt_parentWin || window;\n\n  /** @type {!goog.html.SafeUrl} */\n  var safeLinkRef;\n\n  if (linkRef instanceof goog.html.SafeUrl) {\n    safeLinkRef = linkRef;\n  } else {\n    // HTMLAnchorElement has a toString() method with the same behavior as\n    // goog.Uri in all browsers except for Safari, which returns\n    // '[object HTMLAnchorElement]'.  We check for the href first, then\n    // assume that it's a goog.Uri or String otherwise.\n    /**\n     * @type {string|!goog.string.TypedString}\n     * @suppress {missingProperties}\n     */\n    var url =\n        typeof linkRef.href != 'undefined' ? linkRef.href : String(linkRef);\n    safeLinkRef = goog.html.SafeUrl.sanitize(url);\n  }\n\n  /** @suppress {missingProperties} loose references to 'target' */\n  /** @suppress {strictMissingProperties} */\n  var target = opt_options.target || linkRef.target;\n\n  var sb = [];\n  for (var option in opt_options) {\n    switch (option) {\n      case 'width':\n      case 'height':\n      case 'top':\n      case 'left':\n        sb.push(option + '=' + opt_options[option]);\n        break;\n      case 'target':\n      case 'noopener':\n      case 'noreferrer':\n        break;\n      default:\n        sb.push(option + '=' + (opt_options[option] ? 1 : 0));\n    }\n  }\n  var optionString = sb.join(',');\n\n  var newWin;\n  if (goog.labs.userAgent.platform.isIos() && parentWin.navigator &&\n      parentWin.navigator['standalone'] && target && target != '_self') {\n    // iOS in standalone mode disregards \"target\" in window.open and always\n    // opens new URL in the same window. The workaround is to create an \"A\"\n    // element and send a click event to it.\n    // Notice that the \"A\" tag does NOT have to be added to the DOM.\n\n    var a = /** @type {!HTMLAnchorElement} */\n        (parentWin.document.createElement(String(goog.dom.TagName.A)));\n    goog.dom.safe.setAnchorHref(a, safeLinkRef);\n\n    a.setAttribute('target', target);\n    if (opt_options['noreferrer']) {\n      a.setAttribute('rel', 'noreferrer');\n    }\n\n    var click = /** @type {!MouseEvent} */ (document.createEvent('MouseEvent'));\n    click.initMouseEvent(\n        'click',\n        true,  // canBubble\n        true,  // cancelable\n        parentWin,\n        1);  // detail = mousebutton\n    a.dispatchEvent(click);\n    // New window is not available in this case. Instead, a fake Window object\n    // is returned. In particular, it will have window.document undefined. In\n    // general, it will appear to most of clients as a Window for a different\n    // origin. Since iOS standalone web apps are run in their own sandbox, this\n    // is the most appropriate return value.\n    newWin = goog.window.createFakeWindow_();\n  } else if (opt_options['noreferrer']) {\n    // This code used to use meta-refresh to stop the referrer from being\n    // included in the request headers. This was the only cross-browser way\n    // to remove the referrer circa 2009. However, this never worked in Chrome,\n    // and, instead newWin.opener had to be set to null on this browser. This\n    // behavior is slated to be removed in Chrome and should not be relied\n    // upon. Referrer Policy is the only spec'd and supported way of stripping\n    // referrers and works across all current browsers. This is used in\n    // addition to the aforementioned tricks.\n    //\n    // We also set the opener to be set to null in the new window, thus\n    // disallowing the opened window from navigating its opener.\n    //\n    // Detecting user agent and then using a different strategy per browser\n    // would allow the referrer to leak in case of an incorrect/missing user\n    // agent.\n    //\n    // Also note that we can't use goog.dom.safe.openInWindow here, as it\n    // requires a goog.string.Const 'name' parameter, while we're using plain\n    // strings here for target.\n    newWin = parentWin.open('', target, optionString);\n\n    var sanitizedLinkRef = goog.html.SafeUrl.unwrap(safeLinkRef);\n    if (newWin) {\n      if (goog.userAgent.EDGE_OR_IE) {\n        // IE/EDGE can't parse the content attribute if the url contains\n        // a semicolon. We can fix this by adding quotes around the url, but\n        // then we can't parse quotes in the URL correctly. We take a\n        // best-effort approach.\n        //\n        // If the URL has semicolons, wrap it in single quotes to protect\n        // the semicolons.\n        // If the URL has semicolons and single quotes, url-encode the single\n        // quotes as well.\n        //\n        // This is imperfect. Notice that both ' and ; are reserved characters\n        // in URIs, so this could do the wrong thing, but at least it will\n        // do the wrong thing in only rare cases.\n        // ugh.\n        if (goog.string.contains(sanitizedLinkRef, ';')) {\n          sanitizedLinkRef = \"'\" + sanitizedLinkRef.replace(/'/g, '%27') + \"'\";\n        }\n      }\n      newWin.opener = null;\n\n      // TODO(rjamet): Building proper SafeHtml with SafeHtml.createMetaRefresh\n      // pulls in a lot of compiled code, which is composed of various unneeded\n      // goog.html parts such as SafeStyle.create among others. So, for now,\n      // keep the unchecked conversion until we figure out how to make the\n      // dependencies of createSafeHtmlTagSecurityPrivateDoNotAccessOrElse less\n      // heavy.\n      var safeHtml =\n          goog.html.uncheckedconversions\n              .safeHtmlFromStringKnownToSatisfyTypeContract(\n                  goog.string.Const.from(\n                      'b/12014412, meta tag with sanitized URL'),\n                  '<meta name=\"referrer\" content=\"no-referrer\">' +\n                      '<meta http-equiv=\"refresh\" content=\"0; url=' +\n                      goog.string.htmlEscape(sanitizedLinkRef) + '\">');\n      goog.dom.safe.documentWrite(newWin.document, safeHtml);\n      newWin.document.close();\n    }\n  } else {\n    newWin = parentWin.open(\n        goog.html.SafeUrl.unwrap(safeLinkRef), target, optionString);\n    // Passing in 'noopener' into the 'windowFeatures' param of window.open(...)\n    // will yield a feature-deprived browser. This is an known issue, tracked\n    // here: https://github.com/whatwg/html/issues/1902\n    if (newWin && opt_options['noopener']) {\n      newWin.opener = null;\n    }\n  }\n  // newWin is null if a popup blocker prevented the window open.\n  return newWin;\n};\n\n\n/**\n * Opens a new window without any real content in it.\n *\n * This can be used to get around popup blockers if you need to open a window\n * in response to a user event, but need to do asynchronous work to determine\n * the URL to open, and then set the URL later.\n *\n * Example usage:\n *\n * var newWin = goog.window.openBlank('Loading...');\n * setTimeout(\n *     function() {\n *       newWin.location.href = 'http://www.google.com';\n *     }, 100);\n *\n * @param {string=} opt_message String to show in the new window. This string\n *     will be HTML-escaped to avoid XSS issues.\n * @param {?Object=} opt_options Options to open window with.\n *     {@see goog.window.open for exact option semantics}.\n * @param {?Window=} opt_parentWin Parent window that should be used to open the\n *                 new window.\n * @return {?Window} Returns the window object that was opened. This returns\n *                  null if a popup blocker prevented the window from being\n *                  opened.\n */\ngoog.window.openBlank = function(opt_message, opt_options, opt_parentWin) {\n  // Open up a window with the loading message and nothing else.\n  // This will be interpreted as HTML content type with a missing doctype\n  // and html/body tags, but is otherwise acceptable.\n  //\n  // IMPORTANT: The order of escaping is crucial here in order to avoid XSS.\n  // First, HTML-escaping is needed because the result of the JS expression\n  // is evaluated as HTML. Second, JS-string escaping is needed; this avoids\n  // \\u escaping from inserting HTML tags and \\ from escaping the final \".\n  // Finally, URL percent-encoding is done with encodeURI(); this\n  // avoids percent-encoding from bypassing HTML and JS escaping.\n  //\n  // Note: There are other ways the same result could be achieved but the\n  // current behavior was preserved when this code was refactored to use\n  // SafeUrl, in order to avoid breakage.\n  var loadingMessage;\n  if (!opt_message) {\n    loadingMessage = '';\n  } else {\n    loadingMessage =\n        goog.string.escapeString(goog.string.htmlEscape(opt_message));\n  }\n  var url = goog.html.uncheckedconversions\n                .safeUrlFromStringKnownToSatisfyTypeContract(\n                    goog.string.Const.from(\n                        'b/12014412, encoded string in javascript: URL'),\n                    'javascript:\"' + encodeURI(loadingMessage) + '\"');\n  return /** @type {?Window} */ (\n      goog.window.open(url, opt_options, opt_parentWin));\n};\n\n\n/**\n * Raise a help popup window, defaulting to \"Google standard\" size and name.\n *\n * (If your project is using GXPs, consider using {@link PopUpLink.gxp}.)\n *\n* @param {?goog.html.SafeUrl|string|?Object} linkRef If an Object with an 'href'\n *     attribute (such as HTMLAnchorElement) is passed then the value of 'href'\n *     is used, otherwise  otherwise its toString method is called. Note that\n *     if a string|Object is used, it will be sanitized with SafeUrl.sanitize().\n *\n * @param {?Object=} opt_options Options to open window with.\n *     {@see goog.window.open for exact option semantics}\n *     Additional wrinkles to the options:\n *     - if 'target' field is null, linkRef.target will be used. If *that's*\n *     null, the default is \"google_popup\".\n *     - if 'width' field is not specified, the default is 690.\n *     - if 'height' field is not specified, the default is 500.\n *\n * @return {boolean} true if the window was not popped up, false if it was.\n */\ngoog.window.popup = function(linkRef, opt_options) {\n  if (!opt_options) {\n    opt_options = {};\n  }\n\n  // set default properties\n  opt_options['target'] = opt_options['target'] || linkRef['target'] ||\n      goog.window.DEFAULT_POPUP_TARGET;\n  opt_options['width'] =\n      opt_options['width'] || goog.window.DEFAULT_POPUP_WIDTH;\n  opt_options['height'] =\n      opt_options['height'] || goog.window.DEFAULT_POPUP_HEIGHT;\n\n  var newWin = goog.window.open(linkRef, opt_options);\n  if (!newWin) {\n    return true;\n  }\n  newWin.focus();\n\n  return false;\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Closure user agent platform detection.\n * @see <a href=\"http://www.useragentstring.com/\">User agent strings</a>\n * For more information on browser brand, rendering engine, or device see the\n * other sub-namespaces in goog.labs.userAgent (browser, engine, and device\n * respectively).\n *\n */\n\ngoog.provide('goog.labs.userAgent.platform');\n\ngoog.require('goog.labs.userAgent.util');\ngoog.require('goog.string');\n\n\n/**\n * @return {boolean} Whether the platform is Android.\n */\ngoog.labs.userAgent.platform.isAndroid = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Android');\n};\n\n\n/**\n * @return {boolean} Whether the platform is iPod.\n */\ngoog.labs.userAgent.platform.isIpod = function() {\n  return goog.labs.userAgent.util.matchUserAgent('iPod');\n};\n\n\n/**\n * @return {boolean} Whether the platform is iPhone.\n */\ngoog.labs.userAgent.platform.isIphone = function() {\n  return goog.labs.userAgent.util.matchUserAgent('iPhone') &&\n      !goog.labs.userAgent.util.matchUserAgent('iPod') &&\n      !goog.labs.userAgent.util.matchUserAgent('iPad');\n};\n\n\n/**\n * @return {boolean} Whether the platform is iPad.\n */\ngoog.labs.userAgent.platform.isIpad = function() {\n  return goog.labs.userAgent.util.matchUserAgent('iPad');\n};\n\n\n/**\n * @return {boolean} Whether the platform is iOS.\n */\ngoog.labs.userAgent.platform.isIos = function() {\n  return goog.labs.userAgent.platform.isIphone() ||\n      goog.labs.userAgent.platform.isIpad() ||\n      goog.labs.userAgent.platform.isIpod();\n};\n\n\n/**\n * @return {boolean} Whether the platform is Mac.\n */\ngoog.labs.userAgent.platform.isMacintosh = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Macintosh');\n};\n\n\n/**\n * Note: ChromeOS is not considered to be Linux as it does not report itself\n * as Linux in the user agent string.\n * @return {boolean} Whether the platform is Linux.\n */\ngoog.labs.userAgent.platform.isLinux = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Linux');\n};\n\n\n/**\n * @return {boolean} Whether the platform is Windows.\n */\ngoog.labs.userAgent.platform.isWindows = function() {\n  return goog.labs.userAgent.util.matchUserAgent('Windows');\n};\n\n\n/**\n * @return {boolean} Whether the platform is ChromeOS.\n */\ngoog.labs.userAgent.platform.isChromeOS = function() {\n  return goog.labs.userAgent.util.matchUserAgent('CrOS');\n};\n\n/**\n * @return {boolean} Whether the platform is Chromecast.\n */\ngoog.labs.userAgent.platform.isChromecast = function() {\n  return goog.labs.userAgent.util.matchUserAgent('CrKey');\n};\n\n/**\n * @return {boolean} Whether the platform is KaiOS.\n */\ngoog.labs.userAgent.platform.isKaiOS = function() {\n  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('KaiOS');\n};\n\n/**\n * @return {boolean} Whether the platform is Go2Phone.\n */\ngoog.labs.userAgent.platform.isGo2Phone = function() {\n  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('GAFP');\n};\n\n/**\n * The version of the platform. We only determine the version for Windows,\n * Mac, and Chrome OS. It doesn't make much sense on Linux. For Windows, we only\n * look at the NT version. Non-NT-based versions (e.g. 95, 98, etc.) are given\n * version 0.0.\n *\n * @return {string} The platform version or empty string if version cannot be\n *     determined.\n */\ngoog.labs.userAgent.platform.getVersion = function() {\n  var userAgentString = goog.labs.userAgent.util.getUserAgent();\n  var version = '', re;\n  if (goog.labs.userAgent.platform.isWindows()) {\n    re = /Windows (?:NT|Phone) ([0-9.]+)/;\n    var match = re.exec(userAgentString);\n    if (match) {\n      version = match[1];\n    } else {\n      version = '0.0';\n    }\n  } else if (goog.labs.userAgent.platform.isIos()) {\n    re = /(?:iPhone|iPod|iPad|CPU)\\s+OS\\s+(\\S+)/;\n    var match = re.exec(userAgentString);\n    // Report the version as x.y.z and not x_y_z\n    version = match && match[1].replace(/_/g, '.');\n  } else if (goog.labs.userAgent.platform.isMacintosh()) {\n    re = /Mac OS X ([0-9_.]+)/;\n    var match = re.exec(userAgentString);\n    // Note: some old versions of Camino do not report an OSX version.\n    // Default to 10.\n    version = match ? match[1].replace(/_/g, '.') : '10';\n  } else if (goog.labs.userAgent.platform.isKaiOS()) {\n    re = /(?:KaiOS)\\/(\\S+)/i;\n    var match = re.exec(userAgentString);\n    version = match && match[1];\n  } else if (goog.labs.userAgent.platform.isAndroid()) {\n    re = /Android\\s+([^\\);]+)(\\)|;)/;\n    var match = re.exec(userAgentString);\n    version = match && match[1];\n  } else if (goog.labs.userAgent.platform.isChromeOS()) {\n    re = /(?:CrOS\\s+(?:i686|x86_64)\\s+([0-9.]+))/;\n    var match = re.exec(userAgentString);\n    version = match && match[1];\n  }\n  return version || '';\n};\n\n\n/**\n * @param {string|number} version The version to check.\n * @return {boolean} Whether the browser version is higher or the same as the\n *     given version.\n */\ngoog.labs.userAgent.platform.isVersionOrHigher = function(version) {\n  return goog.string.compareVersions(\n             goog.labs.userAgent.platform.getVersion(), version) >= 0;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides methods for manipulating objects.\n */\n\ngoog.provide('fireauth.object');\n\ngoog.require('fireauth.deprecation');\ngoog.require('fireauth.deprecation.Deprecations');\n\n\n/**\n * Checks whether the defineProperty method allows to change the value of\n * the property.\n * @return {boolean} Whether the defineProperty method allows to change the\n *    value of the property.\n * @private\n */\nfireauth.object.isReadonlyConfigurable_ = function() {\n  // Android 2.3 stock browser doesn't allow to change the value of\n  // a read-only property once defined.\n  try {\n    var obj = {};\n    Object.defineProperty(obj, 'abcd', {\n      configurable: true,\n      enumerable: true,\n      value: 1\n    });\n    Object.defineProperty(obj, 'abcd', {\n      configurable: true,\n      enumerable: true,\n      value: 2\n    });\n    return obj['abcd'] == 2;\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * @private {boolean} Whether the defineProperty method allows to change the\n *     value of the property.\n */\nfireauth.object.readonlyConfigurable_ =\n    fireauth.object.isReadonlyConfigurable_();\n\n\n/**\n * Defines a property on an object that is not writable by clients. However, the\n * property can be overwritten within the Firebase library through subsequent\n * calls to setReadonlyProperty.\n *\n * In browsers that do not support read-only properties (notably IE8 and below),\n * fall back to writable properties.\n *\n * @param {!Object} obj The object to which we add the property.\n * @param {string} key The name of the property.\n * @param {*} value The desired value.\n */\nfireauth.object.setReadonlyProperty = function(obj, key, value) {\n  if (fireauth.object.readonlyConfigurable_) {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: true,\n      value: value\n    });\n  } else {\n    obj[key] = value;\n  }\n};\n\n\n/**\n * Defines a deprecated property, which emits a warning if the developer tries\n * to use it.\n *\n * In browsers that do not support getters, we fall back to a normal property\n * with no message.\n *\n * @param {!Object} obj The object to which we add the property.\n * @param {string} key The name of the deprecated property.\n * @param {*} value The desired value.\n * @param {!fireauth.deprecation.Deprecations} deprecationMessage The\n *     deprecation warning to display.\n */\nfireauth.object.setDeprecatedReadonlyProperty = function(obj, key, value,\n    deprecationMessage) {\n  if (fireauth.object.readonlyConfigurable_) {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: true,\n      get: function() {\n        fireauth.deprecation.log(deprecationMessage);\n        return value;\n      }\n    });\n  } else {\n    obj[key] = value;\n  }\n};\n\n\n/**\n * Defines properties on an object that are not writable by clients, equivalent\n * to many calls to setReadonlyProperty.\n * @param {!Object} obj The object to which we add the properties.\n * @param {?Object<string, *>} props An object that maps the keys and values\n *     that we wish to add.\n */\nfireauth.object.setReadonlyProperties = function(obj, props) {\n  if (!props) {\n    return;\n  }\n\n  for (var key in props) {\n    if (props.hasOwnProperty(key)) {\n      fireauth.object.setReadonlyProperty(obj, key, props[key]);\n    }\n  }\n};\n\n\n/**\n * Makes a shallow read-only copy of an object. The writability of any child\n * objects will not be affected.\n * @param {?Object} obj The object that we wish to copy.\n * @return {!Object}\n */\nfireauth.object.makeReadonlyCopy = function(obj) {\n  var output = {};\n  fireauth.object.setReadonlyProperties(output, obj);\n  return output;\n};\n\n\n/**\n * Makes a shallow writable copy of a read-only object. The writability of any\n * child objects will not be affected.\n * @param {?Object} obj The object that we wish to copy.\n * @return {!Object}\n */\nfireauth.object.makeWritableCopy = function(obj) {\n  var output = {};\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      output[key] = obj[key];\n    }\n  }\n  return output;\n};\n\n\n/**\n * Returns true if the all the specified fields are present in obj and are not\n * null, undefined, or the empty string. If the field list is empty, returns\n * true regardless of the value of obj.\n * @param {?Object=} opt_obj The object.\n * @param {?Array<string>=} opt_fields The desired fields of the object.\n * @return {boolean} True if obj has all the specified fields.\n */\nfireauth.object.hasNonEmptyFields = function(opt_obj, opt_fields) {\n  if (!opt_fields || !opt_fields.length) {\n    return true;\n  }\n  if (!opt_obj) {\n    return false;\n  }\n  for (var i = 0; i < opt_fields.length; i++) {\n    var field = opt_obj[opt_fields[i]];\n    if (field === undefined || field === null || field === '') {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Traverses the specified object and creates a read-only deep copy of it.\n * This will fail when circular references are contained within the object.\n * @param {*} obj The object to make a read-only copy from.\n * @return {*} A Read-only copy of the obj specified.\n */\nfireauth.object.unsafeCreateReadOnlyCopy = function(obj) {\n  var copy = obj;\n  if (typeof obj == 'object' && obj != null) {\n    // Make the right type of copy.\n    copy = 'length' in obj ? [] : {};\n    // Make a deep copy.\n    for (var key in obj) {\n      fireauth.object.setReadonlyProperty(\n          copy, key, fireauth.object.unsafeCreateReadOnlyCopy(obj[key]));\n    }\n  }\n  // Return the copy.\n  return copy;\n};\n\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides utilities for displaying deprecation notices.\n */\ngoog.provide('fireauth.deprecation');\ngoog.provide('fireauth.deprecation.Deprecations');\ngoog.require('fireauth.util');\n\n\n/**\n * An enum of valid notices to display. All deprecation notices must be in this\n * enum. Deprecation messages should be unique and provide the full context\n * of what is deprecated (e.g. the fully qualified path to a method).\n * @enum {string}\n */\nfireauth.deprecation.Deprecations = {\n  LINK_WITH_CREDENTIAL: 'firebase.User.prototype.linkAndRetrieveDataWithCrede' +\n      'ntial is deprecated. Please use firebase.User.prototype.linkWithCreden' +\n      'tial instead.',\n  REAUTH_WITH_CREDENTIAL: 'firebase.User.prototype.reauthenticateAndRetrieveD' +\n      'ataWithCredential is deprecated. Please use firebase.User.prototype.re' +\n      'authenticateWithCredential instead.',\n  SIGN_IN_WITH_CREDENTIAL: 'firebase.auth.Auth.prototype.signInAndRetrieveDat' +\n      'aWithCredential is deprecated. Please use firebase.auth.Auth.prototype' +\n      '.signInWithCredential instead.'\n};\n\n\n/**\n * Keeps track of notices that were already displayed.\n * @type {!Object<fireauth.deprecation.Deprecations, boolean>}\n * @private\n */\nfireauth.deprecation.shownMessages_ = {};\n\n\n/**\n * Logs a deprecation notice to the developer.\n * @param {!fireauth.deprecation.Deprecations} message\n */\nfireauth.deprecation.log = function(message) {\n  if (fireauth.deprecation.shownMessages_[message]) {\n    return;\n  }\n  fireauth.deprecation.shownMessages_[message] = true;\n  fireauth.util.consoleWarn(message);\n};\n\n\n/**\n * Resets the displayed deprecation notices.\n */\nfireauth.deprecation.resetForTesting = function() {\n  fireauth.deprecation.shownMessages_ =\n      /** @type {!Object<fireauth.deprecation.Deprecations, boolean>} */ ({});\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the firebase.auth.ActionCodeInfo class that is returned\n * when calling checkActionCode API and is populated from the server response\n * directly.\n */\n\ngoog.provide('fireauth.ActionCodeInfo');\n\ngoog.require('fireauth.object');\n\n\n/**\n * Constructs the action code info object which provides metadata corresponding\n * to action codes. This includes the type of operation (RESET_PASSWORD,\n * VERIFY_EMAIL and RECOVER_EMAIL), the email corresponding to the operation\n * and in case of the recover email flow, the old and new email.\n * @param {!Object} response The server response for checkActionCode.\n * @constructor\n */\nfireauth.ActionCodeInfo = function(response) {\n  var data = {};\n  // Original email for email change revocation.\n  var email = response[fireauth.ActionCodeInfo.ServerFieldName.EMAIL];\n  // The new email.\n  var newEmail = response[fireauth.ActionCodeInfo.ServerFieldName.NEW_EMAIL];\n  var operation =\n      response[fireauth.ActionCodeInfo.ServerFieldName.REQUEST_TYPE];\n  // Email could be empty only if the request type is EMAIL_SIGNIN.\n  if (!operation ||\n      (operation != fireauth.ActionCodeInfo.Operation.EMAIL_SIGNIN &&\n      !email)) {\n    // This is internal only.\n    throw new Error('Invalid provider user info!');\n  }\n  data[fireauth.ActionCodeInfo.DataField.FROM_EMAIL] = newEmail || null;\n  data[fireauth.ActionCodeInfo.DataField.EMAIL] = email || null;\n  fireauth.object.setReadonlyProperty(\n      this,\n      fireauth.ActionCodeInfo.PropertyName.OPERATION,\n      operation);\n  fireauth.object.setReadonlyProperty(\n      this,\n      fireauth.ActionCodeInfo.PropertyName.DATA,\n      fireauth.object.unsafeCreateReadOnlyCopy(data));\n};\n\n\n/**\n * Firebase Auth Action Code Info operation possible values.\n * @enum {string}\n */\nfireauth.ActionCodeInfo.Operation = {\n  PASSWORD_RESET: 'PASSWORD_RESET',\n  RECOVER_EMAIL: 'RECOVER_EMAIL',\n  EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n  VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n\n/**\n * The checkActionCode endpoint server response field names.\n * @enum {string}\n */\nfireauth.ActionCodeInfo.ServerFieldName = {\n  // This is the current email of the account and in email recovery, the email\n  // to revert to.\n  EMAIL: 'email',\n  // For email recovery, this is the new email.\n  NEW_EMAIL: 'newEmail',\n  // The action code request type.\n  REQUEST_TYPE: 'requestType'\n};\n\n\n/**\n * The ActionCodeInfo data object field names.\n * @enum {string}\n */\nfireauth.ActionCodeInfo.DataField = {\n  EMAIL: 'email',\n  FROM_EMAIL: 'fromEmail'\n};\n\n\n/**\n * The ActionCodeInfo main property names\n * @enum {string}\n */\nfireauth.ActionCodeInfo.PropertyName = {\n  DATA: 'data',\n  OPERATION: 'operation'\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines developer-visible errors for Firebase Auth APIs.\n */\n\n\ngoog.provide('fireauth.AuthError');\ngoog.provide('fireauth.authenum');\ngoog.provide('fireauth.authenum.Error');\n\n\n\n/**\n * Error that can be returned to the developer.\n * @param {!fireauth.authenum.Error} code The short error code.\n * @param {?string=} opt_message The human-readable message.\n * @constructor\n * @extends {Error}\n */\nfireauth.AuthError = function(code, opt_message) {\n  this['code'] = fireauth.AuthError.ERROR_CODE_PREFIX + code;\n  this.message = opt_message || fireauth.AuthError.MESSAGES_[code] || '';\n};\ngoog.inherits(fireauth.AuthError, Error);\n\n\n/**\n * @return {!Object} The plain object form of the error.\n */\nfireauth.AuthError.prototype.toPlainObject = function() {\n  return {\n    'code': this['code'],\n    'message': this.message\n  };\n};\n\n\n/**\n * @return {!Object} The plain object form of the error. This is used by\n *     JSON.toStringify() to return the stringified representation of the error;\n * @override\n */\nfireauth.AuthError.prototype.toJSON = function() {\n  // Return the plain object representation in case JSON.stringify is called on\n  // an auth error instance.\n  return this.toPlainObject();\n};\n\n\n/**\n * @param {?Object|undefined} response The object response to convert to a\n *     fireauth.AuthError.\n * @return {?fireauth.AuthError} The error representation of the response.\n */\nfireauth.AuthError.fromPlainObject = function(response) {\n  var fullCode = response && response['code'];\n  if (fullCode) {\n    // Remove prefix from name.\n    var code = fullCode.substring(\n        fireauth.AuthError.ERROR_CODE_PREFIX.length);\n    return new fireauth.AuthError(\n        /** @type {fireauth.authenum.Error} */ (code), response['message']);\n  }\n  return null;\n};\n\n\n/**\n * Takes in an error and translates a specific error code to another one if\n * found in the current error.\n * @param {*} error The error thrown.\n * @param {!fireauth.authenum.Error} fromCode The error code to translate from.\n * @param {!fireauth.authenum.Error} toCode The error code to translate to.\n * @return {*} The mapped error message.\n */\nfireauth.AuthError.translateError = function(error, fromCode, toCode) {\n  if (error &&\n      error['code'] &&\n      error['code'] == fireauth.AuthError.ERROR_CODE_PREFIX + fromCode) {\n    // Translate the error to the new one.\n    return new fireauth.AuthError(toCode);\n  }\n  // Return the same error if the fromCode is not found.\n  return error;\n};\n\n\n/**\n * The error prefix for fireauth.Auth errors.\n * @protected {string}\n */\nfireauth.AuthError.ERROR_CODE_PREFIX = 'auth/';\n\n\n/**\n * Developer facing Firebase Auth error codes.\n * @enum {string}\n */\nfireauth.authenum.Error = {\n  ADMIN_ONLY_OPERATION: 'admin-restricted-operation',\n  ARGUMENT_ERROR: 'argument-error',\n  APP_NOT_AUTHORIZED: 'app-not-authorized',\n  APP_NOT_INSTALLED: 'app-not-installed',\n  CAPTCHA_CHECK_FAILED: 'captcha-check-failed',\n  CODE_EXPIRED: 'code-expired',\n  CORDOVA_NOT_READY: 'cordova-not-ready',\n  CORS_UNSUPPORTED: 'cors-unsupported',\n  CREDENTIAL_ALREADY_IN_USE: 'credential-already-in-use',\n  CREDENTIAL_MISMATCH: 'custom-token-mismatch',\n  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'requires-recent-login',\n  DYNAMIC_LINK_NOT_ACTIVATED: 'dynamic-link-not-activated',\n  EMAIL_EXISTS: 'email-already-in-use',\n  EXPIRED_OOB_CODE: 'expired-action-code',\n  EXPIRED_POPUP_REQUEST: 'cancelled-popup-request',\n  INTERNAL_ERROR: 'internal-error',\n  INVALID_API_KEY: 'invalid-api-key',\n  INVALID_APP_CREDENTIAL: 'invalid-app-credential',\n  INVALID_APP_ID: 'invalid-app-id',\n  INVALID_AUTH: 'invalid-user-token',\n  INVALID_AUTH_EVENT: 'invalid-auth-event',\n  INVALID_CERT_HASH: 'invalid-cert-hash',\n  INVALID_CODE: 'invalid-verification-code',\n  INVALID_CONTINUE_URI: 'invalid-continue-uri',\n  INVALID_CORDOVA_CONFIGURATION: 'invalid-cordova-configuration',\n  INVALID_CUSTOM_TOKEN: 'invalid-custom-token',\n  INVALID_DYNAMIC_LINK_DOMAIN: 'invalid-dynamic-link-domain',\n  INVALID_EMAIL: 'invalid-email',\n  INVALID_IDP_RESPONSE: 'invalid-credential',\n  INVALID_MESSAGE_PAYLOAD: 'invalid-message-payload',\n  INVALID_OAUTH_CLIENT_ID: 'invalid-oauth-client-id',\n  INVALID_OAUTH_PROVIDER: 'invalid-oauth-provider',\n  INVALID_OOB_CODE: 'invalid-action-code',\n  INVALID_ORIGIN: 'unauthorized-domain',\n  INVALID_PASSWORD: 'wrong-password',\n  INVALID_PERSISTENCE: 'invalid-persistence-type',\n  INVALID_PHONE_NUMBER: 'invalid-phone-number',\n  INVALID_PROVIDER_ID: 'invalid-provider-id',\n  INVALID_RECIPIENT_EMAIL: 'invalid-recipient-email',\n  INVALID_SENDER: 'invalid-sender',\n  INVALID_SESSION_INFO: 'invalid-verification-id',\n  INVALID_TENANT_ID: 'invalid-tenant-id',\n  MISSING_ANDROID_PACKAGE_NAME: 'missing-android-pkg-name',\n  MISSING_APP_CREDENTIAL: 'missing-app-credential',\n  MISSING_AUTH_DOMAIN: 'auth-domain-config-required',\n  MISSING_CODE: 'missing-verification-code',\n  MISSING_CONTINUE_URI: 'missing-continue-uri',\n  MISSING_IFRAME_START: 'missing-iframe-start',\n  MISSING_IOS_BUNDLE_ID: 'missing-ios-bundle-id',\n  MISSING_OR_INVALID_NONCE: 'missing-or-invalid-nonce',\n  MISSING_PHONE_NUMBER: 'missing-phone-number',\n  MISSING_SESSION_INFO: 'missing-verification-id',\n  MODULE_DESTROYED: 'app-deleted',\n  NEED_CONFIRMATION: 'account-exists-with-different-credential',\n  NETWORK_REQUEST_FAILED: 'network-request-failed',\n  NULL_USER: 'null-user',\n  NO_AUTH_EVENT: 'no-auth-event',\n  NO_SUCH_PROVIDER: 'no-such-provider',\n  OPERATION_NOT_ALLOWED: 'operation-not-allowed',\n  OPERATION_NOT_SUPPORTED: 'operation-not-supported-in-this-environment',\n  POPUP_BLOCKED: 'popup-blocked',\n  POPUP_CLOSED_BY_USER: 'popup-closed-by-user',\n  PROVIDER_ALREADY_LINKED: 'provider-already-linked',\n  QUOTA_EXCEEDED: 'quota-exceeded',\n  REDIRECT_CANCELLED_BY_USER: 'redirect-cancelled-by-user',\n  REDIRECT_OPERATION_PENDING: 'redirect-operation-pending',\n  REJECTED_CREDENTIAL: 'rejected-credential',\n  TENANT_ID_MISMATCH: 'tenant-id-mismatch',\n  TIMEOUT: 'timeout',\n  TOKEN_EXPIRED: 'user-token-expired',\n  TOO_MANY_ATTEMPTS_TRY_LATER: 'too-many-requests',\n  UNAUTHORIZED_DOMAIN: 'unauthorized-continue-uri',\n  UNSUPPORTED_PERSISTENCE: 'unsupported-persistence-type',\n  UNSUPPORTED_TENANT_OPERATION: 'unsupported-tenant-operation',\n  USER_CANCELLED: 'user-cancelled',\n  USER_DELETED: 'user-not-found',\n  USER_DISABLED: 'user-disabled',\n  USER_MISMATCH: 'user-mismatch',\n  USER_SIGNED_OUT: 'user-signed-out',\n  WEAK_PASSWORD: 'weak-password',\n  WEB_STORAGE_UNSUPPORTED: 'web-storage-unsupported'\n};\n\n\n/**\n * Map from developer error codes to human-readable error messages.\n * @private {!Object<string, string>}\n */\nfireauth.AuthError.MESSAGES_ = {};\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.ADMIN_ONLY_OPERATION] =\n    'This operation is restricted to administrators only.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.ARGUMENT_ERROR] = '';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.APP_NOT_AUTHORIZED] =\n    'This app, identified by the domain where it\\'s hosted, is not ' +\n    'authorized to use Firebase Authentication with the provided API key. ' +\n    'Review your key configuration in the Google API console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.APP_NOT_INSTALLED] =\n    'The requested mobile application corresponding to the identifier (' +\n    'Android package name or iOS bundle ID) provided is not installed on ' +\n    'this device.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.CAPTCHA_CHECK_FAILED] =\n    'The reCAPTCHA response token provided is either invalid, expired, ' +\n    'already used or the domain associated with it does not match the list ' +\n    'of whitelisted domains.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.CODE_EXPIRED] =\n    'The SMS code has expired. Please re-send the verification code to try ' +\n    'again.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.CORDOVA_NOT_READY] =\n    'Cordova framework is not ready.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.CORS_UNSUPPORTED] =\n    'This browser is not supported.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.CREDENTIAL_ALREADY_IN_USE] =\n    'This credential is already associated with a different user account.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.CREDENTIAL_MISMATCH] =\n    'The custom token corresponds to a different audience.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.CREDENTIAL_TOO_OLD_LOGIN_AGAIN] =\n    'This operation is sensitive and requires recent authentication. Log in ' +\n    'again before retrying this request.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.DYNAMIC_LINK_NOT_ACTIVATED] = 'Please activate ' +\n    'Dynamic Links in the Firebase Console and agree to the terms and ' +\n    'conditions.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.EMAIL_EXISTS] =\n    'The email address is already in use by another account.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.EXPIRED_OOB_CODE] =\n    'The action code has expired. ';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.EXPIRED_POPUP_REQUEST] =\n    'This operation has been cancelled due to another conflicting popup ' +\n    'being opened.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INTERNAL_ERROR] =\n    'An internal error has occurred.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_APP_CREDENTIAL] =\n    'The phone verification request contains an invalid application verifier.' +\n    ' The reCAPTCHA token response is either invalid or expired.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_APP_ID] =\n    'The mobile app identifier is not registed for the current project.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_AUTH] =\n    'This user\\'s credential isn\\'t valid for this project. This can happen ' +\n    'if the user\\'s token has been tampered with, or if the user isn\\'t for ' +\n    'the project associated with this API key.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_AUTH_EVENT] =\n    'An internal error has occurred.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_CODE] =\n    'The SMS verification code used to create the phone auth credential is ' +\n    'invalid. Please resend the verification code sms and be sure use the ' +\n    'verification code provided by the user.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_CONTINUE_URI] =\n    'The continue URL provided in the request is invalid.';\nfireauth.AuthError.MESSAGES_[\n     fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION] = 'The following' +\n    ' Cordova plugins must be installed to enable OAuth sign-in: ' +\n    'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\n    'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\n    'cordova-plugin-customurlscheme.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_CUSTOM_TOKEN] =\n    'The custom token format is incorrect. Please check the documentation.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.INVALID_DYNAMIC_LINK_DOMAIN] = 'The provided ' +\n    'dynamic link domain is not configured or authorized for the current ' +\n    'project.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_EMAIL] =\n    'The email address is badly formatted.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_API_KEY] =\n    'Your API key is invalid, please check you have copied it correctly.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_CERT_HASH] =\n    'The SHA-1 certificate hash provided is invalid.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_IDP_RESPONSE] =\n    'The supplied auth credential is malformed or has expired.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_MESSAGE_PAYLOAD] =\n    'The email template corresponding to this action contains invalid charac' +\n    'ters in its message. Please fix by going to the Auth email templates se' +\n    'ction in the Firebase Console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_OAUTH_PROVIDER] =\n    'EmailAuthProvider is not supported for this operation. This operation ' +\n    'only supports OAuth providers.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_OAUTH_CLIENT_ID] =\n    'The OAuth client ID provided is either invalid or does not match the ' +\n    'specified API key.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_ORIGIN] =\n    'This domain is not authorized for OAuth operations for your Firebase ' +\n    'project. Edit the list of authorized domains from the Firebase console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_OOB_CODE] =\n    'The action code is invalid. This can happen if the code is malformed, ' +\n    'expired, or has already been used.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_PASSWORD] =\n    'The password is invalid or the user does not have a password.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_PERSISTENCE] =\n    'The specified persistence type is invalid. It can only be local, ' +\n    'session or none.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_PHONE_NUMBER] =\n    'The format of the phone number provided is incorrect. Please enter the ' +\n    'phone number in a format that can be parsed into E.164 format. E.164 ' +\n    'phone numbers are written in the format [+][country code][subscriber ' +\n    'number including area code].';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_PROVIDER_ID] =\n    'The specified provider ID is invalid.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_RECIPIENT_EMAIL] =\n    'The email corresponding to this action failed to send as the provided ' +\n    'recipient email address is invalid.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_SENDER] =\n    'The email template corresponding to this action contains an invalid sen' +\n    'der email or name. Please fix by going to the Auth email templates sect' +\n    'ion in the Firebase Console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_SESSION_INFO] =\n    'The verification ID used to create the phone auth credential is invalid.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.INVALID_TENANT_ID] =\n    'The Auth instance\\'s tenant ID is invalid.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.MISSING_ANDROID_PACKAGE_NAME] = 'An Android ' +\n    'Package Name must be provided if the Android App is required to be ' +\n    'installed.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_AUTH_DOMAIN] =\n    'Be sure to include authDomain when calling firebase.initializeApp(), ' +\n    'by following the instructions in the Firebase console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_APP_CREDENTIAL] =\n    'The phone verification request is missing an application verifier ' +\n    'assertion. A reCAPTCHA response token needs to be provided.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_CODE] =\n    'The phone auth credential was created with an empty SMS verification ' +\n    'code.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_CONTINUE_URI] =\n    'A continue URL must be provided in the request.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_IFRAME_START] =\n    'An internal error has occurred.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_IOS_BUNDLE_ID] =\n    'An iOS Bundle ID must be provided if an App Store ID is provided.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_OR_INVALID_NONCE] =\n    'The OIDC ID token requires a valid unhashed nonce.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_PHONE_NUMBER] =\n    'To send verification codes, provide a phone number for the recipient.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MISSING_SESSION_INFO] =\n    'The phone auth credential was created with an empty verification ID.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.MODULE_DESTROYED] =\n    'This instance of FirebaseApp has been deleted.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.NEED_CONFIRMATION] =\n    'An account already exists with the same email address but different ' +\n    'sign-in credentials. Sign in using a provider associated with this ' +\n    'email address.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.NETWORK_REQUEST_FAILED] =\n    'A network error (such as timeout, interrupted connection or ' +\n    'unreachable host) has occurred.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.NO_AUTH_EVENT] =\n    'An internal error has occurred.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.NO_SUCH_PROVIDER] =\n    'User was not linked to an account with the given provider.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.NULL_USER] =\n    'A null user object was provided as the argument for an operation which ' +\n    'requires a non-null user object.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.OPERATION_NOT_ALLOWED] =\n    'The given sign-in provider is disabled for this Firebase project. ' +\n    'Enable it in the Firebase console, under the sign-in method tab of the ' +\n    'Auth section.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.OPERATION_NOT_SUPPORTED] =\n    'This operation is not supported in the environment this application is ' +\n    'running on. \"location.protocol\" must be http, https or chrome-extension' +\n    ' and web storage must be enabled.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.POPUP_BLOCKED] =\n    'Unable to establish a connection with the popup. It may have been ' +\n    'blocked by the browser.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.POPUP_CLOSED_BY_USER] =\n    'The popup has been closed by the user before finalizing the operation.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.PROVIDER_ALREADY_LINKED] =\n    'User can only be linked to one identity for the given provider.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.QUOTA_EXCEEDED] =\n    'The project\\'s quota for this operation has been exceeded.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.REDIRECT_CANCELLED_BY_USER] =\n    'The redirect operation has been cancelled by the user before finalizing.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.REDIRECT_OPERATION_PENDING] =\n    'A redirect sign-in operation is already pending.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.REJECTED_CREDENTIAL] =\n    'The request contains malformed or mismatching credentials.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.TENANT_ID_MISMATCH] =\n    'The provided tenant ID does not match the Auth instance\\'s tenant ID';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.TIMEOUT] =\n    'The operation has timed out.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.TOKEN_EXPIRED] =\n    'The user\\'s credential is no longer valid. The user must sign in again.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.TOO_MANY_ATTEMPTS_TRY_LATER] =\n    'We have blocked all requests from this device due to unusual activity. ' +\n    'Try again later.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.UNAUTHORIZED_DOMAIN] =\n    'The domain of the continue URL is not whitelisted.  Please whitelist ' +\n    'the domain in the Firebase console.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.UNSUPPORTED_PERSISTENCE] =\n    'The current environment does not support the specified persistence type.';\nfireauth.AuthError.MESSAGES_[\n    fireauth.authenum.Error.UNSUPPORTED_TENANT_OPERATION] =\n    'This operation is not supported in a multi-tenant context.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.USER_CANCELLED] =\n    'User did not grant your application the permissions it requested.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.USER_DELETED] =\n    'There is no user record corresponding to this identifier. The user may ' +\n    'have been deleted.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.USER_DISABLED] =\n    'The user account has been disabled by an administrator.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.USER_MISMATCH] =\n    'The supplied credentials do not correspond to the previously signed in ' +\n    'user.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.USER_SIGNED_OUT] = '';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.WEAK_PASSWORD] =\n    'The password must be 6 characters long or more.';\nfireauth.AuthError.MESSAGES_[fireauth.authenum.Error.WEB_STORAGE_UNSUPPORTED] =\n    'This browser is not supported or 3rd party cookies and data may be ' +\n    'disabled.';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines firebase.auth.ActionCodeURL class which is the utility\n * to parse action code URLs.\n */\n\ngoog.provide('fireauth.ActionCodeURL');\n\ngoog.require('fireauth.ActionCodeInfo');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.object');\ngoog.require('goog.Uri');\n\n\n/**\n * The utility class to help parse action code URLs used for out of band email\n * flows such as password reset, email verification, email link sign in, etc.\n * @param {string} actionLink The action link string.\n * @constructor\n */\nfireauth.ActionCodeURL = function(actionLink) {\n  var uri = goog.Uri.parse(actionLink);\n  var apiKey = uri.getParameterValue(\n      fireauth.ActionCodeURL.QueryField.API_KEY) || null;\n  var code = uri.getParameterValue(\n      fireauth.ActionCodeURL.QueryField.CODE) || null;\n  var mode = uri.getParameterValue(\n      fireauth.ActionCodeURL.QueryField.MODE) || null;\n  var operation = fireauth.ActionCodeURL.getOperation(mode);\n  // Validate API key, code and mode.\n  if (!apiKey || !code || !operation) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        fireauth.ActionCodeURL.QueryField.API_KEY + ', ' +\n        fireauth.ActionCodeURL.QueryField.CODE + 'and ' +\n        fireauth.ActionCodeURL.QueryField.MODE +\n        ' are required in a valid action code URL.');\n  }\n  fireauth.object.setReadonlyProperties(this, {\n    'apiKey': apiKey,\n    'operation': operation,\n    'code': code,\n    'continueUrl': uri.getParameterValue(\n        fireauth.ActionCodeURL.QueryField.CONTINUE_URL) || null,\n    'languageCode': uri.getParameterValue(\n        fireauth.ActionCodeURL.QueryField.LANGUAGE_CODE) || null,\n    'tenantId': uri.getParameterValue(\n        fireauth.ActionCodeURL.QueryField.TENANT_ID) || null\n  });\n};\n\n\n/**\n * Enums for fields in URL query string.\n * @enum {string}\n */\nfireauth.ActionCodeURL.QueryField = {\n  API_KEY: 'apiKey',\n  CODE: 'oobCode',\n  CONTINUE_URL: 'continueUrl',\n  LANGUAGE_CODE: 'languageCode',\n  MODE: 'mode',\n  TENANT_ID: 'tenantId'\n};\n\n\n/**\n * Map of mode string to Action Code Info operation.\n * @const @private {!Object<string, !fireauth.ActionCodeInfo.Operation>}\n */\nfireauth.ActionCodeURL.ModeToOperationMap_ = {\n  'recoverEmail': fireauth.ActionCodeInfo.Operation.RECOVER_EMAIL,\n  'resetPassword': fireauth.ActionCodeInfo.Operation.PASSWORD_RESET,\n  'signIn': fireauth.ActionCodeInfo.Operation.EMAIL_SIGNIN,\n  'verifyEmail': fireauth.ActionCodeInfo.Operation.VERIFY_EMAIL\n};\n\n\n/**\n * Maps the mode string in action code URL to Action Code Info operation.\n * @param {?string} mode The mode string in the URL.\n * @return {?fireauth.ActionCodeInfo.Operation}\n */\nfireauth.ActionCodeURL.getOperation = function(mode) {\n  if (!mode) {\n    return null;\n  }\n  return fireauth.ActionCodeURL.ModeToOperationMap_[mode] || null;\n\n};\n\n\n/**\n * Returns an ActionCodeURL instance if the link is valid, otherwise null.\n * @param {string} actionLink The action code link string.\n * @return {?fireauth.ActionCodeURL}\n */\nfireauth.ActionCodeURL.parseLink = function(actionLink) {\n  try {\n    return new fireauth.ActionCodeURL(actionLink);\n  } catch(e) {\n    return null;\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Utility for firebase.auth.ActionCodeSettings and its helper\n * functions.\n */\n\ngoog.provide('fireauth.ActionCodeSettings');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\n\n\n/**\n * Defines the action code settings structure used to specify how email action\n * links are handled.\n * @param {!Object} settingsObj The action code settings object used to\n *     construct the action code link.\n * @constructor @struct @final\n */\nfireauth.ActionCodeSettings = function(settingsObj) {\n  // Validate the settings object passed.\n  this.initialize_(settingsObj);\n};\n\n\n/**\n * Validate the action code settings object.\n * @param {!Object} settingsObj The action code settings object to validate.\n * @private\n */\nfireauth.ActionCodeSettings.prototype.initialize_ = function(settingsObj) {\n  // URL should be required.\n  var continueUrl = settingsObj[fireauth.ActionCodeSettings.RawField.URL];\n  if (typeof continueUrl === 'undefined') {\n    throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_CONTINUE_URI);\n  } else if (typeof continueUrl !== 'string' ||\n             (typeof continueUrl === 'string' && !continueUrl.length)) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_CONTINUE_URI);\n  }\n  /** @const @private {string} The continue URL. */\n  this.continueUrl_ = /** @type {string} */ (continueUrl);\n\n  // Validate Android parameters.\n  /** @private {?string} The Android package name. */\n  this.apn_ = null;\n  /** @private {?string} The Android minimum version. */\n  this.amv_ = null;\n  /** @private {boolean} Whether to install the Android app. */\n  this.installApp_ = false;\n  var androidSettings =\n      settingsObj[fireauth.ActionCodeSettings.RawField.ANDROID];\n  if (androidSettings && typeof androidSettings === 'object') {\n    var apn = androidSettings[\n      fireauth.ActionCodeSettings.AndroidRawField.PACKAGE_NAME];\n    var installApp = androidSettings[\n      fireauth.ActionCodeSettings.AndroidRawField.INSTALL_APP];\n    var amv = androidSettings[\n      fireauth.ActionCodeSettings.AndroidRawField.MINIMUM_VERSION];\n    if (typeof apn === 'string' && apn.length) {\n      this.apn_ = /** @type {string} */ (apn);\n      if (typeof installApp !== 'undefined' &&\n          typeof installApp !== 'boolean') {\n        throw new fireauth.AuthError(\n            fireauth.authenum.Error.ARGUMENT_ERROR,\n            fireauth.ActionCodeSettings.AndroidRawField.INSTALL_APP +\n            ' property must be a boolean when specified.');\n      }\n      this.installApp_ = !!installApp;\n      if (typeof amv !== 'undefined' &&\n          (typeof amv !== 'string' ||\n           (typeof amv === 'string' && !amv.length))) {\n        throw new fireauth.AuthError(\n            fireauth.authenum.Error.ARGUMENT_ERROR,\n            fireauth.ActionCodeSettings.AndroidRawField.MINIMUM_VERSION +\n            ' property must be a non empty string when specified.');\n      }\n      this.amv_ = /** @type {?string}*/ (amv || null);\n    } else if (typeof apn !== 'undefined') {\n      throw new fireauth.AuthError(\n          fireauth.authenum.Error.ARGUMENT_ERROR,\n          fireauth.ActionCodeSettings.AndroidRawField.PACKAGE_NAME +\n          ' property must be a non empty string when specified.');\n    } else if (typeof installApp !== 'undefined' ||\n               typeof amv !== 'undefined') {\n      // If installApp or amv specified with no valid APN, fail quickly.\n      throw new fireauth.AuthError(\n          fireauth.authenum.Error.MISSING_ANDROID_PACKAGE_NAME);\n    }\n  } else if (typeof androidSettings !== 'undefined') {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        fireauth.ActionCodeSettings.RawField.ANDROID +\n        ' property must be a non null object when specified.');\n  }\n\n  // Validate iOS parameters.\n  /** @private {?string} The iOS bundle ID. */\n  this.ibi_ = null;\n  var iosSettings = settingsObj[fireauth.ActionCodeSettings.RawField.IOS];\n  if (iosSettings && typeof iosSettings === 'object') {\n    var ibi = iosSettings[\n      fireauth.ActionCodeSettings.IosRawField.BUNDLE_ID];\n    if (typeof ibi === 'string' && ibi.length) {\n      this.ibi_ = /** @type {string}*/ (ibi);\n    } else if (typeof ibi !== 'undefined') {\n      throw new fireauth.AuthError(\n          fireauth.authenum.Error.ARGUMENT_ERROR,\n          fireauth.ActionCodeSettings.IosRawField.BUNDLE_ID +\n          ' property must be a non empty string when specified.');\n    }\n  } else if (typeof iosSettings !== 'undefined') {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        fireauth.ActionCodeSettings.RawField.IOS +\n        ' property must be a non null object when specified.');\n  }\n\n  // Validate canHandleCodeInApp.\n  var canHandleCodeInApp =\n      settingsObj[fireauth.ActionCodeSettings.RawField.HANDLE_CODE_IN_APP];\n  if (typeof canHandleCodeInApp !== 'undefined' &&\n      typeof canHandleCodeInApp !== 'boolean') {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        fireauth.ActionCodeSettings.RawField.HANDLE_CODE_IN_APP +\n        ' property must be a boolean when specified.');\n  }\n  /** @const @private {boolean} Whether the code can be handled in app. */\n  this.canHandleCodeInApp_ = !!canHandleCodeInApp;\n\n  // Validate dynamicLinkDomain.\n  var dynamicLinkDomain = settingsObj[\n      fireauth.ActionCodeSettings.RawField.DYNAMIC_LINK_DOMAIN];\n  if (typeof dynamicLinkDomain !== 'undefined' &&\n      (typeof dynamicLinkDomain !== 'string' ||\n       (typeof dynamicLinkDomain === 'string' &&\n        !dynamicLinkDomain.length))) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        fireauth.ActionCodeSettings.RawField.DYNAMIC_LINK_DOMAIN +\n        ' property must be a non empty string when specified.');\n  }\n  /** @const @private {?string} The FDL domain. */\n  this.dynamicLinkDomain_ = dynamicLinkDomain || null;\n};\n\n\n/**\n * Action code settings backend request field names.\n * @enum {string}\n */\nfireauth.ActionCodeSettings.RequestField = {\n  ANDROID_INSTALL_APP: 'androidInstallApp',\n  ANDROID_MINIMUM_VERSION: 'androidMinimumVersion',\n  ANDROID_PACKAGE_NAME: 'androidPackageName',\n  CAN_HANDLE_CODE_IN_APP: 'canHandleCodeInApp',\n  CONTINUE_URL: 'continueUrl',\n  DYNAMIC_LINK_DOMAIN: 'dynamicLinkDomain',\n  IOS_BUNDLE_ID: 'iOSBundleId'\n};\n\n\n/**\n * Action code settings raw field names.\n * @enum {string}\n */\nfireauth.ActionCodeSettings.RawField = {\n  ANDROID: 'android',\n  DYNAMIC_LINK_DOMAIN: 'dynamicLinkDomain',\n  HANDLE_CODE_IN_APP: 'handleCodeInApp',\n  IOS: 'iOS',\n  URL: 'url'\n};\n\n\n/**\n * Action code settings raw Android raw field names.\n * @enum {string}\n */\nfireauth.ActionCodeSettings.AndroidRawField = {\n  INSTALL_APP: 'installApp',\n  MINIMUM_VERSION: 'minimumVersion',\n  PACKAGE_NAME: 'packageName'\n};\n\n\n/**\n * Action code settings raw iOS raw field names.\n * @enum {string}\n */\nfireauth.ActionCodeSettings.IosRawField = {\n  BUNDLE_ID: 'bundleId'\n};\n\n\n/**\n * Builds and returns the backend request for the passed action code settings.\n * @return {!Object} The constructed backend request populated with the action\n *     code settings parameters.\n */\nfireauth.ActionCodeSettings.prototype.buildRequest = function() {\n  // Construct backend request.\n  var request = {};\n  request[fireauth.ActionCodeSettings.RequestField.CONTINUE_URL] =\n      this.continueUrl_;\n  request[fireauth.ActionCodeSettings.RequestField.CAN_HANDLE_CODE_IN_APP] =\n      this.canHandleCodeInApp_;\n  request[fireauth.ActionCodeSettings.RequestField.ANDROID_PACKAGE_NAME] =\n      this.apn_;\n  if (this.apn_) {\n    request[fireauth.ActionCodeSettings.RequestField.ANDROID_MINIMUM_VERSION] =\n        this.amv_;\n    request[fireauth.ActionCodeSettings.RequestField.ANDROID_INSTALL_APP] =\n        this.installApp_;\n  }\n  request[fireauth.ActionCodeSettings.RequestField.IOS_BUNDLE_ID] = this.ibi_;\n  request[fireauth.ActionCodeSettings.RequestField.DYNAMIC_LINK_DOMAIN] =\n      this.dynamicLinkDomain_;\n  // Remove null fields.\n  for (var key in request) {\n    if (request[key] === null) {\n      delete request[key];\n    }\n  }\n  return request;\n};\n\n\n/**\n * Returns the canHandleCodeInApp setting of ActionCodeSettings.\n * @return {boolean} Whether the code can be handled in app.\n */\nfireauth.ActionCodeSettings.prototype.canHandleCodeInApp = function() {\n  return this.canHandleCodeInApp_;\n};\n","// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Base64 en/decoding. Not much to say here except that we\n * work with decoded values in arrays of bytes. By \"byte\" I mean a number\n * in [0, 255].\n *\n * @author doughtie@google.com (Gavin Doughtie)\n */\n\ngoog.provide('goog.crypt.base64');\n\ngoog.require('goog.asserts');\ngoog.require('goog.crypt');\ngoog.require('goog.string');\ngoog.require('goog.userAgent');\ngoog.require('goog.userAgent.product');\n\n// Static lookup maps, lazily populated by init_()\n\n\n/**\n * Maps bytes to characters.\n * @type {?Object}\n * @private\n */\ngoog.crypt.base64.byteToCharMap_ = null;\n\n\n/**\n * Maps characters to bytes. Used for normal and websafe characters.\n * @type {?Object}\n * @private\n */\ngoog.crypt.base64.charToByteMap_ = null;\n\n\n/**\n * Maps bytes to websafe characters.\n * @type {?Object}\n * @private\n */\ngoog.crypt.base64.byteToCharMapWebSafe_ = null;\n\n\n/**\n * Our default alphabet, shared between\n * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n    'abcdefghijklmnopqrstuvwxyz' +\n    '0123456789';\n\n\n/**\n * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS = goog.crypt.base64.ENCODED_VALS_BASE + '+/=';\n\n\n/**\n * Our websafe alphabet.\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_WEBSAFE =\n    goog.crypt.base64.ENCODED_VALS_BASE + '-_.';\n\n\n/**\n * White list of implementations with known-good native atob and btoa functions.\n * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code\n * removal in per-browser compilations.\n * @private {boolean}\n */\ngoog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO ||\n    (goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI) ||\n    goog.userAgent.OPERA;\n\n\n/**\n * Does this browser have a working btoa function?\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_ENCODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    typeof(goog.global.btoa) == 'function';\n\n\n/**\n * Does this browser have a working atob function?\n * We blacklist known-bad implementations:\n *  - IE (10+) added atob() but it does not tolerate whitespace on the input.\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_DECODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&\n     typeof(goog.global.atob) == 'function');\n\n\n/**\n * Base64-encode an array of bytes.\n *\n * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n *     value in [0, 255]) to encode.\n * @param {boolean=} opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeByteArray = function(input, opt_webSafe) {\n  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce\n  // size of jscompiler output, and which yields slight performance increase.\n  goog.asserts.assert(\n      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');\n\n  goog.crypt.base64.init_();\n\n  var byteToCharMap = opt_webSafe ? goog.crypt.base64.byteToCharMapWebSafe_ :\n                                    goog.crypt.base64.byteToCharMap_;\n\n  var output = [];\n\n  for (var i = 0; i < input.length; i += 3) {\n    var byte1 = input[i];\n    var haveByte2 = i + 1 < input.length;\n    var byte2 = haveByte2 ? input[i + 1] : 0;\n    var haveByte3 = i + 2 < input.length;\n    var byte3 = haveByte3 ? input[i + 2] : 0;\n\n    var outByte1 = byte1 >> 2;\n    var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n    var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);\n    var outByte4 = byte3 & 0x3F;\n\n    if (!haveByte3) {\n      outByte4 = 64;\n\n      if (!haveByte2) {\n        outByte3 = 64;\n      }\n    }\n\n    output.push(\n        byteToCharMap[outByte1], byteToCharMap[outByte2],\n        byteToCharMap[outByte3], byteToCharMap[outByte4]);\n  }\n\n  return output.join('');\n};\n\n\n/**\n * Base64-encode a string.\n *\n * @param {string} input A string to encode.\n * @param {boolean=} opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeString = function(input, opt_webSafe) {\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !opt_webSafe) {\n    return goog.global.btoa(input);\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToByteArray(input), opt_webSafe);\n};\n\n\n/**\n * Base64-decode a string.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs. Note that\n *     passing false may also still allow webSafe input decoding, when the\n *     fallback decoder is used on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeString = function(input, opt_webSafe) {\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !opt_webSafe) {\n    return goog.global.atob(input);\n  }\n  var output = '';\n  function pushByte(b) { output += String.fromCharCode(b); }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to an Array of numbers.\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.\n * @return {!Array<number>} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {\n  var output = [];\n  function pushByte(b) { output.push(b); }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to a Uint8Array.\n *\n * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.\n * @see http://caniuse.com/uint8array\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @return {!Uint8Array} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToUint8Array = function(input) {\n  goog.asserts.assert(\n      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher('10'),\n      'Browser does not support typed arrays');\n  var len = input.length;\n  // Approximate the length of the array needed for output.\n  // Our method varies according to the format of the input, which we can\n  // consider in three categories:\n  //   A) well-formed with proper padding\n  //   B) well-formed without any padding\n  //   C) not-well-formed, either with extra whitespace in the middle or with\n  //      extra padding characters.\n  //\n  //  In the case of (A), (length * 3 / 4) will result in an integer number of\n  //  bytes evenly divisible by 3, and we need only subtract bytes according to\n  //  the padding observed.\n  //\n  //  In the case of (B), (length * 3 / 4) will result in a non-integer number\n  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible\n  //  by 3, it's well-formed with the proper amount of padding [0 padding]).\n  //  This approximation can become exact by rounding down.\n  //\n  //  In the case of (C), the only way to get the length is to walk the full\n  //  length of the string to consider each character. This is handled by\n  //  tracking the number of bytes added to the array and using subarray to\n  //  trim the array back down to size.\n  var approxByteLength = len * 3 / 4;\n  if (approxByteLength % 3) {\n    // The string isn't complete, either because it didn't include padding, or\n    // because it has extra white space.\n    // In either case, we won't generate more bytes than are completely encoded,\n    // so rounding down is appropriate to have a buffer at least as large as\n    // output.\n    approxByteLength = Math.floor(approxByteLength);\n  } else if (input[len - 1] === '=') {\n    // The string has a round length, and has some padding.\n    // Reduce the byte length according to the quantity of padding.\n    if (input[len - 2] === '=') {\n      approxByteLength -= 2;\n    } else {\n      approxByteLength -= 1;\n    }\n  }\n  var output = new Uint8Array(approxByteLength);\n  var outLen = 0;\n  function pushByte(b) {\n    output[outLen++] = b;\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  // Return a subarray to handle the case that input included extra whitespace\n  // or extra padding and approxByteLength was incorrect.\n  return output.subarray(0, outLen);\n};\n\n\n/**\n * @param {string} input Input to decode.\n * @param {function(number):void} pushByte result accumulator.\n * @private\n */\ngoog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {\n  goog.crypt.base64.init_();\n\n  var nextCharIndex = 0;\n  /**\n   * @param {number} default_val Used for end-of-input.\n   * @return {number} The next 6-bit value, or the default for end-of-input.\n   */\n  function getByte(default_val) {\n    while (nextCharIndex < input.length) {\n      var ch = input.charAt(nextCharIndex++);\n      var b = goog.crypt.base64.charToByteMap_[ch];\n      if (b != null) {\n        return b;  // Common case: decoded the char.\n      }\n      if (!goog.string.isEmptyOrWhitespace(ch)) {\n        throw new Error('Unknown base64 encoding at char: ' + ch);\n      }\n      // We encountered whitespace: loop around to the next input char.\n    }\n    return default_val;  // No more input remaining.\n  }\n\n  while (true) {\n    var byte1 = getByte(-1);\n    var byte2 = getByte(0);\n    var byte3 = getByte(64);\n    var byte4 = getByte(64);\n\n    // The common case is that all four bytes are present, so if we have byte4\n    // we can skip over the truncated input special case handling.\n    if (byte4 === 64) {\n      if (byte1 === -1) {\n        return;  // Terminal case: no input left to decode.\n      }\n      // Here we know an intermediate number of bytes are missing.\n      // The defaults for byte2, byte3 and byte4 apply the inferred padding\n      // rules per the public API documentation. i.e: 1 byte\n      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield\n      // a single byte of output. (Recall that 64 corresponds the padding char).\n    }\n\n    var outByte1 = (byte1 << 2) | (byte2 >> 4);\n    pushByte(outByte1);\n\n    if (byte3 != 64) {\n      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);\n      pushByte(outByte2);\n\n      if (byte4 != 64) {\n        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;\n        pushByte(outByte3);\n      }\n    }\n  }\n};\n\n\n/**\n * Lazy static initialization function. Called before\n * accessing any of the static map variables.\n * @private\n */\ngoog.crypt.base64.init_ = function() {\n  if (!goog.crypt.base64.byteToCharMap_) {\n    goog.crypt.base64.byteToCharMap_ = {};\n    goog.crypt.base64.charToByteMap_ = {};\n    goog.crypt.base64.byteToCharMapWebSafe_ = {};\n\n    // We want quick mappings back and forth, so we precompute two maps.\n    for (var i = 0; i < goog.crypt.base64.ENCODED_VALS.length; i++) {\n      goog.crypt.base64.byteToCharMap_[i] =\n          goog.crypt.base64.ENCODED_VALS.charAt(i);\n      goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[i]] = i;\n      goog.crypt.base64.byteToCharMapWebSafe_[i] =\n          goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i);\n\n      // Be forgiving when decoding and correctly decode both encodings.\n      if (i >= goog.crypt.base64.ENCODED_VALS_BASE.length) {\n        goog.crypt.base64\n            .charToByteMap_[goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i)] =\n            i;\n      }\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Utility functions to handle Firebase Auth ID tokens.\n */\n\ngoog.provide('fireauth.IdToken');\n\ngoog.require('goog.crypt.base64');\n\n\n/**\n * Parses the token string into a {@code Token} object.\n * @param {!fireauth.IdToken.JsonToken} token The parsed JSON token.\n * @constructor\n */\nfireauth.IdToken = function(token) {\n  /** @const @private {string} The issuer of the token. */\n  this.iss_ = token['iss'];\n  /** @const @private {string} The audience of the token. */\n  this.aud_ = token['aud'];\n  /** @const @private {number} The expire time in seconds of the token. */\n  this.exp_ = token['exp'];\n  /** @const @private {string} The local user ID of the token. */\n  this.localId_ = token['sub'];\n  var now = goog.now() / 1000;\n  /** @const @private {number} The issue time in seconds of the token. */\n  this.iat_ = token['iat'] || (now > this.exp_ ? this.exp_ : now);\n  /** @const @private {?string} The email address of the token. */\n  this.email_ = token['email'] || null;\n  /** @const @private {boolean} Whether the user is verified. */\n  this.verified_ = !!token['verified'];\n  /** @const @private {?string} The provider ID of the token. */\n  this.providerId_ = token['provider_id'] ||\n      (token['firebase'] && token['firebase']['sign_in_provider']) ||\n      null;\n  /** @const @private {?string} The tenant ID of the token. */\n  this.tenantId_ = (token['firebase'] && token['firebase']['tenant']) || null;\n  /** @const @private {boolean} Whether the user is anonymous. */\n  this.anonymous_ = !!token['is_anonymous'] || this.providerId_ == 'anonymous';\n  /** @const @private {?string} The federated ID of the token. */\n  this.federatedId_ = token['federated_id'] || null;\n  /** @const @private {?string} The display name of the token. */\n  this.displayName_ = token['display_name'] || null;\n  /** @const @private {?string} The photo URL of the token. */\n  this.photoURL_ = token['photo_url'] || null;\n  /**\n   * @const @private {?string} The phone number of the user identified by the\n   *     token.\n   */\n  this.phoneNumber_ = token['phone_number'] || null;\n};\n\n\n/**\n * @typedef {{\n *   identities: (?Object|undefined),\n *   sign_in_provider: (?string|undefined),\n *   tenant: (string|undefined)\n * }}\n */\nfireauth.IdToken.Firebase;\n\n\n/**\n * @typedef {{\n *   iss: string,\n *   aud: string,\n *   exp: number,\n *   sub: string,\n *   iat: (?number|undefined),\n *   email: (?string|undefined),\n *   verified: (?boolean|undefined),\n *   provider_id: (?string|undefined),\n *   is_anonymous: (?boolean|undefined),\n *   federated_id: (?string|undefined),\n *   display_name: (?string|undefined),\n *   photo_url: (?string|undefined),\n *   phone_number: (?string|undefined),\n *   firebase: (?fireauth.IdToken.Firebase|undefined)\n * }}\n */\nfireauth.IdToken.JsonToken;\n\n\n/** @return {?string} The email address of the account. */\nfireauth.IdToken.prototype.getEmail = function() {\n  return this.email_;\n};\n\n\n/** @return {number} The expire time in seconds. */\nfireauth.IdToken.prototype.getExp = function() {\n  return this.exp_;\n};\n\n\n/** @return {?string} The ID of the identity provider. */\nfireauth.IdToken.prototype.getProviderId = function() {\n  return this.providerId_;\n};\n\n\n/** @return {?string} The tenant ID. */\nfireauth.IdToken.prototype.getTenantId = function() {\n  return this.tenantId_;\n};\n\n\n/** @return {?string} The display name of the account. */\nfireauth.IdToken.prototype.getDisplayName = function() {\n  return this.displayName_;\n};\n\n\n/** @return {?string} The photo URL of the account. */\nfireauth.IdToken.prototype.getPhotoUrl = function() {\n  return this.photoURL_;\n};\n\n\n/** @return {string} The user ID of the account. */\nfireauth.IdToken.prototype.getLocalId = function() {\n  return this.localId_;\n};\n\n\n/** @return {?string} The federated ID of the account. */\nfireauth.IdToken.prototype.getFederatedId = function() {\n  return this.federatedId_;\n};\n\n\n/** @return {boolean} Whether the user is anonymous. */\nfireauth.IdToken.prototype.isAnonymous = function() {\n  return this.anonymous_;\n};\n\n\n/** @return {boolean} Whether the user email is verified. */\nfireauth.IdToken.prototype.isVerified = function() {\n  return this.verified_;\n};\n\n\n/** @return {boolean} Whether token is expired. */\nfireauth.IdToken.prototype.isExpired = function() {\n  var now = Math.floor(goog.now() / 1000);\n  // It is expired if token expiration time is less than current time.\n  return this.getExp() <= now;\n};\n\n\n/** @return {string} The issuer of the token. */\nfireauth.IdToken.prototype.getIssuer = function() {\n  return this.iss_;\n};\n\n\n/** @return {?string} The phone number of the account. */\nfireauth.IdToken.prototype.getPhoneNumber = function() {\n  return this.phoneNumber_;\n};\n\n\n/**\n * Parses the JWT token and extracts the information part without verifying the\n * token signature.\n * @param {string} tokenString The JWT token.\n * @return {?fireauth.IdToken} The decoded token.\n */\nfireauth.IdToken.parse = function(tokenString) {\n  var token = fireauth.IdToken.parseIdTokenClaims(tokenString);\n  if (token && token['sub'] && token['iss'] && token['aud'] && token['exp']) {\n    return new fireauth.IdToken(\n        /** @type {!fireauth.IdToken.JsonToken} */ (token));\n  }\n  return null;\n};\n\n/**\n * Converts the information part of JWT token to plain object format.\n * @param {?string} tokenString The JWT token.\n * @return {?Object}\n */\nfireauth.IdToken.parseIdTokenClaims = function(tokenString) {\n  if (!tokenString) {\n    return null;\n  }\n  // Token format is <algorithm>.<info>.<sig>\n  var fields = tokenString.split('.');\n  if (fields.length != 3) {\n    return null;\n  }\n  var jsonInfo = fields[1];\n  // Google base64 library does not handle padding.\n  var padLen = (4 - jsonInfo.length % 4) % 4;\n  for (var i = 0; i < padLen; i++) {\n    jsonInfo += '.';\n  }\n  try {\n    var token = JSON.parse(goog.crypt.base64.decodeString(jsonInfo, true));\n    return /** @type {?Object} */ (token);\n  } catch (e) {}\n  return null;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines all common constants and enums used by firebase-auth.\n */\n\ngoog.provide('fireauth.constants');\ngoog.provide('fireauth.constants.AuthEventType');\n\n\n/**\n * Enums for authentication operation types.\n * @enum {string}\n */\nfireauth.constants.OperationType = {\n  LINK: 'link',\n  REAUTHENTICATE: 'reauthenticate',\n  SIGN_IN: 'signIn'\n};\n\n\n/**\n * Events dispatched firebase.auth.Auth.\n * @enum {string}\n */\nfireauth.constants.AuthEventType = {\n  /** Dispatched when Firebase framework is changed. */\n  FRAMEWORK_CHANGED: 'frameworkChanged',\n  /** Dispatched when language code is changed. */\n  LANGUAGE_CODE_CHANGED: 'languageCodeChanged'\n};\n\n\n/**\n * The settings of an Auth endpoint. The fields are:\n * <ul>\n * <li>firebaseAuthEndpoint: defines the Firebase Auth backend endpoint for\n *     specified endpoint type.</li>\n * <li>secureTokenEndpoint: defines the secure token backend endpoint for\n *     specified endpoint type.</li>\n * <li>id: defines the endpoint identifier.</li>\n * </ul>\n * @typedef {{\n *   firebaseAuthEndpoint: string,\n *   secureTokenEndpoint: string,\n *   id: string\n * }}\n */\nfireauth.constants.EndpointSettings;\n\n\n/**\n * The different endpoints for Firebase Auth backend.\n * @enum {!fireauth.constants.EndpointSettings}\n */\nfireauth.constants.Endpoint = {\n  PRODUCTION: {\n    firebaseAuthEndpoint: 'https://www.googleapis.com/identitytoolkit/v3/' +\n        'relyingparty/',\n    secureTokenEndpoint: 'https://securetoken.googleapis.com/v1/token',\n    id: 'p'\n  },\n  STAGING: {\n    firebaseAuthEndpoint: 'https://staging-www.sandbox.googleapis.com/' +\n        'identitytoolkit/v3/relyingparty/',\n    secureTokenEndpoint: 'https://staging-securetoken.sandbox.googleapis.com' +\n        '/v1/token',\n    id: 's'\n  },\n  TEST: {\n    firebaseAuthEndpoint: 'https://www-googleapis-test.sandbox.google.com/' +\n        'identitytoolkit/v3/relyingparty/',\n    secureTokenEndpoint: 'https://test-securetoken.sandbox.googleapis.com/v1' +\n        '/token',\n    id: 't'\n  }\n};\n\n\n/**\n * Returns the endpoint specific RpcHandler configuration.\n * @param {?string=} opt_id The identifier of the endpoint type if available.\n * @return {?Object|undefined} The RpcHandler endpoint configuration object.\n */\nfireauth.constants.getEndpointConfig = function(opt_id) {\n  for (var endpointKey in fireauth.constants.Endpoint) {\n    if (fireauth.constants.Endpoint[endpointKey].id === opt_id) {\n      var endpoint = fireauth.constants.Endpoint[endpointKey];\n      return {\n        'firebaseEndpoint': endpoint.firebaseAuthEndpoint,\n        'secureTokenEndpoint': endpoint.secureTokenEndpoint\n      };\n    }\n  }\n  return null;\n};\n\n\n/**\n * Returns the validated endpoint identifier. Undefined if the provided one is\n * invalid.\n * @param {?string=} opt_id The identifier of the endpoint type if available.\n * @return {string|undefined} The validated endpoint ID. If not valid,\n *     undefined.\n */\nfireauth.constants.getEndpointId = function(opt_id) {\n  if (opt_id && fireauth.constants.getEndpointConfig(opt_id)) {\n    return opt_id;\n  }\n  return undefined;\n};\n\n\n/** @const {string|undefined} The current client endpoint. */\nfireauth.constants.clientEndpoint = fireauth.constants.getEndpointId('__EID__');\n\n\n/** @const {string} The required SAML provider ID prefix. */\nfireauth.constants.SAML_PREFIX = 'saml.';\n\n\n/** @const {string} The required OIDC provider ID prefix. */\nfireauth.constants.OIDC_PREFIX = 'oidc.';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the IdP provider IDs and related settings.\n */\n\ngoog.provide('fireauth.idp');\ngoog.provide('fireauth.idp.IdpSettings');\ngoog.provide('fireauth.idp.ProviderId');\ngoog.provide('fireauth.idp.Settings');\ngoog.provide('fireauth.idp.SignInMethod');\n\ngoog.require('fireauth.constants');\n\n\n/**\n * Enums for supported provider IDs. These provider IDs correspond to the\n * sign_in_provider in the Firebase ID token and do not correspond to the\n * supported client exposed firebase.auth.AuthProviders.\n * @enum {string}\n */\nfireauth.idp.ProviderId = {\n  ANONYMOUS: 'anonymous',\n  CUSTOM: 'custom',\n  FACEBOOK: 'facebook.com',\n  FIREBASE: 'firebase',\n  GITHUB: 'github.com',\n  GOOGLE: 'google.com',\n  PASSWORD: 'password',\n  PHONE: 'phone',\n  TWITTER: 'twitter.com'\n};\n\n\n/**\n * Enums for supported sign in methods.\n * @enum {string}\n */\nfireauth.idp.SignInMethod = {\n  EMAIL_LINK: 'emailLink',\n  EMAIL_PASSWORD: 'password',\n  FACEBOOK: 'facebook.com',\n  GITHUB: 'github.com',\n  GOOGLE: 'google.com',\n  PHONE: 'phone',\n  TWITTER: 'twitter.com'\n};\n\n\n/**\n * The settings of an identity provider. The fields are:\n * <ul>\n * <li>languageParam: defines the custom OAuth language parameter.\n * <li>popupWidth: defines the popup recommended width.\n * <li>popupHeight: defines the popup recommended height.\n * <li>providerId: defines the provider ID.\n * <li>reservedOAuthParameters: defines the list of reserved OAuth parameters.\n * </ul>\n * @typedef {{\n *   languageParam: (?string|undefined),\n *   popupWidth: (?number|undefined),\n *   popupHeight: (?number|undefined),\n *   providerId: !fireauth.idp.ProviderId,\n *   reservedOAuthParameters: !Array<string>\n * }}\n */\nfireauth.idp.IdpSettings;\n\n\n/**\n * The list of reserved OAuth 1.0 parameters.\n * @const {!Array<string>}\n */\nfireauth.idp.RESERVED_OAUTH1_PARAMS =\n    ['oauth_consumer_key', 'oauth_nonce', 'oauth_signature',\n     'oauth_signature_method', 'oauth_timestamp', 'oauth_token',\n     'oauth_version'];\n\n\n/**\n * The list of reserved OAuth 2.0 parameters.\n * @const {!Array<string>}\n */\nfireauth.idp.RESERVED_OAUTH2_PARAMS =\n    ['client_id', 'response_type', 'scope', 'redirect_uri', 'state'];\n\n\n/**\n * The recommendations for the different IdP display settings.\n * @enum {!fireauth.idp.IdpSettings}\n */\nfireauth.idp.Settings = {\n  FACEBOOK: {\n    languageParam: 'locale',\n    popupWidth: 500,\n    popupHeight: 600,\n    providerId: fireauth.idp.ProviderId.FACEBOOK,\n    reservedOAuthParameters: fireauth.idp.RESERVED_OAUTH2_PARAMS\n  },\n  GITHUB: {\n    languageParam: null,\n    popupWidth: 500,\n    popupHeight: 620,\n    providerId: fireauth.idp.ProviderId.GITHUB,\n    reservedOAuthParameters: fireauth.idp.RESERVED_OAUTH2_PARAMS\n  },\n  GOOGLE: {\n    languageParam: 'hl',\n    popupWidth: 515,\n    popupHeight: 680,\n    providerId: fireauth.idp.ProviderId.GOOGLE,\n    reservedOAuthParameters: fireauth.idp.RESERVED_OAUTH2_PARAMS\n  },\n  TWITTER: {\n    languageParam: 'lang',\n    popupWidth: 485,\n    popupHeight: 705,\n    providerId: fireauth.idp.ProviderId.TWITTER,\n    reservedOAuthParameters: fireauth.idp.RESERVED_OAUTH1_PARAMS\n  }\n};\n\n\n/**\n * @param {!fireauth.idp.ProviderId} providerId The requested provider ID.\n * @return {?fireauth.idp.Settings} The settings for the requested provider ID.\n */\nfireauth.idp.getIdpSettings = function(providerId) {\n  for (var key in fireauth.idp.Settings) {\n    if (fireauth.idp.Settings[key].providerId == providerId) {\n      return fireauth.idp.Settings[key];\n    }\n  }\n  return null;\n};\n\n\n/**\n * @param {!fireauth.idp.ProviderId} providerId The requested provider ID.\n * @return {!Array<string>} The list of reserved OAuth parameters.\n */\nfireauth.idp.getReservedOAuthParams = function(providerId) {\n  var settings = fireauth.idp.getIdpSettings(providerId);\n  return (settings && settings.reservedOAuthParameters) || [];\n};\n\n\n/**\n * @param {?string|undefined} identifier The provider identifier.\n * @return {boolean} Whether the identifier provided is a SAML provider ID.\n */\nfireauth.idp.isSaml = function(identifier) {\n   return typeof identifier === 'string' &&\n     identifier.indexOf(fireauth.constants.SAML_PREFIX) == 0;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines all the fireauth additional user info interfaces,\n * implementations and subclasses.\n */\n\ngoog.provide('fireauth.AdditionalUserInfo');\ngoog.provide('fireauth.FacebookAdditionalUserInfo');\ngoog.provide('fireauth.FederatedAdditionalUserInfo');\ngoog.provide('fireauth.GenericAdditionalUserInfo');\ngoog.provide('fireauth.GithubAdditionalUserInfo');\ngoog.provide('fireauth.GoogleAdditionalUserInfo');\ngoog.provide('fireauth.TwitterAdditionalUserInfo');\n\ngoog.require('fireauth.IdToken');\ngoog.require('fireauth.idp');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\n\n\n/**\n * The interface that represents additional user info.\n * @interface\n */\nfireauth.AdditionalUserInfo = function() {};\n\n\n/**\n * Constructs the corresponding additional user info for the backend\n * verifyAssertion response.\n * @param {?Object|undefined} resp The backend verifyAssertion,\n *     verifyPhoneNumber or verifyPassword/setAccountInfo response.\n * @return {?fireauth.AdditionalUserInfo} The fireauth.AdditionalUserInfo\n *     instance.\n */\nfireauth.AdditionalUserInfo.fromPlainObject = function(resp) {\n  var factory = {};\n  factory[fireauth.idp.ProviderId.FACEBOOK] =\n      fireauth.FacebookAdditionalUserInfo;\n  factory[fireauth.idp.ProviderId.GOOGLE] =\n      fireauth.GoogleAdditionalUserInfo;\n  factory[fireauth.idp.ProviderId.GITHUB] =\n      fireauth.GithubAdditionalUserInfo;\n  factory[fireauth.idp.ProviderId.TWITTER] =\n      fireauth.TwitterAdditionalUserInfo;\n  // Provider ID and UID are required.\n  var providerId =\n      resp &&\n      resp[fireauth.AdditionalUserInfo.VerifyAssertionField.PROVIDER_ID];\n  try {\n    // Provider ID already present.\n    if (providerId) {\n      if (factory[providerId]) {\n        // 1st class supported federated providers.\n        return new factory[providerId](resp);\n      } else {\n        // Generic federated providers.\n        return new fireauth.FederatedAdditionalUserInfo(\n            /** @type {!Object} */ (resp));\n      }\n    } else if (typeof resp[fireauth.AdditionalUserInfo.VerifyAssertionField\n                           .ID_TOKEN] !== 'undefined') {\n      // For all other ID token responses with no providerId, get the required\n      // providerId from the ID token itself.\n      return new fireauth.GenericAdditionalUserInfo(\n          /** @type {!Object} */ (resp));\n    }\n  } catch (e) {\n    // Do nothing, null will be returned.\n  }\n  return null;\n};\n\n\n\n/**\n * verifyAssertion response additional user info fields.\n * @enum {string}\n */\nfireauth.AdditionalUserInfo.VerifyAssertionField = {\n  ID_TOKEN: 'idToken',\n  IS_NEW_USER: 'isNewUser',\n  KIND: 'kind',\n  PROVIDER_ID: 'providerId',\n  RAW_USER_INFO: 'rawUserInfo',\n  SCREEN_NAME: 'screenName'\n};\n\n\n/**\n * Constructs a generic additional user info object from the backend\n * verifyPhoneNumber and verifyPassword provider response.\n * @param {!Object} info The verifyPhoneNumber/verifyPassword/setAccountInfo\n *     response data object.\n * @constructor\n * @implements {fireauth.AdditionalUserInfo}\n */\nfireauth.GenericAdditionalUserInfo = function(info) {\n  // Federated provider profile data.\n  var providerId =\n      info[fireauth.AdditionalUserInfo.VerifyAssertionField.PROVIDER_ID];\n  // Try to get providerId from the ID token if available.\n  if (!providerId &&\n      info[fireauth.AdditionalUserInfo.VerifyAssertionField.ID_TOKEN]) {\n    // verifyPassword/setAccountInfo and verifyPhoneNumber return an ID token\n    // but no providerId. Get providerId from the token itself.\n    // isNewUser will be returned for verifyPhoneNumber.\n    var idToken = fireauth.IdToken.parse(\n        info[fireauth.AdditionalUserInfo.VerifyAssertionField.ID_TOKEN]);\n    if (idToken && idToken.getProviderId()) {\n      providerId = idToken.getProviderId();\n    }\n  }\n  if (!providerId) {\n    // This is internal only.\n    throw new Error('Invalid additional user info!');\n  }\n  // For custom token and anonymous token, set provider ID to null.\n  if (providerId == fireauth.idp.ProviderId.ANONYMOUS ||\n      providerId == fireauth.idp.ProviderId.CUSTOM) {\n      providerId = null;\n  }\n  // Check whether user is new. Temporary Solution since backend does not return\n  // isNewUser field for SignupNewUserResponse.\n  var isNewUser = false;\n  if (typeof info[fireauth.AdditionalUserInfo.VerifyAssertionField.IS_NEW_USER]\n      !== 'undefined') {\n    isNewUser =\n        !!info[fireauth.AdditionalUserInfo.VerifyAssertionField.IS_NEW_USER];\n  } else if (info[fireauth.AdditionalUserInfo.VerifyAssertionField.KIND]\n             === 'identitytoolkit#SignupNewUserResponse') {\n    //For SignupNewUserResponse, always set isNewUser to true.\n    isNewUser = true;\n  }\n  // Set required providerId.\n  fireauth.object.setReadonlyProperty(this, 'providerId', providerId);\n  // Set read-only isNewUser property.\n  fireauth.object.setReadonlyProperty(this, 'isNewUser', isNewUser);\n};\n\n\n/**\n * Constructs a federated additional user info object from the backend\n * verifyAssertion federated provider response.\n * @param {!Object} info The verifyAssertion response data object.\n * @constructor\n * @extends {fireauth.GenericAdditionalUserInfo}\n */\nfireauth.FederatedAdditionalUserInfo = function(info) {\n  fireauth.FederatedAdditionalUserInfo.base(this, 'constructor', info);\n  // Federated provider profile data.\n  // This structure will also be used for generic IdPs.\n  var profile = fireauth.util.parseJSON(\n      info[fireauth.AdditionalUserInfo.VerifyAssertionField.RAW_USER_INFO] ||\n      '{}');\n  // Set read-only profile property.\n  fireauth.object.setReadonlyProperty(\n      this,\n      'profile',\n      fireauth.object.unsafeCreateReadOnlyCopy(profile || {}));\n};\ngoog.inherits(\n    fireauth.FederatedAdditionalUserInfo, fireauth.GenericAdditionalUserInfo);\n\n\n/**\n * Constructs a Facebook additional user info object from the backend\n * verifyAssertion Facebook provider response.\n * @param {!Object} info The verifyAssertion response data object.\n * @constructor\n * @extends {fireauth.FederatedAdditionalUserInfo}\n */\nfireauth.FacebookAdditionalUserInfo = function(info) {\n  fireauth.FacebookAdditionalUserInfo.base(this, 'constructor', info);\n  // This should not happen as this object is initialized via fromPlainObject.\n  if (this['providerId'] != fireauth.idp.ProviderId.FACEBOOK) {\n    throw new Error('Invalid provider ID!');\n  }\n};\ngoog.inherits(\n    fireauth.FacebookAdditionalUserInfo, fireauth.FederatedAdditionalUserInfo);\n\n\n\n/**\n * Constructs a GitHub additional user info object from the backend\n * verifyAssertion GitHub provider response.\n * @param {!Object} info The verifyAssertion response data object.\n * @constructor\n * @extends {fireauth.FederatedAdditionalUserInfo}\n */\nfireauth.GithubAdditionalUserInfo = function(info) {\n  fireauth.GithubAdditionalUserInfo.base(this, 'constructor', info);\n  // This should not happen as this object is initialized via fromPlainObject.\n  if (this['providerId'] != fireauth.idp.ProviderId.GITHUB) {\n    throw new Error('Invalid provider ID!');\n  }\n  // GitHub username.\n  fireauth.object.setReadonlyProperty(\n      this,\n      'username',\n      (this['profile'] && this['profile']['login']) || null);\n};\ngoog.inherits(\n    fireauth.GithubAdditionalUserInfo, fireauth.FederatedAdditionalUserInfo);\n\n\n\n/**\n * Constructs a Google additional user info object from the backend\n * verifyAssertion Google provider response.\n * @param {!Object} info The verifyAssertion response data object.\n * @constructor\n * @extends {fireauth.FederatedAdditionalUserInfo}\n */\nfireauth.GoogleAdditionalUserInfo = function(info) {\n  fireauth.GoogleAdditionalUserInfo.base(this, 'constructor', info);\n  // This should not happen as this object is initialized via fromPlainObject.\n  if (this['providerId'] != fireauth.idp.ProviderId.GOOGLE) {\n    throw new Error('Invalid provider ID!');\n  }\n};\ngoog.inherits(\n    fireauth.GoogleAdditionalUserInfo, fireauth.FederatedAdditionalUserInfo);\n\n\n\n/**\n * Constructs a Twitter additional user info object from the backend\n * verifyAssertion Twitter provider response.\n * @param {!Object} info The verifyAssertion response data object.\n * @constructor\n * @extends {fireauth.FederatedAdditionalUserInfo}\n */\nfireauth.TwitterAdditionalUserInfo = function(info) {\n  fireauth.TwitterAdditionalUserInfo.base(this, 'constructor', info);\n  // This should not happen as this object is initialized via fromPlainObject.\n  if (this['providerId'] != fireauth.idp.ProviderId.TWITTER) {\n    throw new Error('Invalid provider ID!');\n  }\n  // Twitter user name.\n  fireauth.object.setReadonlyProperty(\n      this,\n      'username',\n      info[fireauth.AdditionalUserInfo.VerifyAssertionField.SCREEN_NAME] ||\n      null);\n};\ngoog.inherits(\n    fireauth.TwitterAdditionalUserInfo, fireauth.FederatedAdditionalUserInfo);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the Firebase dynamic link constructor.\n */\n\ngoog.provide('fireauth.DynamicLink');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\ngoog.require('goog.Uri');\n\n\n/**\n * Dynamic link builder used to help build the FDL link to redirect to an app\n * while passing some payload or error.\n * @param {?string} fdlDomain The FDL domain. If none is available, custom\n *     scheme redirects are used.\n * @param {!fireauth.DynamicLink.Platform} platform The FDL supported\n *     platform (Android or iOS).\n * @param {string} appIdentifier The app identifier (iOS bundle ID or Android\n *     package name).\n * @param {string} authDomain The Firebase application authDomain.\n * @param {string} payload The FDL deep link content.\n * @param {?string=} opt_clientId The optional OAuth client ID.\n * @constructor\n */\nfireauth.DynamicLink = function(fdlDomain, platform, appIdentifier, authDomain,\n    payload, opt_clientId) {\n  // The fallback error when the app is not installed on the device.\n  var defaultError =\n      new fireauth.AuthError(fireauth.authenum.Error.APP_NOT_INSTALLED);\n  /** @private {string} The fallback URL when the app is not installed. */\n  this.fallbackUrl_ = 'https://' + authDomain + '/__/auth/handler?' +\n      'firebaseError=' + encodeURIComponent(/** @type {string} */ (\n          fireauth.util.stringifyJSON(defaultError.toPlainObject())));\n  fireauth.object.setReadonlyProperty(this, 'fallbackUrl', this.fallbackUrl_);\n  /** @private {?string} The FDL domain if available. */\n  this.fdlDomain_ = fdlDomain;\n  fireauth.object.setReadonlyProperty(this, 'fdlDomain', fdlDomain);\n  /** @private {!fireauth.DynamicLink.Platform} The FDL link platform. */\n  this.platform_ = platform;\n  fireauth.object.setReadonlyProperty(this, 'platform', platform);\n  /** @private {string} The app identifier. */\n  this.appIdentifier_ = appIdentifier;\n  fireauth.object.setReadonlyProperty(this, 'appIdentifier', appIdentifier);\n  /** @private {string} The Firebase application authDomain. */\n  this.authDomain_ = authDomain;\n  fireauth.object.setReadonlyProperty(this, 'authDomain', authDomain);\n  /** @private {string} The FDL deep link content. */\n  this.link_ = payload;\n  fireauth.object.setReadonlyProperty(this, 'payload', payload);\n  /** @private {?string} The application display name. */\n  this.appName_ = null;\n  fireauth.object.setReadonlyProperty(this, 'appName', null);\n  /** @private {?string} The client ID if available. */\n  this.clientId_ = opt_clientId || null;\n  fireauth.object.setReadonlyProperty(this, 'clientId', this.clientId_);\n};\n\n\n/**\n * Sets the app name for the current dynamic link.\n * @param {?string|undefined} appName The app name typically displayed in an FDL\n *     button.\n */\nfireauth.DynamicLink.prototype.setAppName = function(appName) {\n  this.appName_ = appName || null;\n  fireauth.object.setReadonlyProperty(this, 'appName', appName);\n};\n\n\n/**\n * Sets the dynamic link fallback URL overriding the default one.\n * @param {string} fallbackUrl The dynamic link fallback URL.\n */\nfireauth.DynamicLink.prototype.setFallbackUrl = function(fallbackUrl) {\n  this.fallbackUrl_ = fallbackUrl;\n  fireauth.object.setReadonlyProperty(this, 'fallbackUrl', fallbackUrl);\n};\n\n\n/**\n * Parses a dynamic link object from an automatic FDL redirect link.\n * @param {string} url The URL string to parse and convert to a dynamic link.\n * @return {?fireauth.DynamicLink} The corresponding dynamic link if applicable.\n */\nfireauth.DynamicLink.fromURL = function(url) {\n  // This constructs the Dynamic link from the URL provided.\n  var uri = goog.Uri.parse(url);\n  var fdlDomain = uri.getParameterValue('fdlDomain');\n  var platform = uri.getParameterValue('platform');\n  var appIdentifier = uri.getParameterValue('appIdentifier');\n  var authDomain = uri.getParameterValue('authDomain');\n  var payload = uri.getParameterValue('link');\n  var appName = uri.getParameterValue('appName');\n  if (fdlDomain && platform && appIdentifier && authDomain && payload &&\n      appName) {\n    var dl = new fireauth.DynamicLink(\n        /** @type {string} */ (fdlDomain),\n        /** @type {!fireauth.DynamicLink.Platform} */ (platform),\n        /** @type {string} */ (appIdentifier),\n        /** @type {string} */ (authDomain),\n        /** @type {string} */ (payload));\n    dl.setAppName(appName);\n    return dl;\n  }\n  return null;\n};\n\n\n/**\n * @param {string} url The dynamic link URL.\n * @return {string} The deep link embedded within the dynamic link.\n */\nfireauth.DynamicLink.parseDeepLink = function(url) {\n  var uri = goog.Uri.parse(url);\n  var link = uri.getParameterValue('link');\n  // Double link case (automatic redirect).\n  var doubleDeepLink = goog.Uri.parse(link).getParameterValue('link');\n  // iOS custom scheme links.\n  var iOSdeepLink = uri.getParameterValue('deep_link_id');\n  var iOSDoubledeepLink = goog.Uri.parse(iOSdeepLink).getParameterValue('link');\n  var callbackUrl =\n      iOSDoubledeepLink || iOSdeepLink || doubleDeepLink || link || url;\n  return callbackUrl;\n};\n\n\n/**\n * The supported FDL platforms.\n * @enum {string}\n */\nfireauth.DynamicLink.Platform = {\n  ANDROID: 'android',\n  IOS: 'ios'\n};\n\n\n/**\n * Constructs the common FDL link base used for building the button link or the\n * automatic redirect link.\n * @param {string} fallbackUrl The fallback URL to use.\n * @return {!goog.Uri} The partial URI of the FDL link used to build the final\n *     button link or the automatic redirect link.\n * @private\n */\nfireauth.DynamicLink.prototype.constructFdlBase_ = function(fallbackUrl) {\n  var uri = goog.Uri.create(\n      'https',\n      null,\n      this.fdlDomain_,\n      null,\n      '/');\n  if (this.platform_ == fireauth.DynamicLink.Platform.ANDROID) {\n    uri.setParameterValue('apn', this.appIdentifier_);\n    uri.setParameterValue('afl', fallbackUrl);\n  } else if (this.platform_ == fireauth.DynamicLink.Platform.IOS) {\n    uri.setParameterValue('ibi', this.appIdentifier_);\n    uri.setParameterValue('ifl', fallbackUrl);\n  }\n  return uri;\n};\n\n\n/**\n * Constructs the custom scheme URL. This is used when no FDL domain is\n * available.\n * @return {!goog.Uri} The uri of the dynamic link used to build the final\n *      button link or the automatic redirect link.\n * @private\n */\nfireauth.DynamicLink.prototype.constructCustomSchemeUrl_ = function() {\n  // This mimics the FDL custom scheme URL format.\n  var uri = goog.Uri.create(\n      this.clientId_ ? this.clientId_.split('.').reverse().join('.') :\n          this.appIdentifier_,\n      null,\n      // 'firebaseauth' is used in the app verification flow.\n      // 'google' is used for the Cordova iOS flow.\n      this.clientId_ ? 'firebaseauth' : 'google',\n      null,\n      '/link');\n  uri.setParameterValue('deep_link_id', this.link_);\n  return uri;\n};\n\n\n/**\n * @param {boolean=} opt_isAutoRedirect Whether the link is an auto redirect\n *     link.\n * @return {string} The generated dynamic link string.\n * @override\n */\nfireauth.DynamicLink.prototype.toString = function(opt_isAutoRedirect) {\n  // When FDL domain is not available, always returns the custom scheme URL.\n  if (!this.fdlDomain_) {\n    return this.constructCustomSchemeUrl_().toString();\n  }\n  if (!!opt_isAutoRedirect) {\n    return this.generateAutomaticRedirectLink_();\n  }\n  return this.generateButtonLink_();\n};\n\n\n/**\n * @return {string} The final FDL button link.\n * @private\n */\nfireauth.DynamicLink.prototype.generateButtonLink_ = function() {\n  var fdlLink = this.constructFdlBase_(this.fallbackUrl_);\n  fdlLink.setParameterValue('link', this.link_);\n  return fdlLink.toString();\n};\n\n\n/**\n * @return {string} The final FDL automatic redirect link.\n * @private\n */\nfireauth.DynamicLink.prototype.generateAutomaticRedirectLink_ =\n    function() {\n  var doubleDeeplink = goog.Uri.create(\n      'https',\n      null,\n      this.authDomain_,\n      null,\n      '/__/auth/callback');\n  doubleDeeplink.setParameterValue('fdlDomain', this.fdlDomain_);\n  doubleDeeplink.setParameterValue('platform', this.platform_);\n  doubleDeeplink.setParameterValue('appIdentifier', this.appIdentifier_);\n  doubleDeeplink.setParameterValue('authDomain', this.authDomain_);\n  doubleDeeplink.setParameterValue('link', this.link_);\n  doubleDeeplink.setParameterValue('appName', this.appName_ || '');\n  // The fallback URL is the deep link itself.\n  // This is in case the link fails to be intercepted by the app, FDL will\n  // redirect to the fallback URL.\n  var fdlLink = this.constructFdlBase_(doubleDeeplink.toString());\n  fdlLink.setParameterValue('link', doubleDeeplink.toString());\n  return fdlLink.toString();\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines Auth credentials used for signInWithCredential.\n */\n\ngoog.provide('fireauth.AuthCredential');\ngoog.provide('fireauth.AuthProvider');\ngoog.provide('fireauth.EmailAuthCredential');\ngoog.provide('fireauth.EmailAuthProvider');\ngoog.provide('fireauth.FacebookAuthProvider');\ngoog.provide('fireauth.FederatedProvider');\ngoog.provide('fireauth.GithubAuthProvider');\ngoog.provide('fireauth.GoogleAuthProvider');\ngoog.provide('fireauth.OAuthCredential');\ngoog.provide('fireauth.OAuthProvider');\ngoog.provide('fireauth.OAuthResponse');\ngoog.provide('fireauth.PhoneAuthCredential');\ngoog.provide('fireauth.PhoneAuthProvider');\ngoog.provide('fireauth.SAMLAuthCredential');\ngoog.provide('fireauth.SAMLAuthProvider');\ngoog.provide('fireauth.TwitterAuthProvider');\n\ngoog.require('fireauth.ActionCodeInfo');\ngoog.require('fireauth.ActionCodeURL');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.DynamicLink');\ngoog.require('fireauth.IdToken');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.idp');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Uri');\ngoog.require('goog.array');\ngoog.require('goog.object');\n\ngoog.forwardDeclare('fireauth.RpcHandler');\n\n\n\n/**\n * The interface that represents Auth credential. It provides the underlying\n * implementation for retrieving the ID token depending on the type of\n * credential.\n * @interface\n */\nfireauth.AuthCredential = function() {};\n\n\n/**\n * Returns a promise to retrieve ID token using the underlying RPC handler API\n * for the current credential.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @return {!goog.Promise<!Object, !fireauth.AuthError>}\n *     idTokenPromise The RPC handler method that returns a promise which\n *     resolves with an ID token.\n */\nfireauth.AuthCredential.prototype.getIdTokenProvider;\n\n\n/**\n * Links the credential to an existing account, identified by an ID token.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} idToken The ID token of the existing account.\n * @return {!goog.Promise<!Object>} A Promise that resolves when the accounts\n *     are linked.\n */\nfireauth.AuthCredential.prototype.linkToIdToken;\n\n\n/**\n * Tries to match the credential's idToken with the provided UID.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} uid The UID of the user to reauthenticate.\n * @return {!goog.Promise<!Object>} A Promise that resolves when\n *     idToken UID match succeeds and returns the server response.\n */\nfireauth.AuthCredential.prototype.matchIdTokenWithUid;\n\n\n/**\n * @return {!Object} The plain object representation of an Auth credential. This\n *     will be exposed as toJSON() externally.\n */\nfireauth.AuthCredential.prototype.toPlainObject;\n\n\n/**\n * @param {!goog.Promise<!Object>} idTokenResolver A promise that resolves with\n *     the ID token response.\n * @param {string} uid The UID to match in the token response.\n * @return {!goog.Promise<!Object>} A promise that resolves with the same\n *     response if the UID matches.\n */\nfireauth.AuthCredential.verifyTokenResponseUid =\n    function(idTokenResolver, uid) {\n  return idTokenResolver.then(function(response) {\n    // This should not happen as rpcHandler verifyAssertion and verifyPassword\n    // always guarantee an ID token is available.\n    if (response[fireauth.RpcHandler.AuthServerField.ID_TOKEN]) {\n      // Parse the token object.\n      var parsedIdToken = fireauth.IdToken.parse(\n          response[fireauth.RpcHandler.AuthServerField.ID_TOKEN]);\n      // Confirm token localId matches the provided UID. If not, throw the user\n      // mismatch error.\n      if (!parsedIdToken || uid != parsedIdToken.getLocalId()) {\n        throw new fireauth.AuthError(fireauth.authenum.Error.USER_MISMATCH);\n      }\n      return response;\n    }\n    throw new fireauth.AuthError(fireauth.authenum.Error.USER_MISMATCH);\n  })\n  .thenCatch(function(error) {\n    // Translate auth/user-not-found error directly to auth/user-mismatch.\n    throw fireauth.AuthError.translateError(\n        error,\n        fireauth.authenum.Error.USER_DELETED,\n        fireauth.authenum.Error.USER_MISMATCH);\n  });\n};\n\n\n\n/**\n * The interface that represents the Auth provider.\n * @interface\n */\nfireauth.AuthProvider = function() {};\n\n\n/**\n * @param {...*} var_args The credential data.\n * @return {!fireauth.AuthCredential} The Auth provider credential.\n */\nfireauth.AuthProvider.credential;\n\n\n/**\n * @typedef {{\n *   accessToken: (?string|undefined),\n *   idToken: (?string|undefined),\n *   nonce: (?string|undefined),\n *   oauthToken: (?string|undefined),\n *   oauthTokenSecret: (?string|undefined),\n *   pendingToken: (?string|undefined)\n * }}\n */\nfireauth.OAuthResponse;\n\n\n/**\n * The SAML Auth credential class. The Constructor is not publicly visible.\n * This is constructed by the SDK on successful or failure after SAML sign-in\n * and returned to developer.\n * @param {!fireauth.idp.ProviderId} providerId The provider ID.\n * @param {string} pendingToken The SAML response pending token.\n * @constructor\n * @implements {fireauth.AuthCredential}\n */\nfireauth.SAMLAuthCredential = function(providerId, pendingToken) {\n  if (pendingToken) {\n    /** @private {string} The pending token where SAML response is encrypted. */\n    this.pendingToken_ = pendingToken;\n  } else {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'failed to construct a credential');\n  }\n\n  fireauth.object.setReadonlyProperty(this, 'providerId', providerId);\n  fireauth.object.setReadonlyProperty(this, 'signInMethod', providerId);\n};\n\n\n/**\n * Returns a promise to retrieve ID token using the underlying RPC handler API\n * for the current credential.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @return {!goog.Promise<!Object, !fireauth.AuthError>}\n *     idTokenPromise The RPC handler method that returns a promise which\n *     resolves with an ID token.\n * @override\n */\nfireauth.SAMLAuthCredential.prototype.getIdTokenProvider =\n    function(rpcHandler) {\n  return rpcHandler.verifyAssertion(\n      /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (\n      this.makeVerifyAssertionRequest_()));\n};\n\n\n/**\n * Links the credential to an existing account, identified by an ID token.\n * @param {!fireauth.RpcHandler} rpcHandler The rpc handler.\n * @param {string} idToken The ID token of the existing account.\n * @return {!goog.Promise<!Object>} A Promise that resolves when the accounts\n *     are linked, returning the backend response.\n * @override\n */\nfireauth.SAMLAuthCredential.prototype.linkToIdToken =\n    function(rpcHandler, idToken) {\n  var request = this.makeVerifyAssertionRequest_();\n  request['idToken'] = idToken;\n  return rpcHandler.verifyAssertionForLinking(\n      /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (request));\n};\n\n\n/**\n * Tries to match the credential's idToken with the provided UID.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} uid The UID of the user to reauthenticate.\n * @return {!goog.Promise<!Object>} A Promise that resolves when\n *     idToken UID match succeeds and returns the server response.\n * @override\n */\nfireauth.SAMLAuthCredential.prototype.matchIdTokenWithUid =\n    function(rpcHandler, uid) {\n  var request = this.makeVerifyAssertionRequest_();\n  // Do not create a new account if the user doesn't exist.\n  return fireauth.AuthCredential.verifyTokenResponseUid(\n      rpcHandler.verifyAssertionForExisting(\n          /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (request)),\n      uid);\n};\n\n\n/**\n * @return {!Object} A request to the VerifyAssertion endpoint, populated with\n *     the assertion data from this credential.\n * @private\n */\nfireauth.SAMLAuthCredential.prototype.makeVerifyAssertionRequest_ =\n    function() {\n  return {\n    'pendingToken': this.pendingToken_,\n    // Always use http://localhost.\n    'requestUri': 'http://localhost'\n  };\n};\n\n\n/**\n * @return {!Object} The plain object representation of an Auth credential.\n * @override\n */\nfireauth.SAMLAuthCredential.prototype.toPlainObject = function() {\n  return {\n    'providerId': this['providerId'],\n    'signInMethod': this['signInMethod'],\n    'pendingToken': this.pendingToken_\n  };\n};\n\n\n/**\n * @param {?Object|undefined} json The plain object representation of a\n *     SAMLAuthCredential.\n * @return {?fireauth.SAMLAuthCredential} The SAML credential if the object\n *     is a JSON representation of a SAMLAuthCredential, null otherwise.\n */\nfireauth.SAMLAuthCredential.fromJSON = function(json) {\n  if (json &&\n      json['providerId'] &&\n      json['signInMethod'] &&\n      json['providerId'].indexOf(fireauth.constants.SAML_PREFIX) == 0 &&\n      json['pendingToken']) {\n    try {\n      return new fireauth.SAMLAuthCredential(\n          json['providerId'], json['pendingToken']);\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n};\n\n\n/**\n * The OAuth credential class.\n * @param {!fireauth.idp.ProviderId} providerId The provider ID.\n * @param {!fireauth.OAuthResponse} oauthResponse The OAuth\n *     response object containing token information.\n * @param {!fireauth.idp.SignInMethod} signInMethod The sign in method.\n * @constructor\n * @implements {fireauth.AuthCredential}\n */\nfireauth.OAuthCredential = function(providerId, oauthResponse, signInMethod) {\n  /**\n   * @private {?string} The pending token where the IdP response is encrypted.\n   */\n  this.pendingToken_ = null;\n  if (oauthResponse['idToken'] || oauthResponse['accessToken']) {\n    // OAuth 2 and either ID token or access token.\n    if (oauthResponse['idToken']) {\n      fireauth.object.setReadonlyProperty(\n          this, 'idToken', oauthResponse['idToken']);\n    }\n    if (oauthResponse['accessToken']) {\n      fireauth.object.setReadonlyProperty(\n          this, 'accessToken', oauthResponse['accessToken']);\n    }\n    // Add nonce if available and no pendingToken is present.\n    if (oauthResponse['nonce'] && !oauthResponse['pendingToken']) {\n      fireauth.object.setReadonlyProperty(\n          this, 'nonce', oauthResponse['nonce']);\n    }\n    if (oauthResponse['pendingToken']) {\n      this.pendingToken_ = oauthResponse['pendingToken'];\n    }\n  } else if (oauthResponse['oauthToken'] &&\n             oauthResponse['oauthTokenSecret'])  {\n    // OAuth 1 and OAuth token with OAuth token secret.\n    fireauth.object.setReadonlyProperty(\n        this, 'accessToken', oauthResponse['oauthToken']);\n    fireauth.object.setReadonlyProperty(\n        this, 'secret', oauthResponse['oauthTokenSecret']);\n  } else {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'failed to construct a credential');\n  }\n\n  fireauth.object.setReadonlyProperty(this, 'providerId', providerId);\n  fireauth.object.setReadonlyProperty(this, 'signInMethod', signInMethod);\n};\n\n\n/**\n * Returns a promise to retrieve ID token using the underlying RPC handler API\n * for the current credential.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @return {!goog.Promise<!Object, !fireauth.AuthError>}\n *     idTokenPromise The RPC handler method that returns a promise which\n *     resolves with an ID token.\n * @override\n */\nfireauth.OAuthCredential.prototype.getIdTokenProvider = function(rpcHandler) {\n  return rpcHandler.verifyAssertion(\n      /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (\n      this.makeVerifyAssertionRequest_()));\n};\n\n\n/**\n * Links the credential to an existing account, identified by an ID token.\n * @param {!fireauth.RpcHandler} rpcHandler The rpc handler.\n * @param {string} idToken The ID token of the existing account.\n * @return {!goog.Promise<!Object>} A Promise that resolves when the accounts\n *     are linked, returning the backend response.\n * @override\n */\nfireauth.OAuthCredential.prototype.linkToIdToken =\n    function(rpcHandler, idToken) {\n  var request = this.makeVerifyAssertionRequest_();\n  request['idToken'] = idToken;\n  return rpcHandler.verifyAssertionForLinking(\n      /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (request));\n};\n\n\n/**\n * Tries to match the credential's idToken with the provided UID.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} uid The UID of the user to reauthenticate.\n * @return {!goog.Promise<!Object>} A Promise that resolves when\n *     idToken UID match succeeds and returns the server response.\n * @override\n */\nfireauth.OAuthCredential.prototype.matchIdTokenWithUid =\n    function(rpcHandler, uid) {\n  var request = this.makeVerifyAssertionRequest_();\n  // Do not create a new account if the user doesn't exist.\n  return fireauth.AuthCredential.verifyTokenResponseUid(\n      rpcHandler.verifyAssertionForExisting(\n          /** @type {!fireauth.RpcHandler.VerifyAssertionData} */ (request)),\n      uid);\n};\n\n\n/**\n * @return {!Object} A request to the VerifyAssertion endpoint, populated with\n *     the OAuth data from this credential.\n * @private\n */\nfireauth.OAuthCredential.prototype.makeVerifyAssertionRequest_ = function() {\n  var postBody = {};\n  if (this['idToken']) {\n    postBody['id_token'] = this['idToken'];\n  }\n  if (this['accessToken']) {\n    postBody['access_token'] = this['accessToken'];\n  }\n  if (this['secret']) {\n    postBody['oauth_token_secret'] = this['secret'];\n  }\n  postBody['providerId'] = this['providerId'];\n  // Pass nonce in postBody if available.\n  if (this['nonce'] && !this.pendingToken_) {\n    postBody['nonce'] = this['nonce'];\n  }\n  var request = {\n    'postBody': goog.Uri.QueryData.createFromMap(postBody).toString(),\n    // Always use http://localhost.\n    'requestUri': 'http://localhost'\n  };\n  if (this.pendingToken_) {\n    // For pendingToken, just pass it through and drop postBody.\n    delete request['postBody'];\n    request['pendingToken'] = this.pendingToken_;\n  }\n  return request;\n};\n\n\n/**\n * @return {!Object} The plain object representation of an Auth credential.\n * @override\n */\nfireauth.OAuthCredential.prototype.toPlainObject = function() {\n  var obj = {\n    'providerId': this['providerId'],\n    'signInMethod': this['signInMethod']\n  };\n  if (this['idToken']) {\n    obj['oauthIdToken'] = this['idToken'];\n  }\n  if (this['accessToken']) {\n    obj['oauthAccessToken'] = this['accessToken'];\n  }\n  if (this['secret']) {\n    obj['oauthTokenSecret'] = this['secret'];\n  }\n  if (this['nonce']) {\n    obj['nonce'] = this['nonce'];\n  }\n  if (this.pendingToken_) {\n    obj['pendingToken'] = this.pendingToken_;\n  }\n  return obj;\n};\n\n\n/**\n * @param {?Object|undefined} json The plain object representation of an\n *     OAuthCredential.\n * @return {?fireauth.OAuthCredential} The OAuth/OIDC credential if the object\n *     is a JSON representation of an OAuthCredential, null otherwise.\n */\nfireauth.OAuthCredential.fromJSON = function(json) {\n  if (json &&\n      json['providerId'] &&\n      json['signInMethod']) {\n    // Convert to OAuthResponse format.\n    var oauthResponse = {\n      // OIDC && google.com.\n      'idToken': json['oauthIdToken'],\n      // OAuth 2.0 providers.\n      'accessToken': json['oauthTokenSecret'] ? null : json['oauthAccessToken'],\n      // OAuth 1.0 provider, eg. Twitter.\n      'oauthTokenSecret': json['oauthTokenSecret'],\n      'oauthToken': json['oauthTokenSecret'] && json['oauthAccessToken'],\n      'nonce': json['nonce'],\n      'pendingToken': json['pendingToken']\n    };\n    try {\n      // Constructor will validate the OAuthResponse.\n      return new fireauth.OAuthCredential(\n          json['providerId'], oauthResponse, json['signInMethod']);\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n};\n\n\n/**\n * A generic OAuth provider (OAuth1 or OAuth2).\n * @param {string} providerId The IdP provider ID (e.g. google.com,\n *     facebook.com) registered with the backend.\n * @param {?Array<string>=} opt_reservedParams The backlist of parameters that\n *     cannot be set through setCustomParameters.\n * @constructor\n */\nfireauth.FederatedProvider = function(providerId, opt_reservedParams) {\n  /** @private {!Array<string>} */\n  this.reservedParams_ = opt_reservedParams || [];\n\n  // Set read only instance providerId property.\n  // Set read only instance isOAuthProvider property.\n  fireauth.object.setReadonlyProperties(this, {\n    'providerId': providerId,\n    'isOAuthProvider': true\n  });\n\n  /** @private {!Object} The OAuth custom parameters for current provider. */\n  this.customParameters_ = {};\n  /** @protected {?string} The custom OAuth language parameter. */\n  this.languageParameter =\n      (fireauth.idp.getIdpSettings(/** @type {!fireauth.idp.ProviderId} */ (\n          providerId)) || {}).languageParam || null;\n  /** @protected {?string} The default language. */\n  this.defaultLanguageCode = null;\n};\n\n/**\n * @param {!Object} customParameters The custom OAuth parameters to pass\n *     in OAuth request.\n * @return {!fireauth.FederatedProvider} The FederatedProvider instance, for\n *     chaining method calls.\n */\nfireauth.FederatedProvider.prototype.setCustomParameters =\n    function(customParameters) {\n  this.customParameters_ = goog.object.clone(customParameters);\n  return this;\n};\n\n\n/**\n * Set the default language code on the provider instance.\n * @param {?string} languageCode The default language code to set if not already\n *     provided in the custom parameters.\n */\nfireauth.FederatedProvider.prototype.setDefaultLanguage =\n    function(languageCode) {\n  this.defaultLanguageCode = languageCode;\n};\n\n\n/**\n * @return {!Object} The custom OAuth parameters to pass in OAuth request.\n */\nfireauth.FederatedProvider.prototype.getCustomParameters = function() {\n  // The backend already checks for these values and makes sure no reserved\n  // fields like client ID, redirect URI, state are overwritten by these\n  // fields.\n  var params =\n      fireauth.util.copyWithoutNullsOrUndefined(this.customParameters_);\n  // Convert to strings.\n  for (var key in params) {\n    params[key] = params[key].toString();\n  }\n  // Remove blacklisted OAuth custom parameters.\n  var customParams =\n      fireauth.util.removeEntriesWithKeys(params, this.reservedParams_);\n  // If language param supported and not already provided, use default language.\n  if (this.languageParameter &&\n      this.defaultLanguageCode &&\n      !customParams[this.languageParameter]) {\n    customParams[this.languageParameter] = this.defaultLanguageCode;\n  }\n  return customParams;\n};\n\n\n/**\n * Generic SAML auth provider.\n * @param {string} providerId The SAML IdP provider ID (e.g. saml.saml2rp)\n *     registered with the backend.\n * @constructor\n * @extends {fireauth.FederatedProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.SAMLAuthProvider = function(providerId) {\n  // SAML provider IDs must be prefixed with the SAML_PREFIX.\n  if (!fireauth.idp.isSaml(providerId)) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        'SAML provider IDs must be prefixed with \"' +\n        fireauth.constants.SAML_PREFIX + '\"');\n  }\n  // isOAuthProvider is true even though this is not an OAuth provider.\n  // This can be confusing as this is a SAML provider. However, this property\n  // is needed to allow signInWithPopup/Redirect. We should rename it to\n  // something more accurate: isFederatedProvider.\n  fireauth.SAMLAuthProvider.base(this, 'constructor', providerId, []);\n};\ngoog.inherits(fireauth.SAMLAuthProvider, fireauth.FederatedProvider);\n\n\n/**\n * Generic OAuth2 Auth provider.\n * @param {string} providerId The IdP provider ID (e.g. google.com,\n *     facebook.com) registered with the backend.\n * @constructor\n * @extends {fireauth.FederatedProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.OAuthProvider = function(providerId) {\n  fireauth.OAuthProvider.base(this, 'constructor', providerId,\n      fireauth.idp.RESERVED_OAUTH2_PARAMS);\n\n  /** @private {!Array<string>} The list of OAuth2 scopes to request. */\n  this.scopes_ = [];\n};\ngoog.inherits(fireauth.OAuthProvider, fireauth.FederatedProvider);\n\n\n/**\n * @param {string} scope The OAuth scope to request.\n * @return {!fireauth.OAuthProvider} The OAuthProvider instance, for chaining\n *     method calls.\n */\nfireauth.OAuthProvider.prototype.addScope = function(scope) {\n  // If not already added, add scope to list.\n  if (!goog.array.contains(this.scopes_, scope)) {\n    this.scopes_.push(scope);\n  }\n  return this;\n};\n\n\n/** @return {!Array<string>} The Auth provider's list of scopes. */\nfireauth.OAuthProvider.prototype.getScopes = function() {\n  return goog.array.clone(this.scopes_);\n};\n\n\n/**\n * Initializes an OAuth AuthCredential. At least one of ID token or access token\n * must be defined. When providing an OIDC ID token with a nonce encoded, the\n * raw nonce must also be provided.\n * @param {?Object|string} optionsOrIdToken Either the options object containing\n *     the ID token, access token and raw nonce or the ID token string.\n * @param {?string=} opt_accessToken The optional OAuth access token.\n * @return {!fireauth.AuthCredential} The Auth credential object.\n */\nfireauth.OAuthProvider.prototype.credential =\n    function(optionsOrIdToken, opt_accessToken) {\n  var oauthResponse;\n  if (goog.isObject(optionsOrIdToken)) {\n    oauthResponse = {\n      'idToken': optionsOrIdToken['idToken'] || null,\n      'accessToken': optionsOrIdToken['accessToken'] || null,\n      'nonce': optionsOrIdToken['rawNonce'] || null\n    };\n  } else {\n    oauthResponse = {\n      'idToken': optionsOrIdToken || null,\n      'accessToken': opt_accessToken || null\n    };\n  }\n  if (!oauthResponse['idToken'] && !oauthResponse['accessToken']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        'credential failed: must provide the ID token and/or the access ' +\n        'token.');\n  }\n  // For OAuthCredential, sign in method is same as providerId.\n  return new fireauth.OAuthCredential(this['providerId'],\n                                      oauthResponse,\n                                      this['providerId']);\n};\n\n\n/**\n * Facebook Auth provider.\n * @constructor\n * @extends {fireauth.OAuthProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.FacebookAuthProvider = function() {\n  fireauth.FacebookAuthProvider.base(this, 'constructor',\n      fireauth.idp.ProviderId.FACEBOOK);\n};\ngoog.inherits(fireauth.FacebookAuthProvider, fireauth.OAuthProvider);\n\nfireauth.object.setReadonlyProperty(fireauth.FacebookAuthProvider,\n    'PROVIDER_ID', fireauth.idp.ProviderId.FACEBOOK);\n\nfireauth.object.setReadonlyProperty(fireauth.FacebookAuthProvider,\n    'FACEBOOK_SIGN_IN_METHOD', fireauth.idp.SignInMethod.FACEBOOK);\n\n\n/**\n * Initializes a Facebook AuthCredential.\n * @param {string} accessTokenOrObject The Facebook access token, or object\n *     containing the token for FirebaseUI backwards compatibility.\n * @return {!fireauth.AuthCredential} The Auth credential object.\n * @override\n */\nfireauth.FacebookAuthProvider.credential = function(accessTokenOrObject) {\n  if (!accessTokenOrObject) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        'credential failed: expected 1 argument (the OAuth access token).');\n  }\n  var accessToken = accessTokenOrObject;\n  if (goog.isObject(accessTokenOrObject)) {\n    accessToken = accessTokenOrObject['accessToken'];\n  }\n  return new fireauth.FacebookAuthProvider().credential({\n    'accessToken': /** @type {string} */ (accessToken)\n  });\n};\n\n\n/**\n * GitHub Auth provider.\n * @constructor\n * @extends {fireauth.OAuthProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.GithubAuthProvider = function() {\n  fireauth.GithubAuthProvider.base(this, 'constructor',\n      fireauth.idp.ProviderId.GITHUB);\n};\ngoog.inherits(fireauth.GithubAuthProvider, fireauth.OAuthProvider);\n\nfireauth.object.setReadonlyProperty(fireauth.GithubAuthProvider,\n    'PROVIDER_ID', fireauth.idp.ProviderId.GITHUB);\n\nfireauth.object.setReadonlyProperty(fireauth.GithubAuthProvider,\n    'GITHUB_SIGN_IN_METHOD', fireauth.idp.SignInMethod.GITHUB);\n\n\n/**\n * Initializes a GitHub AuthCredential.\n * @param {string} accessTokenOrObject The GitHub access token, or object\n *     containing the token for FirebaseUI backwards compatibility.\n * @return {!fireauth.AuthCredential} The Auth credential object.\n * @override\n */\nfireauth.GithubAuthProvider.credential = function(accessTokenOrObject) {\n  if (!accessTokenOrObject) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        'credential failed: expected 1 argument (the OAuth access token).');\n  }\n  var accessToken = accessTokenOrObject;\n  if (goog.isObject(accessTokenOrObject)) {\n    accessToken = accessTokenOrObject['accessToken'];\n  }\n  return new fireauth.GithubAuthProvider().credential({\n    'accessToken': /** @type {string} */ (accessToken)\n  });\n};\n\n\n/**\n * Google Auth provider.\n * @constructor\n * @extends {fireauth.OAuthProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.GoogleAuthProvider = function() {\n  fireauth.GoogleAuthProvider.base(this, 'constructor',\n      fireauth.idp.ProviderId.GOOGLE);\n\n  // Add profile scope to Google Auth provider as default scope.\n  // This is to ensure profile info is populated in current user.\n  this.addScope('profile');\n};\ngoog.inherits(fireauth.GoogleAuthProvider, fireauth.OAuthProvider);\n\nfireauth.object.setReadonlyProperty(fireauth.GoogleAuthProvider,\n    'PROVIDER_ID', fireauth.idp.ProviderId.GOOGLE);\n\nfireauth.object.setReadonlyProperty(fireauth.GoogleAuthProvider,\n    'GOOGLE_SIGN_IN_METHOD', fireauth.idp.SignInMethod.GOOGLE);\n\n\n/**\n * Initializes a Google AuthCredential.\n * @param {?string=} idTokenOrObject The Google ID token. If null or undefined,\n *     we expect the access token to be passed. It can also be an object\n *     containing the tokens for FirebaseUI backwards compatibility.\n * @param {?string=} accessToken The Google access token. If null or\n *     undefined, we expect the ID token to have been passed.\n * @return {!fireauth.AuthCredential} The Auth credential object.\n * @override\n */\nfireauth.GoogleAuthProvider.credential =\n    function(idTokenOrObject, accessToken) {\n  var idToken = idTokenOrObject;\n  if (goog.isObject(idTokenOrObject)) {\n    idToken = idTokenOrObject['idToken'];\n    accessToken = idTokenOrObject['accessToken'];\n  }\n  return new fireauth.GoogleAuthProvider().credential({\n    'idToken':  /** @type {string} */ (idToken),\n    'accessToken': /** @type {string} */ (accessToken)\n  });\n};\n\n\n/**\n * Twitter Auth provider.\n * @constructor\n * @extends {fireauth.FederatedProvider}\n * @implements {fireauth.AuthProvider}\n */\nfireauth.TwitterAuthProvider = function() {\n  fireauth.TwitterAuthProvider.base(this, 'constructor',\n      fireauth.idp.ProviderId.TWITTER,\n      fireauth.idp.RESERVED_OAUTH1_PARAMS);\n};\ngoog.inherits(fireauth.TwitterAuthProvider, fireauth.FederatedProvider);\n\nfireauth.object.setReadonlyProperty(fireauth.TwitterAuthProvider,\n    'PROVIDER_ID', fireauth.idp.ProviderId.TWITTER);\n\nfireauth.object.setReadonlyProperty(fireauth.TwitterAuthProvider,\n    'TWITTER_SIGN_IN_METHOD', fireauth.idp.SignInMethod.TWITTER);\n\n\n/**\n * Initializes a Twitter AuthCredential.\n * @param {string} tokenOrObject The Twitter access token, or object\n *     containing the token for FirebaseUI backwards compatibility.\n * @param {string} secret The Twitter secret.\n * @return {!fireauth.AuthCredential} The Auth credential object.\n * @override\n */\nfireauth.TwitterAuthProvider.credential = function(tokenOrObject, secret) {\n  var tokenObject = tokenOrObject;\n  if (!goog.isObject(tokenObject)) {\n    tokenObject = {\n      'oauthToken': tokenOrObject,\n      'oauthTokenSecret': secret\n    };\n  }\n\n  if (!tokenObject['oauthToken'] || !tokenObject['oauthTokenSecret']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        'credential failed: expected 2 arguments (the OAuth access token ' +\n        'and secret).');\n  }\n\n  return new fireauth.OAuthCredential(fireauth.idp.ProviderId.TWITTER,\n      /** @type {!fireauth.OAuthResponse} */ (tokenObject),\n      fireauth.idp.SignInMethod.TWITTER);\n};\n\n\n/**\n * The email and password credential class.\n * @param {string} email The credential email.\n * @param {string} password The credential password.\n * @param {string=} opt_signInMethod The credential sign in method can be either\n *     'password' or 'emailLink'\n * @constructor\n * @implements {fireauth.AuthCredential}\n */\nfireauth.EmailAuthCredential = function(email, password, opt_signInMethod) {\n  this.email_ = email;\n  this.password_ = password;\n  fireauth.object.setReadonlyProperty(this, 'providerId',\n      fireauth.idp.ProviderId.PASSWORD);\n  var signInMethod = opt_signInMethod ===\n      fireauth.EmailAuthProvider['EMAIL_LINK_SIGN_IN_METHOD'] ?\n      fireauth.EmailAuthProvider['EMAIL_LINK_SIGN_IN_METHOD'] :\n      fireauth.EmailAuthProvider['EMAIL_PASSWORD_SIGN_IN_METHOD'];\n  fireauth.object.setReadonlyProperty(this, 'signInMethod', signInMethod);\n};\n\n\n/**\n * Returns a promise to retrieve ID token using the underlying RPC handler API\n * for the current credential.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @return {!goog.Promise<!Object, !fireauth.AuthError>}\n *     idTokenPromise The RPC handler method that returns a promise which\n *     resolves with an ID token.\n * @override\n */\nfireauth.EmailAuthCredential.prototype.getIdTokenProvider =\n    function(rpcHandler) {\n  if (this['signInMethod'] ==\n      fireauth.EmailAuthProvider['EMAIL_LINK_SIGN_IN_METHOD']) {\n    return rpcHandler.emailLinkSignIn(this.email_, this.password_);\n  }\n  return rpcHandler.verifyPassword(this.email_, this.password_);\n};\n\n\n/**\n * Adds an email and password account to an existing account, identified by an\n * ID token.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} idToken The ID token of the existing account.\n * @return {!goog.Promise<!Object>} A Promise that resolves when the accounts\n *     are linked, returning the backend response.\n * @override\n */\nfireauth.EmailAuthCredential.prototype.linkToIdToken =\n    function(rpcHandler, idToken) {\n  if (this['signInMethod'] ==\n      fireauth.EmailAuthProvider['EMAIL_LINK_SIGN_IN_METHOD']) {\n    return rpcHandler.emailLinkSignInForLinking(\n        idToken, this.email_, this.password_);\n  }\n  return rpcHandler.updateEmailAndPassword(\n      idToken, this.email_, this.password_);\n};\n\n\n/**\n * Tries to match the credential's idToken with the provided UID.\n * @param {!fireauth.RpcHandler} rpcHandler The rpc handler.\n * @param {string} uid The UID of the user to reauthenticate.\n * @return {!goog.Promise<!Object>} A Promise that resolves when\n *     reauthentication succeeds.\n * @override\n */\nfireauth.EmailAuthCredential.prototype.matchIdTokenWithUid =\n    function(rpcHandler, uid) {\n  // Do not create a new account if the user doesn't exist.\n  return fireauth.AuthCredential.verifyTokenResponseUid(\n      // This shouldn't create a new email/password account.\n      this.getIdTokenProvider(rpcHandler),\n      uid);\n};\n\n\n/**\n * @return {!Object} The plain object representation of an Auth credential.\n * @override\n */\nfireauth.EmailAuthCredential.prototype.toPlainObject = function() {\n  return {\n    'email': this.email_,\n    'password': this.password_,\n    'signInMethod': this['signInMethod']\n  };\n};\n\n\n/**\n * @param {?Object|undefined} json The plain object representation of a\n *     EmailAuthCredential.\n * @return {?fireauth.EmailAuthCredential} The email credential if the object\n *     is a JSON representation of an EmailAuthCredential, null otherwise.\n */\nfireauth.EmailAuthCredential.fromJSON = function(json) {\n  if (json && json['email'] && json['password']) {\n    return new fireauth.EmailAuthCredential(\n        json['email'],\n        json['password'],\n        json['signInMethod']);\n  }\n  return null;\n};\n\n\n/**\n * Email password Auth provider implementation.\n * @constructor\n * @implements {fireauth.AuthProvider}\n */\nfireauth.EmailAuthProvider = function() {\n  // Set read-only instance providerId and isOAuthProvider property.\n  fireauth.object.setReadonlyProperties(this, {\n    'providerId': fireauth.idp.ProviderId.PASSWORD,\n    'isOAuthProvider': false\n  });\n};\n\n\n/**\n * Initializes an instance of an email/password Auth credential.\n * @param {string} email The credential email.\n * @param {string} password The credential password.\n * @return {!fireauth.EmailAuthCredential} The Auth credential object.\n * @override\n */\nfireauth.EmailAuthProvider.credential = function(email, password) {\n  return new fireauth.EmailAuthCredential(email, password);\n};\n\n\n/**\n * @param {string} email The credential email.\n * @param {string} emailLink The credential email link.\n * @return {!fireauth.EmailAuthCredential} The Auth credential object.\n */\nfireauth.EmailAuthProvider.credentialWithLink = function(email, emailLink) {\n  var actionCodeUrl = fireauth.EmailAuthProvider\n      .getActionCodeUrlFromSignInEmailLink(emailLink);\n  if (!actionCodeUrl) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR, 'Invalid email link!');\n  }\n  return new fireauth.EmailAuthCredential(email, actionCodeUrl['code'],\n      fireauth.EmailAuthProvider['EMAIL_LINK_SIGN_IN_METHOD']);\n};\n\n\n/**\n * @param {string} emailLink The sign in email link to be validated.\n * @return {?fireauth.ActionCodeURL} The sign in email link action code URL.\n *     Returns null if the email link is invalid.\n */\nfireauth.EmailAuthProvider.getActionCodeUrlFromSignInEmailLink =\n    function(emailLink) {\n  emailLink = fireauth.DynamicLink.parseDeepLink(emailLink);\n  var actionCodeUrl = fireauth.ActionCodeURL.parseLink(emailLink);\n  if (actionCodeUrl && actionCodeUrl['operation'] ===\n      fireauth.ActionCodeInfo.Operation.EMAIL_SIGNIN) {\n    return actionCodeUrl;\n  }\n  return null;\n};\n\n\n// Set read only PROVIDER_ID property.\nfireauth.object.setReadonlyProperties(fireauth.EmailAuthProvider, {\n  'PROVIDER_ID': fireauth.idp.ProviderId.PASSWORD\n});\n\n// Set read only EMAIL_LINK_SIGN_IN_METHOD property.\nfireauth.object.setReadonlyProperties(fireauth.EmailAuthProvider, {\n  'EMAIL_LINK_SIGN_IN_METHOD': fireauth.idp.SignInMethod.EMAIL_LINK\n});\n\n// Set read only EMAIL_PASSWORD_SIGN_IN_METHOD property.\nfireauth.object.setReadonlyProperties(fireauth.EmailAuthProvider, {\n  'EMAIL_PASSWORD_SIGN_IN_METHOD': fireauth.idp.SignInMethod.EMAIL_PASSWORD\n});\n\n\n/**\n * A credential for phone number sign-in.\n * @param {!fireauth.PhoneAuthCredential.Parameters_} params The credential\n *     parameters that prove the user owns the claimed phone number.\n * @constructor\n * @implements {fireauth.AuthCredential}\n */\nfireauth.PhoneAuthCredential = function(params) {\n  // Either verification ID and code, or phone number temporary proof must be\n  // provided.\n  if (!(params.verificationId && params.verificationCode) &&\n      !(params.temporaryProof && params.phoneNumber)) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n\n  /**\n   * The phone Auth parameters that prove ownership of a phone number, either\n   * through completion of a phone verification flow, or by referencing a\n   * previously completed verification flow (\"temporaryProof\").\n   * @private {!fireauth.PhoneAuthCredential.Parameters_}\n   */\n  this.params_ = params;\n\n  fireauth.object.setReadonlyProperty(this, 'providerId',\n      fireauth.idp.ProviderId.PHONE);\n\n  fireauth.object.setReadonlyProperty(\n      this, 'signInMethod', fireauth.idp.SignInMethod.PHONE);\n};\n\n\n/**\n * Parameters that prove ownership of a phone number via a ID \"verificationId\"\n * of a request to send a code to the phone number, with the code\n * \"verificationCode\" that the user received on their phone.\n * @private\n * @typedef {{\n *   verificationId: string,\n *   verificationCode: string\n * }}\n */\nfireauth.PhoneAuthCredential.VerificationParameters_;\n\n\n/**\n * Parameters that prove ownership of a phone number by referencing a previously\n * completed phone Auth flow.\n * @private\n * @typedef {{\n *   temporaryProof: string,\n *   phoneNumber: string\n * }}\n */\nfireauth.PhoneAuthCredential.TemporaryProofParameters_;\n\n\n/**\n * @private\n * @typedef {\n *   !fireauth.PhoneAuthCredential.VerificationParameters_|\n *   !fireauth.PhoneAuthCredential.TemporaryProofParameters_\n * }\n */\nfireauth.PhoneAuthCredential.Parameters_;\n\n\n/**\n * Retrieves an ID token from the backend given the current credential.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @return {!goog.Promise<!Object>} A Promise that resolves with the\n *     backend response.\n * @override\n */\nfireauth.PhoneAuthCredential.prototype.getIdTokenProvider =\n    function(rpcHandler) {\n  return rpcHandler.verifyPhoneNumber(this.makeVerifyPhoneNumberRequest_());\n};\n\n\n/**\n * Adds a phone credential to an existing account identified by an ID token.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} idToken The ID token of the existing account.\n * @return {!goog.Promise<!Object>} A Promise that resolves when the accounts\n *     are linked, returning the backend response.\n * @override\n */\nfireauth.PhoneAuthCredential.prototype.linkToIdToken =\n    function(rpcHandler, idToken) {\n  var request = this.makeVerifyPhoneNumberRequest_();\n  request['idToken'] = idToken;\n  return rpcHandler.verifyPhoneNumberForLinking(request);\n};\n\n\n/**\n * Tries to match the credential's idToken with the provided UID.\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler.\n * @param {string} uid The UID of the user to reauthenticate.\n * @return {!goog.Promise<!Object>} A Promise that resolves when\n *     reauthentication succeeds.\n * @override\n */\nfireauth.PhoneAuthCredential.prototype.matchIdTokenWithUid =\n    function(rpcHandler, uid) {\n  var request = this.makeVerifyPhoneNumberRequest_();\n  return fireauth.AuthCredential.verifyTokenResponseUid(\n      rpcHandler.verifyPhoneNumberForExisting(request),\n      uid);\n};\n\n\n/**\n * Converts a PhoneAuthCredential to a plain object.\n * @return {!Object}\n * @override\n */\nfireauth.PhoneAuthCredential.prototype.toPlainObject = function() {\n  var obj =  {\n    'providerId': fireauth.idp.ProviderId.PHONE\n  };\n  if (this.params_.verificationId) {\n    obj['verificationId'] = this.params_.verificationId;\n  }\n  if (this.params_.verificationCode) {\n    obj['verificationCode'] = this.params_.verificationCode;\n  }\n  if (this.params_.temporaryProof) {\n    obj['temporaryProof'] = this.params_.temporaryProof;\n  }\n  if (this.params_.phoneNumber) {\n    obj['phoneNumber'] = this.params_.phoneNumber;\n  }\n  return obj;\n};\n\n\n/**\n * @param {?Object|undefined} json The plain object representation of a\n *     PhoneAuthCredential.\n * @return {?fireauth.PhoneAuthCredential} The phone credential if the object\n *     is a JSON representation of an PhoneAuthCredential, null otherwise.\n */\nfireauth.PhoneAuthCredential.fromJSON = function(json) {\n  if (json &&\n      json['providerId'] === fireauth.idp.ProviderId.PHONE &&\n      ((json['verificationId'] && json['verificationCode']) ||\n       (json['temporaryProof'] && json['phoneNumber']))) {\n    var params = {};\n    var allowedKeys = [\n      'verificationId', 'verificationCode', 'temporaryProof', 'phoneNumber'\n    ];\n    goog.array.forEach(allowedKeys, function(key) {\n      if (json[key]) {\n        params[key] = json[key];\n      }\n    });\n    return new fireauth.PhoneAuthCredential(\n        /** @type {!fireauth.PhoneAuthCredential.Parameters_} */ (params));\n  }\n  return null;\n};\n\n\n/**\n * @return {!Object} A request to the verifyPhoneNumber endpoint based on the\n *     current state of the object.\n * @private\n */\nfireauth.PhoneAuthCredential.prototype.makeVerifyPhoneNumberRequest_ =\n    function() {\n  if (this.params_.temporaryProof && this.params_.phoneNumber) {\n    return {\n      'temporaryProof': this.params_.temporaryProof,\n      'phoneNumber': this.params_.phoneNumber\n    };\n  }\n\n  return {\n    'sessionInfo': this.params_.verificationId,\n    'code': this.params_.verificationCode\n  };\n};\n\n\n/**\n * Phone Auth provider implementation.\n * @param {?fireauth.Auth=} opt_auth The Firebase Auth instance.\n * @constructor\n * @implements {fireauth.AuthProvider}\n */\nfireauth.PhoneAuthProvider = function(opt_auth) {\n  try {\n    /** @private {!fireauth.Auth} */\n    this.auth_ = opt_auth || firebase['auth']();\n  } catch (e) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        'Either an instance of firebase.auth.Auth must be passed as an ' +\n        'argument to the firebase.auth.PhoneAuthProvider constructor, or the ' +\n        'default firebase App instance must be initialized via ' +\n        'firebase.initializeApp().');\n  }\n  fireauth.object.setReadonlyProperties(this, {\n    'providerId': fireauth.idp.ProviderId.PHONE,\n    'isOAuthProvider': false\n  });\n};\n\n\n/**\n * Initiates a phone number confirmation flow.\n * @param {string} phoneNumber The user's phone number.\n * @param {!firebase.auth.ApplicationVerifier} applicationVerifier The\n *     application verifier for anti-abuse purposes.\n * @return {!goog.Promise<string>} A Promise that resolves with the\n *     verificationId of the phone number confirmation flow.\n */\nfireauth.PhoneAuthProvider.prototype.verifyPhoneNumber =\n    function(phoneNumber, applicationVerifier) {\n  var rpcHandler = this.auth_.getRpcHandler();\n\n  // Convert the promise into a goog.Promise. If the applicationVerifier throws\n  // an error, just propagate it to the client. Reset the reCAPTCHA widget every\n  // time after sending the token to the server.\n  return goog.Promise.resolve(applicationVerifier['verify']())\n      .then(function(assertion) {\n        if (!goog.isString(assertion)) {\n          throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n              'An implementation of firebase.auth.ApplicationVerifier' +\n              '.prototype.verify() must return a firebase.Promise ' +\n              'that resolves with a string.');\n        }\n\n        switch (applicationVerifier['type']) {\n          case 'recaptcha':\n            return rpcHandler\n                .sendVerificationCode(\n                    {'phoneNumber': phoneNumber, 'recaptchaToken': assertion})\n                .then(\n                    function(verificationId) {\n                      if (typeof applicationVerifier.reset === 'function') {\n                        applicationVerifier.reset();\n                      }\n                      return verificationId;\n                    },\n                    function(error) {\n                      if (typeof applicationVerifier.reset === 'function') {\n                        applicationVerifier.reset();\n                      }\n                      throw error;\n                    });\n          default:\n            throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n                'Only firebase.auth.ApplicationVerifiers with ' +\n                'type=\"recaptcha\" are currently supported.');\n        }\n      });\n};\n\n\n/**\n * Creates a PhoneAuthCredential.\n * @param {string} verificationId The ID of the phone number flow, to correlate\n *     this request with a previous call to\n *     PhoneAuthProvider.prototype.verifyPhoneNumber.\n * @param {string} verificationCode The verification code that was sent to the\n *     user's phone.\n * @return {!fireauth.PhoneAuthCredential}\n * @override\n */\nfireauth.PhoneAuthProvider.credential =\n    function(verificationId, verificationCode) {\n  if (!verificationId) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_SESSION_INFO);\n  }\n  if (!verificationCode) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_CODE);\n  }\n  return new fireauth.PhoneAuthCredential({\n    verificationId: verificationId,\n    verificationCode: verificationCode\n  });\n};\n\n\n// Set read only PROVIDER_ID property.\nfireauth.object.setReadonlyProperties(fireauth.PhoneAuthProvider, {\n  'PROVIDER_ID': fireauth.idp.ProviderId.PHONE\n});\n\n\n// Set read only PHONE_SIGN_IN_METHOD property.\nfireauth.object.setReadonlyProperties(fireauth.PhoneAuthProvider, {\n  'PHONE_SIGN_IN_METHOD': fireauth.idp.SignInMethod.PHONE\n});\n\n\n/**\n * Constructs an Auth credential from a backend response.\n * Note, unlike fromJSON which constructs the AuthCredential from a toJSON()\n * response, this helper constructs the credential from the server response.\n * @param {?Object} response The backend response to build a credential from.\n * @return {?fireauth.AuthCredential} The corresponding AuthCredential.\n */\nfireauth.AuthProvider.getCredentialFromResponse = function(response) {\n  // Handle phone Auth credential responses, as they have a different format\n  // from other backend responses (i.e. no providerId).\n  if (response['temporaryProof'] && response['phoneNumber']) {\n    return new fireauth.PhoneAuthCredential({\n      temporaryProof: response['temporaryProof'],\n      phoneNumber: response['phoneNumber']\n    });\n  }\n\n  // Get all OAuth response parameters from response.\n  var providerId = response && response['providerId'];\n\n  // Email and password is not supported as there is no situation where the\n  // server would return the password to the client.\n  if (!providerId || providerId === fireauth.idp.ProviderId.PASSWORD) {\n    return null;\n  }\n\n  var accessToken = response && response['oauthAccessToken'];\n  var accessTokenSecret = response && response['oauthTokenSecret'];\n  // Note this is not actually returned by the backend. It is introduced in\n  // rpcHandler.\n  var rawNonce = response && response['nonce'];\n  // Google Id Token returned when no additional scopes provided.\n  var idToken = response && response['oauthIdToken'];\n  // Pending token for SAML and OAuth/OIDC providers.\n  var pendingToken = response && response['pendingToken'];\n  try {\n    switch (providerId) {\n      case fireauth.idp.ProviderId.GOOGLE:\n        return fireauth.GoogleAuthProvider.credential(\n            idToken, accessToken);\n\n      case fireauth.idp.ProviderId.FACEBOOK:\n        return fireauth.FacebookAuthProvider.credential(\n            accessToken);\n\n      case fireauth.idp.ProviderId.GITHUB:\n        return fireauth.GithubAuthProvider.credential(\n            accessToken);\n\n      case fireauth.idp.ProviderId.TWITTER:\n        return fireauth.TwitterAuthProvider.credential(\n            accessToken, accessTokenSecret);\n\n      default:\n        if (!accessToken && !accessTokenSecret && !idToken && !pendingToken) {\n          return null;\n        }\n        if (pendingToken) {\n          if (providerId.indexOf(fireauth.constants.SAML_PREFIX) == 0) {\n            return new fireauth.SAMLAuthCredential(providerId, pendingToken);\n          } else {\n            // OIDC and non-default providers excluding Twitter.\n            return new fireauth.OAuthCredential(\n                providerId,\n                {\n                  'pendingToken': pendingToken,\n                  'idToken': response['oauthIdToken'],\n                  'accessToken': response['oauthAccessToken']\n                },\n                providerId);\n          }\n        }\n        return new fireauth.OAuthProvider(providerId).credential({\n          'idToken': idToken,\n          'accessToken': accessToken,\n          'rawNonce': rawNonce\n        });\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\n\n/**\n * Constructs an Auth credential from a JSON representation.\n * Note, unlike getCredentialFromResponse which constructs the AuthCredential\n * from a server response, this helper constructs credential from the toJSON()\n * result.\n * @param {!Object|string} json The JSON representation to construct credential\n *     from.\n * @return {?fireauth.AuthCredential} The corresponding AuthCredential.\n */\nfireauth.AuthProvider.getCredentialFromJSON = function(json) {\n  var obj = goog.isString(json) ? JSON.parse(json) : json;\n  var credential;\n  var fromJSON = [\n    fireauth.OAuthCredential.fromJSON,\n    fireauth.EmailAuthCredential.fromJSON,\n    fireauth.PhoneAuthCredential.fromJSON,\n    fireauth.SAMLAuthCredential.fromJSON\n  ];\n  for (var i = 0; i < fromJSON.length; i++) {\n    credential = fromJSON[i](obj);\n    if (credential) {\n      return credential;\n    }\n  }\n  return null;\n};\n\n\n/**\n * Constructs an Auth credential from a JSON representation.\n * @param {!Object|string} json The JSON representation to construct credential from.\n * @return {?fireauth.AuthCredential} The corresponding AuthCredential.\n */\nfireauth.AuthCredential.fromPlainObject =\n    fireauth.AuthProvider.getCredentialFromJSON;\n\n\n/**\n * Checks if OAuth is supported by provider, if not throws an error.\n * @param {!fireauth.AuthProvider} provider The provider to check.\n */\nfireauth.AuthProvider.checkIfOAuthSupported =\n    function(provider) {\n  if (!provider['isOAuthProvider']) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INVALID_OAUTH_PROVIDER);\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the Auth event object.\n */\n\ngoog.provide('fireauth.AuthEvent');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\n\n\n/**\n * Defines the authentication event.\n * @param {!fireauth.AuthEvent.Type} type The Auth event type.\n * @param {?string=} opt_eventId The event identifier.\n * @param {?string=} opt_urlResponse The URL with IdP response.\n * @param {?string=} opt_sessionId The session ID used to prevent session\n *     fixation attacks.\n * @param {?fireauth.AuthError=} opt_error The optional error encountered.\n * @param {?string=} opt_postBody The optional POST body.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @constructor\n */\nfireauth.AuthEvent = function(\n    type, opt_eventId, opt_urlResponse, opt_sessionId, opt_error,\n    opt_postBody, opt_tenantId) {\n  /** @const @private {!fireauth.AuthEvent.Type} The Auth event type. */\n  this.type_ = type;\n  /** @const @private {?string} The Auth event ID. */\n  this.eventId_ = opt_eventId || null;\n  /** @const @private {?string} The callback URL with the sign in response. */\n  this.urlResponse_ = opt_urlResponse || null;\n  /** @const @private {?string} The sign in operation session ID. */\n  this.sessionId_ = opt_sessionId || null;\n  /** @const @private {?string} The POST body string if available. */\n  this.postBody_ = opt_postBody || null;\n  /** @const @private {?string} The tenant ID if available. */\n  this.tenantId_ = opt_tenantId || null;\n  /**\n   * @const @private {?fireauth.AuthError} The Auth event error if available.\n   */\n  this.error_ = opt_error || null;\n  if (!this.urlResponse_ && !this.error_) {\n    // Either URL or error is required. They can't be both null.\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT);\n  } else if (this.urlResponse_ && this.error_) {\n    // An error must not be provided when a URL is available.\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT);\n  } else if (this.urlResponse_ && !this.sessionId_) {\n    // A session ID must accompany a URL response.\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT);\n  }\n};\n\n\n\n/**\n * Auth event operation types.\n * All Auth event types that are used for popup operations should be suffixed\n * with `Popup`, whereas those used for redirect operations should be suffixed\n * with `Redirect`.\n * TODO: consider changing the type from a string to an object with ID\n * and some metadata for determining mode: redirect, popup or none.\n * @enum {string}\n */\nfireauth.AuthEvent.Type = {\n  LINK_VIA_POPUP: 'linkViaPopup',\n  LINK_VIA_REDIRECT: 'linkViaRedirect',\n  REAUTH_VIA_POPUP: 'reauthViaPopup',\n  REAUTH_VIA_REDIRECT: 'reauthViaRedirect',\n  SIGN_IN_VIA_POPUP: 'signInViaPopup',\n  SIGN_IN_VIA_REDIRECT: 'signInViaRedirect',\n  UNKNOWN: 'unknown',\n  VERIFY_APP: 'verifyApp'\n};\n\n\n/**\n * @param {!fireauth.AuthEvent} event The Auth event.\n * @return {boolean} Whether the event is a redirect type.\n */\nfireauth.AuthEvent.isRedirect = function(event) {\n  return !!event.getType().match(/Redirect$/);\n};\n\n\n/**\n * @param {!fireauth.AuthEvent} event The Auth event.\n * @return {boolean} Whether the event is a popup type.\n */\nfireauth.AuthEvent.isPopup = function(event) {\n  return !!event.getType().match(/Popup$/);\n};\n\n\n/** @return {!fireauth.AuthEvent.Type} The type of Auth event. */\nfireauth.AuthEvent.prototype.getType = function() {\n  return this.type_;\n};\n\n\n/** @return {?string} The Auth event identifier. */\nfireauth.AuthEvent.prototype.getEventId = function() {\n  return this.eventId_;\n};\n\n\n/** @return {string} The event unique identifier. */\nfireauth.AuthEvent.prototype.getUid = function() {\n  var components = [];\n  components.push(this.type_);\n  if (this.eventId_) {\n    components.push(this.eventId_);\n  }\n  if (this.sessionId_) {\n    components.push(this.sessionId_);\n  }\n  if (this.tenantId_) {\n    components.push(this.tenantId_);\n  }\n  return components.join('-');\n};\n\n\n/** @return {?string} The url response of Auth event. */\nfireauth.AuthEvent.prototype.getUrlResponse = function() {\n  return this.urlResponse_;\n};\n\n\n/** @return {?string} The session ID Auth event. */\nfireauth.AuthEvent.prototype.getSessionId = function() {\n  return this.sessionId_;\n};\n\n\n/** @return {?string} The POST body of the Auth event, if available. */\nfireauth.AuthEvent.prototype.getPostBody = function() {\n  return this.postBody_;\n};\n\n\n/** @return {?string} The tenant ID of the Auth event, if available. */\nfireauth.AuthEvent.prototype.getTenantId = function() {\n  return this.tenantId_;\n};\n\n\n/** @return {?fireauth.AuthError} The error of Auth event. */\nfireauth.AuthEvent.prototype.getError = function() {\n  return this.error_;\n};\n\n\n/** @return {boolean} Whether Auth event has an error. */\nfireauth.AuthEvent.prototype.hasError = function() {\n  return !!this.error_;\n};\n\n\n/** @return {!Object} The plain object representation of event. */\nfireauth.AuthEvent.prototype.toPlainObject = function() {\n  return {\n    'type': this.type_,\n    'eventId': this.eventId_,\n    'urlResponse': this.urlResponse_,\n    'sessionId': this.sessionId_,\n    'postBody': this.postBody_,\n    'tenantId': this.tenantId_,\n    'error': this.error_ && this.error_.toPlainObject()\n  };\n};\n\n\n/**\n * @param {?Object} rawResponse The plain object representation of Auth event.\n * @return {?fireauth.AuthEvent} The Auth event representation of plain object.\n */\nfireauth.AuthEvent.fromPlainObject = function(rawResponse) {\n  var response = rawResponse || {};\n  if (response['type']) {\n    return new fireauth.AuthEvent(\n        response['type'],\n        response['eventId'],\n        response['urlResponse'],\n        response['sessionId'],\n        response['error'] &&\n            fireauth.AuthError.fromPlainObject(response['error']),\n        response['postBody'],\n        response['tenantId']\n        );\n  }\n  return null;\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides the universal link subscriber utility to allow\n * multiple subscriptions for incoming universal link detection.\n */\ngoog.provide('fireauth.UniversalLinkSubscriber');\n\ngoog.require('fireauth.util');\ngoog.require('goog.array');\n\n/**\n * Defines the universal link subscriber class used to allow multiple universal\n * link subscriptions since the underlying plugin only works with one.\n * This utility is needed since the universal link cordova plugin can only allow\n * one subscriber and multiple app instances can subscribe to this.\n * @constructor @final @struct\n */\nfireauth.UniversalLinkSubscriber = function() {\n  /**\n   * @private {?function(?Object)} The master callback that subscribes directly\n   *     to universalLinks.\n   */\n  this.masterCb_ = null;\n  /**\n   * @private {!Array<function(?Object)>} The list of external subscribers that\n   *     are triggered every time the master callback is triggered.\n   */\n  this.cb_ = [];\n};\n\n\n/**\n * @return {!fireauth.UniversalLinkSubscriber} The default universal link\n *     subscriber instance.\n */\nfireauth.UniversalLinkSubscriber.getInstance = function() {\n  if (!fireauth.UniversalLinkSubscriber.instance_) {\n    fireauth.UniversalLinkSubscriber.instance_ =\n        new fireauth.UniversalLinkSubscriber();\n  }\n  return fireauth.UniversalLinkSubscriber.instance_;\n};\n\n\n/** Clears singleton instance. Useful for testing. */\nfireauth.UniversalLinkSubscriber.clear = function() {\n  fireauth.UniversalLinkSubscriber.instance_ = null;\n};\n\n\n/**\n * @private {?fireauth.UniversalLinkSubscriber} The singleton universal\n *     link subscriber instance.\n */\nfireauth.UniversalLinkSubscriber.instance_ = null;\n\n\n/**\n * Subscribes a callback to the universal link plugin listener.\n * @param {function(?Object)} cb The callback to subscribe to the universal\n *     link plugin.\n */\nfireauth.UniversalLinkSubscriber.prototype.subscribe  = function(cb) {\n  var self = this;\n  this.cb_.push(cb);\n  if (!this.masterCb_) {\n    this.masterCb_ = function(event) {\n      for (var i = 0; i < self.cb_.length; i++) {\n        self.cb_[i](event);\n      }\n    };\n    var subscribe = fireauth.util.getObjectRef(\n        'universalLinks.subscribe', goog.global);\n    // For iOS environments, this plugin is not used, therefore this is a no-op\n    // and no error needs to be thrown.\n    if (typeof subscribe === 'function') {\n      subscribe(null, this.masterCb_);\n    }\n  }\n};\n\n\n/**\n * Unsubscribes a callback from the universal link plugin listener.\n * @param {function(?Object)} cb The callback to unsubscribe from the universal\n *     link plugin.\n */\nfireauth.UniversalLinkSubscriber.prototype.unsubscribe = function(cb) {\n  goog.array.removeAllIf(this.cb_, function(ele) {\n    return ele == cb;\n  });\n};\n\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Utility for handling RPC requests to server.\n */\ngoog.provide('fireauth.RpcHandler');\ngoog.provide('fireauth.RpcHandler.ApiMethodHandler');\ngoog.provide('fireauth.RpcHandler.VerifyAssertionData');\ngoog.provide('fireauth.XmlHttpFactory');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthErrorWithCredential');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.idp');\ngoog.require('fireauth.idp.ProviderId');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Uri');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.json');\ngoog.require('goog.net.CorsXmlHttpFactory');\ngoog.require('goog.net.EventType');\ngoog.require('goog.net.FetchXmlHttpFactory');\ngoog.require('goog.net.XhrIo');\ngoog.require('goog.net.XmlHttpFactory');\ngoog.require('goog.net.jsloader');\ngoog.require('goog.object');\ngoog.require('goog.string.Const');\n\n\n\n/**\n * Firebase Auth XmlHttpRequest factory. This is useful for environments like\n * Node.js where XMLHttpRequest does not exist. XmlHttpFactory would be\n * initialized using the polyfill XMLHttpRequest module.\n * @param {function(new:XMLHttpRequest)} xmlHttpRequest The xmlHttpRequest\n *     constructor.\n * @constructor\n * @extends {goog.net.XmlHttpFactory}\n * @final\n */\nfireauth.XmlHttpFactory = function(xmlHttpRequest) {\n  /**\n   * @private {function(new:XMLHttpRequest)} The underlying XHR reference.\n   */\n  this.xmlHttpRequest_ = xmlHttpRequest;\n  fireauth.XmlHttpFactory.base(this, 'constructor');\n};\ngoog.inherits(fireauth.XmlHttpFactory, goog.net.XmlHttpFactory);\n\n\n/**\n * @return {!goog.net.XhrLike|!XMLHttpRequest} A new XhrLike instance.\n * @override\n */\nfireauth.XmlHttpFactory.prototype.createInstance = function() {\n  return new this.xmlHttpRequest_();\n};\n\n\n/**\n * @return {!Object} Options describing how XHR objects obtained from this\n *     factory should be used.\n * @override\n */\nfireauth.XmlHttpFactory.prototype.internalGetOptions = function() {\n  return {};\n};\n\n\n\n/**\n * Creates an RPC request handler for the project specified by the API key.\n *\n * @param {string} apiKey The API key.\n * @param {?Object=} opt_config The RPC request processor configuration.\n * @param {?string=} opt_firebaseClientVersion The optional Firebase client\n *     version to log with requests to Firebase Auth server.\n * @constructor\n */\nfireauth.RpcHandler = function(apiKey, opt_config, opt_firebaseClientVersion) {\n  /** @private {string} The project API key. */\n  this.apiKey_ = apiKey;\n  var config = opt_config || {};\n  this.secureTokenEndpoint_ = config['secureTokenEndpoint'] ||\n      fireauth.RpcHandler.SECURE_TOKEN_ENDPOINT_;\n  /**\n   * @private @const {!fireauth.util.Delay} The delay for secure token endpoint\n   *     network timeout.\n   */\n  this.secureTokenTimeout_ = config['secureTokenTimeout'] ||\n      fireauth.RpcHandler.DEFAULT_SECURE_TOKEN_TIMEOUT_;\n  this.secureTokenHeaders_ = goog.object.clone(\n      config['secureTokenHeaders'] ||\n      fireauth.RpcHandler.DEFAULT_SECURE_TOKEN_HEADERS_);\n  this.firebaseEndpoint_ = config['firebaseEndpoint'] ||\n      fireauth.RpcHandler.FIREBASE_ENDPOINT_;\n  /**\n   * @private @const {!fireauth.util.Delay} The delay for Firebase Auth endpoint\n   *     network timeout.\n   */\n  this.firebaseTimeout_ = config['firebaseTimeout'] ||\n      fireauth.RpcHandler.DEFAULT_FIREBASE_TIMEOUT_;\n  this.firebaseHeaders_ = goog.object.clone(\n      config['firebaseHeaders'] ||\n      fireauth.RpcHandler.DEFAULT_FIREBASE_HEADERS_);\n  // If Firebase client version needs to be logged too.\n  if (opt_firebaseClientVersion) {\n    // Log client version for Firebase Auth server.\n    this.firebaseHeaders_['X-Client-Version'] = opt_firebaseClientVersion;\n    // Log client version for securetoken server.\n    this.secureTokenHeaders_['X-Client-Version'] = opt_firebaseClientVersion;\n  }\n  \n  // Get XMLHttpRequest reference.\n  var XMLHttpRequest = fireauth.RpcHandler.getXMLHttpRequest();\n  if (!XMLHttpRequest && !fireauth.util.isWorker()) {\n    // In a Node.js environment, xmlhttprequest module needs to be required.\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'The XMLHttpRequest compatibility library was not found.');\n  }\n  /** @private {!goog.net.XmlHttpFactory|undefined} The XHR factory. */\n  this.rpcHandlerXhrFactory_ = undefined;\n  // Initialize XHR factory. CORS does not apply in native environments or\n  // workers so don't use CorsXmlHttpFactory in those cases.\n  if (fireauth.util.isWorker()) {\n    // For worker environment use FetchXmlHttpFactory.\n    this.rpcHandlerXhrFactory_ = new goog.net.FetchXmlHttpFactory(\n        /** @type {!WorkerGlobalScope} */ (self));\n  } else if (fireauth.util.isNativeEnvironment()) {\n    // For Node.js, this is the polyfill library. For other environments,\n    // this is the native global XMLHttpRequest.\n    this.rpcHandlerXhrFactory_ = new fireauth.XmlHttpFactory(\n        /** @type {function(new:XMLHttpRequest)} */ (XMLHttpRequest));\n  } else {\n    // CORS Browser environment.\n    this.rpcHandlerXhrFactory_ = new goog.net.CorsXmlHttpFactory();\n  }\n  /** @private {?string} The tenant ID. */\n  this.tenantId_ = null;\n};\n\n\n/**\n * @return {?function(new:XMLHttpRequest)|undefined} The current environment\n *     XMLHttpRequest. This is undefined for worker environment.\n */\nfireauth.RpcHandler.getXMLHttpRequest = function() {\n  // In Node.js XMLHttpRequest is polyfilled.\n  var isNode = fireauth.util.getEnvironment() == fireauth.util.Env.NODE;\n  var XMLHttpRequest = goog.global['XMLHttpRequest'] ||\n      (isNode &&\n       firebase.INTERNAL['node'] &&\n       firebase.INTERNAL['node']['XMLHttpRequest']);\n  return XMLHttpRequest;\n};\n\n\n/**\n * Enums for HTTP request methods.\n * @enum {string}\n */\nfireauth.RpcHandler.HttpMethod = {\n  POST: 'POST',\n  GET: 'GET'\n};\n\n\n/**\n * Firebase Auth server error codes.\n * @enum {string}\n */\nfireauth.RpcHandler.ServerError = {\n  ADMIN_ONLY_OPERATION: 'ADMIN_ONLY_OPERATION',\n  CAPTCHA_CHECK_FAILED: 'CAPTCHA_CHECK_FAILED',\n  CORS_UNSUPPORTED: 'CORS_UNSUPPORTED',\n  CREDENTIAL_MISMATCH: 'CREDENTIAL_MISMATCH',\n  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'CREDENTIAL_TOO_OLD_LOGIN_AGAIN',\n  DYNAMIC_LINK_NOT_ACTIVATED: 'DYNAMIC_LINK_NOT_ACTIVATED',\n  EMAIL_EXISTS: 'EMAIL_EXISTS',\n  EMAIL_NOT_FOUND: 'EMAIL_NOT_FOUND',\n  EXPIRED_OOB_CODE: 'EXPIRED_OOB_CODE',\n  FEDERATED_USER_ID_ALREADY_LINKED: 'FEDERATED_USER_ID_ALREADY_LINKED',\n  INVALID_APP_CREDENTIAL: 'INVALID_APP_CREDENTIAL',\n  INVALID_APP_ID: 'INVALID_APP_ID',\n  INVALID_CERT_HASH: 'INVALID_CERT_HASH',\n  INVALID_CODE: 'INVALID_CODE',\n  INVALID_CONTINUE_URI: 'INVALID_CONTINUE_URI',\n  INVALID_CUSTOM_TOKEN: 'INVALID_CUSTOM_TOKEN',\n  INVALID_DYNAMIC_LINK_DOMAIN: 'INVALID_DYNAMIC_LINK_DOMAIN',\n  INVALID_EMAIL: 'INVALID_EMAIL',\n  INVALID_ID_TOKEN: 'INVALID_ID_TOKEN',\n  INVALID_IDP_RESPONSE: 'INVALID_IDP_RESPONSE',\n  INVALID_IDENTIFIER: 'INVALID_IDENTIFIER',\n  INVALID_MESSAGE_PAYLOAD: 'INVALID_MESSAGE_PAYLOAD',\n  INVALID_OAUTH_CLIENT_ID: 'INVALID_OAUTH_CLIENT_ID',\n  INVALID_OOB_CODE: 'INVALID_OOB_CODE',\n  INVALID_PASSWORD: 'INVALID_PASSWORD',\n  INVALID_PENDING_TOKEN: 'INVALID_PENDING_TOKEN',\n  INVALID_PHONE_NUMBER: 'INVALID_PHONE_NUMBER',\n  INVALID_PROVIDER_ID: 'INVALID_PROVIDER_ID',\n  INVALID_RECIPIENT_EMAIL: 'INVALID_RECIPIENT_EMAIL',\n  INVALID_SENDER: 'INVALID_SENDER',\n  INVALID_SESSION_INFO: 'INVALID_SESSION_INFO',\n  INVALID_TEMPORARY_PROOF: 'INVALID_TEMPORARY_PROOF',\n  INVALID_TENANT_ID: 'INVALID_TENANT_ID',\n  MISSING_ANDROID_PACKAGE_NAME: 'MISSING_ANDROID_PACKAGE_NAME',\n  MISSING_APP_CREDENTIAL: 'MISSING_APP_CREDENTIAL',\n  MISSING_CODE: 'MISSING_CODE',\n  MISSING_CONTINUE_URI: 'MISSING_CONTINUE_URI',\n  MISSING_CUSTOM_TOKEN: 'MISSING_CUSTOM_TOKEN',\n  MISSING_IOS_BUNDLE_ID: 'MISSING_IOS_BUNDLE_ID',\n  MISSING_OOB_CODE: 'MISSING_OOB_CODE',\n  MISSING_OR_INVALID_NONCE: 'MISSING_OR_INVALID_NONCE',\n  MISSING_PASSWORD: 'MISSING_PASSWORD',\n  MISSING_PHONE_NUMBER: 'MISSING_PHONE_NUMBER',\n  MISSING_SESSION_INFO: 'MISSING_SESSION_INFO',\n  OPERATION_NOT_ALLOWED: 'OPERATION_NOT_ALLOWED',\n  PASSWORD_LOGIN_DISABLED: 'PASSWORD_LOGIN_DISABLED',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',\n  RESET_PASSWORD_EXCEED_LIMIT: 'RESET_PASSWORD_EXCEED_LIMIT',\n  REJECTED_CREDENTIAL: 'REJECTED_CREDENTIAL',\n  SESSION_EXPIRED: 'SESSION_EXPIRED',\n  TENANT_ID_MISMATCH: 'TENANT_ID_MISMATCH',\n  TOKEN_EXPIRED: 'TOKEN_EXPIRED',\n  TOO_MANY_ATTEMPTS_TRY_LATER: 'TOO_MANY_ATTEMPTS_TRY_LATER',\n  UNSUPPORTED_TENANT_OPERATION: 'UNSUPPORTED_TENANT_OPERATION',\n  UNAUTHORIZED_DOMAIN: 'UNAUTHORIZED_DOMAIN',\n  USER_CANCELLED: 'USER_CANCELLED',\n  USER_DISABLED: 'USER_DISABLED',\n  USER_NOT_FOUND: 'USER_NOT_FOUND',\n  WEAK_PASSWORD: 'WEAK_PASSWORD'\n};\n\n\n/**\n * A map of server error codes to client errors.\n * @typedef {!Object<\n *     !fireauth.RpcHandler.ServerError, !fireauth.authenum.Error>}\n */\nfireauth.RpcHandler.ServerErrorMap;\n\n\n/**\n * Firebase Auth response field names.\n * @enum {string}\n */\nfireauth.RpcHandler.AuthServerField = {\n  ALL_PROVIDERS: 'allProviders',\n  AUTH_URI: 'authUri',\n  AUTHORIZED_DOMAINS: 'authorizedDomains',\n  DYNAMIC_LINKS_DOMAIN: 'dynamicLinksDomain',\n  EMAIL: 'email',\n  ERROR_MESSAGE: 'errorMessage',\n  EXPIRES_IN: 'expiresIn',\n  ID_TOKEN: 'idToken',\n  NEED_CONFIRMATION: 'needConfirmation',\n  OAUTH_ID_TOKEN: 'oauthIdToken',\n  PENDING_TOKEN: 'pendingToken',\n  POST_BODY: 'postBody',\n  PROVIDER_ID: 'providerId',\n  RECAPTCHA_SITE_KEY: 'recaptchaSiteKey',\n  REQUEST_URI: 'requestUri',\n  REFRESH_TOKEN: 'refreshToken',\n  SESSION_ID: 'sessionId',\n  SESSION_INFO: 'sessionInfo',\n  SIGNIN_METHODS: 'signinMethods',\n  TEMPORARY_PROOF: 'temporaryProof'\n};\n\n\n/**\n * Firebase Auth response injected fields.\n * @enum {string}\n */\nfireauth.RpcHandler.InjectedResponseField = {\n  NONCE: 'nonce'\n};\n\n\n/**\n * Firebase Auth getOobConfirmationCode requestType possible values.\n * @enum {string}\n */\nfireauth.RpcHandler.GetOobCodeRequestType = {\n  EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n  NEW_EMAIL_ACCEPT: 'NEW_EMAIL_ACCEPT',\n  PASSWORD_RESET: 'PASSWORD_RESET',\n  VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n\n/**\n * Firebase Auth response field names.\n * @enum {string}\n */\nfireauth.RpcHandler.StsServerField = {\n  ACCESS_TOKEN: 'access_token',\n  EXPIRES_IN: 'expires_in',\n  REFRESH_TOKEN: 'refresh_token'\n};\n\n\n/**\n * @return {string} The API key.\n */\nfireauth.RpcHandler.prototype.getApiKey = function() {\n  return this.apiKey_;\n};\n\n\n/**\n * The Firebase custom locale header.\n * @const {string}\n * @private\n */\nfireauth.RpcHandler.FIREBASE_LOCALE_KEY_ = 'X-Firebase-Locale';\n\n\n/**\n * The secure token endpoint.\n * @const {string}\n * @private\n */\nfireauth.RpcHandler.SECURE_TOKEN_ENDPOINT_ =\n    'https://securetoken.googleapis.com/v1/token';\n\n\n/**\n * The default timeout delay (units in milliseconds) for requests sending to\n *     STS token endpoint.\n * @const {!fireauth.util.Delay}\n * @private\n */\nfireauth.RpcHandler.DEFAULT_SECURE_TOKEN_TIMEOUT_ =\n    new fireauth.util.Delay(30000, 60000);\n\n\n/**\n * The STS token RPC content headers.\n * @const {!Object}\n * @private\n */\nfireauth.RpcHandler.DEFAULT_SECURE_TOKEN_HEADERS_ = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\n\n/**\n * The Firebase endpoint.\n * @const {string}\n * @private\n */\nfireauth.RpcHandler.FIREBASE_ENDPOINT_ =\n    'https://www.googleapis.com/identitytoolkit/v3/relyingparty/';\n\n\n/**\n * The default timeout delay (units in milliseconds) for requests sending to\n *     Firebase endpoint.\n * @const {!fireauth.util.Delay}\n * @private\n */\nfireauth.RpcHandler.DEFAULT_FIREBASE_TIMEOUT_ =\n    new fireauth.util.Delay(30000, 60000);\n\n\n/**\n * The Firebase RPC content headers.\n * @const {!Object}\n * @private\n */\nfireauth.RpcHandler.DEFAULT_FIREBASE_HEADERS_ = {\n  'Content-Type': 'application/json'\n};\n\n\n/**\n * Updates the custom locale header.\n * @param {?string} languageCode The new languageCode.\n */\nfireauth.RpcHandler.prototype.updateCustomLocaleHeader =\n    function(languageCode) {\n  if (languageCode) {\n    // If a language code is provided, add it to the header.\n    this.firebaseHeaders_[fireauth.RpcHandler.FIREBASE_LOCALE_KEY_] =\n        languageCode;\n  } else {\n    // Otherwise remove the custom locale header.\n    delete this.firebaseHeaders_[fireauth.RpcHandler.FIREBASE_LOCALE_KEY_];\n  }\n};\n\n\n/**\n * Updates the X-Client-Version in the header.\n * @param {?string} clientVersion The new client version.\n */\nfireauth.RpcHandler.prototype.updateClientVersion = function(clientVersion) {\n  if (clientVersion) {\n    // Update client version for Firebase Auth server.\n    this.firebaseHeaders_['X-Client-Version'] = clientVersion;\n    // Update client version for securetoken server.\n    this.secureTokenHeaders_['X-Client-Version'] = clientVersion;\n  } else {\n    // Remove client version from header.\n    delete this.firebaseHeaders_['X-Client-Version'];\n    delete this.secureTokenHeaders_['X-Client-Version'];\n  }\n};\n\n\n/**\n * Updates the tenant ID in the request.\n * @param {?string} tenantId The new tenant ID.\n */\nfireauth.RpcHandler.prototype.updateTenantId = function(tenantId) {\n  this.tenantId_ = tenantId;\n};\n\n\n/**\n * Returns the tenant ID.\n * @return {?string} The tenant ID.\n */\nfireauth.RpcHandler.prototype.getTenantId = function() {\n  return this.tenantId_;\n};\n\n\n/**\n * Sends XhrIo request using goog.net.XhrIo.\n * @param {string} url The URL to make a request to.\n * @param {function(?Object)=} opt_callback The callback to run on completion.\n * @param {fireauth.RpcHandler.HttpMethod=} opt_httpMethod The HTTP send method.\n * @param {?ArrayBuffer|?ArrayBufferView|?Blob|?Document|?FormData|string=}\n *     opt_data The request content.\n * @param {?Object=} opt_headers The request content headers.\n * @param {number=} opt_timeout The request timeout.\n * @private\n */\nfireauth.RpcHandler.prototype.sendXhr_ = function(\n    url,\n    opt_callback,\n    opt_httpMethod,\n    opt_data,\n    opt_headers,\n    opt_timeout) {\n  var sendXhr;\n  if (fireauth.util.supportsCors() || fireauth.util.isWorker()) {\n    // If supports CORS use goog.net.XhrIo.\n    sendXhr = goog.bind(this.sendXhrUsingXhrIo_, this);\n  } else {\n    // Load gapi.client.request and gapi.auth dependency dynamically.\n    if (!fireauth.RpcHandler.loadGApi_) {\n      fireauth.RpcHandler.loadGApi_ =\n          new goog.Promise(function(resolve, reject) {\n            // On load, resolve.\n            fireauth.RpcHandler.loadGApiJs_(resolve, reject);\n          });\n    }\n    // If does not support CORS, use gapi.client.request.\n    sendXhr = goog.bind(this.sendXhrUsingGApiClient_, this);\n  }\n  sendXhr(\n      url, opt_callback, opt_httpMethod, opt_data, opt_headers, opt_timeout);\n};\n\n\n/**\n * Sends XhrIo request using goog.net.XhrIo.\n * @param {string} url The URL to make a request to.\n * @param {function(?Object)=} opt_callback The callback to run on completion.\n * @param {fireauth.RpcHandler.HttpMethod=} opt_httpMethod The HTTP send method.\n * @param {?ArrayBuffer|?ArrayBufferView|?Blob|?Document|?FormData|string=}\n *     opt_data The request content.\n * @param {?Object=} opt_headers The request content headers.\n * @param {number=} opt_timeout The request timeout.\n * @private\n */\nfireauth.RpcHandler.prototype.sendXhrUsingXhrIo_ = function(\n    url,\n    opt_callback,\n    opt_httpMethod,\n    opt_data,\n    opt_headers,\n    opt_timeout) {\n  if (fireauth.util.isWorker() && !fireauth.util.isFetchSupported()) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED,\n        'fetch, Headers and Request native APIs or equivalent Polyfills ' +\n        'must be available to support HTTP requests from a Worker ' +\n        'environment.');\n  }\n  var xhrIo = new goog.net.XhrIo(this.rpcHandlerXhrFactory_);\n\n  // xhrIo.setTimeoutInterval not working in IE10 and IE11, handle manually.\n  var requestTimeout;\n  if (opt_timeout) {\n    xhrIo.setTimeoutInterval(opt_timeout);\n    requestTimeout = setTimeout(function() {\n      xhrIo.dispatchEvent(goog.net.EventType.TIMEOUT);\n    }, opt_timeout);\n  }\n  // Run callback function on completion.\n  xhrIo.listen(\n      goog.net.EventType.COMPLETE,\n      /** @this {goog.net.XhrIo} */\n      function() {\n        // Clear timeout timer.\n        if (requestTimeout) {\n          clearTimeout(requestTimeout);\n        }\n        // Response assumed to be in json format. If not, catch, log error and\n        // pass null to callback.\n        var response = null;\n        try {\n          // Do not use this.responseJson() as it uses goog.json.parse\n          // underneath. Internal goog.json.parse parsing uses eval and since\n          // recommended Content Security Policy does not allow unsafe-eval,\n          // this is failing and throwing an error in chrome extensions and\n          // warnings else where. Use native parsing instead via JSON.parse.\n          response = JSON.parse(this.getResponseText()) || null;\n        } catch (e) {\n          response = null;\n        }\n        if (opt_callback) {\n          opt_callback(/** @type {?Object} */ (response));\n        }\n      });\n  // Dispose xhrIo on ready.\n  xhrIo.listenOnce(\n      goog.net.EventType.READY,\n      /** @this {goog.net.XhrIo} */\n      function() {\n        // Clear timeout timer.\n        if (requestTimeout) {\n          clearTimeout(requestTimeout);\n        }\n        // Dispose xhrIo.\n        this.dispose();\n      });\n  // Listen to timeout error.\n  // This should work when request is aborted too.\n  xhrIo.listenOnce(\n      goog.net.EventType.TIMEOUT,\n      /** @this {goog.net.XhrIo} */\n      function() {\n        // Clear timeout timer.\n        if (requestTimeout) {\n          clearTimeout(requestTimeout);\n        }\n        // Dispose xhrIo.\n        this.dispose();\n        // The request timed out.\n        if (opt_callback) {\n          opt_callback(null);\n        }\n      });\n  xhrIo.send(url, opt_httpMethod, opt_data, opt_headers);\n};\n\n\n/**\n * @const {!goog.string.Const} The GApi client library URL.\n * @private\n */\nfireauth.RpcHandler.GAPI_SRC_ = goog.string.Const.from(\n    'https://apis.google.com/js/client.js?onload=%{onload}');\n\n\n/**\n * @const {string}\n * @private\n */\nfireauth.RpcHandler.GAPI_CALLBACK_NAME_ =\n    '__fcb' + Math.floor(Math.random() * 1000000).toString();\n\n\n/**\n * Loads the GApi client library if it is not loaded.\n * @param {function()} callback The callback to invoke once it's loaded.\n * @param {function(?Object)} errback The error callback.\n * @private\n */\nfireauth.RpcHandler.loadGApiJs_ = function(callback, errback) {\n  // If gapi.client.request not available, load it dynamically.\n  if (!((window['gapi'] || {})['client'] || {})['request']) {\n    goog.global[fireauth.RpcHandler.GAPI_CALLBACK_NAME_] = function() {\n      // Callback will be called by GApi, test properly loaded here instead of\n      // after jsloader resolves.\n      if (!((window['gapi'] || {})['client'] || {})['request']) {\n        errback(new Error(fireauth.RpcHandler.ServerError.CORS_UNSUPPORTED));\n      } else {\n        callback();\n      }\n    };\n    var url = goog.html.TrustedResourceUrl.format(\n        fireauth.RpcHandler.GAPI_SRC_,\n        {'onload': fireauth.RpcHandler.GAPI_CALLBACK_NAME_});\n    // TODO: replace goog.net.jsloader with our own script includer.\n    var result = goog.net.jsloader.safeLoad(url);\n    result.addErrback(function() {\n      // In case file fails to load.\n      errback(new Error(fireauth.RpcHandler.ServerError.CORS_UNSUPPORTED));\n    });\n  } else {\n    callback();\n  }\n};\n\n\n/**\n * Sends XhrIo request using gapi.client.\n * @param {string} url The URL to make a request to.\n * @param {function(?Object)=} opt_callback The callback to run on completion.\n * @param {fireauth.RpcHandler.HttpMethod=} opt_httpMethod The HTTP send method.\n * @param {?ArrayBuffer|?ArrayBufferView|?Blob|?Document|?FormData|string=}\n *     opt_data The request content.\n * @param {?Object=} opt_headers The request content headers.\n * @param {number=} opt_timeout The request timeout.\n * @private\n */\nfireauth.RpcHandler.prototype.sendXhrUsingGApiClient_ = function(\n    url,\n    opt_callback,\n    opt_httpMethod,\n    opt_data,\n    opt_headers,\n    opt_timeout) {\n  var self = this;\n  // Wait for GApi dependency to load.\n  fireauth.RpcHandler.loadGApi_.then(function() {\n    window['gapi']['client']['setApiKey'](self.getApiKey());\n    // GApi maintains the Auth result and automatically append the Auth token to\n    // all outgoing requests. Firebase Auth requests will be rejected if there\n    // are others scopes (e.g. google plus) for the Auth token. Need to empty\n    // the token before call gitkit api. Restored in callback.\n    var oauth2Token = window['gapi']['auth']['getToken']();\n    window['gapi']['auth']['setToken'](null);\n    window['gapi']['client']['request']({\n      'path': url,\n      'method': opt_httpMethod,\n      'body': opt_data,\n      'headers': opt_headers,\n      // This needs to be set to none, otherwise the access token will be passed\n      // in the header field causing apiary to complain.\n      'authType': 'none',\n      'callback': function(response) {\n        window['gapi']['auth']['setToken'](oauth2Token);\n        if (opt_callback) {\n          opt_callback(response);\n        }\n      }\n    });\n  }).thenCatch(function(error) {\n    // Catches failure to support CORS and propagates it.\n    if (opt_callback) {\n      // Simulate backend server error to be caught by upper layer.\n      opt_callback({\n        'error': {\n          'message': (error && error['message']) ||\n              fireauth.RpcHandler.ServerError.CORS_UNSUPPORTED\n        }\n      });\n    }\n  });\n};\n\n\n/**\n * Validates the request for the STS access token.\n *\n * @param {?Object} data The STS token request body.\n * @return {boolean} Whether the request is valid.\n * @private\n */\nfireauth.RpcHandler.prototype.validateStsTokenRequest_ = function(data) {\n  if (data['grant_type'] == 'refresh_token' && data['refresh_token']) {\n    // Exchange refresh token.\n    return true;\n  } else if (data['grant_type'] == 'authorization_code' && data['code']) {\n    // Exchange ID token.\n    return true;\n  } else {\n    // Invalid.\n    return false;\n  }\n};\n\n\n/**\n * Handles the request for the STS access token.\n *\n * @param {!Object} data The STS token request body.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.requestStsToken = function(data) {\n  var self = this;\n  return new goog.Promise(function(resolve, reject) {\n    if (self.validateStsTokenRequest_(data)) {\n      self.sendXhr_(\n          self.secureTokenEndpoint_ + '?key=' +\n          encodeURIComponent(self.getApiKey()),\n          function(response) {\n            if (!response) {\n              // An unparseable response from the XHR most likely indicates some\n              // problem with the network.\n              reject(new fireauth.AuthError(\n                  fireauth.authenum.Error.NETWORK_REQUEST_FAILED));\n            } else if (fireauth.RpcHandler.hasError_(response)) {\n              reject(fireauth.RpcHandler.getDeveloperError_(response));\n            } else if (\n                !response[fireauth.RpcHandler.StsServerField.ACCESS_TOKEN] ||\n                !response[fireauth.RpcHandler.StsServerField.REFRESH_TOKEN]) {\n              reject(new fireauth.AuthError(\n                  fireauth.authenum.Error.INTERNAL_ERROR));\n            } else {\n              resolve(response);\n            }\n          },\n          fireauth.RpcHandler.HttpMethod.POST,\n          goog.Uri.QueryData.createFromMap(data).toString(),\n          self.secureTokenHeaders_,\n          self.secureTokenTimeout_.get());\n    } else {\n      reject(new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR));\n    }\n  });\n};\n\n\n/**\n * @param {!Object} data The object to serialize.\n * @return {string} The serialized object with null, undefined and empty string\n *     values removed.\n * @private\n */\nfireauth.RpcHandler.serialize_ = function(data) {\n  // goog.json.serialize converts undefined values to null.\n  // This helper removes all empty strings, nulls and undefined from serialized\n  // object.\n  // Serialize trimmed data.\n  return goog.json.serialize(fireauth.util.copyWithoutNullsOrUndefined(data));\n};\n\n\n/**\n * Creates and executes a request for the given API method.\n * @param {string} method The API method.\n * @param {!fireauth.RpcHandler.HttpMethod} httpMethod The http request method.\n * @param {!Object} data The data for the API request. In the case of a GET\n *     request, the contents of this object will be form encoded and appended\n *     to the query string of the URL. No post body is sent in that case. If an\n *     object value is specified, it will be converted to a string:\n *     encodeURIComponent(String(value)).\n * @param {?fireauth.RpcHandler.ServerErrorMap=} opt_customErrorMap A map\n *     of server error codes to client errors to override default error\n *     handling.\n * @param {boolean=} opt_cachebuster Whether to append a unique string to\n *     request to force backend to return an uncached response to request.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.requestFirebaseEndpoint = function(\n    method, httpMethod, data, opt_customErrorMap, opt_cachebuster) {\n  var self = this;\n  // Construct endpoint URL.\n  var uri = goog.Uri.parse(this.firebaseEndpoint_ + method);\n  uri.setParameterValue('key', this.getApiKey());\n  // Check whether to append cachebuster to request.\n  if (opt_cachebuster) {\n    uri.setParameterValue('cb', goog.now().toString());\n  }\n  // Firebase allows GET endpoints.\n  var isGet = httpMethod == fireauth.RpcHandler.HttpMethod.GET;\n  if (isGet) {\n    // For GET HTTP method, append data to query string.\n    for (var key in data) {\n      if (data.hasOwnProperty(key)) {\n        uri.setParameterValue(key, data[key]);\n      }\n    }\n  }\n  return new goog.Promise(function(resolve, reject) {\n    self.sendXhr_(\n        uri.toString(),\n        function(response) {\n          if (!response) {\n            // An unparseable response from the XHR most likely indicates some\n            // problem with the network.\n            reject(new fireauth.AuthError(\n                fireauth.authenum.Error.NETWORK_REQUEST_FAILED));\n          } else if (fireauth.RpcHandler.hasError_(response)) {\n            reject(fireauth.RpcHandler.getDeveloperError_(response,\n                opt_customErrorMap || {}));\n          } else {\n            resolve(response);\n          }\n        },\n        httpMethod,\n        // No post body data in GET requests.\n        isGet ? undefined : fireauth.RpcHandler.serialize_(data),\n        self.firebaseHeaders_,\n        self.firebaseTimeout_.get());\n  });\n};\n\n\n/**\n * Verifies that the request has a valid email set.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateRequestHasEmail_ = function(request) {\n  if (!fireauth.util.isValidEmailAddress(request['email'])) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_EMAIL);\n  }\n};\n\n\n/**\n * Verifies that the response has a valid email set.\n * @param {!Object} response\n * @private\n */\nfireauth.RpcHandler.validateResponseHasEmail_ = function(response) {\n  if (!fireauth.util.isValidEmailAddress(response['email'])) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Verifies that the an email is valid, if it is there.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateEmailIfPresent_ = function(request) {\n  if ('email' in request) {\n    fireauth.RpcHandler.validateRequestHasEmail_(request);\n  }\n};\n\n\n/**\n * @param {string} providerId The provider ID.\n * @param {?Array<string>=} opt_additionalScopes The list of scope strings.\n * @return {?string} The IDP and its comma separated scope strings serialized.\n * @private\n */\nfireauth.RpcHandler.getAdditionalScopes_ =\n    function(providerId, opt_additionalScopes) {\n  var scopes = {};\n  if (opt_additionalScopes && opt_additionalScopes.length) {\n    scopes[providerId] = opt_additionalScopes.join(',');\n    // Return stringified scopes.\n    return goog.json.serialize(scopes);\n  }\n  return null;\n};\n\n\n/**\n * Validates a response from getAuthUri.\n * @param {?Object} response The getAuthUri response data.\n * @private\n */\nfireauth.RpcHandler.validateGetAuthResponse_ = function(response) {\n  if (!response[fireauth.RpcHandler.AuthServerField.AUTH_URI]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'Unable to determine the authorization endpoint for the specified '+\n        'provider. This may be an issue in the provider configuration.');\n  } else if ( !response[fireauth.RpcHandler.AuthServerField.SESSION_ID]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Requests createAuthUri endpoint to retrieve the authUri and session ID for\n * the start of an OAuth handshake.\n * @param {string} providerId The provider ID.\n * @param {string} continueUri The IdP callback URL.\n * @param {?Object=} opt_customParameters The optional OAuth custom parameters\n *     plain object.\n * @param {?Array<string>=} opt_additionalScopes The list of scope strings.\n * @param {?string=} opt_email The optional email.\n * @param {?string=} opt_sessionId The optional session ID.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.getAuthUri = function(\n    providerId,\n    continueUri,\n    opt_customParameters,\n    opt_additionalScopes,\n    opt_email,\n    opt_sessionId) {\n  // SAML provider request is constructed differently than OAuth requests.\n  var isSaml = fireauth.idp.isSaml(providerId);\n  var request = {\n    'identifier': opt_email,\n    'providerId': providerId,\n    'continueUri': continueUri,\n    'customParameter': opt_customParameters || {},\n    'oauthScope': fireauth.RpcHandler.getAdditionalScopes_(\n        providerId, opt_additionalScopes),\n    'sessionId': opt_sessionId\n  };\n  // Custom parameters and OAuth scopes should be ignored.\n  if (isSaml) {\n    delete request['customParameter'];\n    delete request['oauthScope'];\n  }\n  // When sessionId is provided, mobile flow (Cordova) is being used, force\n  // code flow and not implicit flow. All other providers use code flow by\n  // default.\n  if (opt_sessionId && providerId == fireauth.idp.ProviderId.GOOGLE) {\n    request['authFlowType'] = 'CODE_FLOW';\n  }\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.GET_AUTH_URI,\n      request);\n};\n\n\n/**\n * Gets the list of IDPs that can be used to log in for the given identifier.\n * @param {string} identifier The identifier, such as an email address.\n * @return {!goog.Promise<!Array<string>>}\n */\nfireauth.RpcHandler.prototype.fetchProvidersForIdentifier =\n    function(identifier) {\n  // createAuthUri returns an error if continue URI is not http or https.\n  // For environments like Cordova, Chrome extensions, native frameworks, file\n  // systems, etc, use http://localhost as continue URL.\n  var continueUri = fireauth.util.isHttpOrHttps() ?\n      fireauth.util.getCurrentUrl() : 'http://localhost';\n  var request = {\n    'identifier': identifier,\n    'continueUri': continueUri\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.CREATE_AUTH_URI, request)\n      .then(function(response) {\n        return response[fireauth.RpcHandler.AuthServerField.ALL_PROVIDERS] ||\n            [];\n      });\n};\n\n\n/**\n * Returns the list of sign in methods for the given identifier.\n * @param {string} identifier The identifier, such as an email address.\n * @return {!goog.Promise<!Array<string>>}\n */\nfireauth.RpcHandler.prototype.fetchSignInMethodsForIdentifier = function(\n    identifier) {\n  // createAuthUri returns an error if continue URI is not http or https.\n  // For environments like Cordova, Chrome extensions, native frameworks, file\n  // systems, etc, use http://localhost as continue URL.\n  var continueUri = fireauth.util.isHttpOrHttps() ?\n      fireauth.util.getCurrentUrl() :\n      'http://localhost';\n  var request = {\n    'identifier': identifier,\n    'continueUri': continueUri\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.CREATE_AUTH_URI, request)\n      .then(function(response) {\n        return response[fireauth.RpcHandler.AuthServerField.SIGNIN_METHODS] ||\n            [];\n      });\n};\n\n\n/**\n * Gets the list of authorized domains for the specified project.\n * @return {!goog.Promise<!Array<string>>}\n */\nfireauth.RpcHandler.prototype.getAuthorizedDomains = function() {\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.GET_PROJECT_CONFIG, {})\n      .then(function(response) {\n        return response[\n           fireauth.RpcHandler.AuthServerField.AUTHORIZED_DOMAINS] || [];\n      });\n};\n\n\n/**\n * Gets the reCAPTCHA parameters needed to render the project's provisioned\n * reCAPTCHA.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.getRecaptchaParam = function() {\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.GET_RECAPTCHA_PARAM, {});\n};\n\n\n/**\n * Gets the list of authorized domains for the specified project.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.getDynamicLinkDomain = function() {\n  var request = {\n    'returnDynamicLink': true\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.RETURN_DYNAMIC_LINK, request);\n};\n\n\n/**\n * Checks if the provided iOS bundle ID belongs to the project as specified by\n * the API key.\n * @param {string} iosBundleId  The iOS bundle ID to check.\n * @return {!goog.Promise<void>}\n */\nfireauth.RpcHandler.prototype.isIosBundleIdValid = function(iosBundleId) {\n  var request = {\n    'iosBundleId': iosBundleId\n  };\n  // This will either resolve if the identifier is valid or throw INVALID_APP_ID\n  // if not.\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.GET_PROJECT_CONFIG, request)\n      .then(function(result) {\n        // Do not return anything.\n      });\n};\n\n\n/**\n * Checks if the provided Android package name belongs to the project as\n * specified by the API key.\n * @param {string} androidPackageName  The iOS bundle ID to check.\n * @param {?string=} opt_sha1Cert The optional SHA-1 Android cert to check.\n * @return {!goog.Promise<void>}\n */\nfireauth.RpcHandler.prototype.isAndroidPackageNameValid =\n    function(androidPackageName, opt_sha1Cert) {\n  var request = {\n    'androidPackageName': androidPackageName\n  };\n  // This is relevant for the native Android SDK flow.\n  // This will redirect to an FDL domain owned by GMScore instead of\n  // the developer's FDL domain as is done for Cordova apps.\n  if (!!opt_sha1Cert) {\n    request['sha1Cert'] = opt_sha1Cert;\n  }\n  // When no sha1Cert is passed, this will either resolve if the identifier is\n  // valid or throw INVALID_APP_ID if not.\n  // When sha1Cert is also passed, this will either resolve or fail with an\n  // INVALID_CERT_HASH error.\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.GET_PROJECT_CONFIG, request)\n      .then(function(result) {\n        // Do not return anything.\n      });\n};\n\n\n/**\n * Checks if the provided OAuth client ID belongs to the project as specified by\n * the API key.\n * @param {string} clientId The OAuth client ID to check.\n * @return {!goog.Promise<void>}\n */\nfireauth.RpcHandler.prototype.isOAuthClientIdValid = function(clientId) {\n  var request = {\n    'clientId': clientId\n  };\n  // This will either resolve if the client ID is valid or throw\n  // INVALID_OAUTH_CLIENT_ID if not.\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.GET_PROJECT_CONFIG, request)\n      .then(function(result) {\n        // Do not return anything.\n      });\n};\n\n\n/**\n * Requests getAccountInfo endpoint using an ID token.\n * @param {string} idToken The ID token.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.getAccountInfoByIdToken = function(idToken) {\n  var request = {'idToken': idToken};\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.GET_ACCOUNT_INFO,\n      request);\n};\n\n\n/**\n * Validates a request to sign in with email and password.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateVerifyCustomTokenRequest_ = function(request) {\n  if (!request['token']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_CUSTOM_TOKEN);\n  }\n};\n\n\n/**\n * Verifies a custom token and returns a Promise that resolves with the ID\n * token.\n * @param {string} token The custom token.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyCustomToken = function(token) {\n  var request = {'token': token};\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.VERIFY_CUSTOM_TOKEN,\n      request);\n};\n\n\n/**\n * Validates a request to sign in with email and password.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateVerifyPasswordRequest_ = function(request) {\n  fireauth.RpcHandler.validateRequestHasEmail_(request);\n  if (!request['password']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_PASSWORD);\n  }\n};\n\n\n/**\n * Verifies a password and returns a Promise that resolves with the ID\n * token.\n * @param {string} email The email address.\n * @param {string} password The entered password.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyPassword = function(email, password) {\n  var request = {\n    'email': email,\n    'password': password\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.VERIFY_PASSWORD,\n      request);\n};\n\n\n/**\n * Verifies an email link OTP for sign-in and returns a Promise that resolves\n * with the ID token.\n * @param {string} email The email address.\n * @param {string} oobCode The email action OTP.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.emailLinkSignIn = function(email, oobCode) {\n  var request = {\n    'email': email,\n    'oobCode': oobCode\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.EMAIL_LINK_SIGNIN, request);\n};\n\n\n/**\n * Verifies an email link OTP for linking and returns a Promise that resolves\n * with the ID token.\n * @param {string} idToken The ID token.\n * @param {string} email The email address.\n * @param {string} oobCode The email action OTP.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.emailLinkSignInForLinking =\n    function(idToken, email, oobCode) {\n  var request = {\n    'idToken': idToken,\n    'email': email,\n    'oobCode': oobCode\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.EMAIL_LINK_SIGNIN_FOR_LINKING,\n      request);\n};\n\n\n/**\n * Validates a response that should contain an ID token.\n * @param {?Object} response The server response data.\n * @private\n */\nfireauth.RpcHandler.validateIdTokenResponse_ = function(response) {\n  if (!response[fireauth.RpcHandler.AuthServerField.ID_TOKEN]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Validates a getRecaptchaParam response.\n * @param {?Object} response The server response data.\n * @private\n */\nfireauth.RpcHandler.validateGetRecaptchaParamResponse_ = function(response) {\n  // Both are required. This could change though.\n  if (!response[fireauth.RpcHandler.AuthServerField.RECAPTCHA_SITE_KEY]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Validates a request that sends the verification ID and code for a sign in/up\n * phone Auth flow.\n * @param {!Object} request The server request object.\n * @private\n */\nfireauth.RpcHandler.validateVerifyPhoneNumberRequest_ = function(request) {\n  // There are 2 cases here:\n  // case 1: sessionInfo and code\n  // case 2: phoneNumber and temporaryProof\n  if (request['phoneNumber'] || request['temporaryProof']) {\n    // Case 2. Both phoneNumber and temporaryProof should be set.\n    if (!request['phoneNumber'] || !request['temporaryProof']) {\n      throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n    }\n  } else {\n    // Otherwise it's case 1, so we expect sessionInfo and code.\n    if (!request['sessionInfo']) {\n      throw new fireauth.AuthError(\n          fireauth.authenum.Error.MISSING_SESSION_INFO);\n    }\n    if (!request['code']) {\n      throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_CODE);\n    }\n  }\n};\n\n\n/**\n * Validates a request that sends the verification ID and code for a link/update\n * phone Auth flow.\n * @param {!Object} request The server request object.\n * @private\n */\nfireauth.RpcHandler.validateVerifyPhoneNumberLinkRequest_ = function(request) {\n  // idToken should be required here.\n  if (!request['idToken']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n  // The other request parameters match the sign in flow.\n  fireauth.RpcHandler.validateVerifyPhoneNumberRequest_(request);\n};\n\n\n/**\n * Validates a request to create an email and password account.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateCreateAccountRequest_ = function(request) {\n  fireauth.RpcHandler.validateRequestHasEmail_(request);\n  if (!request['password']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.WEAK_PASSWORD);\n  }\n};\n\n\n/**\n * Validates a request to createAuthUri.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateGetAuthUriRequest_ = function(request) {\n  if (!request['continueUri']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_CONTINUE_URI);\n  }\n  // Either a SAML or non SAML providerId must be provided.\n  if (!request['providerId']) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INTERNAL_ERROR,\n        'A provider ID must be provided in the request.');\n  }\n};\n\n\n/**\n * Creates an email/password account. Returns a Promise that resolves with the\n * ID token.\n * @param {string} email The email address of the account.\n * @param {string} password The password.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.createAccount = function(email, password) {\n  var request = {\n    'email': email,\n    'password': password\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.CREATE_ACCOUNT,\n      request);\n};\n\n\n/**\n * Signs in a user as anonymous. Returns a Promise that resolves with the\n * ID token.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.signInAnonymously = function() {\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.SIGN_IN_ANONYMOUSLY, {});\n};\n\n\n/**\n * Deletes the user's account corresponding to the idToken given.\n * @param {string} idToken The idToken of the user.\n * @return {!goog.Promise<undefined>}\n */\nfireauth.RpcHandler.prototype.deleteAccount = function(idToken) {\n  var request = {\n    'idToken': idToken\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.DELETE_ACCOUNT,\n      request);\n};\n\n\n/**\n * Requests setAccountInfo endpoint for updateEmail operation.\n * @param {string} idToken The ID token.\n * @param {string} newEmail The new email.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.updateEmail = function(idToken, newEmail) {\n  var request = {\n    'idToken': idToken,\n    'email': newEmail\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.SET_ACCOUNT_INFO,\n      request);\n};\n\n\n/**\n * Validates a setAccountInfo request that updates the password.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateSetAccountInfoSensitive_ = function(request) {\n  fireauth.RpcHandler.validateEmailIfPresent_(request);\n  if (!request['password']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.WEAK_PASSWORD);\n  }\n};\n\n\n/**\n * Requests setAccountInfo endpoint for updatePassword operation.\n * @param {string} idToken The ID token.\n * @param {string} newPassword The new password.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.updatePassword = function(idToken, newPassword) {\n  var request = {\n    'idToken': idToken,\n    'password': newPassword\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.SET_ACCOUNT_INFO_SENSITIVE, request);\n};\n\n\n/**\n * Requests setAccountInfo endpoint to set the email and password. This can be\n * used to link an existing account to a new email and password account.\n * @param {string} idToken The ID token.\n * @param {string} newEmail The new email.\n * @param {string} newPassword The new password.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.updateEmailAndPassword = function(idToken,\n    newEmail, newPassword) {\n  var request = {\n    'idToken': idToken,\n    'email': newEmail,\n    'password': newPassword\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.SET_ACCOUNT_INFO_SENSITIVE, request);\n};\n\n\n/**\n * Maps the name of a field in the account info object to the backend enum\n * value, for deletion of profile fields.\n * @private {!Object<string, string>}\n */\nfireauth.RpcHandler.PROFILE_FIELD_TO_ENUM_NAME_ = {\n  'displayName': 'DISPLAY_NAME',\n  'photoUrl': 'PHOTO_URL'\n};\n\n\n/**\n * Updates the profile of the user. When resolved, promise returns a response\n * similar to that of getAccountInfo.\n * @param {string} idToken The ID token of the user whose profile is changing.\n * @param {!Object} profileData The new profile data.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.updateProfile = function(idToken, profileData) {\n  var data = {\n    'idToken': idToken\n  };\n  var fieldsToDelete = [];\n\n  // Copy over the relevant fields from profileData, or explicitly flag a field\n  // for deletion if null is passed as the value. Note that this currently only\n  // checks profileData to the first level.\n  goog.object.forEach(fireauth.RpcHandler.PROFILE_FIELD_TO_ENUM_NAME_,\n      function(enumName, fieldName) {\n        var fieldValue = profileData[fieldName];\n        if (fieldValue === null) {\n          // If null is explicitly provided, delete the field.\n          fieldsToDelete.push(enumName);\n        } else if (fieldName in profileData) {\n          // If the field is explicitly set, send it to the backend.\n          data[fieldName] = fieldValue;\n        }\n      });\n  if (fieldsToDelete.length) {\n    data['deleteAttribute'] = fieldsToDelete;\n  }\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.SET_ACCOUNT_INFO, data);\n};\n\n\n/**\n * Validates a request for an email action code for password reset.\n * @param {!Object} request The getOobCode request data for password reset.\n * @private\n */\nfireauth.RpcHandler.validateOobCodeRequest_ = function(request) {\n  if (request['requestType'] !=\n          fireauth.RpcHandler.GetOobCodeRequestType.PASSWORD_RESET) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n  fireauth.RpcHandler.validateRequestHasEmail_(request);\n};\n\n\n/**\n * Validates a request for an email action for passwordless email sign-in.\n * @param {!Object} request The getOobCode request data for email sign-in.\n * @private\n */\nfireauth.RpcHandler.validateEmailSignInCodeRequest_ = function(request) {\n  if (request['requestType'] !=\n      fireauth.RpcHandler.GetOobCodeRequestType.EMAIL_SIGNIN) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n  fireauth.RpcHandler.validateRequestHasEmail_(request);\n};\n\n\n/**\n * Validates a request for an email action for email verification.\n * @param {!Object} request The getOobCode request data for email verification.\n * @private\n */\nfireauth.RpcHandler.validateEmailVerificationCodeRequest_ = function(request) {\n  if (request['requestType'] !=\n          fireauth.RpcHandler.GetOobCodeRequestType.VERIFY_EMAIL) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Requests getOobCode endpoint for password reset, returns promise that\n * resolves with user's email.\n * @param {string} email The email account with the password to be reset.\n * @param {!Object} additionalRequestData Additional data to add to the request.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.sendPasswordResetEmail =\n    function(email, additionalRequestData) {\n  var request = {\n    'requestType': fireauth.RpcHandler.GetOobCodeRequestType.PASSWORD_RESET,\n    'email': email\n  };\n  // Extend the original request with the additional data.\n  goog.object.extend(request, additionalRequestData);\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.GET_OOB_CODE, request);\n};\n\n\n/**\n * Requests getOobCode endpoint for passwordless email sign-in, returns promise\n * that resolves with user's email.\n * @param {string} email The email account to sign in with.\n * @param {!Object} additionalRequestData Additional data to add to the request.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.sendSignInLinkToEmail = function(\n    email, additionalRequestData) {\n  var request = {\n    'requestType': fireauth.RpcHandler.GetOobCodeRequestType.EMAIL_SIGNIN,\n    'email': email\n  };\n  // Extend the original request with the additional data.\n  goog.object.extend(request, additionalRequestData);\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.GET_EMAIL_SIGNIN_CODE, request);\n};\n\n\n/**\n * Requests getOobCode endpoint for email verification, returns promise that\n * resolves with user's email.\n * @param {string} idToken The idToken of the user confirming his email.\n * @param {!Object} additionalRequestData Additional data to add to the request.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.sendEmailVerification =\n    function(idToken, additionalRequestData) {\n  var request = {\n    'requestType': fireauth.RpcHandler.GetOobCodeRequestType.VERIFY_EMAIL,\n    'idToken': idToken\n  };\n  // Extend the original request with the additional data.\n  goog.object.extend(request, additionalRequestData);\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.GET_EMAIL_VERIFICATION_CODE, request);\n};\n\n\n/**\n * Requests sendVerificationCode endpoint for verifying the user's ownership of\n * a phone number. It resolves with a sessionInfo (verificationId).\n * @param {!Object} request The verification request which contains a phone\n *     number and an assertion.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.sendVerificationCode = function(request) {\n  // In the future, we could support other types of assertions so for now,\n  // we are keeping the request an object.\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.SEND_VERIFICATION_CODE, request);\n};\n\n\n/**\n * Requests verifyPhoneNumber endpoint for sign in/sign up phone number\n * authentication flow and resolves with the STS token response.\n * @param {!Object} request The phone number ID and code to exchange for a\n *     Firebase Auth session.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyPhoneNumber = function(request) {\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_PHONE_NUMBER, request);\n};\n\n\n/**\n * Requests verifyPhoneNumber endpoint for link/update phone number\n * authentication flow and resolves with the STS token response.\n * @param {!Object} request The phone number ID and code to exchange for a\n *     Firebase Auth session.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyPhoneNumberForLinking = function(request) {\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_PHONE_NUMBER_FOR_LINKING, request);\n};\n\n\n/**\n * Validates a response to a phone number linking request.\n * @param {?Object} response The server response data.\n * @private\n */\nfireauth.RpcHandler.validateVerifyPhoneNumberForLinkingResponse_ =\n    function(response) {\n  if (response[fireauth.RpcHandler.AuthServerField.TEMPORARY_PROOF]) {\n    response['code'] = fireauth.authenum.Error.CREDENTIAL_ALREADY_IN_USE;\n    throw fireauth.AuthErrorWithCredential.fromPlainObject(response);\n  }\n\n  // If there's no temporary proof, then we expect the request to have\n  // succeeded and returned an ID token.\n  fireauth.RpcHandler.validateIdTokenResponse_(response);\n};\n\n\n/**\n * Requests verifyPhoneNumber endpoint for reauthenticating with a phone number\n * and resolves with the STS token response.\n * @param {!Object} request The phone number ID, code, and current ID token to\n *     exchange for a refreshed Firebase Auth session.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyPhoneNumberForExisting = function(request) {\n  request['operation'] = 'REAUTH';\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_PHONE_NUMBER_FOR_EXISTING,\n      request);\n};\n\n\n/**\n * The custom error map for reauth with verifyPhoneNumber.\n * @private {!fireauth.RpcHandler.ServerErrorMap}\n */\nfireauth.RpcHandler.verifyPhoneNumberForExistingErrorMap_ = {};\n\n// For most RPCs, the backend error USER_NOT_FOUND means that the sent STS\n// token is invalid. However, for this specific case, USER_NOT_FOUND actually\n// means that the sent credential is invalid.\nfireauth.RpcHandler.verifyPhoneNumberForExistingErrorMap_[\n  fireauth.RpcHandler.ServerError.USER_NOT_FOUND] =\n    fireauth.authenum.Error.USER_DELETED;\n\n\n/**\n * Validates a request to deleteLinkedAccounts.\n * @param {?Object} request\n * @private\n */\nfireauth.RpcHandler.validateDeleteLinkedAccountsRequest_ = function(request) {\n  if (!goog.isArray(request['deleteProvider'])) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Updates the providers for the account associated with the idToken.\n * @param {string} idToken The ID token.\n * @param {!Array<string>} providersToDelete The array of providers to delete.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.deleteLinkedAccounts =\n    function(idToken, providersToDelete) {\n  var request = {\n    'idToken': idToken,\n    'deleteProvider': providersToDelete\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.DELETE_LINKED_ACCOUNTS,\n      request);\n};\n\n\n/**\n * Validates a verifyAssertion request.\n * @param {?Object} request The verifyAssertion request data.\n * @private\n */\nfireauth.RpcHandler.validateVerifyAssertionRequest_ = function(request) {\n  // Either (requestUri and sessionId), (requestUri and postBody) or\n  // (requestUri and pendingToken) are required.\n  if (!request[fireauth.RpcHandler.AuthServerField.REQUEST_URI] ||\n      (!request[fireauth.RpcHandler.AuthServerField.SESSION_ID] &&\n       !request[fireauth.RpcHandler.AuthServerField.POST_BODY] &&\n       !request[fireauth.RpcHandler.AuthServerField.PENDING_TOKEN])) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Processes the verifyAssertion response and injects the same raw nonce\n * if available in request.\n * @param {!Object} request The verifyAssertion request data.\n * @param {!Object} response The original verifyAssertion response data.\n * @return {!Object} The modified verifyAssertion response.\n * @private\n */\nfireauth.RpcHandler.processVerifyAssertionResponse_ =\n    function(request, response) {\n  // This makes it possible for OIDC providers to:\n  // 1. Initialize an OIDC Auth credential on successful response.\n  // 2. Initialize an OIDC Auth credential within the recovery error.\n\n  // When request has sessionId and response has OIDC ID token and no pending\n  // token, a credential with raw nonce and OIDC ID token needs to be returned.\n  if (response[fireauth.RpcHandler.AuthServerField.OAUTH_ID_TOKEN] &&\n      response[fireauth.RpcHandler.AuthServerField.PROVIDER_ID] &&\n      response[fireauth.RpcHandler.AuthServerField.PROVIDER_ID]\n          .indexOf(fireauth.constants.OIDC_PREFIX) == 0 &&\n      // Use pendingToken instead of idToken and rawNonce when available.\n      !response[fireauth.RpcHandler.AuthServerField.PENDING_TOKEN]) {\n    if (request[fireauth.RpcHandler.AuthServerField.SESSION_ID]) {\n      // For full OAuth flow, the nonce is in the session ID.\n      response[fireauth.RpcHandler.InjectedResponseField.NONCE] =\n          request[fireauth.RpcHandler.AuthServerField.SESSION_ID];\n    } else if (request[fireauth.RpcHandler.AuthServerField.POST_BODY]) {\n      // For credential flow, the nonce is in the postBody nonce field.\n      var queryData = new goog.Uri.QueryData(\n          request[fireauth.RpcHandler.AuthServerField.POST_BODY]);\n      if (queryData.containsKey(\n              fireauth.RpcHandler.InjectedResponseField.NONCE)) {\n        response[fireauth.RpcHandler.InjectedResponseField.NONCE] =\n            queryData.get(fireauth.RpcHandler.InjectedResponseField.NONCE);\n      }\n    }\n  }\n  return response;\n};\n\n\n/**\n * Validates a response from verifyAssertionForExisting.\n * @param {?Object} response The verifyAssertionForExisting response data.\n * @private\n */\nfireauth.RpcHandler.validateVerifyAssertionForExistingResponse_ =\n    function(response) {\n  // When returnIdpCredential is set to true and the account is new, no error\n  // is thrown but an errorMessage is added to the response. No idToken is\n  // passed.\n  if (response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE] &&\n      response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE] ==\n          fireauth.RpcHandler.ServerError.USER_NOT_FOUND) {\n    // This corresponds to user-not-found.\n    throw new fireauth.AuthError(fireauth.authenum.Error.USER_DELETED);\n  } else if (response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE]) {\n    // Construct developer facing error message from server code in errorMessage\n    // field.\n    throw fireauth.RpcHandler.getDeveloperErrorFromCode_(\n        response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE]);\n  }\n  // Need confirmation should not be returned when do not create new user flag\n  // is set.\n  // If no error found and ID token is missing, throw an internal error.\n  if (!response[fireauth.RpcHandler.AuthServerField.ID_TOKEN]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Validates a response from verifyAssertion.\n * @param {?Object} response The verifyAssertion response data.\n * @private\n */\nfireauth.RpcHandler.validateVerifyAssertionResponse_ = function(response) {\n  var error = null;\n  if (response[fireauth.RpcHandler.AuthServerField.NEED_CONFIRMATION]) {\n    // Account linking required, previously logged in to another account\n    // with same email. User must authenticate they are owners of the\n    // first account.\n    // If enough info for Auth linking error, throw an instance of Auth linking\n    // error. This will be used by developer after reauthenticating with email\n    // provided by error to link using the credentials in Auth linking error.\n    // If missing information, return regular Auth error.\n    response['code'] = fireauth.authenum.Error.NEED_CONFIRMATION;\n    error = fireauth.AuthErrorWithCredential.fromPlainObject(response);\n  } else if (response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE] ==\n             fireauth.RpcHandler.ServerError.FEDERATED_USER_ID_ALREADY_LINKED) {\n    // When FEDERATED_USER_ID_ALREADY_LINKED returned in error message, auth\n    // credential and email will also be returned, throw relevant error in that\n    // case.\n    // In this case the developer needs to signInWithCredential to the returned\n    // credentials.\n    response['code'] = fireauth.authenum.Error.CREDENTIAL_ALREADY_IN_USE;\n    error = fireauth.AuthErrorWithCredential.fromPlainObject(response);\n  } else if (response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE] ==\n             fireauth.RpcHandler.ServerError.EMAIL_EXISTS) {\n    // When EMAIL_EXISTS returned in error message, Auth credential and email\n    // will also be returned, throw relevant error in that case.\n    // In this case, the developers needs to sign in the user to the original\n    // owner of the account and then link to the returned credential here.\n    response['code'] = fireauth.authenum.Error.EMAIL_EXISTS;\n    error = fireauth.AuthErrorWithCredential.fromPlainObject(response);\n  } else if (response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE]) {\n    // Construct developer facing error message from server code in errorMessage\n    // field.\n    error = fireauth.RpcHandler.getDeveloperErrorFromCode_(\n        response[fireauth.RpcHandler.AuthServerField.ERROR_MESSAGE]);\n  }\n  // If error found, throw it.\n  if (error) {\n    throw error;\n  }\n  // If no error found and ID token is missing, throw an internal error.\n  if (!response[fireauth.RpcHandler.AuthServerField.ID_TOKEN]) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Validates a verifyAssertion with linking request.\n * @param {?Object} request The verifyAssertion request data.\n * @private\n */\nfireauth.RpcHandler.validateVerifyAssertionLinkRequest_ = function(request) {\n  // idToken with either (requestUri and sessionId) or (requestUri and postBody)\n  // are required.\n  fireauth.RpcHandler.validateVerifyAssertionRequest_(request);\n  if (!request['idToken']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * @typedef {{\n *   autoCreate: (boolean|undefined),\n *   requestUri: string,\n *   postBody: (?string|undefined),\n *   pendingIdToken: (?string|undefined),\n *   sessionId: (?string|undefined),\n *   idToken: (?string|undefined),\n *   returnIdpCredential: (boolean|undefined),\n *   tenantId: (?string|undefined)\n * }}\n */\nfireauth.RpcHandler.VerifyAssertionData;\n\n\n/**\n * Requests verifyAssertion endpoint. When resolved, promise returns the whole\n * response.\n * @param {!fireauth.RpcHandler.VerifyAssertionData} request\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyAssertion = function(request) {\n  // Force Auth credential to be returned on the following errors:\n  // FEDERATED_USER_ID_ALREADY_LINKED\n  // EMAIL_EXISTS\n  request['returnIdpCredential'] = true;\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_ASSERTION,\n      request);\n};\n\n\n/**\n * Requests verifyAssertion endpoint for federated account linking. When\n * resolved, promise returns the whole response.\n * @param {!fireauth.RpcHandler.VerifyAssertionData} request\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyAssertionForLinking = function(request) {\n  // Force Auth credential to be returned on the following errors:\n  // FEDERATED_USER_ID_ALREADY_LINKED\n  // EMAIL_EXISTS\n  request['returnIdpCredential'] = true;\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_ASSERTION_FOR_LINKING,\n      request);\n};\n\n\n/**\n * Requests verifyAssertion endpoint for an existing federated account. When\n * resolved, promise returns the whole response. If not existing, a\n * user-not-found error is thrown.\n * @param {!fireauth.RpcHandler.VerifyAssertionData} request\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.verifyAssertionForExisting = function(request) {\n  // Since we are setting returnIdpCredential to true, a response will be\n  // returned even though the account doesn't exist but an error message is\n  // appended with value set to USER_NOT_FOUND. If this flag is not passed, only\n  // the USER_NOT_FOUND error is thrown without any response.\n  request['returnIdpCredential'] = true;\n  // Do not create a new account if the user doesn't exist.\n  request['autoCreate'] = false;\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.VERIFY_ASSERTION_FOR_EXISTING,\n      request);\n};\n\n\n/**\n * Validates a request that should contain an action code.\n * @param {!Object} request\n * @private\n */\nfireauth.RpcHandler.validateApplyActionCodeRequest_ = function(request) {\n  if (!request['oobCode']) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_OOB_CODE);\n  }\n};\n\n\n/**\n * Validates that a checkActionCode response contains the email and requestType\n * fields.\n * @param {!Object} response The raw response returned by the server.\n * @private\n */\nfireauth.RpcHandler.validateCheckActionCodeResponse_ = function(response) {\n  // If the code is invalid, usually a clear error would be returned.\n  // In this case, something unexpected happened.\n  // Email could be empty only if the request type is EMAIL_SIGNIN.\n  var operation = response['requestType'];\n  if (!operation || (!response['email'] && operation != 'EMAIL_SIGNIN')) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n};\n\n\n/**\n * Requests resetPassword endpoint for password reset, returns promise that\n * resolves with user's email.\n * @param {string} code The email action code to confirm for password reset.\n * @param {string} newPassword The new password.\n * @return {!goog.Promise<string>}\n */\nfireauth.RpcHandler.prototype.confirmPasswordReset =\n    function(code, newPassword) {\n  var request = {\n    'oobCode': code,\n    'newPassword': newPassword\n  };\n  return this.invokeRpc_(fireauth.RpcHandler.ApiMethod.RESET_PASSWORD, request);\n};\n\n\n/**\n * Checks the validity of an email action code and returns the response\n * received.\n * @param {string} code The email action code to check.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.RpcHandler.prototype.checkActionCode = function(code) {\n  var request = {\n    'oobCode': code\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.CHECK_ACTION_CODE, request);\n};\n\n\n/**\n * Applies an out-of-band email action code, such as an email verification code.\n * @param {string} code The email action code.\n * @return {!goog.Promise<string>} A promise that resolves with the user's\n *     email.\n */\nfireauth.RpcHandler.prototype.applyActionCode = function(code) {\n  var request = {\n    'oobCode': code\n  };\n  return this.invokeRpc_(\n      fireauth.RpcHandler.ApiMethod.APPLY_OOB_CODE, request);\n};\n\n\n/**\n * The specification of an RPC call. The fields are:\n * <ul>\n * <li>cachebuster: defines whether to send a unique string with request to\n *     force the backend to return an uncached response to request.\n * <li>customErrorMap: A map of backend error codes to client-side errors.\n *     Any entries set here override the default handling of the backend error\n *     code.\n * <li>endpoint: defines the backend endpoint to call.\n * <li>httpMethod: defines the HTTP method to use, defaulting to POST if not\n *     specified.\n * <li>requestRequiredFields: an array of the fields that are required in the\n *     request. The RPC call will fail with an INTERNAL_ERROR error if a\n *     required field is not present or if it is null, undefined, or the empty\n *     string.\n * <li>requestValidator: a function that takes in the request object and throws\n *     an error if the request is invalid.\n * <li>responsePreprocessor: a function to modify the response before running\n *     validation. The function takes in the request and response object.\n * <li>responseValidator: a function that takes in the response object and\n *     throws an error if the response is invalid.\n * <li>responseField: the field of the response object that will be returned\n *     from the RPC call. If no field is specified, the entire response object\n *     will be returned.\n * <li>returnSecureToken: Set to true to explicitly request STS tokens instead\n *     of legacy Google Identity Toolkit tokens from the backend.\n * <li>requireTenantId: Set to true to send tenant ID to backend in the request.\n * </ul>\n * @typedef {{\n *   cachebuster: (boolean|undefined),\n *   customErrorMap: (!fireauth.RpcHandler.ServerErrorMap|undefined),\n *   endpoint: string,\n *   httpMethod: (!fireauth.RpcHandler.HttpMethod|undefined),\n *   requestRequiredFields: (!Array<string>|undefined),\n *   requestValidator: (function(!Object):void|undefined),\n *   responsePreprocessor: ((function(!Object, !Object):!Object)|undefined),\n *   responseValidator: (function(!Object):void|undefined),\n *   responseField: (string|undefined),\n *   returnSecureToken: (boolean|undefined),\n *   requireTenantId: (boolean|undefined)\n * }}\n */\nfireauth.RpcHandler.ApiMethodHandler;\n\n\n/**\n * The specifications for the backend API methods.\n * @enum {!fireauth.RpcHandler.ApiMethodHandler}\n */\nfireauth.RpcHandler.ApiMethod = {\n  APPLY_OOB_CODE: {\n    endpoint: 'setAccountInfo',\n    requestValidator: fireauth.RpcHandler.validateApplyActionCodeRequest_,\n    responseField: fireauth.RpcHandler.AuthServerField.EMAIL,\n    requireTenantId: true\n  },\n  CHECK_ACTION_CODE: {\n    endpoint: 'resetPassword',\n    requestValidator: fireauth.RpcHandler.validateApplyActionCodeRequest_,\n    responseValidator: fireauth.RpcHandler.validateCheckActionCodeResponse_,\n    requireTenantId: true\n  },\n  CREATE_ACCOUNT: {\n    endpoint: 'signupNewUser',\n    requestValidator: fireauth.RpcHandler.validateCreateAccountRequest_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true,\n    requireTenantId: true\n  },\n  CREATE_AUTH_URI: {\n    endpoint: 'createAuthUri',\n    requireTenantId: true\n  },\n  DELETE_ACCOUNT: {\n    endpoint: 'deleteAccount',\n    requestRequiredFields: ['idToken']\n  },\n  DELETE_LINKED_ACCOUNTS: {\n    endpoint: 'setAccountInfo',\n    requestRequiredFields: ['idToken', 'deleteProvider'],\n    requestValidator: fireauth.RpcHandler.validateDeleteLinkedAccountsRequest_\n  },\n  EMAIL_LINK_SIGNIN: {\n    endpoint: 'emailLinkSignin',\n    requestRequiredFields: ['email', 'oobCode'],\n    requestValidator: fireauth.RpcHandler.validateRequestHasEmail_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true,\n    requireTenantId: true\n  },\n  EMAIL_LINK_SIGNIN_FOR_LINKING: {\n    endpoint: 'emailLinkSignin',\n    requestRequiredFields: ['idToken', 'email', 'oobCode'],\n    requestValidator: fireauth.RpcHandler.validateRequestHasEmail_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true\n  },\n  GET_ACCOUNT_INFO: {\n    endpoint: 'getAccountInfo'\n  },\n  GET_AUTH_URI: {\n    endpoint: 'createAuthUri',\n    requestValidator: fireauth.RpcHandler.validateGetAuthUriRequest_,\n    responseValidator: fireauth.RpcHandler.validateGetAuthResponse_,\n    requireTenantId: true\n  },\n  GET_EMAIL_SIGNIN_CODE: {\n    endpoint: 'getOobConfirmationCode',\n    requestRequiredFields: ['requestType'],\n    requestValidator: fireauth.RpcHandler.validateEmailSignInCodeRequest_,\n    responseField: fireauth.RpcHandler.AuthServerField.EMAIL,\n    requireTenantId: true\n  },\n  GET_EMAIL_VERIFICATION_CODE: {\n    endpoint: 'getOobConfirmationCode',\n    requestRequiredFields: ['idToken', 'requestType'],\n    requestValidator: fireauth.RpcHandler.validateEmailVerificationCodeRequest_,\n    responseField: fireauth.RpcHandler.AuthServerField.EMAIL,\n    requireTenantId: true\n  },\n  GET_OOB_CODE: {\n    endpoint: 'getOobConfirmationCode',\n    requestRequiredFields: ['requestType'],\n    requestValidator: fireauth.RpcHandler.validateOobCodeRequest_,\n    responseField: fireauth.RpcHandler.AuthServerField.EMAIL,\n    requireTenantId: true\n  },\n  GET_PROJECT_CONFIG: {\n    // Microsoft edge caching bug. There are two getProjectConfig API calls,\n    // first from top level window and then from iframe. The second call has a\n    // response of 304 which means it's a cached response. We suspect the call\n    // from iframe is reusing the response from the first call and checks the\n    // allowed origin in the cached response, which only contains the domain for\n    // the top level window.\n    cachebuster: true,\n    endpoint: 'getProjectConfig',\n    httpMethod: fireauth.RpcHandler.HttpMethod.GET\n  },\n  GET_RECAPTCHA_PARAM: {\n    cachebuster: true,\n    endpoint: 'getRecaptchaParam',\n    httpMethod: fireauth.RpcHandler.HttpMethod.GET,\n    responseValidator: fireauth.RpcHandler.validateGetRecaptchaParamResponse_\n  },\n  RESET_PASSWORD: {\n    endpoint: 'resetPassword',\n    requestValidator: fireauth.RpcHandler.validateApplyActionCodeRequest_,\n    responseField: fireauth.RpcHandler.AuthServerField.EMAIL,\n    requireTenantId: true\n  },\n  RETURN_DYNAMIC_LINK: {\n    cachebuster: true,\n    endpoint: 'getProjectConfig',\n    httpMethod: fireauth.RpcHandler.HttpMethod.GET,\n    responseField: fireauth.RpcHandler.AuthServerField.DYNAMIC_LINKS_DOMAIN\n  },\n  SEND_VERIFICATION_CODE: {\n    endpoint: 'sendVerificationCode',\n    // Currently only reCAPTCHA tokens supported.\n    requestRequiredFields: ['phoneNumber', 'recaptchaToken'],\n    responseField: fireauth.RpcHandler.AuthServerField.SESSION_INFO,\n    requireTenantId: true\n  },\n  SET_ACCOUNT_INFO: {\n    endpoint: 'setAccountInfo',\n    requestRequiredFields: ['idToken'],\n    requestValidator: fireauth.RpcHandler.validateEmailIfPresent_,\n    returnSecureToken: true // Maybe updating email will invalidate token in the\n                            // future, this will prevent breaking the client.\n  },\n  SET_ACCOUNT_INFO_SENSITIVE: {\n    endpoint: 'setAccountInfo',\n    requestRequiredFields: ['idToken'],\n    requestValidator: fireauth.RpcHandler.validateSetAccountInfoSensitive_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true // Updating password will send back new sts tokens.\n  },\n  SIGN_IN_ANONYMOUSLY: {\n    endpoint: 'signupNewUser',\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true,\n    requireTenantId: true\n  },\n  VERIFY_ASSERTION: {\n    endpoint: 'verifyAssertion',\n    requestValidator: fireauth.RpcHandler.validateVerifyAssertionRequest_,\n    responsePreprocessor: fireauth.RpcHandler.processVerifyAssertionResponse_,\n    responseValidator: fireauth.RpcHandler.validateVerifyAssertionResponse_,\n    returnSecureToken: true,\n    // Tenant ID is required for this endpoint. But for\n    // signInWithRedirect/Popup APIs, to make createAuthUri call and\n    // verifyAssertion call atomic, the tenant ID on RPC handler will be\n    // overridden by the tenant ID passed directly from the\n    // request, which is retrieved from Auth event. For signInWithCredential\n    // API, the tenant ID will still be retrieved from the RPC handler.\n    requireTenantId: true\n  },\n  VERIFY_ASSERTION_FOR_EXISTING: {\n    endpoint: 'verifyAssertion',\n    requestValidator: fireauth.RpcHandler.validateVerifyAssertionRequest_,\n    responsePreprocessor: fireauth.RpcHandler.processVerifyAssertionResponse_,\n    responseValidator:\n        fireauth.RpcHandler.validateVerifyAssertionForExistingResponse_,\n    returnSecureToken: true,\n    // Tenant ID is required for this endpoint. But for\n    // reauthenticateWithRedirect/Popup APIs, to make createAuthUri call and\n    // verifyAssertion call atomic, the tenant ID on RPC handler will be\n    // overridden by the tenant ID passed directly from the\n    // request, which is retrieved from Auth event. For\n    // reauthenticateWithCredential API, the tenant ID will still be retrieved\n    // from the RPC handler.\n    requireTenantId: true\n  },\n  VERIFY_ASSERTION_FOR_LINKING: {\n    endpoint: 'verifyAssertion',\n    requestValidator: fireauth.RpcHandler.validateVerifyAssertionLinkRequest_,\n    responsePreprocessor: fireauth.RpcHandler.processVerifyAssertionResponse_,\n    responseValidator: fireauth.RpcHandler.validateVerifyAssertionResponse_,\n    returnSecureToken: true\n  },\n  VERIFY_CUSTOM_TOKEN: {\n    endpoint: 'verifyCustomToken',\n    requestValidator: fireauth.RpcHandler.validateVerifyCustomTokenRequest_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true,\n    requireTenantId: true\n  },\n  VERIFY_PASSWORD: {\n    endpoint: 'verifyPassword',\n    requestValidator: fireauth.RpcHandler.validateVerifyPasswordRequest_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    returnSecureToken: true,\n    requireTenantId: true\n  },\n  VERIFY_PHONE_NUMBER: {\n    endpoint: 'verifyPhoneNumber',\n    requestValidator: fireauth.RpcHandler.validateVerifyPhoneNumberRequest_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    requireTenantId: true\n  },\n  VERIFY_PHONE_NUMBER_FOR_LINKING: {\n    endpoint: 'verifyPhoneNumber',\n    requestValidator: fireauth.RpcHandler.validateVerifyPhoneNumberLinkRequest_,\n    responseValidator:\n        fireauth.RpcHandler.validateVerifyPhoneNumberForLinkingResponse_\n  },\n  VERIFY_PHONE_NUMBER_FOR_EXISTING: {\n    customErrorMap: fireauth.RpcHandler.verifyPhoneNumberForExistingErrorMap_,\n    endpoint: 'verifyPhoneNumber',\n    requestValidator: fireauth.RpcHandler.validateVerifyPhoneNumberRequest_,\n    responseValidator: fireauth.RpcHandler.validateIdTokenResponse_,\n    requireTenantId: true\n  }\n};\n\n\n/**\n * @const {string} The parameter to send to the backend to specify that the\n *     client accepts STS tokens directly from Firebear backends.\n * @private\n */\nfireauth.RpcHandler.USE_STS_TOKEN_PARAM_ = 'returnSecureToken';\n\n\n/**\n * @const {string} The parameter to send to the backend to specify the tenant\n *     ID.\n * @private\n */\nfireauth.RpcHandler.TENANT_ID_PARAM_ = 'tenantId';\n\n\n/**\n * Invokes an RPC method according to the specification defined by\n * {@code fireauth.RpcHandler.ApiMethod}.\n * @param {!fireauth.RpcHandler.ApiMethod} method The method to invoke.\n * @param {!Object} request The input data to the method.\n * @return {!goog.Promise} A promise that resolves with the results of the RPC.\n *     The format of the results can be modified in\n *     {@code fireauth.RpcHandler.ApiMethod}.\n * @private\n */\nfireauth.RpcHandler.prototype.invokeRpc_ = function(method, request) {\n  if (!fireauth.object.hasNonEmptyFields(\n      request, method.requestRequiredFields)) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.INTERNAL_ERROR));\n  }\n\n  var httpMethod = method.httpMethod || fireauth.RpcHandler.HttpMethod.POST;\n  var self = this;\n  var response;\n  return goog.Promise.resolve(request)\n      .then(method.requestValidator)\n      .then(function() {\n        if (method.returnSecureToken) {\n          // Signal that the client accepts STS tokens, for the legacy Google\n          // Identity Toolkit token to STS token migration.\n          request[fireauth.RpcHandler.USE_STS_TOKEN_PARAM_] = true;\n        }\n        // If tenant ID is explicitly passed in the request, it will override\n        // the tenant ID on RPC handler.\n        if (method.requireTenantId && self.tenantId_ &&\n            (typeof request[fireauth.RpcHandler.TENANT_ID_PARAM_] ===\n             'undefined')) {\n          request[fireauth.RpcHandler.TENANT_ID_PARAM_] = self.tenantId_;\n        }\n        return self.requestFirebaseEndpoint(method.endpoint, httpMethod,\n            request, method.customErrorMap, method.cachebuster || false);\n      })\n      .then(function(tempResponse) {\n        response = tempResponse;\n        // If response processor is available, pass request and response through\n        // it. Modifications would be made using response reference.\n        if (method.responsePreprocessor) {\n          return method.responsePreprocessor(request, response);\n        }\n        return response;\n      })\n      .then(method.responseValidator)\n      .then(function() {\n        if (!method.responseField) {\n          return response;\n        }\n        if (!(method.responseField in response)) {\n          throw new fireauth.AuthError(\n              fireauth.authenum.Error.INTERNAL_ERROR);\n        }\n        return response[method.responseField];\n      });\n};\n\n\n/**\n * Checks if the server response contains errors.\n * @param {!Object} resp The API response.\n * @return {boolean} {@code true} if the response contains errors.\n * @private\n */\nfireauth.RpcHandler.hasError_ = function(resp) {\n  return !!resp['error'];\n};\n\n\n/**\n * Returns the developer facing error corresponding to the server code provided.\n * @param {string} serverErrorCode The server error message.\n * @return {!fireauth.AuthError} The corresponding error object.\n * @private\n */\nfireauth.RpcHandler.getDeveloperErrorFromCode_ = function(serverErrorCode) {\n  // Encapsulate the server error code in a typical server error response with\n  // the code populated within. This will convert the response to a developer\n  // facing one.\n  return fireauth.RpcHandler.getDeveloperError_({\n    'error': {\n      'errors': [\n        {\n          'message': serverErrorCode\n        }\n      ],\n      'code': 400,\n      'message': serverErrorCode\n    }\n  });\n};\n\n\n/**\n * Converts a server response with errors to a developer-facing AuthError.\n * @param {!Object} response The server response.\n * @param {?fireauth.RpcHandler.ServerErrorMap=} opt_customErrorMap A map of\n *     backend error codes to client-side errors. Any entries set here\n *     override the default handling of the backend error code.\n * @return {!fireauth.AuthError} The corresponding error object.\n * @private\n */\nfireauth.RpcHandler.getDeveloperError_ =\n    function(response, opt_customErrorMap) {\n  var errorMessage;\n  var apiaryError = fireauth.RpcHandler.getApiaryError_(response);\n  if (apiaryError) {\n    return apiaryError;\n  }\n\n  var serverErrorCode = fireauth.RpcHandler.getErrorCode_(response);\n\n  var errorMap = {};\n\n  // Custom token errors.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_CUSTOM_TOKEN] =\n      fireauth.authenum.Error.INVALID_CUSTOM_TOKEN;\n  errorMap[fireauth.RpcHandler.ServerError.CREDENTIAL_MISMATCH] =\n      fireauth.authenum.Error.CREDENTIAL_MISMATCH;\n  // This can only happen if the SDK sends a bad request.\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_CUSTOM_TOKEN] =\n      fireauth.authenum.Error.INTERNAL_ERROR;\n\n  // Create Auth URI errors.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_IDENTIFIER] =\n      fireauth.authenum.Error.INVALID_EMAIL;\n  // This can only happen if the SDK sends a bad request.\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_CONTINUE_URI] =\n      fireauth.authenum.Error.INTERNAL_ERROR;\n\n  // Sign in with email and password errors (some apply to sign up too).\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_EMAIL] =\n      fireauth.authenum.Error.INVALID_EMAIL;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_PASSWORD] =\n      fireauth.authenum.Error.INVALID_PASSWORD;\n  errorMap[fireauth.RpcHandler.ServerError.USER_DISABLED] =\n      fireauth.authenum.Error.USER_DISABLED;\n  // This can only happen if the SDK sends a bad request.\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_PASSWORD] =\n      fireauth.authenum.Error.INTERNAL_ERROR;\n\n  // Sign up with email and password errors.\n  errorMap[fireauth.RpcHandler.ServerError.EMAIL_EXISTS] =\n      fireauth.authenum.Error.EMAIL_EXISTS;\n  errorMap[fireauth.RpcHandler.ServerError.PASSWORD_LOGIN_DISABLED] =\n      fireauth.authenum.Error.OPERATION_NOT_ALLOWED;\n\n  // Verify assertion for sign in with credential errors:\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_IDP_RESPONSE] =\n      fireauth.authenum.Error.INVALID_IDP_RESPONSE;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_PENDING_TOKEN] =\n      fireauth.authenum.Error.INVALID_IDP_RESPONSE;\n  errorMap[fireauth.RpcHandler.ServerError.FEDERATED_USER_ID_ALREADY_LINKED] =\n      fireauth.authenum.Error.CREDENTIAL_ALREADY_IN_USE;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_OR_INVALID_NONCE] =\n      fireauth.authenum.Error.MISSING_OR_INVALID_NONCE;\n\n  // Email template errors while sending emails:\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_MESSAGE_PAYLOAD] =\n      fireauth.authenum.Error.INVALID_MESSAGE_PAYLOAD;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_RECIPIENT_EMAIL] =\n      fireauth.authenum.Error.INVALID_RECIPIENT_EMAIL;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_SENDER] =\n      fireauth.authenum.Error.INVALID_SENDER;\n\n  // Send Password reset email errors:\n  errorMap[fireauth.RpcHandler.ServerError.EMAIL_NOT_FOUND] =\n      fireauth.authenum.Error.USER_DELETED;\n  errorMap[fireauth.RpcHandler.ServerError.RESET_PASSWORD_EXCEED_LIMIT] =\n      fireauth.authenum.Error.TOO_MANY_ATTEMPTS_TRY_LATER;    \n\n  // Reset password errors:\n  errorMap[fireauth.RpcHandler.ServerError.EXPIRED_OOB_CODE] =\n      fireauth.authenum.Error.EXPIRED_OOB_CODE;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_OOB_CODE] =\n      fireauth.authenum.Error.INVALID_OOB_CODE;\n  // This can only happen if the SDK sends a bad request.\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_OOB_CODE] =\n      fireauth.authenum.Error.INTERNAL_ERROR;\n\n  // Get Auth URI errors:\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_PROVIDER_ID] =\n      fireauth.authenum.Error.INVALID_PROVIDER_ID;\n\n  // Operations that require ID token in request:\n  errorMap[fireauth.RpcHandler.ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN] =\n      fireauth.authenum.Error.CREDENTIAL_TOO_OLD_LOGIN_AGAIN;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_ID_TOKEN] =\n      fireauth.authenum.Error.INVALID_AUTH;\n  errorMap[fireauth.RpcHandler.ServerError.TOKEN_EXPIRED] =\n      fireauth.authenum.Error.TOKEN_EXPIRED;\n  errorMap[fireauth.RpcHandler.ServerError.USER_NOT_FOUND] =\n      fireauth.authenum.Error.TOKEN_EXPIRED;\n\n  // CORS issues.\n  errorMap[fireauth.RpcHandler.ServerError.CORS_UNSUPPORTED] =\n      fireauth.authenum.Error.CORS_UNSUPPORTED;\n\n  // Dynamic link not activated.\n  errorMap[fireauth.RpcHandler.ServerError.DYNAMIC_LINK_NOT_ACTIVATED] =\n      fireauth.authenum.Error.DYNAMIC_LINK_NOT_ACTIVATED;\n\n  // iosBundleId or androidPackageName not valid error.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_APP_ID] =\n      fireauth.authenum.Error.INVALID_APP_ID;\n\n  // Other errors.\n  errorMap[fireauth.RpcHandler.ServerError.TOO_MANY_ATTEMPTS_TRY_LATER] =\n      fireauth.authenum.Error.TOO_MANY_ATTEMPTS_TRY_LATER;\n  errorMap[fireauth.RpcHandler.ServerError.WEAK_PASSWORD] =\n      fireauth.authenum.Error.WEAK_PASSWORD;\n  errorMap[fireauth.RpcHandler.ServerError.OPERATION_NOT_ALLOWED] =\n      fireauth.authenum.Error.OPERATION_NOT_ALLOWED;\n  errorMap[fireauth.RpcHandler.ServerError.USER_CANCELLED] =\n      fireauth.authenum.Error.USER_CANCELLED;\n\n  // Phone Auth related errors.\n  errorMap[fireauth.RpcHandler.ServerError.CAPTCHA_CHECK_FAILED] =\n      fireauth.authenum.Error.CAPTCHA_CHECK_FAILED;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_APP_CREDENTIAL] =\n      fireauth.authenum.Error.INVALID_APP_CREDENTIAL;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_CODE] =\n      fireauth.authenum.Error.INVALID_CODE;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_PHONE_NUMBER] =\n      fireauth.authenum.Error.INVALID_PHONE_NUMBER;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_SESSION_INFO] =\n      fireauth.authenum.Error.INVALID_SESSION_INFO;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_TEMPORARY_PROOF] =\n      fireauth.authenum.Error.INVALID_IDP_RESPONSE;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_APP_CREDENTIAL] =\n      fireauth.authenum.Error.MISSING_APP_CREDENTIAL;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_CODE] =\n      fireauth.authenum.Error.MISSING_CODE;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_PHONE_NUMBER] =\n      fireauth.authenum.Error.MISSING_PHONE_NUMBER;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_SESSION_INFO] =\n      fireauth.authenum.Error.MISSING_SESSION_INFO;\n  errorMap[fireauth.RpcHandler.ServerError.QUOTA_EXCEEDED] =\n      fireauth.authenum.Error.QUOTA_EXCEEDED;\n  errorMap[fireauth.RpcHandler.ServerError.SESSION_EXPIRED] =\n      fireauth.authenum.Error.CODE_EXPIRED;\n  errorMap[fireauth.RpcHandler.ServerError.REJECTED_CREDENTIAL] =\n      fireauth.authenum.Error.REJECTED_CREDENTIAL;\n\n  // Other action code errors when additional settings passed.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_CONTINUE_URI] =\n      fireauth.authenum.Error.INVALID_CONTINUE_URI;\n  // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n  // This is OK as this error will be caught by client side validation.\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_ANDROID_PACKAGE_NAME] =\n      fireauth.authenum.Error.MISSING_ANDROID_PACKAGE_NAME;\n  errorMap[fireauth.RpcHandler.ServerError.MISSING_IOS_BUNDLE_ID] =\n      fireauth.authenum.Error.MISSING_IOS_BUNDLE_ID;\n  errorMap[fireauth.RpcHandler.ServerError.UNAUTHORIZED_DOMAIN] =\n      fireauth.authenum.Error.UNAUTHORIZED_DOMAIN;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_DYNAMIC_LINK_DOMAIN] =\n      fireauth.authenum.Error.INVALID_DYNAMIC_LINK_DOMAIN;\n\n  // getProjectConfig errors when clientId is passed.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_OAUTH_CLIENT_ID] =\n      fireauth.authenum.Error.INVALID_OAUTH_CLIENT_ID;\n  // getProjectConfig errors when sha1Cert is passed.\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_CERT_HASH] =\n      fireauth.authenum.Error.INVALID_CERT_HASH;\n\n  // Multi-tenant related errors.\n  errorMap[fireauth.RpcHandler.ServerError.UNSUPPORTED_TENANT_OPERATION] =\n      fireauth.authenum.Error.UNSUPPORTED_TENANT_OPERATION;\n  errorMap[fireauth.RpcHandler.ServerError.INVALID_TENANT_ID] =\n      fireauth.authenum.Error.INVALID_TENANT_ID;\n\n  // User actions (sign-up or deletion) disabled errors.\n  errorMap[fireauth.RpcHandler.ServerError.ADMIN_ONLY_OPERATION] =\n      fireauth.authenum.Error.ADMIN_ONLY_OPERATION;\n\n  // Override errors set in the custom map.\n  var customErrorMap = opt_customErrorMap || {};\n  goog.object.extend(errorMap, customErrorMap);\n\n  // Get detailed message if available.\n  errorMessage = fireauth.RpcHandler.getErrorCodeDetails(serverErrorCode);\n\n  // Handle backend errors where the error code can be a prefix of the message\n  // (e.g. \"WEAK_PASSWORD : Password should be at least 6 characters\").\n  // Use the details after the colon as the error message. If none available,\n  // pass undefined, which will default to the client hard coded error messages.\n  for (var prefixCode in errorMap) {\n    if (serverErrorCode.indexOf(prefixCode) === 0) {\n      return new fireauth.AuthError(errorMap[prefixCode], errorMessage);\n    }\n  }\n\n  // No error message found, return the serialized response as the message.\n  // This is likely to be an Apiary error for unexpected cases like keyExpired,\n  // etc.\n  if (!errorMessage && response) {\n     errorMessage = fireauth.util.stringifyJSON(response);\n  }\n  // The backend returned some error we don't recognize; this is an error on\n  // our side.\n  return new fireauth.AuthError(\n      fireauth.authenum.Error.INTERNAL_ERROR, errorMessage);\n};\n\n\n/**\n * @param {string} serverMessage The server error code.\n * @return {string|undefined} The detailed error code message.\n */\nfireauth.RpcHandler.getErrorCodeDetails = function(serverMessage) {\n  // Use the error details part as the autherror message.\n  // For a message INVALID_CUSTOM_TOKEN : [error detail here],\n  // The Auth error message should be [error detail here].\n  // No space should be contained in the error code, otherwise no detailed error\n  // message returned.\n  var matches = serverMessage.match(/^[^\\s]+\\s*:\\s*(.*)$/);\n  if (matches && matches.length > 1) {\n    return matches[1];\n  }\n  return undefined;\n};\n\n\n/**\n * Gets the Apiary error from a backend response, if applicable.\n * @param {!Object} response The API response.\n * @return {?fireauth.AuthError} The error, if applicable.\n * @private\n */\nfireauth.RpcHandler.getApiaryError_ = function(response) {\n  var error = response['error'] && response['error']['errors'] &&\n      response['error']['errors'][0] || {};\n  var reason = error['reason'] || '';\n\n  var errorReasonMap = {\n    'keyInvalid': fireauth.authenum.Error.INVALID_API_KEY,\n    'ipRefererBlocked': fireauth.authenum.Error.APP_NOT_AUTHORIZED\n  };\n\n  if (errorReasonMap[reason]) {\n    return new fireauth.AuthError(errorReasonMap[reason]);\n  }\n\n  return null;\n};\n\n\n/**\n * Gets the server error code from the response.\n * @param {!Object} resp The API response.\n * @return {string} The error code if present.\n * @private\n */\nfireauth.RpcHandler.getErrorCode_ = function(resp) {\n  return (resp['error'] && resp['error']['message']) || '';\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Low level handling of XMLHttpRequest.\n * @author arv@google.com (Erik Arvidsson)\n * @author dbk@google.com (David Barrett-Kahn)\n */\n\ngoog.provide('goog.net.DefaultXmlHttpFactory');\ngoog.provide('goog.net.XmlHttp');\ngoog.provide('goog.net.XmlHttp.OptionType');\ngoog.provide('goog.net.XmlHttp.ReadyState');\ngoog.provide('goog.net.XmlHttpDefines');\n\ngoog.require('goog.asserts');\ngoog.require('goog.net.WrapperXmlHttpFactory');\ngoog.require('goog.net.XmlHttpFactory');\n\n\n/**\n * Static class for creating XMLHttpRequest objects.\n * @return {!goog.net.XhrLike.OrNative} A new XMLHttpRequest object.\n */\ngoog.net.XmlHttp = function() {\n  return goog.net.XmlHttp.factory_.createInstance();\n};\n\n\n/**\n * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to\n *     true bypasses the ActiveX probing code.\n * NOTE(ruilopes): Due to the way JSCompiler works, this define *will not* strip\n * out the ActiveX probing code from binaries.  To achieve this, use\n * `goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR` instead.\n * TODO(ruilopes): Collapse both defines.\n */\ngoog.net.XmlHttp.ASSUME_NATIVE_XHR =\n    goog.define('goog.net.XmlHttp.ASSUME_NATIVE_XHR', false);\n\n\n/** @const */\ngoog.net.XmlHttpDefines = {};\n\n\n/**\n * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to\n *     true eliminates the ActiveX probing code.\n */\ngoog.net.XmlHttpDefines.ASSUME_NATIVE_XHR =\n    goog.define('goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR', false);\n\n\n/**\n * Gets the options to use with the XMLHttpRequest objects obtained using\n * the static methods.\n * @return {Object} The options.\n */\ngoog.net.XmlHttp.getOptions = function() {\n  return goog.net.XmlHttp.factory_.getOptions();\n};\n\n\n/**\n * Type of options that an XmlHttp object can have.\n * @enum {number}\n */\ngoog.net.XmlHttp.OptionType = {\n  /**\n   * Whether a goog.nullFunction should be used to clear the onreadystatechange\n   * handler instead of null.\n   */\n  USE_NULL_FUNCTION: 0,\n\n  /**\n   * NOTE(user): In IE if send() errors on a *local* request the readystate\n   * is still changed to COMPLETE.  We need to ignore it and allow the\n   * try/catch around send() to pick up the error.\n   */\n  LOCAL_REQUEST_ERROR: 1\n};\n\n\n/**\n * Status constants for XMLHTTP, matches:\n * https://msdn.microsoft.com/en-us/library/ms534361(v=vs.85).aspx\n * @enum {number}\n */\ngoog.net.XmlHttp.ReadyState = {\n  /**\n   * Constant for when xmlhttprequest.readyState is uninitialized\n   */\n  UNINITIALIZED: 0,\n\n  /**\n   * Constant for when xmlhttprequest.readyState is loading.\n   */\n  LOADING: 1,\n\n  /**\n   * Constant for when xmlhttprequest.readyState is loaded.\n   */\n  LOADED: 2,\n\n  /**\n   * Constant for when xmlhttprequest.readyState is in an interactive state.\n   */\n  INTERACTIVE: 3,\n\n  /**\n   * Constant for when xmlhttprequest.readyState is completed\n   */\n  COMPLETE: 4\n};\n\n\n/**\n * The global factory instance for creating XMLHttpRequest objects.\n * @type {goog.net.XmlHttpFactory}\n * @private\n */\ngoog.net.XmlHttp.factory_;\n\n\n/**\n * Sets the factories for creating XMLHttpRequest objects and their options.\n * @param {Function} factory The factory for XMLHttpRequest objects.\n * @param {Function} optionsFactory The factory for options.\n * @deprecated Use setGlobalFactory instead.\n */\ngoog.net.XmlHttp.setFactory = function(factory, optionsFactory) {\n  goog.net.XmlHttp.setGlobalFactory(\n      new goog.net.WrapperXmlHttpFactory(\n          goog.asserts.assert(factory), goog.asserts.assert(optionsFactory)));\n};\n\n\n/**\n * Sets the global factory object.\n * @param {!goog.net.XmlHttpFactory} factory New global factory object.\n */\ngoog.net.XmlHttp.setGlobalFactory = function(factory) {\n  goog.net.XmlHttp.factory_ = factory;\n};\n\n\n\n/**\n * Default factory to use when creating xhr objects.  You probably shouldn't be\n * instantiating this directly, but rather using it via goog.net.XmlHttp.\n * @extends {goog.net.XmlHttpFactory}\n * @constructor\n */\ngoog.net.DefaultXmlHttpFactory = function() {\n  goog.net.XmlHttpFactory.call(this);\n};\ngoog.inherits(goog.net.DefaultXmlHttpFactory, goog.net.XmlHttpFactory);\n\n\n/** @override */\ngoog.net.DefaultXmlHttpFactory.prototype.createInstance = function() {\n  var progId = this.getProgId_();\n  if (progId) {\n    return new ActiveXObject(progId);\n  } else {\n    return new XMLHttpRequest();\n  }\n};\n\n\n/** @override */\ngoog.net.DefaultXmlHttpFactory.prototype.internalGetOptions = function() {\n  var progId = this.getProgId_();\n  var options = {};\n  if (progId) {\n    options[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] = true;\n    options[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] = true;\n  }\n  return options;\n};\n\n\n/**\n * The ActiveX PROG ID string to use to create xhr's in IE. Lazily initialized.\n * @type {string|undefined}\n * @private\n */\ngoog.net.DefaultXmlHttpFactory.prototype.ieProgId_;\n\n\n/**\n * Initialize the private state used by other functions.\n * @return {string} The ActiveX PROG ID string to use to create xhr's in IE.\n * @private\n */\ngoog.net.DefaultXmlHttpFactory.prototype.getProgId_ = function() {\n  if (goog.net.XmlHttp.ASSUME_NATIVE_XHR ||\n      goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR) {\n    return '';\n  }\n\n  // The following blog post describes what PROG IDs to use to create the\n  // XMLHTTP object in Internet Explorer:\n  // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx\n  // However we do not (yet) fully trust that this will be OK for old versions\n  // of IE on Win9x so we therefore keep the last 2.\n  if (!this.ieProgId_ && typeof XMLHttpRequest == 'undefined' &&\n      typeof ActiveXObject != 'undefined') {\n    // Candidate Active X types.\n    var ACTIVE_X_IDENTS = [\n      'MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP',\n      'Microsoft.XMLHTTP'\n    ];\n    for (var i = 0; i < ACTIVE_X_IDENTS.length; i++) {\n      var candidate = ACTIVE_X_IDENTS[i];\n\n      try {\n        new ActiveXObject(candidate);\n        // NOTE(user): cannot assign progid and return candidate in one line\n        // because JSCompiler complaings: BUG 658126\n        this.ieProgId_ = candidate;\n        return candidate;\n      } catch (e) {\n        // do nothing; try next choice\n      }\n    }\n\n    // couldn't find any matches\n    throw new Error(\n        'Could not create ActiveXObject. ActiveX might be disabled,' +\n        ' or MSXML might not be installed');\n  }\n\n  return /** @type {string} */ (this.ieProgId_);\n};\n\n\n// Set the global factory to an instance of the default factory.\ngoog.net.XmlHttp.setGlobalFactory(new goog.net.DefaultXmlHttpFactory());\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the invalid origin error, a subclass of\n * fireauth.AuthError.\n */\n\n\ngoog.provide('fireauth.InvalidOriginError');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('goog.Uri');\ngoog.require('goog.string');\n\n\n\n/**\n * Invalid origin error that can be returned to the developer.\n * @param {string} origin The invalid domain name.\n * @constructor\n * @extends {fireauth.AuthError}\n */\nfireauth.InvalidOriginError = function(origin) {\n  var code = fireauth.authenum.Error.INVALID_ORIGIN;\n  var message = undefined;\n  var uri = goog.Uri.parse(origin);\n  // Get domain.\n  var domain = uri.getDomain();\n  // Get scheme.\n  var scheme = uri.getScheme();\n  // Only http, https and chrome-extension currently supported.\n  if (scheme == 'chrome-extension') {\n    // Chrome extension whitelisting.\n    // Replace chrome-extension://CHROME_EXT_ID in error message template.\n    message = goog.string.subs(\n        fireauth.InvalidOriginError.CHROME_EXTENSION_MESSAGE_TEMPLATE_,\n        domain);\n  } else if (scheme == 'http' || scheme == 'https') {\n    // Replace domain in error message template.\n    message = goog.string.subs(\n        fireauth.InvalidOriginError.HTTP_MESSAGE_TEMPLATE_,\n        domain);\n  } else {\n    // Throw operation not supported when non http, https or Chrome extension\n    // protocol.\n    code = fireauth.authenum.Error.OPERATION_NOT_SUPPORTED;\n  }\n  fireauth.InvalidOriginError.base(this, 'constructor', code, message);\n};\ngoog.inherits(fireauth.InvalidOriginError, fireauth.AuthError);\n\n\n/** @private @const {string} The http invalid origin message template. */\nfireauth.InvalidOriginError.HTTP_MESSAGE_TEMPLATE_ = 'This domain (%s) is no' +\n    't authorized to run this operation. Add it to the OAuth redirect domain' +\n    's list in the Firebase console -> Auth section -> Sign in method tab.';\n\n\n/**\n * @private @const {string} The Chrome extension invalid origin message\n *     template.\n */\nfireauth.InvalidOriginError.CHROME_EXTENSION_MESSAGE_TEMPLATE_ = 'This chrom' +\n    'e extension ID (chrome-extension://%s) is not authorized to run this op' +\n    'eration. Add it to the OAuth redirect domains list in the Firebase cons' +\n    'ole -> Auth section -> Sign in method tab.';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the Auth errors that include emails and an Auth\n * credential, a subclass of fireauth.AuthError.\n */\n\n\ngoog.provide('fireauth.AuthErrorWithCredential');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthProvider');\ngoog.require('fireauth.object');\ngoog.require('goog.object');\n\n\n/**\n * Error with email and credential that can be returned to the developer.\n * @param {fireauth.authenum.Error} code The error code.\n * @param {?fireauth.AuthErrorWithCredential.CredentialInfo=} opt_credentialInfo\n *     Additional credential information to associate with the error.\n * @param {string=} opt_message The human-readable message.\n * @constructor\n * @extends {fireauth.AuthError}\n */\nfireauth.AuthErrorWithCredential =\n    function(code, opt_credentialInfo, opt_message) {\n  fireauth.AuthErrorWithCredential.base(\n      this, 'constructor', code, opt_message);\n  var credentialInfo = opt_credentialInfo || {};\n\n  // These properties are public.\n  if (credentialInfo.email) {\n    fireauth.object.setReadonlyProperty(this, 'email', credentialInfo.email);\n  }\n  if (credentialInfo.phoneNumber) {\n    fireauth.object.setReadonlyProperty(this, 'phoneNumber',\n        credentialInfo.phoneNumber);\n  }\n  if (credentialInfo.credential) {\n    fireauth.object.setReadonlyProperty(this, 'credential',\n        credentialInfo.credential);\n  }\n  if (credentialInfo.tenantId) {\n    fireauth.object.setReadonlyProperty(this, 'tenantId',\n        credentialInfo.tenantId);\n  }\n};\ngoog.inherits(fireauth.AuthErrorWithCredential, fireauth.AuthError);\n\n\n/**\n * Additional credential information to associate with an error, so that the\n * user does not have to execute the Auth flow again on linking errors.\n * @typedef {{\n *   email: (?string|undefined),\n *   phoneNumber: (?string|undefined),\n *   credential: (?fireauth.AuthCredential|undefined),\n *   tenantId: (?string|undefined),\n * }}\n */\nfireauth.AuthErrorWithCredential.CredentialInfo;\n\n\n/**\n * @return {!Object} The plain object form of the error.\n * @override\n */\nfireauth.AuthErrorWithCredential.prototype.toPlainObject = function() {\n  var obj = {\n    'code': this['code'],\n    'message': this.message\n  };\n  if (this['email']) {\n    obj['email'] = this['email'];\n  }\n  if (this['phoneNumber']) {\n    obj['phoneNumber'] = this['phoneNumber'];\n  }\n  if (this['tenantId']) {\n    obj['tenantId'] = this['tenantId'];\n  }\n\n  var credential = this['credential'] && this['credential'].toPlainObject();\n  if (credential){\n    goog.object.extend(obj, credential);\n  }\n  return obj;\n};\n\n\n/**\n * @return {!Object} The plain object form of the error. This is used by\n *     JSON.toStringify() to return the stringified representation of the error;\n * @override\n */\nfireauth.AuthErrorWithCredential.prototype.toJSON = function() {\n  // Return the plain object representation in case JSON.stringify is called on\n  // an Auth error instance.\n  return this.toPlainObject();\n};\n\n\n/**\n * @param {?Object|undefined} response The object response to convert to a\n *     fireauth.AuthErrorWithCredential.\n * @return {?fireauth.AuthError} The error representation of the response.\n * @override\n */\nfireauth.AuthErrorWithCredential.fromPlainObject = function(response) {\n  // Code included.\n  if (response['code']) {\n    var code = response['code'] || '';\n    // Remove prefix from name if available.\n    if (code.indexOf(fireauth.AuthError.ERROR_CODE_PREFIX) == 0) {\n      code = code.substring(fireauth.AuthError.ERROR_CODE_PREFIX.length);\n    }\n\n    // Credentials and tenant ID in response.\n    var credentialInfo = {\n      credential: fireauth.AuthProvider.getCredentialFromResponse(response),\n      tenantId: response['tenantId']\n    };\n    if (response['email']) {\n      credentialInfo.email = response['email'];\n    } else if (response['phoneNumber']) {\n      credentialInfo.phoneNumber = response['phoneNumber'];\n    } else if (!credentialInfo.credential) {\n      // Neither email, phone number or credentials are set; return a generic\n      // error.\n      return new fireauth.AuthError(code, response['message'] || undefined);\n    }\n\n    return new fireauth.AuthErrorWithCredential(code, credentialInfo,\n        response['message']);\n  }\n  // No error or invalid response.\n  return null;\n};\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Interface for a factory for creating XMLHttpRequest objects\n * and metadata about them.\n * @author dbk@google.com (David Barrett-Kahn)\n */\n\ngoog.provide('goog.net.XmlHttpFactory');\n\n/** @suppress {extraRequire} Typedef. */\ngoog.require('goog.net.XhrLike');\n\n\n\n/**\n * Abstract base class for an XmlHttpRequest factory.\n * @constructor\n */\ngoog.net.XmlHttpFactory = function() {};\n\n\n/**\n * Cache of options - we only actually call internalGetOptions once.\n * @type {?Object}\n * @private\n */\ngoog.net.XmlHttpFactory.prototype.cachedOptions_ = null;\n\n\n/**\n * @return {!goog.net.XhrLike.OrNative} A new XhrLike instance.\n */\ngoog.net.XmlHttpFactory.prototype.createInstance = goog.abstractMethod;\n\n\n/**\n * @return {Object} Options describing how xhr objects obtained from this\n *     factory should be used.\n */\ngoog.net.XmlHttpFactory.prototype.getOptions = function() {\n  return this.cachedOptions_ ||\n      (this.cachedOptions_ = this.internalGetOptions());\n};\n\n\n/**\n * Override this method in subclasses to preserve the caching offered by\n * getOptions().\n * @return {Object} Options describing how xhr objects obtained from this\n *     factory should be used.\n * @protected\n */\ngoog.net.XmlHttpFactory.prototype.internalGetOptions = goog.abstractMethod;\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview This file contain classes that add support for cross-domain XHR\n * requests (see http://www.w3.org/TR/cors/). Most modern browsers are able to\n * use a regular XMLHttpRequest for that, but IE 8 use XDomainRequest object\n * instead. This file provides an adapter from this object to a goog.net.XhrLike\n * and a factory to allow using this with a goog.net.XhrIo instance.\n *\n * IE 7 and older versions are not supported (given that they do not support\n * CORS requests).\n */\ngoog.provide('goog.net.CorsXmlHttpFactory');\ngoog.provide('goog.net.IeCorsXhrAdapter');\n\ngoog.require('goog.net.HttpStatus');\ngoog.require('goog.net.XhrLike');\ngoog.require('goog.net.XmlHttp');\ngoog.require('goog.net.XmlHttpFactory');\n\n\n\n/**\n * A factory of XML http request objects that supports cross domain requests.\n * This class should be instantiated and passed as the parameter of a\n * goog.net.XhrIo constructor to allow cross-domain requests in every browser.\n *\n * @extends {goog.net.XmlHttpFactory}\n * @constructor\n * @final\n */\ngoog.net.CorsXmlHttpFactory = function() {\n  goog.net.XmlHttpFactory.call(this);\n};\ngoog.inherits(goog.net.CorsXmlHttpFactory, goog.net.XmlHttpFactory);\n\n\n/** @override */\ngoog.net.CorsXmlHttpFactory.prototype.createInstance = function() {\n  var xhr = new XMLHttpRequest();\n  if (('withCredentials' in xhr)) {\n    return xhr;\n  } else if (typeof XDomainRequest != 'undefined') {\n    return new goog.net.IeCorsXhrAdapter();\n  } else {\n    throw new Error('Unsupported browser');\n  }\n};\n\n\n/** @override */\ngoog.net.CorsXmlHttpFactory.prototype.internalGetOptions = function() {\n  return {};\n};\n\n\n\n/**\n * An adapter around Internet Explorer's XDomainRequest object that makes it\n * look like a standard XMLHttpRequest. This can be used instead of\n * XMLHttpRequest to support CORS.\n *\n * @implements {goog.net.XhrLike}\n * @constructor\n * @struct\n * @final\n */\ngoog.net.IeCorsXhrAdapter = function() {\n  /**\n   * The underlying XDomainRequest used to make the HTTP request.\n   * @type {!XDomainRequest}\n   * @private\n   */\n  this.xdr_ = new XDomainRequest();\n\n  /**\n   * The simulated ready state.\n   * @type {number}\n   */\n  this.readyState = goog.net.XmlHttp.ReadyState.UNINITIALIZED;\n\n  /**\n   * The simulated ready state change callback function.\n   * @type {?function()|undefined}\n   */\n  this.onreadystatechange = null;\n\n  /** @override */\n  this.response = '';\n\n  /**\n   * The simulated response text parameter.\n   * @type {string}\n   */\n  this.responseText = '';\n\n  /**\n   * This implementation only supports text response.\n   * @type {string}\n   * @override\n   */\n  this.responseType = '';\n\n  /**\n   * The simulated status code\n   * @type {number}\n   */\n  this.status = -1;\n\n  /** @override */\n  this.responseXML = null;\n\n  /** @override */\n  this.statusText = '';\n\n  this.xdr_.onload = goog.bind(this.handleLoad_, this);\n  this.xdr_.onerror = goog.bind(this.handleError_, this);\n  this.xdr_.onprogress = goog.bind(this.handleProgress_, this);\n  this.xdr_.ontimeout = goog.bind(this.handleTimeout_, this);\n};\n\n\n/**\n * Opens a connection to the provided URL.\n * @param {string} method The HTTP method to use. Valid methods include GET and\n *     POST.\n * @param {string} url The URL to contact. The authority of this URL must match\n *     the authority of the current page's URL (e.g. http or https).\n * @param {?boolean=} opt_async Whether the request is asynchronous, defaulting\n *     to true. XDomainRequest does not support syncronous requests, so setting\n *     it to false will actually raise an exception.\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.open = function(method, url, opt_async) {\n  if (goog.isDefAndNotNull(opt_async) && (!opt_async)) {\n    throw new Error('Only async requests are supported.');\n  }\n  this.xdr_.open(method, url);\n};\n\n\n/**\n * Sends the request to the remote server. Before calling this function, always\n * call {@link open}.\n * @param {(ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string)=}\n *     opt_content The content to send as POSTDATA, if any. Only string data is\n *     supported by this implementation.\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.send = function(opt_content) {\n  if (opt_content) {\n    if (typeof opt_content == 'string') {\n      this.xdr_.send(opt_content);\n    } else {\n      throw new Error('Only string data is supported');\n    }\n  } else {\n    this.xdr_.send();\n  }\n};\n\n\n/**\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.abort = function() {\n  this.xdr_.abort();\n};\n\n\n/**\n * Sets a request header to send to the remote server. Because this\n * implementation does not support request headers, this function does nothing.\n * @param {string} key The name of the HTTP header to set. Ignored.\n * @param {string} value The value to set for the HTTP header. Ignored.\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.setRequestHeader = function(key, value) {\n  // Unsupported; ignore the header.\n};\n\n\n/**\n * Returns the value of the response header identified by key. This\n * implementation only supports the 'content-type' header.\n * @param {string} key The request header to fetch. If this parameter is set to\n *     'content-type' (case-insensitive), this function returns the value of\n *     the 'content-type' request header. If this parameter is set to any other\n *     value, this function always returns an empty string.\n * @return {string} The value of the response header, or an empty string if key\n *     is not 'content-type' (case-insensitive).\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.getResponseHeader = function(key) {\n  if (key.toLowerCase() == 'content-type') {\n    return this.xdr_.contentType;\n  }\n  return '';\n};\n\n\n/**\n * Handles a request that has fully loaded successfully.\n * @private\n */\ngoog.net.IeCorsXhrAdapter.prototype.handleLoad_ = function() {\n  // IE only calls onload if the status is 200, so the status code must be OK.\n  this.status = goog.net.HttpStatus.OK;\n  this.response = this.responseText = this.xdr_.responseText;\n  this.setReadyState_(goog.net.XmlHttp.ReadyState.COMPLETE);\n};\n\n\n/**\n * Handles a request that has failed to load.\n * @private\n */\ngoog.net.IeCorsXhrAdapter.prototype.handleError_ = function() {\n  // IE doesn't tell us what the status code actually is (other than the fact\n  // that it is not 200), so simulate an INTERNAL_SERVER_ERROR.\n  this.status = goog.net.HttpStatus.INTERNAL_SERVER_ERROR;\n  this.response = this.responseText = '';\n  this.setReadyState_(goog.net.XmlHttp.ReadyState.COMPLETE);\n};\n\n\n/**\n * Handles a request that timed out.\n * @private\n */\ngoog.net.IeCorsXhrAdapter.prototype.handleTimeout_ = function() {\n  this.handleError_();\n};\n\n\n/**\n * Handles a request that is in the process of loading.\n * @private\n */\ngoog.net.IeCorsXhrAdapter.prototype.handleProgress_ = function() {\n  // IE only calls onprogress if the status is 200, so the status code must be\n  // OK.\n  this.status = goog.net.HttpStatus.OK;\n  this.setReadyState_(goog.net.XmlHttp.ReadyState.LOADING);\n};\n\n\n/**\n * Sets this XHR's ready state and fires the onreadystatechange listener (if one\n * is set).\n * @param {number} readyState The new ready state.\n * @private\n */\ngoog.net.IeCorsXhrAdapter.prototype.setReadyState_ = function(readyState) {\n  this.readyState = readyState;\n  if (this.onreadystatechange) {\n    this.onreadystatechange();\n  }\n};\n\n\n/**\n * Returns the response headers from the server. This implemntation only returns\n * the 'content-type' header.\n * @return {string} The headers returned from the server.\n * @override\n */\ngoog.net.IeCorsXhrAdapter.prototype.getAllResponseHeaders = function() {\n  return 'content-type: ' + this.xdr_.contentType;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Definition of the LogRecord class. Please minimize\n * dependencies this file has on other closure classes as any dependency it\n * takes won't be able to use the logging infrastructure.\n *\n */\n\ngoog.provide('goog.debug.LogRecord');\n\n\n\n/**\n * LogRecord objects are used to pass logging requests between\n * the logging framework and individual log Handlers.\n * @constructor\n * @param {goog.debug.Logger.Level} level One of the level identifiers.\n * @param {string} msg The string message.\n * @param {string} loggerName The name of the source logger.\n * @param {number=} opt_time Time this log record was created if other than now.\n *     If 0, we use #goog.now.\n * @param {number=} opt_sequenceNumber Sequence number of this log record. This\n *     should only be passed in when restoring a log record from persistence.\n */\ngoog.debug.LogRecord = function(\n    level, msg, loggerName, opt_time, opt_sequenceNumber) {\n  this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber);\n};\n\n\n/**\n * Time the LogRecord was created.\n * @type {number}\n * @private\n */\ngoog.debug.LogRecord.prototype.time_;\n\n\n/**\n * Level of the LogRecord\n * @type {goog.debug.Logger.Level}\n * @private\n */\ngoog.debug.LogRecord.prototype.level_;\n\n\n/**\n * Message associated with the record\n * @type {string}\n * @private\n */\ngoog.debug.LogRecord.prototype.msg_;\n\n\n/**\n * Name of the logger that created the record.\n * @type {string}\n * @private\n */\ngoog.debug.LogRecord.prototype.loggerName_;\n\n\n/**\n * Sequence number for the LogRecord. Each record has a unique sequence number\n * that is greater than all log records created before it.\n * @type {number}\n * @private\n */\ngoog.debug.LogRecord.prototype.sequenceNumber_ = 0;\n\n\n/**\n * Exception associated with the record\n * @type {?Object}\n * @private\n */\ngoog.debug.LogRecord.prototype.exception_ = null;\n\n\n/**\n * @define {boolean} Whether to enable log sequence numbers.\n */\ngoog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS =\n    goog.define('goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS', true);\n\n\n/**\n * A sequence counter for assigning increasing sequence numbers to LogRecord\n * objects.\n * @type {number}\n * @private\n */\ngoog.debug.LogRecord.nextSequenceNumber_ = 0;\n\n\n/**\n * Sets all fields of the log record.\n * @param {goog.debug.Logger.Level} level One of the level identifiers.\n * @param {string} msg The string message.\n * @param {string} loggerName The name of the source logger.\n * @param {number=} opt_time Time this log record was created if other than now.\n *     If 0, we use #goog.now.\n * @param {number=} opt_sequenceNumber Sequence number of this log record. This\n *     should only be passed in when restoring a log record from persistence.\n */\ngoog.debug.LogRecord.prototype.reset = function(\n    level, msg, loggerName, opt_time, opt_sequenceNumber) {\n  if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) {\n    this.sequenceNumber_ = typeof opt_sequenceNumber == 'number' ?\n        opt_sequenceNumber :\n        goog.debug.LogRecord.nextSequenceNumber_++;\n  }\n\n  this.time_ = opt_time || goog.now();\n  this.level_ = level;\n  this.msg_ = msg;\n  this.loggerName_ = loggerName;\n  delete this.exception_;\n};\n\n\n/**\n * Get the source Logger's name.\n *\n * @return {string} source logger name (may be null).\n */\ngoog.debug.LogRecord.prototype.getLoggerName = function() {\n  return this.loggerName_;\n};\n\n\n/**\n * Get the exception that is part of the log record.\n *\n * @return {Object} the exception.\n */\ngoog.debug.LogRecord.prototype.getException = function() {\n  return this.exception_;\n};\n\n\n/**\n * Set the exception that is part of the log record.\n *\n * @param {Object} exception the exception.\n */\ngoog.debug.LogRecord.prototype.setException = function(exception) {\n  this.exception_ = exception;\n};\n\n\n/**\n * Get the source Logger's name.\n *\n * @param {string} loggerName source logger name (may be null).\n */\ngoog.debug.LogRecord.prototype.setLoggerName = function(loggerName) {\n  this.loggerName_ = loggerName;\n};\n\n\n/**\n * Get the logging message level, for example Level.SEVERE.\n * @return {goog.debug.Logger.Level} the logging message level.\n */\ngoog.debug.LogRecord.prototype.getLevel = function() {\n  return this.level_;\n};\n\n\n/**\n * Set the logging message level, for example Level.SEVERE.\n * @param {goog.debug.Logger.Level} level the logging message level.\n */\ngoog.debug.LogRecord.prototype.setLevel = function(level) {\n  this.level_ = level;\n};\n\n\n/**\n * Get the \"raw\" log message, before localization or formatting.\n *\n * @return {string} the raw message string.\n */\ngoog.debug.LogRecord.prototype.getMessage = function() {\n  return this.msg_;\n};\n\n\n/**\n * Set the \"raw\" log message, before localization or formatting.\n *\n * @param {string} msg the raw message string.\n */\ngoog.debug.LogRecord.prototype.setMessage = function(msg) {\n  this.msg_ = msg;\n};\n\n\n/**\n * Get event time in milliseconds since 1970.\n *\n * @return {number} event time in millis since 1970.\n */\ngoog.debug.LogRecord.prototype.getMillis = function() {\n  return this.time_;\n};\n\n\n/**\n * Set event time in milliseconds since 1970.\n *\n * @param {number} time event time in millis since 1970.\n */\ngoog.debug.LogRecord.prototype.setMillis = function(time) {\n  this.time_ = time;\n};\n\n\n/**\n * Get the sequence number.\n * <p>\n * Sequence numbers are normally assigned in the LogRecord\n * constructor, which assigns unique sequence numbers to\n * each new LogRecord in increasing order.\n * @return {number} the sequence number.\n */\ngoog.debug.LogRecord.prototype.getSequenceNumber = function() {\n  return this.sequenceNumber_;\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Definition of the Logger class. Please minimize dependencies\n * this file has on other closure classes as any dependency it takes won't be\n * able to use the logging infrastructure.\n *\n * @see ../demos/debug.html\n */\n\ngoog.provide('goog.debug.LogManager');\ngoog.provide('goog.debug.Loggable');\ngoog.provide('goog.debug.Logger');\ngoog.provide('goog.debug.Logger.Level');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug');\ngoog.require('goog.debug.LogBuffer');\ngoog.require('goog.debug.LogRecord');\n\n\n/**\n * A message value that can be handled by a Logger.\n *\n * Functions are treated like callbacks, but are only called when the event's\n * log level is enabled. This is useful for logging messages that are expensive\n * to construct.\n *\n * @typedef {string|function(): string}\n */\ngoog.debug.Loggable;\n\n\n\n/**\n * The Logger is an object used for logging debug messages. Loggers are\n * normally named, using a hierarchical dot-separated namespace. Logger names\n * can be arbitrary strings, but they should normally be based on the package\n * name or class name of the logged component, such as goog.net.BrowserChannel.\n *\n * The Logger object is loosely based on the java class\n * java.util.logging.Logger. It supports different levels of filtering for\n * different loggers.\n *\n * The logger object should never be instantiated by application code. It\n * should always use the goog.debug.Logger.getLogger function.\n *\n * @constructor\n * @param {string} name The name of the Logger.\n * @final\n */\ngoog.debug.Logger = function(name) {\n  /**\n   * Name of the Logger. Generally a dot-separated namespace\n   * @private {string}\n   */\n  this.name_ = name;\n\n  /**\n   * Parent Logger.\n   * @private {?goog.debug.Logger}\n   */\n  this.parent_ = null;\n\n  /**\n   * Level that this logger only filters above. Null indicates it should\n   * inherit from the parent.\n   * @private {?goog.debug.Logger.Level}\n   */\n  this.level_ = null;\n\n  /**\n   * Map of children loggers. The keys are the leaf names of the children and\n   * the values are the child loggers.\n   * @private {?Object}\n   */\n  this.children_ = null;\n\n  /**\n   * Handlers that are listening to this logger.\n   * @private {?Array<?Function>}\n   */\n  this.handlers_ = null;\n};\n\n\n/** @const */\ngoog.debug.Logger.ROOT_LOGGER_NAME = '';\n\n\n/**\n * @define {boolean} Toggles whether loggers other than the root logger can have\n *     log handlers attached to them and whether they can have their log level\n *     set. Logging is a bit faster when this is set to false.\n */\ngoog.debug.Logger.ENABLE_HIERARCHY =\n    goog.define('goog.debug.Logger.ENABLE_HIERARCHY', true);\n\n\n/**\n * @define {boolean} Toggles whether active log statements are also recorded\n *     to the profiler.\n */\ngoog.debug.Logger.ENABLE_PROFILER_LOGGING =\n    goog.define('goog.debug.Logger.ENABLE_PROFILER_LOGGING', false);\n\n\nif (!goog.debug.Logger.ENABLE_HIERARCHY) {\n  /**\n   * @type {!Array<Function>}\n   * @private\n   */\n  goog.debug.Logger.rootHandlers_ = [];\n\n\n  /**\n   * @type {goog.debug.Logger.Level}\n   * @private\n   */\n  goog.debug.Logger.rootLevel_;\n}\n\n\n\n/**\n * The Level class defines a set of standard logging levels that\n * can be used to control logging output.  The logging Level objects\n * are ordered and are specified by ordered integers.  Enabling logging\n * at a given level also enables logging at all higher levels.\n * <p>\n * Clients should normally use the predefined Level constants such\n * as Level.SEVERE.\n * <p>\n * The levels in descending order are:\n * <ul>\n * <li>SEVERE (highest value)\n * <li>WARNING\n * <li>INFO\n * <li>CONFIG\n * <li>FINE\n * <li>FINER\n * <li>FINEST  (lowest value)\n * </ul>\n * In addition there is a level OFF that can be used to turn\n * off logging, and a level ALL that can be used to enable\n * logging of all messages.\n *\n * @param {string} name The name of the level.\n * @param {number} value The numeric value of the level.\n * @constructor\n * @final\n */\ngoog.debug.Logger.Level = function(name, value) {\n  /**\n   * The name of the level\n   * @type {string}\n   */\n  this.name = name;\n\n  /**\n   * The numeric value of the level\n   * @type {number}\n   */\n  this.value = value;\n};\n\n\n/**\n * @return {string} String representation of the logger level.\n * @override\n */\ngoog.debug.Logger.Level.prototype.toString = function() {\n  return this.name;\n};\n\n\n/**\n * OFF is a special level that can be used to turn off logging.\n * This level is initialized to <CODE>Infinity</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.OFF = new goog.debug.Logger.Level('OFF', Infinity);\n\n\n/**\n * SHOUT is a message level for extra debugging loudness.\n * This level is initialized to <CODE>1200</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level('SHOUT', 1200);\n\n\n/**\n * SEVERE is a message level indicating a serious failure.\n * This level is initialized to <CODE>1000</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level('SEVERE', 1000);\n\n\n/**\n * WARNING is a message level indicating a potential problem.\n * This level is initialized to <CODE>900</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level('WARNING', 900);\n\n\n/**\n * INFO is a message level for informational messages.\n * This level is initialized to <CODE>800</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.INFO = new goog.debug.Logger.Level('INFO', 800);\n\n\n/**\n * CONFIG is a message level for static configuration messages.\n * This level is initialized to <CODE>700</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level('CONFIG', 700);\n\n\n/**\n * FINE is a message level providing tracing information.\n * This level is initialized to <CODE>500</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.FINE = new goog.debug.Logger.Level('FINE', 500);\n\n\n/**\n * FINER indicates a fairly detailed tracing message.\n * This level is initialized to <CODE>400</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.FINER = new goog.debug.Logger.Level('FINER', 400);\n\n/**\n * FINEST indicates a highly detailed tracing message.\n * This level is initialized to <CODE>300</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\n\ngoog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level('FINEST', 300);\n\n\n/**\n * ALL indicates that all messages should be logged.\n * This level is initialized to <CODE>0</CODE>.\n * @type {!goog.debug.Logger.Level}\n */\ngoog.debug.Logger.Level.ALL = new goog.debug.Logger.Level('ALL', 0);\n\n\n/**\n * The predefined levels.\n * @type {!Array<!goog.debug.Logger.Level>}\n * @final\n */\ngoog.debug.Logger.Level.PREDEFINED_LEVELS = [\n  goog.debug.Logger.Level.OFF, goog.debug.Logger.Level.SHOUT,\n  goog.debug.Logger.Level.SEVERE, goog.debug.Logger.Level.WARNING,\n  goog.debug.Logger.Level.INFO, goog.debug.Logger.Level.CONFIG,\n  goog.debug.Logger.Level.FINE, goog.debug.Logger.Level.FINER,\n  goog.debug.Logger.Level.FINEST, goog.debug.Logger.Level.ALL\n];\n\n\n/**\n * A lookup map used to find the level object based on the name or value of\n * the level object.\n * @type {?Object}\n * @private\n */\ngoog.debug.Logger.Level.predefinedLevelsCache_ = null;\n\n\n/**\n * Creates the predefined levels cache and populates it.\n * @private\n */\ngoog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {\n  goog.debug.Logger.Level.predefinedLevelsCache_ = {};\n  for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];\n       i++) {\n    goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;\n    goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;\n  }\n};\n\n\n/**\n * Gets the predefined level with the given name.\n * @param {string} name The name of the level.\n * @return {goog.debug.Logger.Level} The level, or null if none found.\n */\ngoog.debug.Logger.Level.getPredefinedLevel = function(name) {\n  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {\n    goog.debug.Logger.Level.createPredefinedLevelsCache_();\n  }\n\n  return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;\n};\n\n\n/**\n * Gets the highest predefined level <= #value.\n * @param {number} value Level value.\n * @return {goog.debug.Logger.Level} The level, or null if none found.\n */\ngoog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {\n  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {\n    goog.debug.Logger.Level.createPredefinedLevelsCache_();\n  }\n\n  if (value in /** @type {!Object} */ (\n          goog.debug.Logger.Level.predefinedLevelsCache_)) {\n    return goog.debug.Logger.Level.predefinedLevelsCache_[value];\n  }\n\n  for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {\n    var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];\n    if (level.value <= value) {\n      return level;\n    }\n  }\n  return null;\n};\n\n\n/**\n * Finds or creates a logger for a named subsystem. If a logger has already been\n * created with the given name it is returned. Otherwise a new logger is\n * created. If a new logger is created its log level will be configured based\n * on the LogManager configuration and it will configured to also send logging\n * output to its parent's handlers. It will be registered in the LogManager\n * global namespace.\n *\n * @param {string} name A name for the logger. This should be a dot-separated\n * name and should normally be based on the package name or class name of the\n * subsystem, such as goog.net.BrowserChannel.\n * @return {!goog.debug.Logger} The named logger.\n * @deprecated use {@link goog.log} instead.\n */\ngoog.debug.Logger.getLogger = function(name) {\n  return goog.debug.LogManager.getLogger(name);\n};\n\n\n/**\n * Logs a message to profiling tools, if available.\n * {@see https://developers.google.com/web-toolkit/speedtracer/logging-api}\n * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}\n * @param {string} msg The message to log.\n */\ngoog.debug.Logger.logToProfilers = function(msg) {\n  // Some browsers also log timeStamp calls to the console, only log\n  // if actually asked.\n  if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {\n    var msWriteProfilerMark = goog.global['msWriteProfilerMark'];\n    if (msWriteProfilerMark) {\n      // Logs a message to the Microsoft profiler\n      // On IE, console['timeStamp'] may output to console\n      msWriteProfilerMark(msg);\n      return;\n    }\n\n    // Using goog.global, as loggers might be used in window-less contexts.\n    var console = goog.global['console'];\n    if (console && console['timeStamp']) {\n      // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.\n      console['timeStamp'](msg);\n    }\n  }\n};\n\n\n/**\n * Gets the name of this logger.\n * @return {string} The name of this logger.\n */\ngoog.debug.Logger.prototype.getName = function() {\n  return this.name_;\n};\n\n\n/**\n * Adds a handler to the logger. This doesn't use the event system because\n * we want to be able to add logging to the event system.\n * @param {Function} handler Handler function to add.\n */\ngoog.debug.Logger.prototype.addHandler = function(handler) {\n  if (goog.debug.LOGGING_ENABLED) {\n    if (goog.debug.Logger.ENABLE_HIERARCHY) {\n      if (!this.handlers_) {\n        this.handlers_ = [];\n      }\n      this.handlers_.push(handler);\n    } else {\n      goog.asserts.assert(\n          !this.name_, 'Cannot call addHandler on a non-root logger when ' +\n              'goog.debug.Logger.ENABLE_HIERARCHY is false.');\n      goog.debug.Logger.rootHandlers_.push(handler);\n    }\n  }\n};\n\n\n/**\n * Removes a handler from the logger. This doesn't use the event system because\n * we want to be able to add logging to the event system.\n * @param {Function} handler Handler function to remove.\n * @return {boolean} Whether the handler was removed.\n */\ngoog.debug.Logger.prototype.removeHandler = function(handler) {\n  if (goog.debug.LOGGING_ENABLED) {\n    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ?\n        this.handlers_ :\n        goog.debug.Logger.rootHandlers_;\n    return !!handlers && goog.array.remove(handlers, handler);\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * Returns the parent of this logger.\n * @return {goog.debug.Logger} The parent logger or null if this is the root.\n */\ngoog.debug.Logger.prototype.getParent = function() {\n  return this.parent_;\n};\n\n\n/**\n * Returns the children of this logger as a map of the child name to the logger.\n * @return {!Object} The map where the keys are the child leaf names and the\n *     values are the Logger objects.\n */\ngoog.debug.Logger.prototype.getChildren = function() {\n  if (!this.children_) {\n    this.children_ = {};\n  }\n  return this.children_;\n};\n\n\n/**\n * Set the log level specifying which message levels will be logged by this\n * logger. Message levels lower than this value will be discarded.\n * The level value Level.OFF can be used to turn off logging. If the new level\n * is null, it means that this node should inherit its level from its nearest\n * ancestor with a specific (non-null) level value.\n *\n * @param {goog.debug.Logger.Level} level The new level.\n */\ngoog.debug.Logger.prototype.setLevel = function(level) {\n  if (goog.debug.LOGGING_ENABLED) {\n    if (goog.debug.Logger.ENABLE_HIERARCHY) {\n      this.level_ = level;\n    } else {\n      goog.asserts.assert(\n          !this.name_, 'Cannot call setLevel() on a non-root logger when ' +\n              'goog.debug.Logger.ENABLE_HIERARCHY is false.');\n      goog.debug.Logger.rootLevel_ = level;\n    }\n  }\n};\n\n\n/**\n * Gets the log level specifying which message levels will be logged by this\n * logger. Message levels lower than this value will be discarded.\n * The level value Level.OFF can be used to turn off logging. If the level\n * is null, it means that this node should inherit its level from its nearest\n * ancestor with a specific (non-null) level value.\n *\n * @return {goog.debug.Logger.Level} The level.\n */\ngoog.debug.Logger.prototype.getLevel = function() {\n  return goog.debug.LOGGING_ENABLED ? this.level_ : goog.debug.Logger.Level.OFF;\n};\n\n\n/**\n * Returns the effective level of the logger based on its ancestors' levels.\n * @return {goog.debug.Logger.Level} The level.\n */\ngoog.debug.Logger.prototype.getEffectiveLevel = function() {\n  if (!goog.debug.LOGGING_ENABLED) {\n    return goog.debug.Logger.Level.OFF;\n  }\n\n  if (!goog.debug.Logger.ENABLE_HIERARCHY) {\n    return goog.debug.Logger.rootLevel_;\n  }\n  if (this.level_) {\n    return this.level_;\n  }\n  if (this.parent_) {\n    return this.parent_.getEffectiveLevel();\n  }\n  goog.asserts.fail('Root logger has no level set.');\n  return null;\n};\n\n\n/**\n * Checks if a message of the given level would actually be logged by this\n * logger. This check is based on the Loggers effective level, which may be\n * inherited from its parent.\n * @param {goog.debug.Logger.Level} level The level to check.\n * @return {boolean} Whether the message would be logged.\n */\ngoog.debug.Logger.prototype.isLoggable = function(level) {\n  return goog.debug.LOGGING_ENABLED &&\n      level.value >= this.getEffectiveLevel().value;\n};\n\n\n/**\n * Logs a message. If the logger is currently enabled for the\n * given message level then the given message is forwarded to all the\n * registered output Handler objects.\n * @param {goog.debug.Logger.Level} level One of the level identifiers.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error|Object=} opt_exception An exception associated with the\n *     message.\n */\ngoog.debug.Logger.prototype.log = function(level, msg, opt_exception) {\n  // java caches the effective level, not sure it's necessary here\n  if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {\n    // Message callbacks can be useful when a log message is expensive to build.\n    if (goog.isFunction(msg)) {\n      msg = msg();\n    }\n\n    this.doLogRecord_(this.getLogRecord(level, msg, opt_exception));\n  }\n};\n\n\n/**\n * Creates a new log record and adds the exception (if present) to it.\n * @param {goog.debug.Logger.Level} level One of the level identifiers.\n * @param {string} msg The string message.\n * @param {Error|Object=} opt_exception An exception associated with the\n *     message.\n * @return {!goog.debug.LogRecord} A log record.\n * @suppress {es5Strict}\n */\ngoog.debug.Logger.prototype.getLogRecord = function(level, msg, opt_exception) {\n  if (goog.debug.LogBuffer.isBufferingEnabled()) {\n    var logRecord =\n        goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);\n  } else {\n    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);\n  }\n  if (opt_exception) {\n    logRecord.setException(opt_exception);\n  }\n  return logRecord;\n};\n\n\n/**\n * Logs a message at the Logger.Level.SHOUT level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.shout = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.SEVERE level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.severe = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.WARNING level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.warning = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.INFO level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.info = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.CONFIG level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.config = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.FINE level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.fine = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.FINER level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.finer = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Logger.Level.FINEST level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.debug.Logger.prototype.finest = function(msg, opt_exception) {\n  if (goog.debug.LOGGING_ENABLED) {\n    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a LogRecord. If the logger is currently enabled for the\n * given message level then the given message is forwarded to all the\n * registered output Handler objects.\n * @param {goog.debug.LogRecord} logRecord A log record to log.\n */\ngoog.debug.Logger.prototype.logRecord = function(logRecord) {\n  if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) {\n    this.doLogRecord_(logRecord);\n  }\n};\n\n\n/**\n * Logs a LogRecord.\n * @param {goog.debug.LogRecord} logRecord A log record to log.\n * @private\n */\ngoog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {\n  if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {\n    goog.debug.Logger.logToProfilers('log:' + logRecord.getMessage());\n  }\n  if (goog.debug.Logger.ENABLE_HIERARCHY) {\n    var target = this;\n    while (target) {\n      target.callPublish_(logRecord);\n      target = target.getParent();\n    }\n  } else {\n    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++];) {\n      handler(logRecord);\n    }\n  }\n};\n\n\n/**\n * Calls the handlers for publish.\n * @param {goog.debug.LogRecord} logRecord The log record to publish.\n * @private\n */\ngoog.debug.Logger.prototype.callPublish_ = function(logRecord) {\n  if (this.handlers_) {\n    for (var i = 0, handler; handler = this.handlers_[i]; i++) {\n      handler(logRecord);\n    }\n  }\n};\n\n\n/**\n * Sets the parent of this logger. This is used for setting up the logger tree.\n * @param {goog.debug.Logger} parent The parent logger.\n * @private\n */\ngoog.debug.Logger.prototype.setParent_ = function(parent) {\n  this.parent_ = parent;\n};\n\n\n/**\n * Adds a child to this logger. This is used for setting up the logger tree.\n * @param {string} name The leaf name of the child.\n * @param {goog.debug.Logger} logger The child logger.\n * @private\n */\ngoog.debug.Logger.prototype.addChild_ = function(name, logger) {\n  this.getChildren()[name] = logger;\n};\n\n\n/**\n * There is a single global LogManager object that is used to maintain a set of\n * shared state about Loggers and log services. This is loosely based on the\n * java class java.util.logging.LogManager.\n * @const\n */\ngoog.debug.LogManager = {};\n\n\n/**\n * Map of logger names to logger objects.\n *\n * @type {!Object<string, !goog.debug.Logger>}\n * @private\n */\ngoog.debug.LogManager.loggers_ = {};\n\n\n/**\n * The root logger which is the root of the logger tree.\n * @type {?goog.debug.Logger}\n * @private\n */\ngoog.debug.LogManager.rootLogger_ = null;\n\n\n/**\n * Initializes the LogManager if not already initialized.\n */\ngoog.debug.LogManager.initialize = function() {\n  if (!goog.debug.LogManager.rootLogger_) {\n    goog.debug.LogManager.rootLogger_ =\n        new goog.debug.Logger(goog.debug.Logger.ROOT_LOGGER_NAME);\n    goog.debug.LogManager.loggers_[goog.debug.Logger.ROOT_LOGGER_NAME] =\n        goog.debug.LogManager.rootLogger_;\n    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);\n  }\n};\n\n\n/**\n * Returns all the loggers.\n * @return {!Object<string, !goog.debug.Logger>} Map of logger names to logger\n *     objects.\n */\ngoog.debug.LogManager.getLoggers = function() {\n  return goog.debug.LogManager.loggers_;\n};\n\n\n/**\n * Returns the root of the logger tree namespace, the logger with the empty\n * string as its name.\n *\n * @return {!goog.debug.Logger} The root logger.\n */\ngoog.debug.LogManager.getRoot = function() {\n  goog.debug.LogManager.initialize();\n  return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);\n};\n\n\n/**\n * Finds a named logger.\n *\n * @param {string} name A name for the logger. This should be a dot-separated\n * name and should normally be based on the package name or class name of the\n * subsystem, such as goog.net.BrowserChannel.\n * @return {!goog.debug.Logger} The named logger.\n */\ngoog.debug.LogManager.getLogger = function(name) {\n  goog.debug.LogManager.initialize();\n  var ret = goog.debug.LogManager.loggers_[name];\n  return ret || goog.debug.LogManager.createLogger_(name);\n};\n\n\n/**\n * Creates a function that can be passed to goog.debug.catchErrors. The function\n * will log all reported errors using the given logger.\n * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.\n *     Defaults to the root logger.\n * @return {function(Object)} The created function.\n */\ngoog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {\n  return function(info) {\n    var logger = opt_logger || goog.debug.LogManager.getRoot();\n    logger.severe(\n        'Error: ' + info.message + ' (' + info.fileName + ' @ Line: ' +\n        info.line + ')');\n  };\n};\n\n\n/**\n * Creates the named logger. Will also create the parents of the named logger\n * if they don't yet exist.\n * @param {string} name The name of the logger.\n * @return {!goog.debug.Logger} The named logger.\n * @private\n */\ngoog.debug.LogManager.createLogger_ = function(name) {\n  // find parent logger\n  var logger = new goog.debug.Logger(name);\n  if (goog.debug.Logger.ENABLE_HIERARCHY) {\n    var lastDotIndex = name.lastIndexOf('.');\n    var parentName = name.substr(0, lastDotIndex);\n    var leafName = name.substr(lastDotIndex + 1);\n    var parentLogger = goog.debug.LogManager.getLogger(parentName);\n\n    // tell the parent about the child and the child about the parent\n    parentLogger.addChild_(leafName, logger);\n    logger.setParent_(parentLogger);\n  }\n\n  goog.debug.LogManager.loggers_[name] = logger;\n  return logger;\n};\n","// Copyright 2011 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Constants for HTTP status codes.\n */\n\ngoog.provide('goog.net.HttpStatus');\n\n\n/**\n * HTTP Status Codes defined in RFC 2616, RFC 6585, RFC 4918 and RFC 7538.\n * @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n * @see http://tools.ietf.org/html/rfc6585\n * @see https://tools.ietf.org/html/rfc4918\n * @see https://tools.ietf.org/html/rfc7538\n * @enum {number}\n */\ngoog.net.HttpStatus = {\n  // Informational 1xx\n  CONTINUE: 100,\n  SWITCHING_PROTOCOLS: 101,\n\n  // Successful 2xx\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NON_AUTHORITATIVE_INFORMATION: 203,\n  NO_CONTENT: 204,\n  RESET_CONTENT: 205,\n  PARTIAL_CONTENT: 206,\n  MULTI_STATUS: 207,\n\n  // Redirection 3xx\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  USE_PROXY: 305,\n  TEMPORARY_REDIRECT: 307,\n  PERMANENT_REDIRECT: 308,\n\n  // Client Error 4xx\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  REQUEST_ENTITY_TOO_LARGE: 413,\n  REQUEST_URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  REQUEST_RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n\n  // Server Error 5xx\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  INSUFFICIENT_STORAGE: 507,\n  NETWORK_AUTHENTICATION_REQUIRED: 511,\n\n  /*\n   * IE returns this code for 204 due to its use of URLMon, which returns this\n   * code for 'Operation Aborted'. The status text is 'Unknown', the response\n   * headers are ''. Known to occur on IE 6 on XP through IE9 on Win7.\n   */\n  QUIRK_IE_NO_CONTENT: 1223\n};\n\n\n/**\n * Returns whether the given status should be considered successful.\n *\n * Successful codes are OK (200), CREATED (201), ACCEPTED (202),\n * NO CONTENT (204), PARTIAL CONTENT (206), NOT MODIFIED (304),\n * and IE's no content code (1223).\n *\n * @param {number} status The status code to test.\n * @return {boolean} Whether the status code should be considered successful.\n */\ngoog.net.HttpStatus.isSuccess = function(status) {\n  switch (status) {\n    case goog.net.HttpStatus.OK:\n    case goog.net.HttpStatus.CREATED:\n    case goog.net.HttpStatus.ACCEPTED:\n    case goog.net.HttpStatus.NO_CONTENT:\n    case goog.net.HttpStatus.PARTIAL_CONTENT:\n    case goog.net.HttpStatus.NOT_MODIFIED:\n    case goog.net.HttpStatus.QUIRK_IE_NO_CONTENT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n","// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Utilities for creating functions. Loosely inspired by these\n * java classes from the Guava library:\n * com.google.common.base.Functions\n * https://google.github.io/guava/releases/snapshot-jre/api/docs/index.html?com/google/common/base/Functions.html\n *\n * com.google.common.base.Predicates\n * https://google.github.io/guava/releases/snapshot-jre/api/docs/index.html?com/google/common/base/Predicates.html\n *\n * More about these can be found at\n * https://github.com/google/guava/wiki/FunctionalExplained\n *\n * @author nicksantos@google.com (Nick Santos)\n */\n\n\ngoog.provide('goog.functions');\n\n\n/**\n * Creates a function that always returns the same value.\n * @param {T} retValue The value to return.\n * @return {function():T} The new function.\n * @template T\n */\ngoog.functions.constant = function(retValue) {\n  return function() { return retValue; };\n};\n\n\n/**\n * Always returns false.\n * @type {function(...): boolean}\n */\ngoog.functions.FALSE = function() {\n  return false;\n};\n\n\n/**\n * Always returns true.\n * @type {function(...): boolean}\n */\ngoog.functions.TRUE = function() {\n  return true;\n};\n\n\n/**\n * Always returns NULL.\n * @type {function(...): null}\n */\ngoog.functions.NULL = function() {\n  return null;\n};\n\n\n/**\n * A simple function that returns the first argument of whatever is passed\n * into it.\n * @param {T=} opt_returnValue The single value that will be returned.\n * @param {...*} var_args Optional trailing arguments. These are ignored.\n * @return {T} The first argument passed in, or undefined if nothing was passed.\n * @template T\n */\ngoog.functions.identity = function(opt_returnValue, var_args) {\n  return opt_returnValue;\n};\n\n\n/**\n * Creates a function that always throws an error with the given message.\n * @param {string} message The error message.\n * @return {!Function} The error-throwing function.\n */\ngoog.functions.error = function(message) {\n  return function() {\n    throw new Error(message);\n  };\n};\n\n\n/**\n * Creates a function that throws the given object.\n * @param {*} err An object to be thrown.\n * @return {!Function} The error-throwing function.\n */\ngoog.functions.fail = function(err) {\n  return function() { throw err; };\n};\n\n\n/**\n * Given a function, create a function that keeps opt_numArgs arguments and\n * silently discards all additional arguments.\n * @param {Function} f The original function.\n * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.\n * @return {!Function} A version of f that only keeps the first opt_numArgs\n *     arguments.\n */\ngoog.functions.lock = function(f, opt_numArgs) {\n  opt_numArgs = opt_numArgs || 0;\n  return function() {\n    var self = /** @type {*} */ (this);\n    return f.apply(self, Array.prototype.slice.call(arguments, 0, opt_numArgs));\n  };\n};\n\n\n/**\n * Creates a function that returns its nth argument.\n * @param {number} n The position of the return argument.\n * @return {!Function} A new function.\n */\ngoog.functions.nth = function(n) {\n  return function() { return arguments[n]; };\n};\n\n\n/**\n * Like goog.partial(), except that arguments are added after arguments to the\n * returned function.\n *\n * Usage:\n * function f(arg1, arg2, arg3, arg4) { ... }\n * var g = goog.functions.partialRight(f, arg3, arg4);\n * g(arg1, arg2);\n *\n * @param {!Function} fn A function to partially apply.\n * @param {...*} var_args Additional arguments that are partially applied to fn\n *     at the end.\n * @return {!Function} A partially-applied form of the function goog.partial()\n *     was invoked as a method of.\n */\ngoog.functions.partialRight = function(fn, var_args) {\n  var rightArgs = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    var self = /** @type {*} */ (this);\n    var newArgs = Array.prototype.slice.call(arguments);\n    newArgs.push.apply(newArgs, rightArgs);\n    return fn.apply(self, newArgs);\n  };\n};\n\n\n/**\n * Given a function, create a new function that swallows its return value\n * and replaces it with a new one.\n * @param {Function} f A function.\n * @param {T} retValue A new return value.\n * @return {function(...?):T} A new function.\n * @template T\n */\ngoog.functions.withReturnValue = function(f, retValue) {\n  return goog.functions.sequence(f, goog.functions.constant(retValue));\n};\n\n\n/**\n * Creates a function that returns whether its argument equals the given value.\n *\n * Example:\n * var key = goog.object.findKey(obj, goog.functions.equalTo('needle'));\n *\n * @param {*} value The value to compare to.\n * @param {boolean=} opt_useLooseComparison Whether to use a loose (==)\n *     comparison rather than a strict (===) one. Defaults to false.\n * @return {function(*):boolean} The new function.\n */\ngoog.functions.equalTo = function(value, opt_useLooseComparison) {\n  return function(other) {\n    return opt_useLooseComparison ? (value == other) : (value === other);\n  };\n};\n\n\n/**\n * Creates the composition of the functions passed in.\n * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).\n * @param {function(...?):T} fn The final function.\n * @param {...Function} var_args A list of functions.\n * @return {function(...?):T} The composition of all inputs.\n * @template T\n */\ngoog.functions.compose = function(fn, var_args) {\n  var functions = arguments;\n  var length = functions.length;\n  return function() {\n    var self = /** @type {*} */ (this);\n    var result;\n    if (length) {\n      result = functions[length - 1].apply(self, arguments);\n    }\n\n    for (var i = length - 2; i >= 0; i--) {\n      result = functions[i].call(self, result);\n    }\n    return result;\n  };\n};\n\n\n/**\n * Creates a function that calls the functions passed in in sequence, and\n * returns the value of the last function. For example,\n * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).\n * @param {...Function} var_args A list of functions.\n * @return {!Function} A function that calls all inputs in sequence.\n */\ngoog.functions.sequence = function(var_args) {\n  var functions = arguments;\n  var length = functions.length;\n  return function() {\n    var self = /** @type {*} */ (this);\n    var result;\n    for (var i = 0; i < length; i++) {\n      result = functions[i].apply(self, arguments);\n    }\n    return result;\n  };\n};\n\n\n/**\n * Creates a function that returns true if each of its components evaluates\n * to true. The components are evaluated in order, and the evaluation will be\n * short-circuited as soon as a function returns false.\n * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).\n * @param {...Function} var_args A list of functions.\n * @return {function(...?):boolean} A function that ANDs its component\n *      functions.\n */\ngoog.functions.and = function(var_args) {\n  var functions = arguments;\n  var length = functions.length;\n  return function() {\n    var self = /** @type {*} */ (this);\n    for (var i = 0; i < length; i++) {\n      if (!functions[i].apply(self, arguments)) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n\n\n/**\n * Creates a function that returns true if any of its components evaluates\n * to true. The components are evaluated in order, and the evaluation will be\n * short-circuited as soon as a function returns true.\n * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).\n * @param {...Function} var_args A list of functions.\n * @return {function(...?):boolean} A function that ORs its component\n *    functions.\n */\ngoog.functions.or = function(var_args) {\n  var functions = arguments;\n  var length = functions.length;\n  return function() {\n    var self = /** @type {*} */ (this);\n    for (var i = 0; i < length; i++) {\n      if (functions[i].apply(self, arguments)) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\n\n\n/**\n * Creates a function that returns the Boolean opposite of a provided function.\n * For example, (goog.functions.not(f))(x) is equivalent to !f(x).\n * @param {!Function} f The original function.\n * @return {function(...?):boolean} A function that delegates to f and returns\n * opposite.\n */\ngoog.functions.not = function(f) {\n  return function() {\n    var self = /** @type {*} */ (this);\n    return !f.apply(self, arguments);\n  };\n};\n\n\n/**\n * Generic factory function to construct an object given the constructor\n * and the arguments. Intended to be bound to create object factories.\n *\n * Example:\n *\n * var factory = goog.partial(goog.functions.create, Class);\n *\n * @param {function(new:T, ...)} constructor The constructor for the Object.\n * @param {...*} var_args The arguments to be passed to the constructor.\n * @return {T} A new instance of the class given in `constructor`.\n * @template T\n */\ngoog.functions.create = function(constructor, var_args) {\n  /**\n   * @constructor\n   * @final\n   */\n  var temp = function() {};\n  temp.prototype = constructor.prototype;\n\n  // obj will have constructor's prototype in its chain and\n  // 'obj instanceof constructor' will be true.\n  var obj = new temp();\n\n  // obj is initialized by constructor.\n  // arguments is only array-like so lacks shift(), but can be used with\n  // the Array prototype function.\n  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));\n  return obj;\n};\n\n\n/**\n * @define {boolean} Whether the return value cache should be used.\n *    This should only be used to disable caches when testing.\n */\ngoog.functions.CACHE_RETURN_VALUE =\n    goog.define('goog.functions.CACHE_RETURN_VALUE', true);\n\n\n/**\n * Gives a wrapper function that caches the return value of a parameterless\n * function when first called.\n *\n * When called for the first time, the given function is called and its\n * return value is cached (thus this is only appropriate for idempotent\n * functions).  Subsequent calls will return the cached return value. This\n * allows the evaluation of expensive functions to be delayed until first used.\n *\n * To cache the return values of functions with parameters, see goog.memoize.\n *\n * @param {function():T} fn A function to lazily evaluate.\n * @return {function():T} A wrapped version the function.\n * @template T\n */\ngoog.functions.cacheReturnValue = function(fn) {\n  var called = false;\n  var value;\n\n  return function() {\n    if (!goog.functions.CACHE_RETURN_VALUE) {\n      return fn();\n    }\n\n    if (!called) {\n      value = fn();\n      called = true;\n    }\n\n    return value;\n  };\n};\n\n\n/**\n * Wraps a function to allow it to be called, at most, once. All\n * additional calls are no-ops.\n *\n * This is particularly useful for initialization functions\n * that should be called, at most, once.\n *\n * @param {function():*} f Function to call.\n * @return {function():undefined} Wrapped function.\n */\ngoog.functions.once = function(f) {\n  // Keep a reference to the function that we null out when we're done with\n  // it -- that way, the function can be GC'd when we're done with it.\n  var inner = f;\n  return function() {\n    if (inner) {\n      var tmp = inner;\n      inner = null;\n      tmp();\n    }\n  };\n};\n\n\n/**\n * Wraps a function to allow it to be called, at most, once per interval\n * (specified in milliseconds). If the wrapper function is called N times within\n * that interval, only the Nth call will go through.\n *\n * This is particularly useful for batching up repeated actions where the\n * last action should win. This can be used, for example, for refreshing an\n * autocomplete pop-up every so often rather than updating with every keystroke,\n * since the final text typed by the user is the one that should produce the\n * final autocomplete results. For more stateful debouncing with support for\n * pausing, resuming, and canceling debounced actions, use\n * `goog.async.Debouncer`.\n *\n * @param {function(this:SCOPE, ...?)} f Function to call.\n * @param {number} interval Interval over which to debounce. The function will\n *     only be called after the full interval has elapsed since the last call.\n * @param {SCOPE=} opt_scope Object in whose scope to call the function.\n * @return {function(...?): undefined} Wrapped function.\n * @template SCOPE\n */\ngoog.functions.debounce = function(f, interval, opt_scope) {\n  var timeout = 0;\n  return /** @type {function(...?)} */ (function(var_args) {\n    goog.global.clearTimeout(timeout);\n    var args = arguments;\n    timeout = goog.global.setTimeout(function() {\n      f.apply(opt_scope, args);\n    }, interval);\n  });\n};\n\n\n/**\n * Wraps a function to allow it to be called, at most, once per interval\n * (specified in milliseconds). If the wrapper function is called N times in\n * that interval, both the 1st and the Nth calls will go through.\n *\n * This is particularly useful for limiting repeated user requests where the\n * the last action should win, but you also don't want to wait until the end of\n * the interval before sending a request out, as it leads to a perception of\n * slowness for the user.\n *\n * @param {function(this:SCOPE, ...?)} f Function to call.\n * @param {number} interval Interval over which to throttle. The function can\n *     only be called once per interval.\n * @param {SCOPE=} opt_scope Object in whose scope to call the function.\n * @return {function(...?): undefined} Wrapped function.\n * @template SCOPE\n */\ngoog.functions.throttle = function(f, interval, opt_scope) {\n  var timeout = 0;\n  var shouldFire = false;\n  var args = [];\n\n  var handleTimeout = function() {\n    timeout = 0;\n    if (shouldFire) {\n      shouldFire = false;\n      fire();\n    }\n  };\n\n  var fire = function() {\n    timeout = goog.global.setTimeout(handleTimeout, interval);\n    f.apply(opt_scope, args);\n  };\n\n  return /** @type {function(...?)} */ (function(var_args) {\n    args = arguments;\n    if (!timeout) {\n      fire();\n    } else {\n      shouldFire = true;\n    }\n  });\n};\n\n\n/**\n * Wraps a function to allow it to be called, at most, once per interval\n * (specified in milliseconds). If the wrapper function is called N times within\n * that interval, only the 1st call will go through.\n *\n * This is particularly useful for limiting repeated user requests where the\n * first request is guaranteed to have all the data required to perform the\n * final action, so there's no need to wait until the end of the interval before\n * sending the request out.\n *\n * @param {function(this:SCOPE, ...?)} f Function to call.\n * @param {number} interval Interval over which to rate-limit. The function will\n *     only be called once per interval, and ignored for the remainer of the\n *     interval.\n * @param {SCOPE=} opt_scope Object in whose scope to call the function.\n * @return {function(...?): undefined} Wrapped function.\n * @template SCOPE\n */\ngoog.functions.rateLimit = function(f, interval, opt_scope) {\n  var timeout = 0;\n\n  var handleTimeout = function() {\n    timeout = 0;\n  };\n\n  return /** @type {function(...?)} */ (function(var_args) {\n    if (!timeout) {\n      timeout = goog.global.setTimeout(handleTimeout, interval);\n      f.apply(opt_scope, arguments);\n    }\n  });\n};\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Basic strippable logging definitions.\n * @see http://go/closurelogging\n *\n * @author johnlenz@google.com (John Lenz)\n */\n\ngoog.provide('goog.log');\ngoog.provide('goog.log.Level');\ngoog.provide('goog.log.LogRecord');\ngoog.provide('goog.log.Logger');\n\ngoog.require('goog.debug');\ngoog.require('goog.debug.LogManager');\ngoog.require('goog.debug.LogRecord');\ngoog.require('goog.debug.Logger');\n\n\n/** @define {boolean} Whether logging is enabled. */\ngoog.log.ENABLED = goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);\n\n\n/** @const {string} */\ngoog.log.ROOT_LOGGER_NAME = goog.debug.Logger.ROOT_LOGGER_NAME;\n\n\n\n/**\n * @constructor\n * @final\n */\ngoog.log.Logger = goog.debug.Logger;\n\n\n\n/**\n * @constructor\n * @final\n */\ngoog.log.Level = goog.debug.Logger.Level;\n\n\n\n/**\n * @constructor\n * @final\n */\ngoog.log.LogRecord = goog.debug.LogRecord;\n\n\n/**\n * Finds or creates a logger for a named subsystem. If a logger has already been\n * created with the given name it is returned. Otherwise a new logger is\n * created. If a new logger is created its log level will be configured based\n * on the goog.debug.LogManager configuration and it will configured to also\n * send logging output to its parent's handlers.\n * @see goog.debug.LogManager\n *\n * @param {string} name A name for the logger. This should be a dot-separated\n *     name and should normally be based on the package name or class name of\n *     the subsystem, such as goog.net.BrowserChannel.\n * @param {goog.log.Level=} opt_level If provided, override the\n *     default logging level with the provided level.\n * @return {goog.log.Logger} The named logger or null if logging is disabled.\n */\ngoog.log.getLogger = function(name, opt_level) {\n  if (goog.log.ENABLED) {\n    var logger = goog.debug.LogManager.getLogger(name);\n    if (opt_level && logger) {\n      logger.setLevel(opt_level);\n    }\n    return logger;\n  } else {\n    return null;\n  }\n};\n\n\n// TODO(johnlenz): try to tighten the types to these functions.\n/**\n * Adds a handler to the logger. This doesn't use the event system because\n * we want to be able to add logging to the event system.\n * @param {goog.log.Logger} logger\n * @param {Function} handler Handler function to add.\n */\ngoog.log.addHandler = function(logger, handler) {\n  if (goog.log.ENABLED && logger) {\n    logger.addHandler(handler);\n  }\n};\n\n\n/**\n * Removes a handler from the logger. This doesn't use the event system because\n * we want to be able to add logging to the event system.\n * @param {goog.log.Logger} logger\n * @param {Function} handler Handler function to remove.\n * @return {boolean} Whether the handler was removed.\n */\ngoog.log.removeHandler = function(logger, handler) {\n  if (goog.log.ENABLED && logger) {\n    return logger.removeHandler(handler);\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * Logs a message. If the logger is currently enabled for the\n * given message level then the given message is forwarded to all the\n * registered output Handler objects.\n * @param {goog.log.Logger} logger\n * @param {goog.log.Level} level One of the level identifiers.\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error|Object=} opt_exception An exception associated with the\n *     message.\n */\ngoog.log.log = function(logger, level, msg, opt_exception) {\n  if (goog.log.ENABLED && logger) {\n    logger.log(level, msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Level.SEVERE level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.log.Logger} logger\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.log.error = function(logger, msg, opt_exception) {\n  if (goog.log.ENABLED && logger) {\n    logger.severe(msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Level.WARNING level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.log.Logger} logger\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.log.warning = function(logger, msg, opt_exception) {\n  if (goog.log.ENABLED && logger) {\n    logger.warning(msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Level.INFO level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.log.Logger} logger\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.log.info = function(logger, msg, opt_exception) {\n  if (goog.log.ENABLED && logger) {\n    logger.info(msg, opt_exception);\n  }\n};\n\n\n/**\n * Logs a message at the Level.Fine level.\n * If the logger is currently enabled for the given message level then the\n * given message is forwarded to all the registered output Handler objects.\n * @param {goog.log.Logger} logger\n * @param {goog.debug.Loggable} msg The message to log.\n * @param {Error=} opt_exception An exception associated with the message.\n */\ngoog.log.fine = function(logger, msg, opt_exception) {\n  if (goog.log.ENABLED && logger) {\n    logger.fine(msg, opt_exception);\n  }\n};\n","// Copyright 2015 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.net.FetchXmlHttp');\ngoog.provide('goog.net.FetchXmlHttpFactory');\n\ngoog.require('goog.asserts');\ngoog.require('goog.events.EventTarget');\ngoog.require('goog.functions');\ngoog.require('goog.log');\ngoog.require('goog.net.XhrLike');\ngoog.require('goog.net.XmlHttpFactory');\n\n\n\n/**\n * Factory for creating Xhr objects that uses the native fetch() method.\n * https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n * Note that this factory is intended for use in Service Worker only.\n * @param {!WorkerGlobalScope} worker The Service Worker global scope.\n * @extends {goog.net.XmlHttpFactory}\n * @struct\n * @constructor\n */\ngoog.net.FetchXmlHttpFactory = function(worker) {\n  goog.net.FetchXmlHttpFactory.base(this, 'constructor');\n\n  /** @private @final {!WorkerGlobalScope} */\n  this.worker_ = worker;\n\n  /** @private {!RequestCredentials|undefined} */\n  this.credentialsMode_ = undefined;\n\n  /** @private {!RequestCache|undefined} */\n  this.cacheMode_ = undefined;\n};\ngoog.inherits(goog.net.FetchXmlHttpFactory, goog.net.XmlHttpFactory);\n\n\n/** @override */\ngoog.net.FetchXmlHttpFactory.prototype.createInstance = function() {\n  var instance = new goog.net.FetchXmlHttp(this.worker_);\n  if (this.credentialsMode_) {\n    instance.setCredentialsMode(this.credentialsMode_);\n  }\n  if (this.cacheMode_) {\n    instance.setCacheMode(this.cacheMode_);\n  }\n  return instance;\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttpFactory.prototype.internalGetOptions =\n    goog.functions.constant({});\n\n\n/**\n * @param {!RequestCredentials} credentialsMode The credentials mode of the\n *     Service Worker fetch.\n */\ngoog.net.FetchXmlHttpFactory.prototype.setCredentialsMode = function(\n    credentialsMode) {\n  this.credentialsMode_ = credentialsMode;\n};\n\n\n/**\n * @param {!RequestCache} cacheMode The cache mode of the Service Worker fetch.\n */\ngoog.net.FetchXmlHttpFactory.prototype.setCacheMode = function(cacheMode) {\n  this.cacheMode_ = cacheMode;\n};\n\n\n\n/**\n * FetchXmlHttp object constructor.\n * @param {!WorkerGlobalScope} worker\n * @extends {goog.events.EventTarget}\n * @implements {goog.net.XhrLike}\n * @constructor\n * @struct\n */\ngoog.net.FetchXmlHttp = function(worker) {\n  goog.net.FetchXmlHttp.base(this, 'constructor');\n\n  /** @private @final {!WorkerGlobalScope} */\n  this.worker_ = worker;\n\n  /** @private {RequestCredentials|undefined} */\n  this.credentialsMode_ = undefined;\n\n  /** @private {RequestCache|undefined} */\n  this.cacheMode_ = undefined;\n\n  /**\n   * Request state.\n   * @type {goog.net.FetchXmlHttp.RequestState}\n   */\n  this.readyState = goog.net.FetchXmlHttp.RequestState.UNSENT;\n\n  /**\n   * HTTP status.\n   * @type {number}\n   */\n  this.status = 0;\n\n  /**\n   * HTTP status string.\n   * @type {string}\n   */\n  this.statusText = '';\n\n  /**\n   * Content of the response.\n   * @type {string|!ArrayBuffer}\n   */\n  this.response = '';\n\n  /**\n   * Content of the response.\n   * @type {string}\n   */\n  this.responseText = '';\n\n  /**\n   * The type of the response.  If this is set to 'arraybuffer' the request will\n   * be discrete, streaming is only supported for text encoded requests.\n   * @type {string}\n   */\n  this.responseType = '';\n\n  /**\n   * Document response entity body.\n   * NOTE: This is always null and not supported by this class.\n   * @final {null}\n   */\n  this.responseXML = null;\n\n  /**\n   * Method to call when the state changes.\n   * @type {?function()}\n   */\n  this.onreadystatechange = null;\n\n  /** @private {!Headers} */\n  this.requestHeaders_ = new Headers();\n\n  /** @private {?Headers} */\n  this.responseHeaders_ = null;\n\n  /**\n   * Request method (GET or POST).\n   * @private {string}\n   */\n  this.method_ = 'GET';\n\n  /**\n   * Request URL.\n   * @private {string}\n   */\n  this.url_ = '';\n\n  /**\n   * Whether the request is in progress.\n   * @private {boolean}\n   */\n  this.inProgress_ = false;\n\n  /** @private @final {?goog.log.Logger} */\n  this.logger_ = goog.log.getLogger('goog.net.FetchXmlHttp');\n\n  /** @private {?Response} */\n  this.fetchResponse_ = null;\n\n  /** @private {!ReadableStreamDefaultReader|null} */\n  this.currentReader_ = null;\n\n  /** @private {?TextDecoder} */\n  this.textDecoder_ = null;\n};\ngoog.inherits(goog.net.FetchXmlHttp, goog.events.EventTarget);\n\n\n/**\n * State of the requests.\n * @enum {number}\n */\ngoog.net.FetchXmlHttp.RequestState = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADER_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.open = function(method, url, opt_async) {\n  goog.asserts.assert(!!opt_async, 'Only async requests are supported.');\n  if (this.readyState != goog.net.FetchXmlHttp.RequestState.UNSENT) {\n    this.abort();\n    throw new Error('Error reopening a connection');\n  }\n\n  this.method_ = method;\n  this.url_ = url;\n\n  this.readyState = goog.net.FetchXmlHttp.RequestState.OPENED;\n  this.dispatchCallback_();\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.send = function(opt_data) {\n  if (this.readyState != goog.net.FetchXmlHttp.RequestState.OPENED) {\n    this.abort();\n    throw new Error('need to call open() first. ');\n  }\n\n  this.inProgress_ = true;\n  var requestInit = {\n    headers: this.requestHeaders_,\n    method: this.method_,\n    credentials: this.credentialsMode_,\n    cache: this.cacheMode_\n  };\n  if (opt_data) {\n    requestInit['body'] = opt_data;\n  }\n  this.worker_\n      .fetch(new Request(this.url_, /** @type {!RequestInit} */ (requestInit)))\n      .then(\n          this.handleResponse_.bind(this), this.handleSendFailure_.bind(this));\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.abort = function() {\n  this.response = this.responseText = '';\n  this.requestHeaders_ = new Headers();\n  this.status = 0;\n\n  if (!!this.currentReader_) {\n    this.currentReader_.cancel('Request was aborted.');\n  }\n\n  if (((this.readyState >= goog.net.FetchXmlHttp.RequestState.OPENED) &&\n       this.inProgress_) &&\n      (this.readyState != goog.net.FetchXmlHttp.RequestState.DONE)) {\n    this.inProgress_ = false;\n    this.requestDone_(false);\n  }\n\n  this.readyState = goog.net.FetchXmlHttp.RequestState.UNSENT;\n};\n\n\n/**\n * Handles the fetch response.\n * @param {!Response} response\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.handleResponse_ = function(response) {\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n\n  this.fetchResponse_ = response;\n\n  if (!this.responseHeaders_) {\n    this.responseHeaders_ = response.headers;\n    this.readyState = goog.net.FetchXmlHttp.RequestState.HEADER_RECEIVED;\n    this.dispatchCallback_();\n  }\n  // A callback may abort the request.\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n\n  this.readyState = goog.net.FetchXmlHttp.RequestState.LOADING;\n  this.dispatchCallback_();\n  // A callback may abort the request.\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n\n  if (this.responseType === 'arraybuffer') {\n    response.arrayBuffer().then(\n        this.handleResponseArrayBuffer_.bind(this),\n        this.handleSendFailure_.bind(this));\n  } else if (\n      typeof (goog.global.ReadableStream) !== 'undefined' &&\n      'body' in response) {\n    this.response = this.responseText = '';\n    this.currentReader_ =\n        /** @type {!ReadableStreamDefaultReader} */ (response.body.getReader());\n    this.textDecoder_ = new TextDecoder();\n    this.readInputFromFetch_();\n  } else {\n    response.text().then(\n        this.handleResponseText_.bind(this),\n        this.handleSendFailure_.bind(this));\n  }\n};\n\n\n/**\n * Reads the next chunk of data from the fetch response.\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.readInputFromFetch_ = function() {\n  this.currentReader_.read()\n      .then(this.handleDataFromStream_.bind(this))\n      .catch(this.handleSendFailure_.bind(this));\n};\n\n\n/**\n * Handles a chunk of data from the fetch response stream reader.\n * @param {!IteratorResult} result\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.handleDataFromStream_ = function(result) {\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n\n  var dataPacket = result.value ? /** @type {!Uint8Array} */ (result.value) :\n                                  new Uint8Array(0);\n  var newText = this.textDecoder_.decode(dataPacket, {stream: !result.done});\n  if (newText) {\n    this.responseText += newText;\n    this.response = this.responseText;\n  }\n\n  if (result.done) {\n    this.requestDone_(true);\n  } else {\n    this.dispatchCallback_();\n  }\n\n  if (this.readyState == goog.net.FetchXmlHttp.RequestState.LOADING) {\n    this.readInputFromFetch_();\n  }\n};\n\n\n/**\n * Handles the response text.\n * @param {string} responseText\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.handleResponseText_ = function(responseText) {\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n  this.response = this.responseText = responseText;\n  this.requestDone_(true);\n};\n\n\n/**\n * Handles the response text.\n * @param {!ArrayBuffer} responseArrayBuffer\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.handleResponseArrayBuffer_ = function(\n    responseArrayBuffer) {\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n  this.response = responseArrayBuffer;\n  this.requestDone_(true);\n};\n\n\n/**\n * Handles the send failure.\n * @param {*} error\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.handleSendFailure_ = function(error) {\n  var e = error instanceof Error ? error : Error(error);\n  goog.log.warning(this.logger_, 'Failed to fetch url ' + this.url_, e);\n  if (!this.inProgress_) {\n    // The request was aborted, ignore.\n    return;\n  }\n  this.requestDone_(true);\n};\n\n\n/**\n * Sets the request state to DONE and performs cleanup.\n * @param {boolean} setStatus whether to set the status and statusText fields,\n * this is not necessary when the request is aborted.\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.requestDone_ = function(setStatus) {\n  if (setStatus && this.fetchResponse_) {\n    this.status = this.fetchResponse_.status;\n    this.statusText = this.fetchResponse_.statusText;\n  }\n\n  this.readyState = goog.net.FetchXmlHttp.RequestState.DONE;\n\n  this.fetchResponse_ = null;\n  this.currentReader_ = null;\n  this.textDecoder_ = null;\n\n  this.dispatchCallback_();\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.setRequestHeader = function(header, value) {\n  this.requestHeaders_.append(header, value);\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.getResponseHeader = function(header) {\n  // TODO(b/70808323): This method should return null when the headers are not\n  // present or the specified header is missing. The externs need to be fixed.\n  if (!this.responseHeaders_) {\n    goog.log.warning(\n        this.logger_,\n        'Attempting to get response header but no headers have been received ' +\n            'for url: ' + this.url_);\n    return '';\n  }\n  return this.responseHeaders_.get(header.toLowerCase()) || '';\n};\n\n\n/** @override */\ngoog.net.FetchXmlHttp.prototype.getAllResponseHeaders = function() {\n  if (!this.responseHeaders_) {\n    goog.log.warning(\n        this.logger_,\n        'Attempting to get all response headers but no headers have been ' +\n            'received for url: ' + this.url_);\n    return '';\n  }\n  var lines = [];\n  var iter = this.responseHeaders_.entries();\n  var entry = iter.next();\n  while (!entry.done) {\n    var pair = entry.value;\n    lines.push(pair[0] + ': ' + pair[1]);\n    entry = iter.next();\n  }\n  return lines.join('\\r\\n');\n};\n\n\n/**\n * @param {!RequestCredentials} credentialsMode The credentials mode of the\n *     Service Worker fetch.\n */\ngoog.net.FetchXmlHttp.prototype.setCredentialsMode = function(credentialsMode) {\n  this.credentialsMode_ = credentialsMode;\n};\n\n\n/**\n * @param {!RequestCache} cacheMode The cache mode of the Service Worker fetch.\n */\ngoog.net.FetchXmlHttp.prototype.setCacheMode = function(cacheMode) {\n  this.cacheMode_ = cacheMode;\n};\n\n\n/**\n * Dispatches the callback, if the callback attribute is defined.\n * @private\n */\ngoog.net.FetchXmlHttp.prototype.dispatchCallback_ = function() {\n  if (this.onreadystatechange) {\n    this.onreadystatechange.call(this);\n  }\n};\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Wrapper class for handling XmlHttpRequests.\n *\n * One off requests can be sent through goog.net.XhrIo.send() or an\n * instance can be created to send multiple requests.  Each request uses its\n * own XmlHttpRequest object and handles clearing of the event callback to\n * ensure no leaks.\n *\n * XhrIo is event based, it dispatches events on success, failure, finishing,\n * ready-state change, or progress (download and upload).\n *\n * The ready-state or timeout event fires first, followed by\n * a generic completed event. Then the abort, error, or success event\n * is fired as appropriate. Progress events are fired as they are\n * received. Lastly, the ready event will fire to indicate that the\n * object may be used to make another request.\n *\n * The error event may also be called before completed and\n * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.\n *\n * This class does not support multiple requests, queuing, or prioritization.\n *\n * When progress events are supported by the browser, and progress is\n * enabled via .setProgressEventsEnabled(true), the\n * goog.net.EventType.PROGRESS event will be the re-dispatched browser\n * progress event. Additionally, a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event\n * will be fired for download and upload progress respectively.\n *\n */\n\n\ngoog.provide('goog.net.XhrIo');\ngoog.provide('goog.net.XhrIo.ResponseType');\n\ngoog.require('goog.Timer');\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.events.EventTarget');\ngoog.require('goog.json.hybrid');\ngoog.require('goog.log');\ngoog.require('goog.net.ErrorCode');\ngoog.require('goog.net.EventType');\ngoog.require('goog.net.HttpStatus');\ngoog.require('goog.net.XmlHttp');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.structs');\ngoog.require('goog.structs.Map');\ngoog.require('goog.uri.utils');\ngoog.require('goog.userAgent');\n\ngoog.forwardDeclare('goog.Uri');\n\ngoog.scope(function() {\n\n/**\n * Basic class for handling XMLHttpRequests.\n * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when\n *     creating XMLHttpRequest objects.\n * @constructor\n * @extends {goog.events.EventTarget}\n */\ngoog.net.XhrIo = function(opt_xmlHttpFactory) {\n  XhrIo.base(this, 'constructor');\n\n  /**\n   * Map of default headers to add to every request, use:\n   * XhrIo.headers.set(name, value)\n   * @type {!goog.structs.Map}\n   */\n  this.headers = new goog.structs.Map();\n\n  /**\n   * Optional XmlHttpFactory\n   * @private {goog.net.XmlHttpFactory}\n   */\n  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;\n\n  /**\n   * Whether XMLHttpRequest is active.  A request is active from the time send()\n   * is called until onReadyStateChange() is complete, or error() or abort()\n   * is called.\n   * @private {boolean}\n   */\n  this.active_ = false;\n\n  /**\n   * The XMLHttpRequest object that is being used for the transfer.\n   * @private {?goog.net.XhrLike.OrNative}\n   */\n  this.xhr_ = null;\n\n  /**\n   * The options to use with the current XMLHttpRequest object.\n   * @private {?Object}\n   */\n  this.xhrOptions_ = null;\n\n  /**\n   * Last URL that was requested.\n   * @private {string|goog.Uri}\n   */\n  this.lastUri_ = '';\n\n  /**\n   * Method for the last request.\n   * @private {string}\n   */\n  this.lastMethod_ = '';\n\n  /**\n   * Last error code.\n   * @private {!goog.net.ErrorCode}\n   */\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n\n  /**\n   * Last error message.\n   * @private {Error|string}\n   */\n  this.lastError_ = '';\n\n  /**\n   * Used to ensure that we don't dispatch an multiple ERROR events. This can\n   * happen in IE when it does a synchronous load and one error is handled in\n   * the ready statte change and one is handled due to send() throwing an\n   * exception.\n   * @private {boolean}\n   */\n  this.errorDispatched_ = false;\n\n  /**\n   * Used to make sure we don't fire the complete event from inside a send call.\n   * @private {boolean}\n   */\n  this.inSend_ = false;\n\n  /**\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\n   * within a call to this.xhr_.open.\n   * @private {boolean}\n   */\n  this.inOpen_ = false;\n\n  /**\n   * Used in determining if a call to {@link #onReadyStateChange_} is from\n   * within a call to this.xhr_.abort.\n   * @private {boolean}\n   */\n  this.inAbort_ = false;\n\n  /**\n   * Number of milliseconds after which an incomplete request will be aborted\n   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout\n   * is set.\n   * @private {number}\n   */\n  this.timeoutInterval_ = 0;\n\n  /**\n   * Timer to track request timeout.\n   * @private {?number}\n   */\n  this.timeoutId_ = null;\n\n  /**\n   * The requested type for the response. The empty string means use the default\n   * XHR behavior.\n   * @private {goog.net.XhrIo.ResponseType}\n   */\n  this.responseType_ = ResponseType.DEFAULT;\n\n  /**\n   * Whether a \"credentialed\" request is to be sent (one that is aware of\n   * cookies and authentication). This is applicable only for cross-domain\n   * requests and more recent browsers that support this part of the HTTP Access\n   * Control standard.\n   *\n   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute\n   *\n   * @private {boolean}\n   */\n  this.withCredentials_ = false;\n\n  /**\n   * Whether progress events are enabled for this request. This is\n   * disabled by default because setting a progress event handler\n   * causes pre-flight OPTIONS requests to be sent for CORS requests,\n   * even in cases where a pre-flight request would not otherwise be\n   * sent.\n   *\n   * @see http://xhr.spec.whatwg.org/#security-considerations\n   *\n   * Note that this can cause problems for Firefox 22 and below, as an\n   * older \"LSProgressEvent\" will be dispatched by the browser. That\n   * progress event is no longer supported, and can lead to failures,\n   * including throwing exceptions.\n   *\n   * @see http://bugzilla.mozilla.org/show_bug.cgi?id=845631\n   * @see b/23469793\n   *\n   * @private {boolean}\n   */\n  this.progressEventsEnabled_ = false;\n\n  /**\n   * True if we can use XMLHttpRequest's timeout directly.\n   * @private {boolean}\n   */\n  this.useXhr2Timeout_ = false;\n};\ngoog.inherits(goog.net.XhrIo, goog.events.EventTarget);\n\nvar XhrIo = goog.net.XhrIo;\n\n/**\n * Response types that may be requested for XMLHttpRequests.\n * @enum {string}\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute\n */\ngoog.net.XhrIo.ResponseType = {\n  DEFAULT: '',\n  TEXT: 'text',\n  DOCUMENT: 'document',\n  // Not supported as of Chrome 10.0.612.1 dev\n  BLOB: 'blob',\n  ARRAY_BUFFER: 'arraybuffer'\n};\n\nvar ResponseType = goog.net.XhrIo.ResponseType;\n\n\n/**\n * A reference to the XhrIo logger\n * @private {?goog.log.Logger}\n * @const\n */\ngoog.net.XhrIo.prototype.logger_ = goog.log.getLogger('goog.net.XhrIo');\n\n\n/**\n * The Content-Type HTTP header name\n * @type {string}\n */\ngoog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';\n\n\n/**\n * The Content-Transfer-Encoding HTTP header name\n * @type {string}\n */\ngoog.net.XhrIo.CONTENT_TRANSFER_ENCODING = 'Content-Transfer-Encoding';\n\n\n/**\n * The pattern matching the 'http' and 'https' URI schemes\n * @type {!RegExp}\n */\ngoog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;\n\n\n/**\n * The methods that typically come along with form data.  We set different\n * headers depending on whether the HTTP action is one of these.\n * @type {!Array<string>}\n */\ngoog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];\n\n\n/**\n * The Content-Type HTTP header value for a url-encoded form\n * @type {string}\n */\ngoog.net.XhrIo.FORM_CONTENT_TYPE =\n    'application/x-www-form-urlencoded;charset=utf-8';\n\n\n/**\n * The XMLHttpRequest Level two timeout delay ms property name.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n *\n * @private {string}\n * @const\n */\ngoog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';\n\n\n/**\n * The XMLHttpRequest Level two ontimeout handler property name.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n *\n * @private {string}\n * @const\n */\ngoog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';\n\n\n/**\n * All non-disposed instances of goog.net.XhrIo created\n * by {@link goog.net.XhrIo.send} are in this Array.\n * @see goog.net.XhrIo.cleanup\n * @private {!Array<!goog.net.XhrIo>}\n */\ngoog.net.XhrIo.sendInstances_ = [];\n\n\n/**\n * Static send that creates a short lived instance of XhrIo to send the\n * request.\n * @see goog.net.XhrIo.cleanup\n * @param {string|goog.Uri} url Uri to make request to.\n * @param {?function(this:goog.net.XhrIo, ?)=} opt_callback Callback function\n *     for when request is complete.\n * @param {string=} opt_method Send method, default: GET.\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\n *     opt_content Body data.\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\n *     request.\n * @param {number=} opt_timeoutInterval Number of milliseconds after which an\n *     incomplete request will be aborted; 0 means no timeout is set.\n * @param {boolean=} opt_withCredentials Whether to send credentials with the\n *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.\n * @return {!goog.net.XhrIo} The sent XhrIo.\n */\ngoog.net.XhrIo.send = function(\n    url, opt_callback, opt_method, opt_content, opt_headers,\n    opt_timeoutInterval, opt_withCredentials) {\n  var x = new goog.net.XhrIo();\n  goog.net.XhrIo.sendInstances_.push(x);\n  if (opt_callback) {\n    x.listen(goog.net.EventType.COMPLETE, opt_callback);\n  }\n  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);\n  if (opt_timeoutInterval) {\n    x.setTimeoutInterval(opt_timeoutInterval);\n  }\n  if (opt_withCredentials) {\n    x.setWithCredentials(opt_withCredentials);\n  }\n  x.send(url, opt_method, opt_content, opt_headers);\n  return x;\n};\n\n\n/**\n * Disposes all non-disposed instances of goog.net.XhrIo created by\n * {@link goog.net.XhrIo.send}.\n * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance\n * it creates when the request completes or fails.  However, if\n * the request never completes, then the goog.net.XhrIo is not disposed.\n * This can occur if the window is unloaded before the request completes.\n * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo\n * it creates and make the client of {@link goog.net.XhrIo.send} be\n * responsible for disposing it in this case.  However, this makes things\n * significantly more complicated for the client, and the whole point\n * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.\n * Clients of {@link goog.net.XhrIo.send} should call\n * {@link goog.net.XhrIo.cleanup} when doing final\n * cleanup on window unload.\n */\ngoog.net.XhrIo.cleanup = function() {\n  var instances = goog.net.XhrIo.sendInstances_;\n  while (instances.length) {\n    instances.pop().dispose();\n  }\n};\n\n\n/**\n * Installs exception protection for all entry point introduced by\n * goog.net.XhrIo instances which are not protected by\n * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},\n * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or\n * {@link goog.events.protectBrowserEventEntryPoint}.\n *\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\n *     protect the entry point(s).\n */\ngoog.net.XhrIo.protectEntryPoints = function(errorHandler) {\n  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\n      errorHandler.protectEntryPoint(\n          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n};\n\n\n/**\n * Disposes of the specified goog.net.XhrIo created by\n * {@link goog.net.XhrIo.send} and removes it from\n * {@link goog.net.XhrIo.pendingStaticSendInstances_}.\n * @private\n */\ngoog.net.XhrIo.prototype.cleanupSend_ = function() {\n  this.dispose();\n  goog.array.remove(goog.net.XhrIo.sendInstances_, this);\n};\n\n\n/**\n * Returns the number of milliseconds after which an incomplete request will be\n * aborted, or 0 if no timeout is set.\n * @return {number} Timeout interval in milliseconds.\n */\ngoog.net.XhrIo.prototype.getTimeoutInterval = function() {\n  return this.timeoutInterval_;\n};\n\n\n/**\n * Sets the number of milliseconds after which an incomplete request will be\n * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no\n * timeout is set.\n * @param {number} ms Timeout interval in milliseconds; 0 means none.\n */\ngoog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {\n  this.timeoutInterval_ = Math.max(0, ms);\n};\n\n\n/**\n * Sets the desired type for the response. At time of writing, this is only\n * supported in very recent versions of WebKit (10.0.612.1 dev and later).\n *\n * If this is used, the response may only be accessed via {@link #getResponse}.\n *\n * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.\n */\ngoog.net.XhrIo.prototype.setResponseType = function(type) {\n  this.responseType_ = type;\n};\n\n\n/**\n * Gets the desired type for the response.\n * @return {goog.net.XhrIo.ResponseType} The desired type for the response.\n */\ngoog.net.XhrIo.prototype.getResponseType = function() {\n  return this.responseType_;\n};\n\n\n/**\n * Sets whether a \"credentialed\" request that is aware of cookie and\n * authentication information should be made. This option is only supported by\n * browsers that support HTTP Access Control. As of this writing, this option\n * is not supported in IE.\n *\n * @param {boolean} withCredentials Whether this should be a \"credentialed\"\n *     request.\n */\ngoog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {\n  this.withCredentials_ = withCredentials;\n};\n\n\n/**\n * Gets whether a \"credentialed\" request is to be sent.\n * @return {boolean} The desired type for the response.\n */\ngoog.net.XhrIo.prototype.getWithCredentials = function() {\n  return this.withCredentials_;\n};\n\n\n/**\n * Sets whether progress events are enabled for this request. Note\n * that progress events require pre-flight OPTIONS request handling\n * for CORS requests, and may cause trouble with older browsers. See\n * progressEventsEnabled_ for details.\n * @param {boolean} enabled Whether progress events should be enabled.\n */\ngoog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {\n  this.progressEventsEnabled_ = enabled;\n};\n\n\n/**\n * Gets whether progress events are enabled.\n * @return {boolean} Whether progress events are enabled for this request.\n */\ngoog.net.XhrIo.prototype.getProgressEventsEnabled = function() {\n  return this.progressEventsEnabled_;\n};\n\n\n/**\n * Instance send that actually uses XMLHttpRequest to make a server call.\n * @param {string|goog.Uri} url Uri to make request to.\n * @param {string=} opt_method Send method, default: GET.\n * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}\n *     opt_content Body data.\n * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the\n *     request.\n * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different\n * types of parameters for opt_headers.\n */\ngoog.net.XhrIo.prototype.send = function(\n    url, opt_method, opt_content, opt_headers) {\n  if (this.xhr_) {\n    throw new Error(\n        '[goog.net.XhrIo] Object is active with another request=' +\n        this.lastUri_ + '; newUri=' + url);\n  }\n\n  var method = opt_method ? opt_method.toUpperCase() : 'GET';\n\n  this.lastUri_ = url;\n  this.lastError_ = '';\n  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;\n  this.lastMethod_ = method;\n  this.errorDispatched_ = false;\n  this.active_ = true;\n\n  // Use the factory to create the XHR object and options\n  this.xhr_ = this.createXhr();\n  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() :\n                                            goog.net.XmlHttp.getOptions();\n\n  // Set up the onreadystatechange callback\n  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);\n\n  // Set up upload/download progress events, if progress events are supported.\n  if (this.getProgressEventsEnabled() && 'onprogress' in this.xhr_) {\n    this.xhr_.onprogress =\n        goog.bind(function(e) { this.onProgressHandler_(e, true); }, this);\n    if (this.xhr_.upload) {\n      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);\n    }\n  }\n\n  /**\n   * Try to open the XMLHttpRequest (always async), if an error occurs here it\n   * is generally permission denied\n   */\n  try {\n    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));\n    this.inOpen_ = true;\n    this.xhr_.open(method, String(url), true);  // Always async!\n    this.inOpen_ = false;\n  } catch (err) {\n    goog.log.fine(\n        this.logger_, this.formatMsg_('Error opening Xhr: ' + err.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\n    return;\n  }\n\n  // We can't use null since this won't allow requests with form data to have a\n  // content length specified which will cause some proxies to return a 411\n  // error.\n  var content = opt_content || '';\n\n  var headers = this.headers.clone();\n\n  // Add headers specific to this request\n  if (opt_headers) {\n    goog.structs.forEach(\n        opt_headers, function(value, key) { headers.set(key, value); });\n  }\n\n  // Find whether a content type header is set, ignoring case.\n  // HTTP header names are case-insensitive.  See:\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n  var contentTypeKey =\n      goog.array.find(headers.getKeys(), goog.net.XhrIo.isContentTypeHeader_);\n\n  var contentIsFormData =\n      (goog.global['FormData'] && (content instanceof goog.global['FormData']));\n  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&\n      !contentTypeKey && !contentIsFormData) {\n    // For requests typically with form data, default to the url-encoded form\n    // content type unless this is a FormData request.  For FormData,\n    // the browser will automatically add a multipart/form-data content type\n    // with an appropriate multipart boundary.\n    headers.set(\n        goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);\n  }\n\n  // Add the headers to the Xhr object\n  headers.forEach(function(value, key) {\n    this.xhr_.setRequestHeader(key, value);\n  }, this);\n\n  if (this.responseType_) {\n    this.xhr_.responseType = this.responseType_;\n  }\n  // Set xhr_.withCredentials only when the value is different, or else in\n  // synchronous XMLHtppRequest.open Firefox will throw an exception.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=736340\n  if ('withCredentials' in this.xhr_ &&\n      this.xhr_.withCredentials !== this.withCredentials_) {\n    this.xhr_.withCredentials = this.withCredentials_;\n  }\n\n  /**\n   * Try to send the request, or other wise report an error (404 not found).\n   */\n  try {\n    this.cleanUpTimeoutTimer_();  // Paranoid, should never be running.\n    if (this.timeoutInterval_ > 0) {\n      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);\n      goog.log.fine(\n          this.logger_, this.formatMsg_(\n                            'Will abort after ' + this.timeoutInterval_ +\n                            'ms if incomplete, xhr2 ' + this.useXhr2Timeout_));\n      if (this.useXhr2Timeout_) {\n        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;\n        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =\n            goog.bind(this.timeout_, this);\n      } else {\n        this.timeoutId_ =\n            goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);\n      }\n    }\n    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));\n    this.inSend_ = true;\n    this.xhr_.send(content);\n    this.inSend_ = false;\n\n  } catch (err) {\n    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));\n    this.error_(goog.net.ErrorCode.EXCEPTION, err);\n  }\n};\n\n\n/**\n * Determines if the argument is an XMLHttpRequest that supports the level 2\n * timeout value and event.\n *\n * Currently, FF 21.0 OS X has the fields but won't actually call the timeout\n * handler.  Perhaps the confusion in the bug referenced below hasn't\n * entirely been resolved.\n *\n * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816\n *\n * @param {!goog.net.XhrLike.OrNative} xhr The request.\n * @return {boolean} True if the request supports level 2 timeout.\n * @private\n */\ngoog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {\n  return goog.userAgent.IE && goog.userAgent.isVersionOrHigher(9) &&\n      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &&\n      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);\n};\n\n\n/**\n * @param {string} header An HTTP header key.\n * @return {boolean} Whether the key is a content type header (ignoring\n *     case.\n * @private\n */\ngoog.net.XhrIo.isContentTypeHeader_ = function(header) {\n  return goog.string.caseInsensitiveEquals(\n      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);\n};\n\n\n/**\n * Creates a new XHR object.\n * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.\n * @protected\n */\ngoog.net.XhrIo.prototype.createXhr = function() {\n  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() :\n                                goog.net.XmlHttp();\n};\n\n\n/**\n * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}\n * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts\n * the request.\n * @private\n */\ngoog.net.XhrIo.prototype.timeout_ = function() {\n  if (typeof goog == 'undefined') {\n    // If goog is undefined then the callback has occurred as the application\n    // is unloading and will error.  Thus we let it silently fail.\n  } else if (this.xhr_) {\n    this.lastError_ =\n        'Timed out after ' + this.timeoutInterval_ + 'ms, aborting';\n    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;\n    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));\n    this.dispatchEvent(goog.net.EventType.TIMEOUT);\n    this.abort(goog.net.ErrorCode.TIMEOUT);\n  }\n};\n\n\n/**\n * Something errorred, so inactivate, fire error callback and clean up\n * @param {goog.net.ErrorCode} errorCode The error code.\n * @param {Error} err The error object.\n * @private\n */\ngoog.net.XhrIo.prototype.error_ = function(errorCode, err) {\n  this.active_ = false;\n  if (this.xhr_) {\n    this.inAbort_ = true;\n    this.xhr_.abort();  // Ensures XHR isn't hung (FF)\n    this.inAbort_ = false;\n  }\n  this.lastError_ = err;\n  this.lastErrorCode_ = errorCode;\n  this.dispatchErrors_();\n  this.cleanUpXhr_();\n};\n\n\n/**\n * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do\n * not dispatch multiple error events.\n * @private\n */\ngoog.net.XhrIo.prototype.dispatchErrors_ = function() {\n  if (!this.errorDispatched_) {\n    this.errorDispatched_ = true;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ERROR);\n  }\n};\n\n\n/**\n * Abort the current XMLHttpRequest\n * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -\n *     defaults to ABORT.\n */\ngoog.net.XhrIo.prototype.abort = function(opt_failureCode) {\n  if (this.xhr_ && this.active_) {\n    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));\n    this.active_ = false;\n    this.inAbort_ = true;\n    this.xhr_.abort();\n    this.inAbort_ = false;\n    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;\n    this.dispatchEvent(goog.net.EventType.COMPLETE);\n    this.dispatchEvent(goog.net.EventType.ABORT);\n    this.cleanUpXhr_();\n  }\n};\n\n\n/**\n * Nullifies all callbacks to reduce risks of leaks.\n * @override\n * @protected\n */\ngoog.net.XhrIo.prototype.disposeInternal = function() {\n  if (this.xhr_) {\n    // We explicitly do not call xhr_.abort() unless active_ is still true.\n    // This is to avoid unnecessarily aborting a successful request when\n    // dispose() is called in a callback triggered by a complete response, but\n    // in which browser cleanup has not yet finished.\n    // (See http://b/issue?id=1684217.)\n    if (this.active_) {\n      this.active_ = false;\n      this.inAbort_ = true;\n      this.xhr_.abort();\n      this.inAbort_ = false;\n    }\n    this.cleanUpXhr_(true);\n  }\n\n  XhrIo.base(this, 'disposeInternal');\n};\n\n\n/**\n * Internal handler for the XHR object's readystatechange event.  This method\n * checks the status and the readystate and fires the correct callbacks.\n * If the request has ended, the handlers are cleaned up and the XHR object is\n * nullified.\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChange_ = function() {\n  if (this.isDisposed()) {\n    // This method is the target of an untracked goog.Timer.callOnce().\n    return;\n  }\n  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {\n    // Were not being called from within a call to this.xhr_.send\n    // this.xhr_.abort, or this.xhr_.open, so this is an entry point\n    this.onReadyStateChangeEntryPoint_();\n  } else {\n    this.onReadyStateChangeHelper_();\n  }\n};\n\n\n/**\n * Used to protect the onreadystatechange handler entry point.  Necessary\n * as {#onReadyStateChange_} maybe called from within send or abort, this\n * method is only called when {#onReadyStateChange_} is called as an\n * entry point.\n * {@see #protectEntryPoints}\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {\n  this.onReadyStateChangeHelper_();\n};\n\n\n/**\n * Helper for {@link #onReadyStateChange_}.  This is used so that\n * entry point calls to {@link #onReadyStateChange_} can be routed through\n * {@link #onReadyStateChangeEntryPoint_}.\n * @private\n */\ngoog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {\n  if (!this.active_) {\n    // can get called inside abort call\n    return;\n  }\n\n  if (typeof goog == 'undefined') {\n    // NOTE(user): If goog is undefined then the callback has occurred as the\n    // application is unloading and will error.  Thus we let it silently fail.\n\n  } else if (\n      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&\n      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&\n      this.getStatus() == 2) {\n    // NOTE(user): In IE if send() errors on a *local* request the readystate\n    // is still changed to COMPLETE.  We need to ignore it and allow the\n    // try/catch around send() to pick up the error.\n    goog.log.fine(\n        this.logger_,\n        this.formatMsg_('Local request error detected and ignored'));\n\n  } else {\n    // In IE when the response has been cached we sometimes get the callback\n    // from inside the send call and this usually breaks code that assumes that\n    // XhrIo is asynchronous.  If that is the case we delay the callback\n    // using a timer.\n    if (this.inSend_ &&\n        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {\n      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);\n      return;\n    }\n\n    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);\n\n    // readyState indicates the transfer has finished\n    if (this.isComplete()) {\n      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));\n\n      this.active_ = false;\n\n      try {\n        // Call the specific callbacks for success or failure. Only call the\n        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)\n        if (this.isSuccess()) {\n          this.dispatchEvent(goog.net.EventType.COMPLETE);\n          this.dispatchEvent(goog.net.EventType.SUCCESS);\n        } else {\n          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;\n          this.lastError_ =\n              this.getStatusText() + ' [' + this.getStatus() + ']';\n          this.dispatchErrors_();\n        }\n      } finally {\n        this.cleanUpXhr_();\n      }\n    }\n  }\n};\n\n\n/**\n * Internal handler for the XHR object's onprogress event. Fires both a generic\n * PROGRESS event and either a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event to\n * allow specific binding for each XHR progress event.\n * @param {!ProgressEvent} e XHR progress event.\n * @param {boolean=} opt_isDownload Whether the current progress event is from a\n *     download. Used to determine whether DOWNLOAD_PROGRESS or UPLOAD_PROGRESS\n *     event should be dispatched.\n * @private\n */\ngoog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {\n  goog.asserts.assert(\n      e.type === goog.net.EventType.PROGRESS,\n      'goog.net.EventType.PROGRESS is of the same type as raw XHR progress.');\n  this.dispatchEvent(\n      goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));\n  this.dispatchEvent(\n      goog.net.XhrIo.buildProgressEvent_(\n          e, opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS :\n                              goog.net.EventType.UPLOAD_PROGRESS));\n};\n\n\n/**\n * Creates a representation of the native ProgressEvent. IE doesn't support\n * constructing ProgressEvent via \"new\", and the alternatives (e.g.,\n * ProgressEvent.initProgressEvent) are non-standard or deprecated.\n * @param {!ProgressEvent} e XHR progress event.\n * @param {!goog.net.EventType} eventType The type of the event.\n * @return {!ProgressEvent} The progress event.\n * @private\n */\ngoog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {\n  return /** @type {!ProgressEvent} */ ({\n    type: eventType,\n    lengthComputable: e.lengthComputable,\n    loaded: e.loaded,\n    total: e.total\n  });\n};\n\n\n/**\n * Remove the listener to protect against leaks, and nullify the XMLHttpRequest\n * object.\n * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to\n *     fire any events).\n * @private\n */\ngoog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {\n  if (this.xhr_) {\n    // Cancel any pending timeout event handler.\n    this.cleanUpTimeoutTimer_();\n\n    // Save reference so we can mark it as closed after the READY event.  The\n    // READY event may trigger another request, thus we must nullify this.xhr_\n    var xhr = this.xhr_;\n    var clearedOnReadyStateChange =\n        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?\n        goog.nullFunction :\n        null;\n    this.xhr_ = null;\n    this.xhrOptions_ = null;\n\n    if (!opt_fromDispose) {\n      this.dispatchEvent(goog.net.EventType.READY);\n    }\n\n    try {\n      // NOTE(user): Not nullifying in FireFox can still leak if the callbacks\n      // are defined in the same scope as the instance of XhrIo. But, IE doesn't\n      // allow you to set the onreadystatechange to NULL so nullFunction is\n      // used.\n      xhr.onreadystatechange = clearedOnReadyStateChange;\n    } catch (e) {\n      // This seems to occur with a Gears HTTP request. Delayed the setting of\n      // this onreadystatechange until after READY is sent out and catching the\n      // error to see if we can track down the problem.\n      goog.log.error(\n          this.logger_,\n          'Problem encountered resetting onreadystatechange: ' + e.message);\n    }\n  }\n};\n\n\n/**\n * Make sure the timeout timer isn't running.\n * @private\n */\ngoog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {\n  if (this.xhr_ && this.useXhr2Timeout_) {\n    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;\n  }\n  if (this.timeoutId_) {\n    goog.Timer.clear(this.timeoutId_);\n    this.timeoutId_ = null;\n  }\n};\n\n\n/**\n * @return {boolean} Whether there is an active request.\n */\ngoog.net.XhrIo.prototype.isActive = function() {\n  return !!this.xhr_;\n};\n\n\n/**\n * @return {boolean} Whether the request has completed.\n */\ngoog.net.XhrIo.prototype.isComplete = function() {\n  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;\n};\n\n\n/**\n * @return {boolean} Whether the request completed with a success.\n */\ngoog.net.XhrIo.prototype.isSuccess = function() {\n  var status = this.getStatus();\n  // A zero status code is considered successful for local files.\n  return goog.net.HttpStatus.isSuccess(status) ||\n      status === 0 && !this.isLastUriEffectiveSchemeHttp_();\n};\n\n\n/**\n * @return {boolean} whether the effective scheme of the last URI that was\n *     fetched was 'http' or 'https'.\n * @private\n */\ngoog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {\n  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));\n  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);\n};\n\n\n/**\n * Get the readystate from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.\n */\ngoog.net.XhrIo.prototype.getReadyState = function() {\n  return this.xhr_ ?\n      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :\n                                                 goog.net.XmlHttp.ReadyState\n                                                     .UNINITIALIZED;\n};\n\n\n/**\n * Get the status from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {number} Http status.\n */\ngoog.net.XhrIo.prototype.getStatus = function() {\n  /**\n   * IE doesn't like you checking status until the readystate is greater than 2\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\n   */\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\n        this.xhr_.status :\n        -1;\n  } catch (e) {\n    return -1;\n  }\n};\n\n\n/**\n * Get the status text from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @return {string} Status text.\n */\ngoog.net.XhrIo.prototype.getStatusText = function() {\n  /**\n   * IE doesn't like you checking status until the readystate is greater than 2\n   * (i.e. it is receiving or complete).  The try/catch is used for when the\n   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.\n   */\n  try {\n    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?\n        this.xhr_.statusText :\n        '';\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);\n    return '';\n  }\n};\n\n\n/**\n * Get the last Uri that was requested\n * @return {string} Last Uri.\n */\ngoog.net.XhrIo.prototype.getLastUri = function() {\n  return String(this.lastUri_);\n};\n\n\n/**\n * Get the response text from the Xhr object\n * Will only return correct result when called from the context of a callback.\n * @return {string} Result from the server, or '' if no result available.\n */\ngoog.net.XhrIo.prototype.getResponseText = function() {\n  try {\n    return this.xhr_ ? this.xhr_.responseText : '';\n  } catch (e) {\n    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute\n    // states that responseText should return '' (and responseXML null)\n    // when the state is not LOADING or DONE. Instead, IE can\n    // throw unexpected exceptions, for example when a request is aborted\n    // or no data is available yet.\n    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);\n    return '';\n  }\n};\n\n\n/**\n * Get the response body from the Xhr object. This property is only available\n * in IE since version 7 according to MSDN:\n * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx\n * Will only return correct result when called from the context of a callback.\n *\n * One option is to construct a VBArray from the returned object and convert\n * it to a JavaScript array using the toArray method:\n * `(new window['VBArray'](xhrIo.getResponseBody())).toArray()`\n * This will result in an array of numbers in the range of [0..255]\n *\n * Another option is to use the VBScript CStr method to convert it into a\n * string as outlined in http://stackoverflow.com/questions/1919972\n *\n * @return {Object} Binary result from the server or null if not available.\n */\ngoog.net.XhrIo.prototype.getResponseBody = function() {\n  try {\n    if (this.xhr_ && 'responseBody' in this.xhr_) {\n      return this.xhr_['responseBody'];\n    }\n  } catch (e) {\n    // IE can throw unexpected exceptions, for example when a request is aborted\n    // or no data is yet available.\n    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);\n  }\n  return null;\n};\n\n\n/**\n * Get the response XML from the Xhr object\n * Will only return correct result when called from the context of a callback.\n * @return {Document} The DOM Document representing the XML file, or null\n * if no result available.\n */\ngoog.net.XhrIo.prototype.getResponseXml = function() {\n  try {\n    return this.xhr_ ? this.xhr_.responseXML : null;\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);\n    return null;\n  }\n};\n\n\n/**\n * Get the response and evaluates it as JSON from the Xhr object\n * Will only return correct result when called from the context of a callback\n * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for\n *     stripping of the response before parsing. This needs to be set only if\n *     your backend server prepends the same prefix string to the JSON response.\n * @throws Error if the response text is invalid JSON.\n * @return {Object|undefined} JavaScript object.\n */\ngoog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {\n  if (!this.xhr_) {\n    return undefined;\n  }\n\n  var responseText = this.xhr_.responseText;\n  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {\n    responseText = responseText.substring(opt_xssiPrefix.length);\n  }\n\n  return goog.json.hybrid.parse(responseText);\n};\n\n\n/**\n * Get the response as the type specificed by {@link #setResponseType}. At time\n * of writing, this is only directly supported in very recent versions of WebKit\n * (10.0.612.1 dev and later). If the field is not supported directly, we will\n * try to emulate it.\n *\n * Emulating the response means following the rules laid out at\n * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute\n *\n * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only\n * response types of DEFAULT or TEXT may be used, and the response returned will\n * be the text response.\n *\n * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),\n * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the\n * response returned will be either the text response or the Mozilla\n * implementation of the array buffer response.\n *\n * On browsers will full support, any valid response type supported by the\n * browser may be used, and the response provided by the browser will be\n * returned.\n *\n * @return {*} The response.\n */\ngoog.net.XhrIo.prototype.getResponse = function() {\n  try {\n    if (!this.xhr_) {\n      return null;\n    }\n    if ('response' in this.xhr_) {\n      return this.xhr_.response;\n    }\n    switch (this.responseType_) {\n      case ResponseType.DEFAULT:\n      case ResponseType.TEXT:\n        return this.xhr_.responseText;\n      // DOCUMENT and BLOB don't need to be handled here because they are\n      // introduced in the same spec that adds the .response field, and would\n      // have been caught above.\n      // ARRAY_BUFFER needs an implementation for Firefox 4, where it was\n      // implemented using a draft spec rather than the final spec.\n      case ResponseType.ARRAY_BUFFER:\n        if ('mozResponseArrayBuffer' in this.xhr_) {\n          return this.xhr_.mozResponseArrayBuffer;\n        }\n    }\n    // Fell through to a response type that is not supported on this browser.\n    goog.log.error(\n        this.logger_, 'Response type ' + this.responseType_ + ' is not ' +\n            'supported on this browser');\n    return null;\n  } catch (e) {\n    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);\n    return null;\n  }\n};\n\n\n/**\n * Get the value of the response-header with the given name from the Xhr object\n * Will only return correct result when called from the context of a callback\n * and the request has completed\n * @param {string} key The name of the response-header to retrieve.\n * @return {string|undefined} The value of the response-header named key.\n */\ngoog.net.XhrIo.prototype.getResponseHeader = function(key) {\n  if (!this.xhr_ || !this.isComplete()) {\n    return undefined;\n  }\n\n  var value = this.xhr_.getResponseHeader(key);\n  return goog.isNull(value) ? undefined : value;\n};\n\n\n/**\n * Gets the text of all the headers in the response.\n * Will only return correct result when called from the context of a callback\n * and the request has completed.\n * @return {string} The value of the response headers or empty string.\n */\ngoog.net.XhrIo.prototype.getAllResponseHeaders = function() {\n  // getAllResponseHeaders can return null if no response has been received,\n  // ensure we always return an empty string.\n  return this.xhr_ && this.isComplete() ?\n      (this.xhr_.getAllResponseHeaders() || '') :\n      '';\n};\n\n\n/**\n * Returns all response headers as a key-value map.\n * Multiple values for the same header key can be combined into one,\n * separated by a comma and a space.\n * Note that the native getResponseHeader method for retrieving a single header\n * does a case insensitive match on the header name. This method does not\n * include any case normalization logic, it will just return a key-value\n * representation of the headers.\n * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n * @return {!Object<string, string>} An object with the header keys as keys\n *     and header values as values.\n */\ngoog.net.XhrIo.prototype.getResponseHeaders = function() {\n  // TODO(b/120371595): Make this function parse headers as per the spec\n  // (https://tools.ietf.org/html/rfc2616#section-4.2).\n\n  var headersObject = {};\n  var headersArray = this.getAllResponseHeaders().split('\\r\\n');\n  for (var i = 0; i < headersArray.length; i++) {\n    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {\n      continue;\n    }\n    var keyValue =\n        goog.string.splitLimit(headersArray[i], ':', /* maxSplitCount= */ 1);\n    var key = keyValue[0];\n    var value = keyValue[1];\n\n    if (!goog.isString(value)) {\n      // There must be a value but it can be the empty string.\n      continue;\n    }\n\n    // Whitespace at the start and end of the value is meaningless.\n    value = value.trim();\n    // The key should not contain whitespace but we currently ignore that.\n\n    var values = headersObject[key] || [];\n    headersObject[key] = values;\n    values.push(value);\n  }\n\n  return goog.object.map(headersObject, function(values) {\n    return values.join(', ');\n  });\n};\n\n\n/**\n * Get the value of the response-header with the given name from the Xhr object.\n * As opposed to {@link #getResponseHeader}, this method does not require that\n * the request has completed.\n * @param {string} key The name of the response-header to retrieve.\n * @return {?string} The value of the response-header, or null if it is\n *     unavailable.\n */\ngoog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {\n  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;\n};\n\n\n/**\n * Gets the text of all the headers in the response. As opposed to\n * {@link #getAllResponseHeaders}, this method does not require that the request\n * has completed.\n * @return {string} The value of the response headers or empty string.\n */\ngoog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {\n  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : '';\n};\n\n\n/**\n * Get the last error message\n * @return {!goog.net.ErrorCode} Last error code.\n */\ngoog.net.XhrIo.prototype.getLastErrorCode = function() {\n  return this.lastErrorCode_;\n};\n\n\n/**\n * Get the last error message\n * @return {string} Last error message.\n */\ngoog.net.XhrIo.prototype.getLastError = function() {\n  return goog.isString(this.lastError_) ? this.lastError_ :\n                                          String(this.lastError_);\n};\n\n\n/**\n * Adds the last method, status and URI to the message.  This is used to add\n * this information to the logging calls.\n * @param {string} msg The message text that we want to add the extra text to.\n * @return {string} The message with the extra text appended.\n * @private\n */\ngoog.net.XhrIo.prototype.formatMsg_ = function(msg) {\n  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +\n      this.getStatus() + ']';\n};\n\n\n// Register the xhr handler as an entry point, so that\n// it can be monitored for exception handling, etc.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) {\n      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =\n          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);\n    });\n});  // goog.scope\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Common events for the network classes.\n */\n\n\ngoog.provide('goog.net.EventType');\n\n\n/**\n * Event names for network events\n * @enum {string}\n */\ngoog.net.EventType = {\n  COMPLETE: 'complete',\n  SUCCESS: 'success',\n  ERROR: 'error',\n  ABORT: 'abort',\n  READY: 'ready',\n  READY_STATE_CHANGE: 'readystatechange',\n  TIMEOUT: 'timeout',\n  INCREMENTAL_DATA: 'incrementaldata',\n  PROGRESS: 'progress',\n  // DOWNLOAD_PROGRESS and UPLOAD_PROGRESS are special events dispatched by\n  // goog.net.XhrIo to allow binding listeners specific to each type of\n  // progress.\n  DOWNLOAD_PROGRESS: 'downloadprogress',\n  UPLOAD_PROGRESS: 'uploadprogress'\n};\n","// Copyright 2007 Bob Ippolito. All Rights Reserved.\n// Modifications Copyright 2009 The Closure Library Authors. All Rights\n// Reserved.\n\n/**\n * @license Portions of this code are from MochiKit, received by\n * The Closure Authors under the MIT license. All other code is Copyright\n * 2005-2009 The Closure Authors. All Rights Reserved.\n */\n\n/**\n * @fileoverview Classes for tracking asynchronous operations and handling the\n * results. The Deferred object here is patterned after the Deferred object in\n * the Twisted python networking framework.\n *\n * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html\n *\n * Based on the Dojo code which in turn is based on the MochiKit code.\n *\n * @author arv@google.com (Erik Arvidsson)\n * @author brenneman@google.com (Shawn Brenneman)\n */\n\ngoog.provide('goog.async.Deferred');\ngoog.provide('goog.async.Deferred.AlreadyCalledError');\ngoog.provide('goog.async.Deferred.CanceledError');\n\ngoog.require('goog.Promise');\ngoog.require('goog.Thenable');\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Error');\n\n\n\n/**\n * A Deferred represents the result of an asynchronous operation. A Deferred\n * instance has no result when it is created, and is \"fired\" (given an initial\n * result) by calling `callback` or `errback`.\n *\n * Once fired, the result is passed through a sequence of callback functions\n * registered with `addCallback` or `addErrback`. The functions may\n * mutate the result before it is passed to the next function in the sequence.\n *\n * Callbacks and errbacks may be added at any time, including after the Deferred\n * has been \"fired\". If there are no pending actions in the execution sequence\n * of a fired Deferred, any new callback functions will be called with the last\n * computed result. Adding a callback function is the only way to access the\n * result of the Deferred.\n *\n * If a Deferred operation is canceled, an optional user-provided cancellation\n * function is invoked which may perform any special cleanup, followed by firing\n * the Deferred's errback sequence with a `CanceledError`. If the\n * Deferred has already fired, cancellation is ignored.\n *\n * Deferreds may be templated to a specific type they produce using generics\n * with syntax such as:\n *\n *    /** @type {goog.async.Deferred<string>} *\\\n *    var d = new goog.async.Deferred();\n *    // Compiler can infer that foo is a string.\n *    d.addCallback(function(foo) {...});\n *    d.callback('string');  // Checked to be passed a string\n *\n * Since deferreds are often used to produce different values across a chain,\n * the type information is not propagated across chains, but rather only\n * associated with specifically cast objects.\n *\n * @param {Function=} opt_onCancelFunction A function that will be called if the\n *     Deferred is canceled. If provided, this function runs before the\n *     Deferred is fired with a `CanceledError`.\n * @param {Object=} opt_defaultScope The default object context to call\n *     callbacks and errbacks in.\n * @constructor\n * @implements {goog.Thenable<VALUE>}\n * @template VALUE\n */\ngoog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {\n  /**\n   * Entries in the sequence are arrays containing a callback, an errback, and\n   * an optional scope. The callback or errback in an entry may be null.\n   * @type {!Array<!Array>}\n   * @private\n   */\n  this.sequence_ = [];\n\n  /**\n   * Optional function that will be called if the Deferred is canceled.\n   * @type {Function|undefined}\n   * @private\n   */\n  this.onCancelFunction_ = opt_onCancelFunction;\n\n  /**\n   * The default scope to execute callbacks and errbacks in.\n   * @type {Object}\n   * @private\n   */\n  this.defaultScope_ = opt_defaultScope || null;\n\n  /**\n   * Whether the Deferred has been fired.\n   * @type {boolean}\n   * @private\n   */\n  this.fired_ = false;\n\n  /**\n   * Whether the last result in the execution sequence was an error.\n   * @type {boolean}\n   * @private\n   */\n  this.hadError_ = false;\n\n  /**\n   * The current Deferred result, updated as callbacks and errbacks are\n   * executed.\n   * @type {*}\n   * @private\n   */\n  this.result_ = undefined;\n\n  /**\n   * Whether the Deferred is blocked waiting on another Deferred to fire. If a\n   * callback or errback returns a Deferred as a result, the execution sequence\n   * is blocked until that Deferred result becomes available.\n   * @type {boolean}\n   * @private\n   */\n  this.blocked_ = false;\n\n  /**\n   * Whether this Deferred is blocking execution of another Deferred. If this\n   * instance was returned as a result in another Deferred's execution\n   * sequence,that other Deferred becomes blocked until this instance's\n   * execution sequence completes. No additional callbacks may be added to a\n   * Deferred once it is blocking another instance.\n   * @type {boolean}\n   * @private\n   */\n  this.blocking_ = false;\n\n  /**\n   * Whether the Deferred has been canceled without having a custom cancel\n   * function.\n   * @type {boolean}\n   * @private\n   */\n  this.silentlyCanceled_ = false;\n\n  /**\n   * If an error is thrown during Deferred execution with no errback to catch\n   * it, the error is rethrown after a timeout. Reporting the error after a\n   * timeout allows execution to continue in the calling context (empty when\n   * no error is scheduled).\n   * @type {number}\n   * @private\n   */\n  this.unhandledErrorId_ = 0;\n\n  /**\n   * If this Deferred was created by branch(), this will be the \"parent\"\n   * Deferred.\n   * @type {?goog.async.Deferred}\n   * @private\n   */\n  this.parent_ = null;\n\n  /**\n   * The number of Deferred objects that have been branched off this one. This\n   * will be decremented whenever a branch is fired or canceled.\n   * @type {number}\n   * @private\n   */\n  this.branches_ = 0;\n\n  if (goog.async.Deferred.LONG_STACK_TRACES) {\n    /**\n     * Holds the stack trace at time of deferred creation if the JS engine\n     * provides the Error.captureStackTrace API.\n     * @private {?string}\n     */\n    this.constructorStack_ = null;\n    if (Error.captureStackTrace) {\n      var target = { stack: '' };\n      Error.captureStackTrace(target, goog.async.Deferred);\n      // Check if Error.captureStackTrace worked. It fails in gjstest.\n      if (typeof target.stack == 'string') {\n        // Remove first line and force stringify to prevent memory leak due to\n        // holding on to actual stack frames.\n        this.constructorStack_ = target.stack.replace(/^[^\\n]*\\n/, '');\n      }\n    }\n  }\n};\n\n\n/**\n * @define {boolean} Whether unhandled errors should always get rethrown to the\n * global scope. Defaults to false.\n */\ngoog.async.Deferred.STRICT_ERRORS =\n    goog.define('goog.async.Deferred.STRICT_ERRORS', false);\n\n\n/**\n * @define {boolean} Whether to attempt to make stack traces long.  Defaults to\n * false.\n */\ngoog.async.Deferred.LONG_STACK_TRACES =\n    goog.define('goog.async.Deferred.LONG_STACK_TRACES', false);\n\n\n/**\n * Cancels a Deferred that has not yet been fired, or is blocked on another\n * deferred operation. If this Deferred is waiting for a blocking Deferred to\n * fire, the blocking Deferred will also be canceled.\n *\n * If this Deferred was created by calling branch() on a parent Deferred with\n * opt_propagateCancel set to true, the parent may also be canceled. If\n * opt_deepCancel is set, cancel() will be called on the parent (as well as any\n * other ancestors if the parent is also a branch). If one or more branches were\n * created with opt_propagateCancel set to true, the parent will be canceled if\n * cancel() is called on all of those branches.\n *\n * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even\n *     if cancel() hasn't been called on some of the parent's branches. Has no\n *     effect on a branch without opt_propagateCancel set to true.\n */\ngoog.async.Deferred.prototype.cancel = function(opt_deepCancel) {\n  if (!this.hasFired()) {\n    if (this.parent_) {\n      // Get rid of the parent reference before potentially running the parent's\n      // canceler function to ensure that this cancellation isn't\n      // double-counted.\n      var parent = this.parent_;\n      delete this.parent_;\n      if (opt_deepCancel) {\n        parent.cancel(opt_deepCancel);\n      } else {\n        parent.branchCancel_();\n      }\n    }\n\n    if (this.onCancelFunction_) {\n      // Call in user-specified scope.\n      this.onCancelFunction_.call(this.defaultScope_, this);\n    } else {\n      this.silentlyCanceled_ = true;\n    }\n    if (!this.hasFired()) {\n      this.errback(new goog.async.Deferred.CanceledError(this));\n    }\n  } else if (this.result_ instanceof goog.async.Deferred) {\n    this.result_.cancel();\n  }\n};\n\n\n/**\n * Handle a single branch being canceled. Once all branches are canceled, this\n * Deferred will be canceled as well.\n *\n * @private\n */\ngoog.async.Deferred.prototype.branchCancel_ = function() {\n  this.branches_--;\n  if (this.branches_ <= 0) {\n    this.cancel();\n  }\n};\n\n\n/**\n * Called after a blocking Deferred fires. Unblocks this Deferred and resumes\n * its execution sequence.\n *\n * @param {boolean} isSuccess Whether the result is a success or an error.\n * @param {*} res The result of the blocking Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.continue_ = function(isSuccess, res) {\n  this.blocked_ = false;\n  this.updateResult_(isSuccess, res);\n};\n\n\n/**\n * Updates the current result based on the success or failure of the last action\n * in the execution sequence.\n *\n * @param {boolean} isSuccess Whether the new result is a success or an error.\n * @param {*} res The result.\n * @private\n */\ngoog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {\n  this.fired_ = true;\n  this.result_ = res;\n  this.hadError_ = !isSuccess;\n  this.fire_();\n};\n\n\n/**\n * Verifies that the Deferred has not yet been fired.\n *\n * @private\n * @throws {Error} If this has already been fired.\n */\ngoog.async.Deferred.prototype.check_ = function() {\n  if (this.hasFired()) {\n    if (!this.silentlyCanceled_) {\n      throw new goog.async.Deferred.AlreadyCalledError(this);\n    }\n    this.silentlyCanceled_ = false;\n  }\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting result\n * to the first registered callback.\n * @param {VALUE=} opt_result The starting result.\n */\ngoog.async.Deferred.prototype.callback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.updateResult_(true /* isSuccess */, opt_result);\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting error\n * result to the first registered errback.\n * @param {*=} opt_result The starting error.\n */\ngoog.async.Deferred.prototype.errback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.makeStackTraceLong_(opt_result);\n  this.updateResult_(false /* isSuccess */, opt_result);\n};\n\n\n/**\n * Attempt to make the error's stack trace be long in that it contains the\n * stack trace from the point where the deferred was created on top of the\n * current stack trace to give additional context.\n * @param {*} error\n * @private\n */\ngoog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {\n  if (!goog.async.Deferred.LONG_STACK_TRACES) {\n    return;\n  }\n  if (this.constructorStack_ && goog.isObject(error) && error.stack &&\n      // Stack looks like it was system generated. See\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      (/^[^\\n]+(\\n   [^\\n]+)+/).test(error.stack)) {\n    error.stack = error.stack + '\\nDEFERRED OPERATION:\\n' +\n        this.constructorStack_;\n  }\n};\n\n\n/**\n * Asserts that an object is not a Deferred.\n * @param {*} obj The object to test.\n * @throws {Error} Throws an exception if the object is a Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {\n  goog.asserts.assert(\n      !(obj instanceof goog.async.Deferred),\n      'An execution sequence may not be initiated with a blocking Deferred.');\n};\n\n\n/**\n * Register a callback function to be called with a successful result. If no\n * value is returned by the callback function, the result value is unchanged. If\n * a new value is returned, it becomes the Deferred result and will be passed to\n * the next callback in the execution sequence.\n *\n * If the function throws an error, the error becomes the new result and will be\n * passed to the next errback in the execution chain.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,VALUE):?} cb The function to be called with a\n *     successful result.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {\n  return this.addCallbacks(cb, null, opt_scope);\n};\n\n\n/**\n * Register a callback function to be called with an error result. If no value\n * is returned by the function, the error result is unchanged. If a new error\n * value is returned or thrown, that error becomes the Deferred result and will\n * be passed to the next errback in the execution sequence.\n *\n * If the errback function handles the error by returning a non-error value,\n * that result will be passed to the next normal callback in the sequence.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,?):?} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the errback in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {\n  return this.addCallbacks(null, eb, opt_scope);\n};\n\n\n/**\n * Registers one function as both a callback and errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addBoth = function(f, opt_scope) {\n  return this.addCallbacks(f, f, opt_scope);\n};\n\n\n/**\n * Like addBoth, but propagates uncaught exceptions in the errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addFinally = function(f, opt_scope) {\n  return this.addCallbacks(f, function(err) {\n    var result = f.call(/** @type {?} */ (this), err);\n    if (!goog.isDef(result)) {\n      throw err;\n    }\n    return result;\n  }, opt_scope);\n};\n\n\n/**\n * Registers a callback function and an errback function at the same position\n * in the execution sequence. Only one of these functions will execute,\n * depending on the error state during the execution sequence.\n *\n * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If\n * the callback is invoked, the errback will be skipped, and vice versa.\n *\n * @param {?(function(this:T,VALUE):?)} cb The function to be called on a\n *     successful result.\n * @param {?(function(this:T,?):?)} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the functions in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {\n  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');\n  this.sequence_.push([cb, eb, opt_scope]);\n  if (this.hasFired()) {\n    this.fire_();\n  }\n  return this;\n};\n\n\n/**\n * Implements {@see goog.Thenable} for seamless integration with\n * {@see goog.Promise}.\n * Deferred results are mutable and may represent multiple values over\n * their lifetime. Calling `then` on a Deferred returns a Promise\n * with the result of the Deferred at that point in its callback chain.\n * Note that if the Deferred result is never mutated, and only\n * `then` calls are made, the Deferred will behave like a Promise.\n *\n * @override\n */\ngoog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected,\n    opt_context) {\n  var resolve, reject;\n  var promise = new goog.Promise(function(res, rej) {\n    // Copying resolvers to outer scope, so that they are available when the\n    // deferred callback fires (which may be synchronous).\n    resolve = res;\n    reject = rej;\n  });\n  this.addCallbacks(resolve, function(reason) {\n    if (reason instanceof goog.async.Deferred.CanceledError) {\n      promise.cancel();\n    } else {\n      reject(reason);\n    }\n  });\n  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);\n};\ngoog.Thenable.addImplementation(goog.async.Deferred);\n\n\n/**\n * Links another Deferred to the end of this Deferred's execution sequence. The\n * result of this execution sequence will be passed as the starting result for\n * the chained Deferred, invoking either its first callback or errback.\n *\n * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {\n  this.addCallbacks(\n      otherDeferred.callback, otherDeferred.errback, otherDeferred);\n  return this;\n};\n\n\n/**\n * Makes this Deferred wait for another Deferred's execution sequence to\n * complete before continuing.\n *\n * This is equivalent to adding a callback that returns `otherDeferred`,\n * but doesn't prevent additional callbacks from being added to\n * `otherDeferred`.\n *\n * @param {!goog.async.Deferred|!goog.Thenable} otherDeferred The Deferred\n *     to wait for.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {\n  if (!(otherDeferred instanceof goog.async.Deferred)) {\n    // The Thenable case.\n    return this.addCallback(function() {\n      return otherDeferred;\n    });\n  }\n  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));\n};\n\n\n/**\n * Creates a branch off this Deferred's execution sequence, and returns it as a\n * new Deferred. The branched Deferred's starting result will be shared with the\n * parent at the point of the branch, even if further callbacks are added to the\n * parent.\n *\n * All branches at the same stage in the execution sequence will receive the\n * same starting value.\n *\n * @param {boolean=} opt_propagateCancel If cancel() is called on every child\n *     branch created with opt_propagateCancel, the parent will be canceled as\n *     well.\n * @return {!goog.async.Deferred<VALUE>} A Deferred that will be started with\n *     the computed result from this stage in the execution sequence.\n */\ngoog.async.Deferred.prototype.branch = function(opt_propagateCancel) {\n  var d = new goog.async.Deferred();\n  this.chainDeferred(d);\n  if (opt_propagateCancel) {\n    d.parent_ = this;\n    this.branches_++;\n  }\n  return d;\n};\n\n\n/**\n * @return {boolean} Whether the execution sequence has been started on this\n *     Deferred by invoking `callback` or `errback`.\n */\ngoog.async.Deferred.prototype.hasFired = function() {\n  return this.fired_;\n};\n\n\n/**\n * @param {*} res The latest result in the execution sequence.\n * @return {boolean} Whether the current result is an error that should cause\n *     the next errback to fire. May be overridden by subclasses to handle\n *     special error types.\n * @protected\n */\ngoog.async.Deferred.prototype.isError = function(res) {\n  return res instanceof Error;\n};\n\n\n/**\n * @return {boolean} Whether an errback exists in the remaining sequence.\n * @private\n */\ngoog.async.Deferred.prototype.hasErrback_ = function() {\n  return goog.array.some(this.sequence_, function(sequenceRow) {\n    // The errback is the second element in the array.\n    return goog.isFunction(sequenceRow[1]);\n  });\n};\n\n\n/**\n * Exhausts the execution sequence while a result is available. The result may\n * be modified by callbacks or errbacks, and execution will block if the\n * returned result is an incomplete Deferred.\n *\n * @private\n */\ngoog.async.Deferred.prototype.fire_ = function() {\n  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {\n    // It is possible to add errbacks after the Deferred has fired. If a new\n    // errback is added immediately after the Deferred encountered an unhandled\n    // error, but before that error is rethrown, the error is unscheduled.\n    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);\n    this.unhandledErrorId_ = 0;\n  }\n\n  if (this.parent_) {\n    this.parent_.branches_--;\n    delete this.parent_;\n  }\n\n  var res = this.result_;\n  var unhandledException = false;\n  var isNewlyBlocked = false;\n\n  while (this.sequence_.length && !this.blocked_) {\n    var sequenceEntry = this.sequence_.shift();\n\n    var callback = sequenceEntry[0];\n    var errback = sequenceEntry[1];\n    var scope = sequenceEntry[2];\n\n    var f = this.hadError_ ? errback : callback;\n    if (f) {\n\n      try {\n        var ret = f.call(scope || this.defaultScope_, res);\n\n        // If no result, then use previous result.\n        if (goog.isDef(ret)) {\n          // Bubble up the error as long as the return value hasn't changed.\n          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));\n          this.result_ = res = ret;\n        }\n\n        if (goog.Thenable.isImplementedBy(res) ||\n            (typeof goog.global['Promise'] === 'function' &&\n            res instanceof goog.global['Promise'])) {\n          isNewlyBlocked = true;\n          this.blocked_ = true;\n        }\n\n      } catch (ex) {\n        res = ex;\n        this.hadError_ = true;\n        this.makeStackTraceLong_(res);\n\n        if (!this.hasErrback_()) {\n          // If an error is thrown with no additional errbacks in the queue,\n          // prepare to rethrow the error.\n          unhandledException = true;\n        }\n      }\n    }\n  }\n\n  this.result_ = res;\n\n  if (isNewlyBlocked) {\n    var onCallback = goog.bind(this.continue_, this, true /* isSuccess */);\n    var onErrback = goog.bind(this.continue_, this, false /* isSuccess */);\n\n    if (res instanceof goog.async.Deferred) {\n      res.addCallbacks(onCallback, onErrback);\n      res.blocking_ = true;\n    } else {\n      /** @type {!IThenable} */ (res).then(onCallback, onErrback);\n    }\n  } else if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) &&\n      !(res instanceof goog.async.Deferred.CanceledError)) {\n    this.hadError_ = true;\n    unhandledException = true;\n  }\n\n  if (unhandledException) {\n    // Rethrow the unhandled error after a timeout. Execution will continue, but\n    // the error will be seen by global handlers and the user. The throw will\n    // be canceled if another errback is appended before the timeout executes.\n    // The error's original stack trace is preserved where available.\n    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);\n  }\n};\n\n\n/**\n * Creates a Deferred that has an initial result.\n *\n * @param {*=} opt_result The result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.succeed = function(opt_result) {\n  var d = new goog.async.Deferred();\n  d.callback(opt_result);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that fires when the given promise resolves.\n * Use only during migration to Promises.\n *\n * Note: If the promise resolves to a thenable value (which is not allowed by\n * conforming promise implementations), then the deferred may behave\n * unexpectedly as it tries to wait on it. This should not be a risk when using\n * goog.Promise, goog.async.Deferred, or native Promise objects.\n *\n * @param {!IThenable<T>} promise\n * @return {!goog.async.Deferred<T>} The new Deferred.\n * @template T\n */\ngoog.async.Deferred.fromPromise = function(promise) {\n  var d = new goog.async.Deferred();\n  promise.then(\n      function(value) {\n        d.callback(value);\n      },\n      function(error) {\n        d.errback(error);\n      });\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has an initial error result.\n *\n * @param {*} res The error result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.fail = function(res) {\n  var d = new goog.async.Deferred();\n  d.errback(res);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has already been canceled.\n *\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.canceled = function() {\n  var d = new goog.async.Deferred();\n  d.cancel();\n  return d;\n};\n\n\n/**\n * Normalizes values that may or may not be Deferreds.\n *\n * If the input value is a Deferred, the Deferred is branched (so the original\n * execution sequence is not modified) and the input callback added to the new\n * branch. The branch is returned to the caller.\n *\n * If the input value is not a Deferred, the callback will be executed\n * immediately and an already firing Deferred will be returned to the caller.\n *\n * In the following (contrived) example, if <code>isImmediate</code> is true\n * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.\n *\n * <pre>\n * var value;\n * if (isImmediate) {\n *   value = 3;\n * } else {\n *   value = new goog.async.Deferred();\n *   setTimeout(function() { value.callback(6); }, 2000);\n * }\n *\n * var d = goog.async.Deferred.when(value, alert);\n * </pre>\n *\n * @param {*} value Deferred or normal value to pass to the callback.\n * @param {function(this:T, ?):?} callback The callback to execute.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} A new Deferred that will call the input\n *     callback with the input value.\n * @template T\n */\ngoog.async.Deferred.when = function(value, callback, opt_scope) {\n  if (value instanceof goog.async.Deferred) {\n    return value.branch(true).addCallback(callback, opt_scope);\n  } else {\n    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);\n  }\n};\n\n\n\n/**\n * An error sub class that is used when a Deferred has already been called.\n * @param {!goog.async.Deferred} deferred The Deferred.\n *\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.AlreadyCalledError = function(deferred) {\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.message =\n    'Deferred has already fired';\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';\n\n\n\n/**\n * An error sub class that is used when a Deferred is canceled.\n *\n * @param {!goog.async.Deferred} deferred The Deferred object.\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.CanceledError = function(deferred) {\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.name = 'CanceledError';\n\n\n\n/**\n * Wrapper around errors that are scheduled to be thrown by failing deferreds\n * after a timeout.\n *\n * @param {*} error Error from a failing deferred.\n * @constructor\n * @final\n * @private\n * @struct\n */\ngoog.async.Deferred.Error_ = function(error) {\n  /** @const @private {number} */\n  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);\n\n  /** @const @private {*} */\n  this.error_ = error;\n};\n\n\n/**\n * Actually throws the error and removes it from the list of pending\n * deferred errors.\n */\ngoog.async.Deferred.Error_.prototype.throwError = function() {\n  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_],\n      'Cannot throw an error that is not scheduled.');\n  delete goog.async.Deferred.errorMap_[this.id_];\n  throw this.error_;\n};\n\n\n/**\n * Resets the error throw timer.\n */\ngoog.async.Deferred.Error_.prototype.resetTimer = function() {\n  goog.global.clearTimeout(this.id_);\n};\n\n\n/**\n * Map of unhandled errors scheduled to be rethrown in a future timestep.\n * @private {!Object<(number|string), goog.async.Deferred.Error_>}\n */\ngoog.async.Deferred.errorMap_ = {};\n\n\n/**\n * Schedules an error to be thrown after a delay.\n * @param {*} error Error from a failing deferred.\n * @return {number} Id of the error.\n * @private\n */\ngoog.async.Deferred.scheduleError_ = function(error) {\n  var deferredError = new goog.async.Deferred.Error_(error);\n  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;\n  return deferredError.id_;\n};\n\n\n/**\n * Unschedules an error from being thrown.\n * @param {number} id Id of the deferred error to unschedule.\n * @private\n */\ngoog.async.Deferred.unscheduleError_ = function(id) {\n  var error = goog.async.Deferred.errorMap_[id];\n  if (error) {\n    error.resetTimer();\n    delete goog.async.Deferred.errorMap_[id];\n  }\n};\n\n\n/**\n * Asserts that there are no pending deferred errors. If there are any\n * scheduled errors, one will be thrown immediately to make this function fail.\n */\ngoog.async.Deferred.assertNoErrors = function() {\n  var map = goog.async.Deferred.errorMap_;\n  for (var key in map) {\n    var error = map[key];\n    error.resetTimer();\n    error.throwError();\n  }\n};\n","// Copyright 2011 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview A utility to load JavaScript files via DOM script tags.\n * Refactored from goog.net.Jsonp. Works cross-domain.\n *\n */\n\ngoog.provide('goog.net.jsloader');\ngoog.provide('goog.net.jsloader.Error');\ngoog.provide('goog.net.jsloader.ErrorCode');\ngoog.provide('goog.net.jsloader.Options');\n\ngoog.require('goog.array');\ngoog.require('goog.async.Deferred');\ngoog.require('goog.debug.Error');\ngoog.require('goog.dom');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.safe');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.object');\n\n\n/**\n * The name of the property of goog.global under which the JavaScript\n * verification object is stored by the loaded script.\n * @private {string}\n */\ngoog.net.jsloader.GLOBAL_VERIFY_OBJS_ = 'closure_verification';\n\n\n/**\n * The default length of time, in milliseconds, we are prepared to wait for a\n * load request to complete.\n * @type {number}\n */\ngoog.net.jsloader.DEFAULT_TIMEOUT = 5000;\n\n\n/**\n * Optional parameters for goog.net.jsloader.send.\n * timeout: The length of time, in milliseconds, we are prepared to wait\n *     for a load request to complete, or 0 or negative for no timeout. Default\n *     is 5 seconds.\n * document: The HTML document under which to load the JavaScript. Default is\n *     the current document.\n * cleanupWhenDone: If true clean up the script tag after script completes to\n *     load. This is important if you just want to read data from the JavaScript\n *     and then throw it away. Default is false.\n * attributes: Additional attributes to set on the script tag.\n *\n * @typedef {{\n *   timeout: (number|undefined),\n *   document: (HTMLDocument|undefined),\n *   cleanupWhenDone: (boolean|undefined),\n *   attributes: (!Object<string, string>|undefined)\n * }}\n */\ngoog.net.jsloader.Options;\n\n\n/**\n * Scripts (URIs) waiting to be loaded.\n * @private {!Array<!goog.html.TrustedResourceUrl>}\n */\ngoog.net.jsloader.scriptsToLoad_ = [];\n\n\n/**\n * The deferred result of loading the URIs in scriptsToLoad_.\n * We need to return this to a caller that wants to load URIs while\n * a deferred is already working on them.\n * @private {!goog.async.Deferred<null>}\n */\ngoog.net.jsloader.scriptLoadingDeferred_;\n\n\n\n/**\n * Loads and evaluates the JavaScript files at the specified URIs, guaranteeing\n * the order of script loads.\n *\n * Because we have to load the scripts in serial (load script 1, exec script 1,\n * load script 2, exec script 2, and so on), this will be slower than doing\n * the network fetches in parallel.\n *\n * If you need to load a large number of scripts but dependency order doesn't\n * matter, you should just call goog.net.jsloader.safeLoad N times.\n *\n * If you need to load a large number of scripts on the same domain,\n * you may want to use goog.module.ModuleLoader.\n *\n * @param {Array<!goog.html.TrustedResourceUrl>} trustedUris The URIs to load.\n * @param {goog.net.jsloader.Options=} opt_options Optional parameters. See\n *     goog.net.jsloader.options documentation for details.\n * @return {!goog.async.Deferred} The deferred result, that may be used to add\n *     callbacks\n */\ngoog.net.jsloader.safeLoadMany = function(trustedUris, opt_options) {\n  // Loading the scripts in serial introduces asynchronosity into the flow.\n  // Therefore, there are race conditions where client A can kick off the load\n  // sequence for client B, even though client A's scripts haven't all been\n  // loaded yet.\n  //\n  // To work around this issue, all module loads share a queue.\n  if (!trustedUris.length) {\n    return goog.async.Deferred.succeed(null);\n  }\n\n  var isAnotherModuleLoading = goog.net.jsloader.scriptsToLoad_.length;\n  goog.array.extend(goog.net.jsloader.scriptsToLoad_, trustedUris);\n  if (isAnotherModuleLoading) {\n    // jsloader is still loading some other scripts.\n    // In order to prevent the race condition noted above, we just add\n    // these URIs to the end of the scripts' queue and return the deferred\n    // result of the ongoing script load, so the caller knows when they\n    // finish loading.\n    return goog.net.jsloader.scriptLoadingDeferred_;\n  }\n\n  trustedUris = goog.net.jsloader.scriptsToLoad_;\n  var popAndLoadNextScript = function() {\n    var trustedUri = trustedUris.shift();\n    var deferred = goog.net.jsloader.safeLoad(trustedUri, opt_options);\n    if (trustedUris.length) {\n      deferred.addBoth(popAndLoadNextScript);\n    }\n    return deferred;\n  };\n  goog.net.jsloader.scriptLoadingDeferred_ = popAndLoadNextScript();\n  return goog.net.jsloader.scriptLoadingDeferred_;\n};\n\n\n/**\n * Loads and evaluates a JavaScript file.\n * When the script loads, a user callback is called.\n * It is the client's responsibility to verify that the script ran successfully.\n *\n * @param {!goog.html.TrustedResourceUrl} trustedUri The URI of the JavaScript.\n * @param {goog.net.jsloader.Options=} opt_options Optional parameters. See\n *     goog.net.jsloader.Options documentation for details.\n * @return {!goog.async.Deferred} The deferred result, that may be used to add\n *     callbacks and/or cancel the transmission.\n *     The error callback will be called with a single goog.net.jsloader.Error\n *     parameter.\n */\ngoog.net.jsloader.safeLoad = function(trustedUri, opt_options) {\n  var options = opt_options || {};\n  var doc = options.document || document;\n  var uri = goog.html.TrustedResourceUrl.unwrap(trustedUri);\n\n  var script = goog.dom.createElement(goog.dom.TagName.SCRIPT);\n  var request = {script_: script, timeout_: undefined};\n  var deferred = new goog.async.Deferred(goog.net.jsloader.cancel_, request);\n\n  // Set a timeout.\n  var timeout = null;\n  var timeoutDuration = goog.isDefAndNotNull(options.timeout) ?\n      options.timeout :\n      goog.net.jsloader.DEFAULT_TIMEOUT;\n  if (timeoutDuration > 0) {\n    timeout = window.setTimeout(function() {\n      goog.net.jsloader.cleanup_(script, true);\n      deferred.errback(\n          new goog.net.jsloader.Error(\n              goog.net.jsloader.ErrorCode.TIMEOUT,\n              'Timeout reached for loading script ' + uri));\n    }, timeoutDuration);\n    request.timeout_ = timeout;\n  }\n\n  // Hang the user callback to be called when the script completes to load.\n  // NOTE(user): This callback will be called in IE even upon error. In any\n  // case it is the client's responsibility to verify that the script ran\n  // successfully.\n  script.onload = script.onreadystatechange = function() {\n    if (!script.readyState || script.readyState == 'loaded' ||\n        script.readyState == 'complete') {\n      var removeScriptNode = options.cleanupWhenDone || false;\n      goog.net.jsloader.cleanup_(script, removeScriptNode, timeout);\n      deferred.callback(null);\n    }\n  };\n\n  // Add an error callback.\n  // NOTE(user): Not supported in IE.\n  script.onerror = function() {\n    goog.net.jsloader.cleanup_(script, true, timeout);\n    deferred.errback(\n        new goog.net.jsloader.Error(\n            goog.net.jsloader.ErrorCode.LOAD_ERROR,\n            'Error while loading script ' + uri));\n  };\n\n  var properties = options.attributes || {};\n  goog.object.extend(\n      properties, {'type': 'text/javascript', 'charset': 'UTF-8'});\n  goog.dom.setProperties(script, properties);\n  // NOTE(user): Safari never loads the script if we don't set the src\n  // attribute before appending.\n  goog.dom.safe.setScriptSrc(script, trustedUri);\n  var scriptParent = goog.net.jsloader.getScriptParentElement_(doc);\n  scriptParent.appendChild(script);\n\n  return deferred;\n};\n\n\n/**\n * Loads a JavaScript file and verifies it was evaluated successfully, using a\n * verification object.\n * The verification object is set by the loaded JavaScript at the end of the\n * script.\n * We verify this object was set and return its value in the success callback.\n * If the object is not defined we trigger an error callback.\n *\n * @param {!goog.html.TrustedResourceUrl} trustedUri The URI of the JavaScript.\n * @param {string} verificationObjName The name of the verification object that\n *     the loaded script should set.\n * @param {goog.net.jsloader.Options} options Optional parameters. See\n *     goog.net.jsloader.Options documentation for details.\n * @return {!goog.async.Deferred} The deferred result, that may be used to add\n *     callbacks and/or cancel the transmission.\n *     The success callback will be called with a single parameter containing\n *     the value of the verification object.\n *     The error callback will be called with a single goog.net.jsloader.Error\n *     parameter.\n */\ngoog.net.jsloader.safeLoadAndVerify = function(\n    trustedUri, verificationObjName, options) {\n  // Define the global objects variable.\n  if (!goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_]) {\n    goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_] = {};\n  }\n  var verifyObjs = goog.global[goog.net.jsloader.GLOBAL_VERIFY_OBJS_];\n  var uri = goog.html.TrustedResourceUrl.unwrap(trustedUri);\n\n  // Verify that the expected object does not exist yet.\n  if (goog.isDef(verifyObjs[verificationObjName])) {\n    // TODO(user): Error or reset variable?\n    return goog.async.Deferred.fail(\n        new goog.net.jsloader.Error(\n            goog.net.jsloader.ErrorCode.VERIFY_OBJECT_ALREADY_EXISTS,\n            'Verification object ' + verificationObjName +\n                ' already defined.'));\n  }\n\n  // Send request to load the JavaScript.\n  var sendDeferred = goog.net.jsloader.safeLoad(trustedUri, options);\n\n  // Create a deferred object wrapping the send result.\n  var deferred =\n      new goog.async.Deferred(goog.bind(sendDeferred.cancel, sendDeferred));\n\n  // Call user back with object that was set by the script.\n  sendDeferred.addCallback(function() {\n    var result = verifyObjs[verificationObjName];\n    if (goog.isDef(result)) {\n      deferred.callback(result);\n      delete verifyObjs[verificationObjName];\n    } else {\n      // Error: script was not loaded properly.\n      deferred.errback(\n          new goog.net.jsloader.Error(\n              goog.net.jsloader.ErrorCode.VERIFY_ERROR, 'Script ' + uri +\n                  ' loaded, but verification object ' + verificationObjName +\n                  ' was not defined.'));\n    }\n  });\n\n  // Pass error to new deferred object.\n  sendDeferred.addErrback(function(error) {\n    if (goog.isDef(verifyObjs[verificationObjName])) {\n      delete verifyObjs[verificationObjName];\n    }\n    deferred.errback(error);\n  });\n\n  return deferred;\n};\n\n\n/**\n * Gets the DOM element under which we should add new script elements.\n * How? Take the first head element, and if not found take doc.documentElement,\n * which always exists.\n *\n * @param {!HTMLDocument} doc The relevant document.\n * @return {!Element} The script parent element.\n * @private\n */\ngoog.net.jsloader.getScriptParentElement_ = function(doc) {\n  var headElements = goog.dom.getElementsByTagName(goog.dom.TagName.HEAD, doc);\n  if (!headElements || goog.array.isEmpty(headElements)) {\n    return doc.documentElement;\n  } else {\n    return headElements[0];\n  }\n};\n\n\n/**\n * Cancels a given request.\n * @this {{script_: Element, timeout_: number}} The request context.\n * @private\n */\ngoog.net.jsloader.cancel_ = function() {\n  var request = this;\n  if (request && request.script_) {\n    var scriptNode = request.script_;\n    if (scriptNode && scriptNode.tagName == goog.dom.TagName.SCRIPT) {\n      goog.net.jsloader.cleanup_(scriptNode, true, request.timeout_);\n    }\n  }\n};\n\n\n/**\n * Removes the script node and the timeout.\n * @param {Node} scriptNode The node to be cleaned up.\n * @param {boolean} removeScriptNode If true completely remove the script node.\n * @param {?number=} opt_timeout The timeout handler to cleanup.\n * @private\n * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration\n */\ngoog.net.jsloader.cleanup_ = function(\n    scriptNode, removeScriptNode, opt_timeout) {\n  if (goog.isDefAndNotNull(opt_timeout)) {\n    goog.global.clearTimeout(opt_timeout);\n  }\n\n  scriptNode.onload = goog.nullFunction;\n  scriptNode.onerror = goog.nullFunction;\n  scriptNode.onreadystatechange = goog.nullFunction;\n\n  // Do this after a delay (removing the script node of a running script can\n  // confuse older IEs).\n  if (removeScriptNode) {\n    window.setTimeout(function() { goog.dom.removeNode(scriptNode); }, 0);\n  }\n};\n\n\n/**\n * Possible error codes for jsloader.\n * @enum {number}\n */\ngoog.net.jsloader.ErrorCode = {\n  LOAD_ERROR: 0,\n  TIMEOUT: 1,\n  VERIFY_ERROR: 2,\n  VERIFY_OBJECT_ALREADY_EXISTS: 3\n};\n\n\n\n/**\n * A jsloader error.\n *\n * @param {goog.net.jsloader.ErrorCode} code The error code.\n * @param {string=} opt_message Additional message.\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.net.jsloader.Error = function(code, opt_message) {\n  var msg = 'Jsloader error (code #' + code + ')';\n  if (opt_message) {\n    msg += ': ' + opt_message;\n  }\n  goog.net.jsloader.Error.base(this, 'constructor', msg);\n\n  /**\n   * The code for this error.\n   *\n   * @type {goog.net.jsloader.ErrorCode}\n   */\n  this.code = code;\n};\ngoog.inherits(goog.net.jsloader.Error, goog.debug.Error);\n","// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Error codes shared between goog.net.IframeIo and\n * goog.net.XhrIo.\n */\n\ngoog.provide('goog.net.ErrorCode');\n\n\n/**\n * Error codes\n * @enum {number}\n */\ngoog.net.ErrorCode = {\n\n  /**\n   * There is no error condition.\n   */\n  NO_ERROR: 0,\n\n  /**\n   * The most common error from iframeio, unfortunately, is that the browser\n   * responded with an error page that is classed as a different domain. The\n   * situations, are when a browser error page  is shown -- 404, access denied,\n   * DNS failure, connection reset etc.)\n   *\n   */\n  ACCESS_DENIED: 1,\n\n  /**\n   * Currently the only case where file not found will be caused is when the\n   * code is running on the local file system and a non-IE browser makes a\n   * request to a file that doesn't exist.\n   */\n  FILE_NOT_FOUND: 2,\n\n  /**\n   * If Firefox shows a browser error page, such as a connection reset by\n   * server or access denied, then it will fail silently without the error or\n   * load handlers firing.\n   */\n  FF_SILENT_ERROR: 3,\n\n  /**\n   * Custom error provided by the client through the error check hook.\n   */\n  CUSTOM_ERROR: 4,\n\n  /**\n   * Exception was thrown while processing the request.\n   */\n  EXCEPTION: 5,\n\n  /**\n   * The Http response returned a non-successful http status code.\n   */\n  HTTP_ERROR: 6,\n\n  /**\n   * The request was aborted.\n   */\n  ABORT: 7,\n\n  /**\n   * The request timed out.\n   */\n  TIMEOUT: 8,\n\n  /**\n   * The resource is not available offline.\n   */\n  OFFLINE: 9\n};\n\n\n/**\n * Returns a friendly error message for an error code. These messages are for\n * debugging and are not localized.\n * @param {goog.net.ErrorCode} errorCode An error code.\n * @return {string} A message for debugging.\n */\ngoog.net.ErrorCode.getDebugMessage = function(errorCode) {\n  switch (errorCode) {\n    case goog.net.ErrorCode.NO_ERROR:\n      return 'No Error';\n\n    case goog.net.ErrorCode.ACCESS_DENIED:\n      return 'Access denied to content document';\n\n    case goog.net.ErrorCode.FILE_NOT_FOUND:\n      return 'File not found';\n\n    case goog.net.ErrorCode.FF_SILENT_ERROR:\n      return 'Firefox silently errored';\n\n    case goog.net.ErrorCode.CUSTOM_ERROR:\n      return 'Application custom error';\n\n    case goog.net.ErrorCode.EXCEPTION:\n      return 'An exception occurred';\n\n    case goog.net.ErrorCode.HTTP_ERROR:\n      return 'Http response at 400 or 500 level';\n\n    case goog.net.ErrorCode.ABORT:\n      return 'Request was aborted';\n\n    case goog.net.ErrorCode.TIMEOUT:\n      return 'Request timed out';\n\n    case goog.net.ErrorCode.OFFLINE:\n      return 'The resource is not available offline';\n\n    default:\n      return 'Unrecognized error code';\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines fireauth.iframeclient.IframeWrapper used to communicate\n * with the hidden iframe to detect Auth events.\n */\n\ngoog.provide('fireauth.iframeclient.IframeWrapper');\n\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.net.jsloader');\ngoog.require('goog.string.Const');\n\n\n/**\n * Defines the hidden iframe wrapper for cross origin communications.\n * @param {string} url The hidden iframe src URL.\n * @constructor\n */\nfireauth.iframeclient.IframeWrapper = function(url) {\n  /** @private {string} The hidden iframe URL. */\n  this.url_ = url;\n\n  /**\n   * @type {?gapi.iframes.Iframe}\n   * @private\n   */\n  this.iframe_ = null;\n\n  /** @private {!goog.Promise} A promise that resolves on iframe open. */\n  this.onIframeOpen_ = this.open_();\n};\n\n\n/**\n * @typedef {{\n *   type: string\n * }}\n */\nfireauth.iframeclient.IframeWrapper.Message;\n\n/**\n * Returns URL, src of the hidden iframe.\n * @return {string}\n * @private\n */\nfireauth.iframeclient.IframeWrapper.prototype.getPath_ = function() {\n  return this.url_;\n};\n\n\n/**\n * @return {!goog.Promise} The promise that resolves when the iframe is ready.\n */\nfireauth.iframeclient.IframeWrapper.prototype.onReady = function() {\n  return this.onIframeOpen_;\n};\n\n\n/**\n * Returns options used to open the iframe.\n * @return {!gapi.iframes.OptionsBag}\n * @private\n */\nfireauth.iframeclient.IframeWrapper.prototype.getOptions_ = function() {\n  var options = /** @type {!gapi.iframes.OptionsBag} */ ({\n    'where': document.body,\n    'url': this.getPath_(),\n    'messageHandlersFilter': /** @type {!gapi.iframes.IframesFilter} */ (\n        fireauth.util.getObjectRef(\n            'gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER')),\n    'attributes': {\n      'style': {\n        'position': 'absolute',\n        'top': '-100px',\n        'width': '1px',\n        'height': '1px'\n      }\n    },\n    'dontclear': true\n  });\n  return options;\n};\n\n\n/**\n * Opens an iframe.\n * @return {!goog.Promise} A promise that resolves on successful iframe open.\n * @private\n */\nfireauth.iframeclient.IframeWrapper.prototype.open_ = function() {\n  var self = this;\n  return fireauth.iframeclient.IframeWrapper.loadGApiJs_().then(function() {\n    return new goog.Promise(function(resolve, reject) {\n      /**\n       * @param {?gapi.iframes.Iframe} iframe The new opened iframe.\n       */\n      var onOpen = function(iframe) {\n        self.iframe_ = iframe;\n        self.iframe_.restyle({\n          // Prevent iframe from closing on mouse out.\n          'setHideOnLeave': false\n        });\n        // Confirm iframe is correctly loaded.\n        // To fallback on failure, set a timeout.\n        var networkErrorTimer = setTimeout(function() {\n          reject(new Error('Network Error'));\n        }, fireauth.iframeclient.IframeWrapper.PING_TIMEOUT_.get());\n        // Clear timer and resolve pending iframe ready promise.\n        var clearTimerAndResolve = function() {\n          clearTimeout(networkErrorTimer);\n          resolve();\n        };\n        // This returns an IThenable. However the reject part does not call\n        // when the iframe is not loaded.\n        iframe.ping(clearTimerAndResolve).then(\n            clearTimerAndResolve,\n            function(error) { reject(new Error('Network Error')); });\n      };\n      /** @type {function():!gapi.iframes.Context} */ (\n          fireauth.util.getObjectRef('gapi.iframes.getContext'))().open(\n              self.getOptions_(), onOpen);\n    });\n  });\n};\n\n\n/**\n * @param {!fireauth.iframeclient.IframeWrapper.Message} message to send.\n * @return {!goog.Promise<?Object>} The promise that resolve when message is\n *     sent.\n */\nfireauth.iframeclient.IframeWrapper.prototype.sendMessage = function(message) {\n  var self = this;\n  return this.onIframeOpen_.then(function() {\n    return new goog.Promise(function(resolve, reject) {\n      self.iframe_.send(\n          message['type'],\n          message,\n          resolve,\n          /** @type {!gapi.iframes.IframesFilter} */ (\n              fireauth.util.getObjectRef(\n                  'gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER')));\n\n    });\n  });\n};\n\n\n/**\n * Registers a listener to a post message.\n * @param {string} eventName The message to register for.\n * @param {gapi.iframes.MessageHandler} handler Message handler.\n */\nfireauth.iframeclient.IframeWrapper.prototype.registerEvent =\n    function(eventName, handler) {\n  var self = this;\n  this.onIframeOpen_.then(function() {\n    self.iframe_.register(\n        eventName,\n        /** @type {function(this:gapi.iframes.Iframe,\n         *                  *, gapi.iframes.Iframe): *}\n         */ (handler),\n        /** @type {!gapi.iframes.IframesFilter} */ (\n            fireauth.util.getObjectRef(\n                'gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER')));\n  });\n};\n\n\n/**\n * Unregisters a listener to a post message.\n * @param {string} eventName The message to unregister.\n * @param {gapi.iframes.MessageHandler} handler Message handler.\n */\nfireauth.iframeclient.IframeWrapper.prototype.unregisterEvent =\n    function(eventName, handler) {\n  var self = this;\n  this.onIframeOpen_.then(function() {\n    self.iframe_.unregister(\n        eventName,\n        /** @type {(function(this:gapi.iframes.Iframe,\n         *                   *, gapi.iframes.Iframe): *|undefined)}\n         */ (handler));\n  });\n};\n\n\n/** @private @const {!goog.string.Const} The GApi loader URL. */\nfireauth.iframeclient.IframeWrapper.GAPI_LOADER_SRC_ = goog.string.Const.from(\n    'https://apis.google.com/js/api.js?onload=%{onload}');\n\n\n/**\n * @private @const {!fireauth.util.Delay} The gapi.load network error timeout\n *     delay with units in ms.\n */\nfireauth.iframeclient.IframeWrapper.NETWORK_TIMEOUT_ =\n    new fireauth.util.Delay(30000, 60000);\n\n\n/**\n * @private @const {!fireauth.util.Delay} The iframe ping error timeout delay\n *     with units in ms.\n */\nfireauth.iframeclient.IframeWrapper.PING_TIMEOUT_ =\n    new fireauth.util.Delay(5000, 15000);\n\n\n/** @private {?goog.Promise} The cached GApi loader promise. */\nfireauth.iframeclient.IframeWrapper.cachedGApiLoader_ = null;\n\n\n/** Resets the cached GApi loader. */\nfireauth.iframeclient.IframeWrapper.resetCachedGApiLoader = function() {\n  fireauth.iframeclient.IframeWrapper.cachedGApiLoader_ = null;\n};\n\n\n\n/**\n * Loads the GApi client library if it is not loaded for gapi.iframes usage.\n * @return {!goog.Promise} A promise that resolves when gapi.iframes is loaded.\n * @private\n */\nfireauth.iframeclient.IframeWrapper.loadGApiJs_ = function() {\n  // If already pending or resolved, return the cached promise.\n  if (fireauth.iframeclient.IframeWrapper.cachedGApiLoader_) {\n    return fireauth.iframeclient.IframeWrapper.cachedGApiLoader_;\n  }\n  // If there is no cached promise, initialize a new one.\n  fireauth.iframeclient.IframeWrapper.cachedGApiLoader_ =\n      new goog.Promise(function(resolve, reject) {\n    // Function to run when gapi.load is ready.\n    var onGapiLoad = function() {\n      // The developer may have tried to previously run gapi.load and failed.\n      // Run this to fix that.\n      fireauth.util.resetUnloadedGapiModules();\n      var loader = /** @type {function(string, !Object)} */ (\n          fireauth.util.getObjectRef('gapi.load'));\n      loader('gapi.iframes', {\n        'callback': resolve,\n        'ontimeout': function() {\n          // The above reset may be sufficient, but having this reset after\n          // failure ensures that if the developer calls gapi.load after the\n          // connection is re-established and before another attempt to embed\n          // the iframe, it would work and would not be broken because of our\n          // failed attempt.\n          // Timeout when gapi.iframes.Iframe not loaded.\n          fireauth.util.resetUnloadedGapiModules();\n          reject(new Error('Network Error'));\n        },\n        'timeout': fireauth.iframeclient.IframeWrapper.NETWORK_TIMEOUT_.get()\n      });\n    };\n    if (fireauth.util.getObjectRef('gapi.iframes.Iframe')) {\n      // If gapi.iframes.Iframe available, resolve.\n      resolve();\n    } else if (fireauth.util.getObjectRef('gapi.load')) {\n      // Gapi loader ready, load gapi.iframes.\n      onGapiLoad();\n    } else {\n      // Create a new iframe callback when this is called so as not to overwrite\n      // any previous defined callback. This happens if this method is called\n      // multiple times in parallel and could result in the later callback\n      // overwriting the previous one. This would end up with a iframe\n      // timeout.\n      var cbName = '__iframefcb' +\n          Math.floor(Math.random() * 1000000).toString();\n      // GApi loader not available, dynamically load platform.js.\n      goog.global[cbName] = function() {\n        // GApi loader should be ready.\n        if (fireauth.util.getObjectRef('gapi.load')) {\n          onGapiLoad();\n        } else {\n          // Gapi loader failed, throw error.\n          reject(new Error('Network Error'));\n        }\n      };\n      // Build GApi loader.\n      var url = goog.html.TrustedResourceUrl.format(\n          fireauth.iframeclient.IframeWrapper.GAPI_LOADER_SRC_,\n          {'onload': cbName});\n      // Load GApi loader.\n      var result = goog.Promise.resolve(goog.net.jsloader.safeLoad(url));\n      result.thenCatch(function(error) {\n        // In case library fails to load, typically due to a network error,\n        // reset cached loader to null to force a refresh on a retrial.\n        reject(new Error('Network Error'));\n      });\n    }\n  }).thenCatch(function(error) {\n    // Reset cached promise to allow for retrial.\n    fireauth.iframeclient.IframeWrapper.cachedGApiLoader_ = null;\n    throw error;\n  });\n  return fireauth.iframeclient.IframeWrapper.cachedGApiLoader_;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.AsyncStorage');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\n\n\n/**\n * AsyncStorage provides an interface to the React Native AsyncStorage API.\n * @param {!Object=} opt_asyncStorage The AsyncStorage API. If not provided\n *     this method will attempt to fetch an implementation from\n *     firebase.INTERNAL.reactNative.\n * @constructor\n * @implements {fireauth.storage.Storage}\n * @see https://facebook.github.io/react-native/docs/asyncstorage.html\n */\nfireauth.storage.AsyncStorage = function(opt_asyncStorage) {\n  /**\n   * The underlying storage instance for persistent data.\n   * @private\n   */\n  this.storage_ =\n      opt_asyncStorage || (firebase.INTERNAL['reactNative'] &&\n                           firebase.INTERNAL['reactNative']['AsyncStorage']);\n\n  if (!this.storage_) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'The React Native compatibility library was not found.');\n  }\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.ASYNC_STORAGE;\n};\n\n\n/**\n * Retrieves the value stored at the key.\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.AsyncStorage.prototype.get = function(key) {\n  return goog.Promise.resolve(this.storage_['getItem'](key))\n      .then(function(val) {\n        return val && fireauth.util.parseJSON(val);\n      });\n};\n\n\n/**\n * Stores the value at the specified key.\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.AsyncStorage.prototype.set = function(key, value) {\n  return goog.Promise.resolve(\n      this.storage_['setItem'](key, fireauth.util.stringifyJSON(value)));\n};\n\n\n/**\n * Removes the value at the specified key.\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.AsyncStorage.prototype.remove = function(key) {\n  return goog.Promise.resolve(this.storage_['removeItem'](key));\n};\n\n\n/**\n * Does nothing. AsyncStorage does not support storage events,\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.AsyncStorage.prototype.addStorageListener = function(\n    listener) {};\n\n\n/**\n * Does nothing. AsyncStorage does not support storage events,\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.AsyncStorage.prototype.removeStorageListener = function(\n    listener) {};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.Storage');\n\n\n\n/**\n * Defines a generic interface to storage APIs across platforms.\n * @interface\n */\nfireauth.storage.Storage = function() {};\n\n\n/**\n * Retrieves the value stored at the key.\n * @param {string} key\n * @return {!goog.Promise<*>}\n */\nfireauth.storage.Storage.prototype.get = function(key) {};\n\n\n/**\n * Stores the value at the specified key.\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n */\nfireauth.storage.Storage.prototype.set = function(key, value) {};\n\n\n/**\n * Removes the value at the specified key.\n * @param {string} key\n * @return {!goog.Promise<void>}\n */\nfireauth.storage.Storage.prototype.remove = function(key) {};\n\n\n/**\n * Adds a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)|function(!Array<string>)}\n *     listener The storage event listener.\n */\nfireauth.storage.Storage.prototype.addStorageListener = function(listener) {};\n\n\n/**\n * Removes a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)|function(!Array<string>)}\n *     listener The storage event listener.\n */\nfireauth.storage.Storage.prototype.removeStorageListener = function(listener) {\n};\n\n\n/** @type {string} The storage type identifier. */\nfireauth.storage.Storage.prototype.type;\n\n\n/**\n * Enum for the identifier of the type of underlying storage.\n * @enum {string}\n */\nfireauth.storage.Storage.Type = {\n  ASYNC_STORAGE: 'asyncStorage',\n  IN_MEMORY: 'inMemory',\n  INDEXEDDB: 'indexedDB',\n  LOCAL_STORAGE: 'localStorage',\n  MOCK_STORAGE: 'mockStorage',\n  NULL_STORAGE: 'nullStorage',\n  SESSION_STORAGE: 'sessionStorage'\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the MessageChannel based wrapper for receiving\n * messages from other windows or workers.\n */\n\ngoog.provide('fireauth.messagechannel.Receiver');\n\ngoog.require('fireauth.messagechannel.Status');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\ngoog.require('goog.object');\n\n\n/**\n * Initializes a channel to receive specific messages from a specified event\n * target.\n * Note receivers should not be manually instantiated. Instead `getInstance()`\n * should be used instead to get a receiver instance for a specified event\n * target.\n * @param {!EventTarget} eventTarget The event target to listen to.\n * @constructor\n */\nfireauth.messagechannel.Receiver = function(eventTarget) {\n  /**\n   * @const @private {!EventTarget} The messageChannel event target.\n   */\n  this.eventTarget_ = eventTarget;\n  /**\n   * @const @private {!Object.<string,\n   *                    !Array<function(string, *):!goog.Promise<?>|void>>}\n   *     This is the event type to handlers hash map. It is used to hold the\n   *     corresponding handlers for specified events.\n   */\n  this.eventHandlers_ = {};\n  /**\n   * @const @private {function(!Event)} The internal 'message' event handler\n   *     used to reroute the request to corresponding subscribed handlers.\n   */\n  this.messageEventHandler_ = goog.bind(this.handleEvent_, this);\n};\n\n\n/**\n * @param {!EventTarget} eventTarget The event target to check for.\n * @return {boolean} Whether the receiver is listening to the specified event\n *     target.\n */\nfireauth.messagechannel.Receiver.prototype.isListeningTo =\n    function(eventTarget) {\n  return this.eventTarget_ == eventTarget;\n};\n\n\n/**\n * @const @private {!Array<!fireauth.messagechannel.Receiver>} The list of all\n *     created `fireauth.messagechannel.Receiver` instances.\n */\nfireauth.messagechannel.Receiver.receivers_ = [];\n\n\n/**\n * Return a receiver instance for the specified event target. This is needed\n * since one instance can be available per event target. Otherwise receivers\n * could clobber each other.\n * @param {!EventTarget} eventTarget The event target to listen to.\n * @return {!fireauth.messagechannel.Receiver} The receiver instance for the\n *     specified event target.\n */\nfireauth.messagechannel.Receiver.getInstance = function(eventTarget) {\n  // The results are stored in an array since objects can't be keys for other\n  // objects. In addition, setting a unique property on an event target as a\n  // hash map key may not be allowed due to CORS restrictions.\n  var instance;\n  goog.array.forEach(\n      fireauth.messagechannel.Receiver.receivers_,\n      function(receiver) {\n        if (receiver.isListeningTo(eventTarget)) {\n          instance = receiver;\n        }\n      });\n  if (!instance) {\n    instance = new fireauth.messagechannel.Receiver(eventTarget);\n    fireauth.messagechannel.Receiver.receivers_.push(instance);\n  }\n  return instance;\n};\n\n\n/**\n * Handles a PostMessage event based on the following protocol:\n * <ul>\n * <li>When an event is first detected, check there is a subscribed handler.\n *     If not, do nothing as there could be other listeners.</li>\n * <li>If there is a subscribed event, reply with an ACK event to notify the\n *     sender that the event can be handled.</li>\n * <li>Trigger the subscribed handlers.</li>\n * <li>Reply again with the combined results of all subscribed handlers and\n *     return the response back.</li>\n * </ul>\n *\n * @param {!Event} event The PostMessage event to handle.\n * @private\n */\nfireauth.messagechannel.Receiver.prototype.handleEvent_ = function(event) {\n  // Respond to sender first with ack reply. This will let the client\n  // know that the service worker can handle this event.\n  var eventType = event.data['eventType'];\n  var eventId = event.data['eventId'];\n  var handlers = this.eventHandlers_[eventType];\n  if (handlers && handlers.length > 0) {\n    // Event can be handled.\n    event.ports[0].postMessage({\n      'status': fireauth.messagechannel.Status.ACK,\n      'eventId': eventId,\n      'eventType': eventType,\n      'response': null\n    });\n    var promises = [];\n    goog.array.forEach(handlers, function(handler) {\n      // Wrap in promise in case the handler doesn't return a promise.\n      promises.push(goog.Promise.resolve().then(function() {\n        return handler(event.origin, event.data['data']);\n      }));\n    });\n    // allSettled is more flexible as it executes all the promises passed and\n    // returns whether they succeeded or failed.\n    goog.Promise.allSettled(promises)\n        .then(function(result) {\n          // allResponse has the format:\n          // !Array<!{fulfilled: boolean, value: (*|undefined),\n          //          reason: (*|undefined)}>\n          // Respond to sender with ack reply.\n          // De-obfuscate the allSettled result.\n          var allResponses = [];\n          goog.array.forEach(result, function(item) {\n            allResponses.push({\n              'fulfilled': item.fulfilled,\n              'value': item.value,\n              // Error cannot be clone in postMessage.\n              'reason': item.reason ? item.reason.message : undefined\n            });\n          });\n          // Remove undefined fields.\n          goog.array.forEach(allResponses, function(item) {\n            for (var key in item) {\n              if (typeof item[key] === 'undefined') {\n                delete item[key];\n              }\n            }\n          });\n          event.ports[0].postMessage({\n            'status': fireauth.messagechannel.Status.DONE,\n            'eventId': eventId,\n            'eventType': eventType,\n            'response': allResponses\n          });\n        });\n  }\n  // Let unsupported events time out, as there could be external receivers\n  // that can handle them.\n};\n\n\n/**\n * Subscribes to events of the specified type.\n * @param {string} eventType The event type to listen to.\n * @param {function(string, *):!goog.Promise<?>|void} handler The async callback\n *     function to run when the event is triggered.\n */\nfireauth.messagechannel.Receiver.prototype.subscribe =\n    function(eventType, handler) {\n  if (goog.object.isEmpty(this.eventHandlers_)) {\n    this.eventTarget_.addEventListener('message', this.messageEventHandler_);\n  }\n  if (typeof this.eventHandlers_[eventType] === 'undefined') {\n    this.eventHandlers_[eventType] = [];\n  }\n  this.eventHandlers_[eventType].push(handler);\n};\n\n\n/**\n * Unsubscribes the specified handler from the specified event. If no handler\n * is specified, all handlers are unsubscribed.\n * @param {string} eventType The event type to unsubscribe from.\n * @param {?function(string, *):!goog.Promise<?>|void=} opt_handler The\n *     callback function to unsubscribe from the specified event type. If none\n *     is specified, all handlers are unsubscribed.\n */\nfireauth.messagechannel.Receiver.prototype.unsubscribe =\n    function(eventType, opt_handler) {\n  if (typeof this.eventHandlers_[eventType] !== 'undefined' && opt_handler) {\n    goog.array.removeAllIf(this.eventHandlers_[eventType], function(ele) {\n      return ele == opt_handler;\n    });\n    if (this.eventHandlers_[eventType].length == 0) {\n      delete this.eventHandlers_[eventType];\n    }\n  } else if (!opt_handler) {\n    // Unsubscribe all handlers for speficied event.\n    delete this.eventHandlers_[eventType];\n  }\n  if (goog.object.isEmpty(this.eventHandlers_)) {\n    this.eventTarget_.removeEventListener('message', this.messageEventHandler_);\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines a local storage interface with an indexedDB\n * implementation to be used as a fallback with browsers that do not synchronize\n * local storage changes between different windows of the same origin.\n */\n\ngoog.provide('fireauth.storage.IndexedDB');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.messagechannel.Receiver');\ngoog.require('fireauth.messagechannel.Sender');\ngoog.require('fireauth.messagechannel.WorkerClientPostMessager');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\ngoog.require('goog.array');\n\n\n\n/**\n * Initialize an indexedDB local storage manager used to mimic local storage\n * using an indexedDB underlying implementation including the ability to listen\n * to storage changes by key similar to localstorage storage event.\n * @param {string} dbName The indexedDB database name where all local storage\n *     data is to be stored.\n * @param {string} objectStoreName The indexedDB object store name where all\n *     local storage data is to be stored.\n * @param {string} dataKeyPath The indexedDB object store index name used to key\n *     all local storage data.\n * @param {string} valueKeyPath The indexedDB object store value field for each\n *     entry.\n * @param {number} version The indexedDB database version number.\n * @param {?IDBFactory=} opt_indexedDB The optional IndexedDB factory object.\n * @implements {fireauth.storage.Storage}\n * @constructor\n */\nfireauth.storage.IndexedDB = function(\n    dbName,\n    objectStoreName,\n    dataKeyPath,\n    valueKeyPath,\n    version,\n    opt_indexedDB) {\n  // indexedDB not available, fail hard.\n  if (!fireauth.storage.IndexedDB.isAvailable()) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.WEB_STORAGE_UNSUPPORTED);\n  }\n  /**\n   * @const @private {string} The indexedDB database name where all local\n   *     storage data is to be stored.\n   */\n  this.dbName_ = dbName;\n  /**\n   * @const @private {string} The indexedDB object store name where all local\n   *     storage data is to be stored.\n   */\n  this.objectStoreName_ = objectStoreName;\n  /**\n   * @const @private {string} The indexedDB object store index name used to key\n   *     all local storage data.\n   */\n  this.dataKeyPath_ = dataKeyPath;\n  /**\n   * @const @private {string} The indexedDB object store value field for each\n   *     entry.\n   */\n  this.valueKeyPath_ = valueKeyPath;\n  /** @const @private {number} The indexedDB database version number. */\n  this.version_ = version;\n  /** @private {!Object.<string, *>} The local indexedDB map copy. */\n  this.localMap_ = {};\n  /**\n   * @private {!Array<function(!Array<string>)>} Listeners to storage events.\n   */\n  this.storageListeners_ = [];\n  /** @private {number} The indexedDB pending write operations tracker. */\n  this.pendingOpsTracker_ = 0;\n  /** @private {!IDBFactory} The indexedDB factory object. */\n  this.indexedDB_ = /** @type {!IDBFactory} */ (\n      opt_indexedDB || goog.global.indexedDB);\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.INDEXEDDB;\n  /**\n   * @private {?goog.Promise<void>} The pending polling promise for syncing\n   *     unprocessed indexedDB external changes.\n   */\n  this.poll_ = null;\n  /**\n   * @private {?number} The poll timer ID for syncing external indexedDB\n   *     changes.\n   */\n  this.pollTimerId_ = null;\n  /**\n   * @private {?fireauth.messagechannel.Receiver} The messageChannel receiver if\n   *     running from a serviceworker.\n   */\n  this.receiver_ = null;\n  /**\n   * @private {?fireauth.messagechannel.Sender} The messageChannel sender to\n   *     send keyChanged messages to the service worker from the client.\n   */\n  this.sender_ = null;\n  /**\n   * @private {boolean} Whether the service worker has a receiver for the\n   *     keyChanged events.\n   */\n  this.serviceWorkerReceiverAvailable_ = false;\n  /** @private {?ServiceWorker} The current active service worker. */\n  this.activeServiceWorker_ = null;\n  var scope = this;\n  if (fireauth.util.getWorkerGlobalScope()) {\n    this.receiver_ = fireauth.messagechannel.Receiver.getInstance(\n        /** @type {!WorkerGlobalScope} */ (\n            fireauth.util.getWorkerGlobalScope()));\n    // Listen to indexedDB changes.\n    this.receiver_.subscribe('keyChanged', function(origin, request) {\n      // Sync data.\n      return scope.sync_().then(function(keys) {\n        // Trigger listeners if unhandled changes are detected.\n        if (keys.length > 0) {\n          goog.array.forEach(\n              scope.storageListeners_,\n              function(listener) {\n                listener(keys);\n              });\n        }\n        // When this is false, it means the change was already\n        // detected and processed before the notification.\n        return {\n          'keyProcessed': goog.array.contains(keys, request['key'])\n        };\n      });\n    });\n    // Used to inform sender that service worker what events it supports.\n    this.receiver_.subscribe('ping', function(origin, request) {\n      return goog.Promise.resolve(['keyChanged']);\n    });\n  } else {\n    // Get active service worker when its available.\n    fireauth.util.getActiveServiceWorker()\n        .then(function(sw) {\n          scope.activeServiceWorker_ = sw;\n          if (sw) {\n            // Initialize the sender.\n            scope.sender_ = new fireauth.messagechannel.Sender(\n                new fireauth.messagechannel.WorkerClientPostMessager(sw));\n            // Ping the service worker to check what events they can handle.\n            // Use long timeout.\n            scope.sender_.send('ping', null, true)\n                .then(function(results) {\n                  // Check if keyChanged is supported.\n                  if (results[0]['fulfilled'] &&\n                      goog.array.contains(results[0]['value'], 'keyChanged')) {\n                    scope.serviceWorkerReceiverAvailable_ = true;\n                  }\n                })\n                .thenCatch(function(error) {\n                  // Ignore error.\n                });\n          }\n        });\n  }\n};\n\n\n\n/**\n * The indexedDB database name where all local storage data is to be stored.\n * @private @const {string}\n */\nfireauth.storage.IndexedDB.DB_NAME_ = 'firebaseLocalStorageDb';\n\n\n/**\n * The indexedDB object store name where all local storage data is to be stored.\n * @private @const {string}\n */\nfireauth.storage.IndexedDB.DATA_OBJECT_STORE_NAME_ = 'firebaseLocalStorage';\n\n\n/**\n * The indexedDB object store index name used to key all local storage data.\n * @private @const {string}\n */\nfireauth.storage.IndexedDB.DATA_KEY_PATH_ = 'fbase_key';\n\n\n/**\n * The indexedDB object store value field for each entry.\n * @private @const {string}\n */\nfireauth.storage.IndexedDB.VALUE_KEY_PATH_ = 'value';\n\n\n/**\n * The indexedDB database version number.\n * @private @const {number}\n */\nfireauth.storage.IndexedDB.VERSION_ = 1;\n\n\n/**\n * The indexedDB polling delay time in milliseconds.\n * @private @const {number}\n */\nfireauth.storage.IndexedDB.POLLING_DELAY_ = 800;\n\n\n/**\n * The indexedDB polling stop error.\n * @private @const {string}\n */\nfireauth.storage.IndexedDB.STOP_ERROR_ = 'STOP_EVENT';\n\n\n\n/**\n * @return {!fireauth.storage.IndexedDB} The Firebase Auth indexedDB\n *     local storage manager.\n */\nfireauth.storage.IndexedDB.getFireauthManager = function() {\n  if (!fireauth.storage.IndexedDB.managerInstance_) {\n    fireauth.storage.IndexedDB.managerInstance_ =\n        new fireauth.storage.IndexedDB(\n            fireauth.storage.IndexedDB.DB_NAME_,\n            fireauth.storage.IndexedDB.DATA_OBJECT_STORE_NAME_,\n            fireauth.storage.IndexedDB.DATA_KEY_PATH_,\n            fireauth.storage.IndexedDB.VALUE_KEY_PATH_,\n            fireauth.storage.IndexedDB.VERSION_);\n  }\n  return fireauth.storage.IndexedDB.managerInstance_;\n};\n\n\n/**\n * Delete the indexedDB database.\n * @return {!goog.Promise<!IDBDatabase>} A promise that resolves on successful\n *     database deletion.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.deleteDb_ = function() {\n  var self = this;\n  return new goog.Promise(function(resolve, reject) {\n    var request = self.indexedDB_.deleteDatabase(self.dbName_);\n    request.onsuccess = function(event) {\n      resolve();\n    };\n    request.onerror = function(event) {\n      reject(new Error(event.target.error));\n    };\n  });\n};\n\n\n/**\n * Initializes The indexedDB database, creates it if not already created and\n * opens it.\n * @return {!goog.Promise<!IDBDatabase>} A promise for the database object.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.initializeDb_ = function() {\n  var self = this;\n  return new goog.Promise(function(resolve, reject) {\n    var request = self.indexedDB_.open(self.dbName_, self.version_);\n    request.onerror = function(event) {\n      // Suppress this from surfacing to browser console.\n      try {\n        event.preventDefault();\n      } catch (e) {}\n      reject(new Error(event.target.error));\n    };\n    request.onupgradeneeded = function(event) {\n      var db = event.target.result;\n      try {\n        db.createObjectStore(\n            self.objectStoreName_,\n            {\n              'keyPath': self.dataKeyPath_\n            });\n      } catch (e) {\n        reject(e);\n      }\n    };\n    request.onsuccess = function(event) {\n      var db = event.target.result;\n      // Strange bug that occurs in Firefox when multiple tabs are opened at the\n      // same time. The only way to recover seems to be deleting the database\n      // and re-initializing it.\n      // https://github.com/firebase/firebase-js-sdk/issues/634\n      if (!db.objectStoreNames.contains(self.objectStoreName_)) {\n        self.deleteDb_()\n            .then(function() {\n              return self.initializeDb_();\n            })\n            .then(function(newDb) {\n              resolve(newDb);\n            })\n            .thenCatch(function(e) {\n              reject(e);\n            });\n      } else {\n        resolve(db);\n      }\n    };\n  });\n};\n\n\n/**\n * Checks if indexedDB is initialized, if so, the callback is run, otherwise,\n * it waits for the db to initialize and then runs the callback function.\n * @return {!goog.Promise<!IDBDatabase>} A promise for the initialized indexedDB\n *     database.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.initializeDbAndRun_ =\n    function() {\n  if (!this.initPromise_) {\n    this.initPromise_ = this.initializeDb_();\n  }\n  return this.initPromise_;\n};\n\n\n/**\n * @return {boolean} Whether indexedDB is available or not.\n */\nfireauth.storage.IndexedDB.isAvailable = function() {\n  try {\n    return !!goog.global['indexedDB'];\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Creates a reference for the local storage indexedDB object store and returns\n * it.\n * @param {!IDBTransaction} tx The IDB transaction instance.\n * @return {!IDBObjectStore} The indexedDB object store.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.getDataObjectStore_ =\n    function(tx) {\n  return tx.objectStore(this.objectStoreName_);\n};\n\n\n/**\n * Creates an IDB transaction and returns it.\n * @param {!IDBDatabase} db The indexedDB instance.\n * @param {boolean} isReadWrite Whether the current indexedDB operation is a\n *     read/write operation or not.\n * @return {!IDBTransaction} The requested IDB transaction instance.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.getTransaction_ =\n    function(db, isReadWrite) {\n  var tx = db.transaction(\n      [this.objectStoreName_],\n      isReadWrite ? 'readwrite' : 'readonly');\n  return tx;\n};\n\n\n/**\n * @param {!IDBRequest} request The IDB request instance.\n * @return {!goog.Promise} The promise to resolve on transaction completion.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.onIDBRequest_ =\n    function(request) {\n  return new goog.Promise(function(resolve, reject) {\n    request.onsuccess = function(event) {\n      if (event && event.target) {\n        resolve(event.target.result);\n      } else {\n        resolve();\n      }\n    };\n    request.onerror = function(event) {\n      reject(event.target.error);\n    };\n  });\n};\n\n\n/**\n * Sets the item's identified by the key provided to the value passed. If the\n * item does not exist, it is created. An optional callback is run on success.\n * @param {string} key The storage key for the item to set. If the item exists,\n *     it is updated, otherwise created.\n * @param {*} value The value to store for the item to set.\n * @return {!goog.Promise<void>} A promise that resolves on operation success.\n * @override\n */\nfireauth.storage.IndexedDB.prototype.set = function(key, value) {\n  var isLocked = false;\n  var dbTemp;\n  var self = this;\n  return this.initializeDbAndRun_()\n      .then(function(db) {\n        dbTemp = db;\n        var objectStore = self.getDataObjectStore_(\n            self.getTransaction_(dbTemp, true));\n        return self.onIDBRequest_(objectStore.get(key));\n      })\n      .then(function(data) {\n        var objectStore = self.getDataObjectStore_(\n            self.getTransaction_(dbTemp, true));\n        if (data) {\n          // Update the value(s) in the object that you want to change\n          data.value = value;\n          // Put this updated object back into the database.\n          return self.onIDBRequest_(objectStore.put(data));\n        }\n        self.pendingOpsTracker_++;\n        isLocked = true;\n        var obj = {};\n        obj[self.dataKeyPath_] = key;\n        obj[self.valueKeyPath_] = value;\n        return self.onIDBRequest_(objectStore.add(obj));\n      })\n      .then(function() {\n        // Save in local copy to avoid triggering false external event.\n        self.localMap_[key] = value;\n        // Announce change in key to service worker.\n        return self.notifySW_(key);\n      })\n      .thenAlways(function() {\n        if (isLocked) {\n          self.pendingOpsTracker_--;\n        }\n      });\n};\n\n\n/**\n * Notify the service worker of the indexeDB write operation.\n * Waits until the operation is processed.\n * @param {string} key The key which is changing.\n * @return {!goog.Promise<void>} A promise that resolves on delivery.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.notifySW_ = function(key) {\n  // If sender is available.\n  // Run some sanity check to confirm no sw change occurred.\n  // For now, we support one service worker per page.\n  if (this.sender_ &&\n      this.activeServiceWorker_ &&\n      fireauth.util.getServiceWorkerController() ===\n      this.activeServiceWorker_) {\n    return this.sender_.send(\n        'keyChanged',\n        {'key': key},\n        // Use long timeout if receiver is known to be available.\n        this.serviceWorkerReceiverAvailable_)\n        .then(function(responses) {\n          // Return nothing.\n        })\n        .thenCatch(function(error) {\n          // This is a best effort approach. Ignore errors.\n        });\n  }\n  return goog.Promise.resolve();\n};\n\n\n/**\n * Retrieves a stored item identified by the key provided asynchronously.\n * The value is passed to the callback function provided.\n * @param {string} key The storage key for the item to fetch.\n * @return {!goog.Promise} A promise that resolves with the item's value, or\n *     null if the item is not found.\n * @override\n */\nfireauth.storage.IndexedDB.prototype.get = function(key) {\n  var self = this;\n  return this.initializeDbAndRun_()\n      .then(function(db) {\n        return self.onIDBRequest_(\n            self.getDataObjectStore_(self.getTransaction_(db, false)).get(key));\n      })\n      .then(function(response) {\n        return response && response.value;\n      });\n};\n\n\n/**\n * Deletes the item identified by the key provided and on success, runs the\n * optional callback.\n * @param {string} key The storage key for the item to remove.\n * @return {!goog.Promise<void>} A promise that resolves on operation success.\n * @override\n */\nfireauth.storage.IndexedDB.prototype.remove = function(key) {\n  var isLocked = false;\n  var self = this;\n  return this.initializeDbAndRun_()\n      .then(function(db) {\n        isLocked = true;\n        self.pendingOpsTracker_++;\n        return self.onIDBRequest_(\n            self.getDataObjectStore_(\n                self.getTransaction_(db, true))['delete'](key));\n      }).then(function() {\n        // Delete from local copy to avoid triggering false external event.\n        delete self.localMap_[key];\n        // Announce change in key to service worker.\n        return self.notifySW_(key);\n      }).thenAlways(function() {\n        if (isLocked) {\n          self.pendingOpsTracker_--;\n        }\n      });\n};\n\n\n/**\n * @return {!goog.Promise<!Array<string>>} A promise that resolved with all the\n *     storage keys that have changed.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.sync_ = function() {\n  var self = this;\n  return this.initializeDbAndRun_()\n      .then(function(db) {\n        var objectStore =\n            self.getDataObjectStore_(self.getTransaction_(db, false));\n        if (objectStore['getAll']) {\n          // Get all keys and value pairs using getAll if supported.\n          return self.onIDBRequest_(objectStore['getAll']());\n        } else {\n          // If getAll isn't supported, fallback to cursor.\n          return new goog.Promise(function(resolve, reject) {\n            var res = [];\n            var request = objectStore.openCursor();\n            request.onsuccess = function(event) {\n              var cursor = event.target.result;\n              if (cursor) {\n                res.push(cursor.value);\n                cursor['continue']();\n              } else {\n                resolve(res);\n              }\n            };\n            request.onerror = function(event) {\n              reject(event.target.error);\n            };\n          });\n        }\n      }).then(function(res) {\n        var centralCopy = {};\n        // List of keys differing from central copy.\n        var diffKeys = [];\n        // Build central copy (external copy).\n        if (self.pendingOpsTracker_ == 0) {\n          for (var i = 0; i < res.length; i++) {\n            centralCopy[res[i][self.dataKeyPath_]] =\n                res[i][self.valueKeyPath_];\n          }\n          // Get diff of central copy and local copy.\n          diffKeys = fireauth.util.getKeyDiff(self.localMap_, centralCopy);\n          // Update local copy.\n          self.localMap_ = centralCopy;\n        }\n        // Return modified keys.\n        return diffKeys;\n      });\n};\n\n\n/**\n * Adds a listener to storage event change.\n * @param {function(!Array<string>)} listener The storage event listener.\n * @override\n */\nfireauth.storage.IndexedDB.prototype.addStorageListener =\n    function(listener) {\n  // First listener, start listeners.\n  if (this.storageListeners_.length == 0) {\n    this.startListeners_();\n  }\n  this.storageListeners_.push(listener);\n};\n\n\n/**\n * Removes a listener to storage event change.\n * @param {function(!Array<string>)} listener The storage event listener.\n * @override\n */\nfireauth.storage.IndexedDB.prototype.removeStorageListener =\n    function(listener) {\n  goog.array.removeAllIf(\n      this.storageListeners_,\n      function(ele) {\n        return ele == listener;\n      });\n  // No more listeners, stop.\n  if (this.storageListeners_.length == 0) {\n    this.stopListeners_();\n  }\n};\n\n\n/**\n * Removes all listeners to storage event change.\n */\nfireauth.storage.IndexedDB.prototype.removeAllStorageListeners =\n    function() {\n  this.storageListeners_ = [];\n  // No more listeners, stop.\n  this.stopListeners_();\n};\n\n\n/**\n * Starts the listener to storage events.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.startListeners_ = function() {\n  var self = this;\n  // Stop any previous listeners.\n  this.stopListeners_();\n  var repeat = function() {\n    self.pollTimerId_ = setTimeout(\n        function() {\n          self.poll_ = self.sync_()\n              .then(function(keys) {\n                // If keys modified, call listeners.\n                if (keys.length > 0) {\n                  goog.array.forEach(\n                      self.storageListeners_,\n                      function(listener) {\n                        listener(keys);\n                      });\n                }\n              })\n              .then(function() {\n                repeat();\n              })\n              .thenCatch(function(error) {\n                if (error.message != fireauth.storage.IndexedDB.STOP_ERROR_) {\n                  repeat();\n                }\n              });\n        },\n        fireauth.storage.IndexedDB.POLLING_DELAY_);\n  };\n  repeat();\n};\n\n\n/**\n * Stops the listener to storage events.\n * @private\n */\nfireauth.storage.IndexedDB.prototype.stopListeners_ = function() {\n  if (this.poll_) {\n    // Cancel polling function.\n    this.poll_.cancel(fireauth.storage.IndexedDB.STOP_ERROR_);\n  }\n  // Clear any pending polling timer.\n  if (this.pollTimerId_) {\n    clearTimeout(this.pollTimerId_);\n    this.pollTimerId_ = null;\n  }\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the PostMessager interface needed for the\n * `fireauth.messagechannel.Sender`, in addition to 2 types of implementations.\n */\n\ngoog.provide('fireauth.messagechannel.PostMessager');\ngoog.provide('fireauth.messagechannel.WindowPostMessager');\ngoog.provide('fireauth.messagechannel.WorkerClientPostMessager');\n\n\n/**\n * This is the interface defining the postMessage format of a window which\n * takes an additional second parameter for target origin.\n *\n * @typedef {{\n *   postMessage: function(*, string, !Array<!Transferable>)\n * }}\n */\nfireauth.messagechannel.Window;\n\n\n/**\n * This is the interface defining the postMessage format of a worker or\n * ServiceWorkerClient, etc. which just takes a message and a list of\n * Transferables.\n *\n * @typedef {{\n *   postMessage: function(*, !Array<!Transferable>)\n * }}\n */\nfireauth.messagechannel.WorkerClient;\n\n\n/**\n * Defines a common interface to postMessage data to a specified PostMessager.\n * @interface\n */\nfireauth.messagechannel.PostMessager = function() {};\n\n\n/**\n * Sends a message to the specified context.\n * @param {*} message The message to send.\n * @param {!Array<!Transferable>} transfer The list of `Transferable` objects\n *     that are transferred with the message. The ownsership fo these objects is\n *     given to the destination side and they are no longer usable on the\n *     sending side.\n */\nfireauth.messagechannel.PostMessager.prototype.postMessage =\n    function(message, transfer) {};\n\n\n\n/**\n * Defines the implementation for postMessaging to a window context.\n * @param {!fireauth.messagechannel.Window} win The window PostMessager.\n * @param {?string=} opt_targetOrigin The target origin.\n * @constructor\n * @implements {fireauth.messagechannel.PostMessager}\n */\nfireauth.messagechannel.WindowPostMessager = function(win, opt_targetOrigin) {\n  /**\n   * @const @private {!fireauth.messagechannel.Window} The window PostMessager.\n   */\n  this.win_ = win;\n  /** @const @private {string} The postMessage target origin. */\n  this.targetOrigin_ = opt_targetOrigin || '*';\n};\n\n\n/**\n * Sends a message to the specified window context.\n * @param {*} message The message to send.\n * @param {!Array<!Transferable>} transfer The list of `Transferable` objects\n *     that are transferred with the message. The ownsership fo these objects is\n *     given to the destination side and they are no longer usable on the\n *     sending side.\n * @override\n */\nfireauth.messagechannel.WindowPostMessager.prototype.postMessage =\n    function(message, transfer) {\n  this.win_.postMessage(message, this.targetOrigin_, transfer);\n};\n\n\n/**\n * Defines the implementation for postMessaging to a worker/client context.\n * @param {!fireauth.messagechannel.WorkerClient} worker The worker/client\n *     PostMessager.\n * @constructor\n * @implements {fireauth.messagechannel.PostMessager}\n */\nfireauth.messagechannel.WorkerClientPostMessager = function(worker) {\n  /**\n   * @const @private {!fireauth.messagechannel.WorkerClient} The worker/client\n   *     PostMessager.\n   */\n  this.worker_ = worker;\n};\n\n\n/**\n * Sends a message to the specified worker/client context.\n * @param {*} message The message to send.\n * @param {!Array<!Transferable>} transfer The list of `Transferable` objects\n *     that are transferred with the message. The ownsership fo these objects is\n *     given to the destination side and they are no longer usable on the\n *     sending side.\n * @override\n */\nfireauth.messagechannel.WorkerClientPostMessager.prototype.postMessage =\n    function(message, transfer) {\n  this.worker_.postMessage(message, transfer);\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the MessageChannel based wrapper for sending messages\n * to other windows or workers.\n */\n\ngoog.provide('fireauth.messagechannel.Sender');\n\ngoog.require('fireauth.messagechannel.Error');\ngoog.require('fireauth.messagechannel.PostMessager');\ngoog.require('fireauth.messagechannel.Status');\ngoog.require('fireauth.messagechannel.TimeoutDuration');\ngoog.require('fireauth.messagechannel.utils');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\n\n\n/**\n * This is the interface defining a MessageChannel/handler pair.\n *\n * @typedef {{\n *   onMessage: function(!Event),\n *   messageChannel: !MessageChannel\n * }}\n */\nfireauth.messagechannel.MessageHandler;\n\n\n/**\n * Helper static function to create messageChannel errors.\n * @param {!fireauth.messagechannel.Error} errorId The error identifier.\n * @param {?string=} opt_message The optional error message used for generic\n *     error types.\n * @return {!Error} The constructed error to return.\n * @private\n */\nfireauth.messagechannel.createError_ = function(errorId, opt_message) {\n  if (errorId != fireauth.messagechannel.Error.UNKNOWN || !opt_message) {\n    return new Error(errorId);\n  } else {\n    return new Error(opt_message);\n  }\n};\n\n\n/**\n * Initializes a channel to send specific messages to a specified PostMessage.\n * @param {!fireauth.messagechannel.PostMessager} postMessager The post messager\n *     to send messages to.\n * @constructor\n */\nfireauth.messagechannel.Sender = function(postMessager) {\n  /**\n   * @const @private {!fireauth.messagechannel.PostMessager} The messageChannel\n   *     PostMessager.\n   */\n  this.postMessager_ = postMessager;\n  /** @private {boolean} Whether the connection was closed. */\n  this.closed_ = false;\n  /**\n   * @const @private {!Array<!fireauth.messagechannel.MessageHandler>} The list\n   *     of subscribed message handlers and their corresponding MessageChannels.\n   */\n  this.messageHandlers_ = [];\n};\n\n\n/**\n * Sends a message to the receiver. The message is identified by an event\n * type and can carry additional payload data.\n * The sender protocol works as follows:\n * <ul>\n * <li>The request is constructed and postMessaged to the receiver with the port\n *     used to reply back to sender.</li>\n * <li>The operation will block until an ACK response is received. If not, it\n *     will timeout and reject with an error.</li>\n * <li>If an ACK response is received, it will wait longer for the full\n *     processed response.</li>\n * <li>Once the response is received, the operation will resolve with that\n *     result.</li>\n * </ul>\n *\n * @param {string} eventType The event type identifying the message. This is\n *     used to help the receiver handle this message.\n * @param {?Object=} opt_data The optional data to send along the message.\n * @param {?boolean=} opt_useLongTimeout Whether long timeout should be used\n *     for ACK responses.\n * @return {!goog.Promise<!Array<{fulfilled: boolean,\n *                                value: (*|undefined),\n *                                reason: (*|undefined)}>>} A promise that\n *     resolves with the receiver responses.\n */\nfireauth.messagechannel.Sender.prototype.send = function(\n    eventType, opt_data, opt_useLongTimeout) {\n  var self = this;\n  var eventId;\n  var data = opt_data || {};\n  var onMessage;\n  var ackTimer;\n  var completionTimer;\n  var entry = null;\n  if (this.closed_) {\n    return goog.Promise.reject(fireauth.messagechannel.createError_(\n        fireauth.messagechannel.Error.CONNECTION_UNAVAILABLE));\n  }\n  var ackTimeout =\n      !!opt_useLongTimeout ?\n      fireauth.messagechannel.TimeoutDuration.LONG_ACK :\n      fireauth.messagechannel.TimeoutDuration.ACK;\n  var messageChannel =\n      fireauth.messagechannel.utils.initializeMessageChannel();\n  return new goog.Promise(function(resolve, reject) {\n    // Send message along with port for reply\n    if (messageChannel) {\n      eventId = fireauth.messagechannel.utils.generateEventId();\n      // Start the connection if not already started.\n      messageChannel.port1.start();\n      // Handler for receiving message reply from receiver.\n      // Blocks promise resolution until service worker detects the change.\n      ackTimer = setTimeout(function() {\n        // The receiver may not be able to handle the response for various\n        // reasons: library not included, or an incompatible version of\n        // the library is included.\n        // Timeout after some time.\n        reject(fireauth.messagechannel.createError_(\n            fireauth.messagechannel.Error.UNSUPPORTED_EVENT));\n      }, ackTimeout);\n      onMessage = function(event) {\n        // Process only the expected events that match current event ID.\n        if (event.data['eventId'] !== eventId) {\n          return;\n        }\n        // This avoids adding a long wait when the receiver is unable to handle\n        // the event.\n        if (event.data['status'] === fireauth.messagechannel.Status.ACK) {\n          clearTimeout(ackTimer);\n          // Set longer timeout to allow receiver to process.\n          completionTimer = setTimeout(function() {\n            reject(fireauth.messagechannel.createError_(\n                fireauth.messagechannel.Error.TIMEOUT));\n          }, fireauth.messagechannel.TimeoutDuration.COMPLETION);\n          return;\n        } else if (event.data['status'] ===\n                   fireauth.messagechannel.Status.DONE) {\n          clearTimeout(completionTimer);\n          if (typeof event.data['response'] !== 'undefined') {\n            resolve(event.data['response']);\n          } else {\n            reject(fireauth.messagechannel.createError_(\n                fireauth.messagechannel.Error.UNKNOWN));\n          }\n        } else {\n          clearTimeout(ackTimer);\n          clearTimeout(completionTimer);\n          reject(fireauth.messagechannel.createError_(\n              fireauth.messagechannel.Error.INVALID_RESPONSE));\n        }\n      };\n      entry = {\n        'messageChannel': messageChannel,\n        'onMessage': onMessage\n      };\n      self.messageHandlers_.push(entry);\n      messageChannel.port1.addEventListener('message', onMessage);\n      var request = {\n        'eventType': eventType,\n        'eventId': eventId,\n        'data': data\n      };\n      // It is possible the receiver cannot handle this result.\n      // For example, the developer may not be including the library in the\n      // receiver or using an outdated version.\n      self.postMessager_.postMessage(\n          request,\n          [messageChannel.port2]);\n    } else {\n      // No connection available.\n      reject(fireauth.messagechannel.createError_(\n          fireauth.messagechannel.Error.CONNECTION_UNAVAILABLE));\n    }\n  }).then(function(result) {\n    // On completion, remove the message handler. A new one is needed for a\n    // new message.\n    self.removeMessageHandler_(entry);\n    return result;\n  }).thenCatch(function(error) {\n    // On failure, remove the message handler. A new one is needed for a new\n    // message.\n    self.removeMessageHandler_(entry);\n    throw error;\n  });\n};\n\n\n/**\n * Removes the onMessage handler for the specified messageChannel.\n * @param {?fireauth.messagechannel.MessageHandler} messageHandler\n * @private\n */\nfireauth.messagechannel.Sender.prototype.removeMessageHandler_ =\n    function(messageHandler) {\n  if (!messageHandler) {\n    return;\n  }\n  var messageChannel = messageHandler['messageChannel'];\n  var onMessage = messageHandler['onMessage'];\n  if (messageChannel) {\n    messageChannel.port1.removeEventListener('message', onMessage);\n    messageChannel.port1.close();\n  }\n  goog.array.removeAllIf(this.messageHandlers_, function(ele) {\n    return ele == messageHandler;\n  });\n};\n\n\n/** Closes the underlying MessageChannel connection. */\nfireauth.messagechannel.Sender.prototype.close = function() {\n  // Any pending event will timeout.\n  while (this.messageHandlers_.length > 0) {\n    this.removeMessageHandler_(this.messageHandlers_[0]);\n  }\n  this.closed_ = true;\n};\n\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the MessageChannel common utilities and enums.\n */\n\ngoog.provide('fireauth.messagechannel.Error');\ngoog.provide('fireauth.messagechannel.Status');\ngoog.provide('fireauth.messagechannel.TimeoutDuration');\ngoog.provide('fireauth.messagechannel.utils');\n\n\n/**\n * Enum for the messagechannel error messages. These errors are not meant to be\n * user facing.\n * @enum {string}\n */\nfireauth.messagechannel.Error = {\n  CONNECTION_CLOSED: 'connection_closed',\n  CONNECTION_UNAVAILABLE: 'connection_unavailable',\n  INVALID_RESPONSE: 'invalid_response',\n  TIMEOUT: 'timeout',\n  UNKNOWN: 'unknown_error',\n  UNSUPPORTED_EVENT: 'unsupported_event'\n};\n\n\n/**\n * Enum for the message channel request status labels.\n * @enum {string}\n */\nfireauth.messagechannel.Status = {\n  ACK: 'ack',\n  DONE: 'done'\n};\n\n\n/**\n * Enum for the timeout durations in milliseconds for different contexts.\n * @enum {number}\n */\nfireauth.messagechannel.TimeoutDuration = {\n  ACK: 50,\n  COMPLETION: 3000,\n  // Used when a handler is confirmed to be available on the other side.\n  LONG_ACK: 800\n};\n\n\n/**\n * @param {?string=} opt_prefix An optional prefix string to prepend to ID.\n * @param {?number=} opt_digits An optional number of digits used for event ID.\n * @return {string} The generated event ID used to identify a generic event.\n */\nfireauth.messagechannel.utils.generateEventId =\n    function(opt_prefix, opt_digits) {\n  // 0, null and undefined will default to 20.\n  var digits = opt_digits || 20;\n  return opt_prefix ? opt_prefix : '' +\n      Math.floor(Math.random() * Math.pow(10, digits)).toString();\n};\n\n\n/**\n * @return {?MessageChannel} The initialized MessageChannel instance if\n *     supported.\n */\nfireauth.messagechannel.utils.initializeMessageChannel = function() {\n  return typeof MessageChannel !== 'undefined' ? new MessageChannel() : null;\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.HybridIndexedDB');\n\ngoog.require('fireauth.storage.IndexedDB');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\n\n/**\n * HybridStorage provides an interface to indexedDB, the persistent Web\n * Storage API for browsers that support it. This will fallback to the provided\n * fallback storage when indexedDB is not supported which is determined\n * asynchronously.\n * @param {!fireauth.storage.Storage} fallbackStorage The storage to fallback to\n *     when indexedDB is not available.\n * @constructor\n * @implements {fireauth.storage.Storage}\n */\nfireauth.storage.HybridIndexedDB = function(fallbackStorage) {\n  var self = this;\n  var storage = null;\n  /**\n   * @const @private {!Array<function((!goog.events.BrowserEvent|\n   *                                   !Array<string>))>} The storage listeners.\n   */\n  this.storageListeners_ = [];\n  // This type may change if the fallback is used.\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.INDEXEDDB;\n  /**\n   * @const @private {!fireauth.storage.Storage} The fallback storage when\n   *     indexedDB is unavailable.\n   */\n  this.fallbackStorage_ = fallbackStorage;\n  /**\n   * @const @private {!goog.Promise<!fireauth.storage.Storage>} A promise that\n   *     resolves with the underlying indexedDB storage or a fallback when not\n   *     supported.\n   */\n  this.underlyingStoragePromise_ = goog.Promise.resolve().then(function() {\n    // Initial check shows indexedDB is available. This is not enough.\n    // Try to write/read from indexedDB. If it fails, switch to fallback.\n    if (fireauth.storage.IndexedDB.isAvailable()) {\n      // Test write/read using a random key. This is important for the following\n      // reasons:\n      // 1. Double inclusion of the firebase-auth.js library.\n      // 2. Multiple windows opened at the same time.\n      // The above may cause collision if multiple instances try to\n      // write/read/delete from the same entry.\n      var randomId = fireauth.util.generateEventId();\n      var randomKey = fireauth.storage.HybridIndexedDB.KEY_ + randomId;\n      storage = fireauth.storage.IndexedDB.getFireauthManager();\n      return storage.set(randomKey, randomId)\n          .then(function() {\n            return storage.get(randomKey);\n          })\n          .then(function(value) {\n            if (value !== randomId) {\n              throw new Error('indexedDB not supported!');\n            }\n            return storage.remove(randomKey);\n          })\n          .then(function() {\n            return storage;\n          })\n          .thenCatch(function(error) {\n            return self.fallbackStorage_;\n          });\n    } else {\n      // indexedDB not available, use fallback.\n      return self.fallbackStorage_;\n    }\n  }).then(function(storage) {\n    // Update type.\n    self.type = storage.type;\n    // Listen to all storage changes.\n    storage.addStorageListener(function(key) {\n      // Trigger all attached storage listeners.\n      goog.array.forEach(self.storageListeners_, function(listener) {\n        listener(key);\n      });\n    });\n    return storage;\n  });\n};\n\n\n/**\n * The key used to check if the storage instance is available.\n * @private {string}\n * @const\n */\nfireauth.storage.HybridIndexedDB.KEY_ = '__sak';\n\n\n/**\n * Retrieves the value stored at the key.\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.HybridIndexedDB.prototype.get = function(key) {\n  return this.underlyingStoragePromise_.then(function(storage) {\n    return storage.get(key);\n  });\n};\n\n\n/**\n * Stores the value at the specified key.\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.HybridIndexedDB.prototype.set = function(key, value) {\n  return this.underlyingStoragePromise_.then(function(storage) {\n    return storage.set(key, value);\n  });\n};\n\n\n/**\n * Removes the value at the specified key.\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.HybridIndexedDB.prototype.remove = function(key) {\n  return this.underlyingStoragePromise_.then(function(storage) {\n    return storage.remove(key);\n  });\n};\n\n\n/**\n * Adds a listener to storage event change.\n * @param {function((!goog.events.BrowserEvent|!Array<string>))} listener The\n *     storage event listener.\n * @override\n */\nfireauth.storage.HybridIndexedDB.prototype.addStorageListener =\n    function(listener) {\n  this.storageListeners_.push(listener);\n};\n\n\n/**\n * Removes a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.HybridIndexedDB.prototype.removeStorageListener =\n    function(listener) {\n  goog.array.removeAllIf(this.storageListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.InMemoryStorage');\n\ngoog.require('goog.Promise');\n\n\n\n/**\n * InMemoryStorage provides an implementation of Storage that will only persist\n * data in memory. This data is volatile and in a browser environment, will\n * be lost on page unload and will only be available in the current window.\n * This is a useful fallback for browsers where web storage is disabled or\n * environments where the preferred storage mechanism is not available or not\n * supported.\n * @constructor\n * @implements {fireauth.storage.Storage}\n */\nfireauth.storage.InMemoryStorage = function() {\n  /** @protected {!Object} The object where we store values. */\n  this.storage = {};\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.IN_MEMORY;\n};\n\n\n/**\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.InMemoryStorage.prototype.get = function(key) {\n  return goog.Promise.resolve(/** @type {*} */ (this.storage[key]));\n};\n\n\n/**\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.InMemoryStorage.prototype.set = function(key, value) {\n  this.storage[key] = value;\n  return goog.Promise.resolve();\n};\n\n\n/**\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.InMemoryStorage.prototype.remove = function(key) {\n  delete this.storage[key];\n  return goog.Promise.resolve();\n};\n\n\n/**\n * @param {function((!goog.events.BrowserEvent|!Array<string>))} listener The\n *     storage event listener.\n * @override\n */\nfireauth.storage.InMemoryStorage.prototype.addStorageListener =\n    function(listener) {\n};\n\n\n/**\n * @param {function((!goog.events.BrowserEvent|!Array<string>))} listener The\n *     storage event listener.\n * @override\n */\nfireauth.storage.InMemoryStorage.prototype.removeStorageListener = function(\n    listener) {};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.LocalStorage');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.events');\n\n\n\n/**\n * LocalStorage provides an interface to localStorage, the persistent Web\n * Storage API.\n * @constructor\n * @implements {fireauth.storage.Storage}\n */\nfireauth.storage.LocalStorage = function() {\n  // Check is localStorage available in the current environment.\n  if (!fireauth.storage.LocalStorage.isAvailable()) {\n    // In a Node.js environment, dom-storage module needs to be required.\n    if (fireauth.util.getEnvironment() == fireauth.util.Env.NODE) {\n      throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n          'The LocalStorage compatibility library was not found.');\n    }\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.WEB_STORAGE_UNSUPPORTED);\n  }\n\n  /**\n   * The underlying storage instance for persistent data.\n   * @private {!Storage}\n   */\n  this.storage_ = /** @type {!Storage} */ (\n      fireauth.storage.LocalStorage.getGlobalStorage() ||\n      firebase.INTERNAL['node']['localStorage']);\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.LOCAL_STORAGE;\n};\n\n\n/** @return {?Storage|undefined} The global localStorage instance. */\nfireauth.storage.LocalStorage.getGlobalStorage = function() {\n  try {\n    var storage = goog.global['localStorage'];\n    // Try editing web storage. If an error is thrown, it may be disabled.\n    var key = fireauth.util.generateEventId();\n    if (storage) {\n      storage['setItem'](key, '1');\n      storage['removeItem'](key);\n    }\n    return storage;\n  } catch (e) {\n    // In some cases, browsers with web storage disabled throw an error simply\n    // on access.\n    return null;\n  }\n};\n\n\n/**\n * The key used to check if the storage instance is available.\n * @private {string}\n * @const\n */\nfireauth.storage.LocalStorage.STORAGE_AVAILABLE_KEY_ = '__sak';\n\n\n/** @return {boolean} Whether localStorage is available. */\nfireauth.storage.LocalStorage.isAvailable = function() {\n  // In Node.js localStorage is polyfilled.\n  var isNode = fireauth.util.getEnvironment() == fireauth.util.Env.NODE;\n  // Either window should provide this storage mechanism or in case of Node.js,\n  // firebase.INTERNAL should provide it.\n  var storage = fireauth.storage.LocalStorage.getGlobalStorage() ||\n      (isNode &&\n       firebase.INTERNAL['node'] &&\n       firebase.INTERNAL['node']['localStorage']);\n  if (!storage) {\n    return false;\n  }\n  try {\n    // setItem will throw an exception if we cannot access web storage (e.g.,\n    // Safari in private mode).\n    storage.setItem(fireauth.storage.LocalStorage.STORAGE_AVAILABLE_KEY_, '1');\n    storage.removeItem(fireauth.storage.LocalStorage.STORAGE_AVAILABLE_KEY_);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Retrieves the value stored at the key.\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.LocalStorage.prototype.get = function(key) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        var json = self.storage_.getItem(key);\n        return fireauth.util.parseJSON(json);\n      });\n};\n\n\n/**\n * Stores the value at the specified key.\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.LocalStorage.prototype.set = function(key, value) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        var obj = fireauth.util.stringifyJSON(value);\n        if (goog.isNull(obj)) {\n          self.remove(key);\n        } else {\n          self.storage_.setItem(key, obj);\n        }\n      });\n};\n\n\n/**\n * Removes the value at the specified key.\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.LocalStorage.prototype.remove = function(key) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        self.storage_.removeItem(key);\n      });\n};\n\n\n/**\n * Adds a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.LocalStorage.prototype.addStorageListener = function(\n    listener) {\n  if (goog.global['window']) {\n    goog.events.listen(goog.global['window'], 'storage', listener);\n  }\n};\n\n\n/**\n * Removes a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.LocalStorage.prototype.removeStorageListener = function(\n    listener) {\n  if (goog.global['window']) {\n    goog.events.unlisten(goog.global['window'], 'storage', listener);\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.NullStorage');\n\ngoog.require('fireauth.storage.Storage');\ngoog.require('goog.Promise');\n\n\n\n/**\n * NullStorage provides an implementation of Storage that does always returns\n * null. This can be used if a type of storage is unsupported on a platform.\n * @constructor\n * @implements {fireauth.storage.Storage}\n */\nfireauth.storage.NullStorage = function() {\n  /** @private {!Object} The object where we store values. */\n  this.storage_ = {};\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.NULL_STORAGE;\n};\n\n\n/**\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.NullStorage.prototype.get = function(key) {\n  return goog.Promise.resolve(/** @type {*} */ (null));\n};\n\n\n/**\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.NullStorage.prototype.set = function(key, value) {\n  return goog.Promise.resolve();\n};\n\n\n/**\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.NullStorage.prototype.remove = function(key) {\n  return goog.Promise.resolve();\n};\n\n\n/**\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.NullStorage.prototype.addStorageListener = function(listener) {\n};\n\n\n/**\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.NullStorage.prototype.removeStorageListener = function(\n    listener) {};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.SessionStorage');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\n\n\n\n/**\n * SessionStorage provides an interface to sessionStorage, the temporary web\n * storage API.\n * @constructor\n * @implements {fireauth.storage.Storage}\n */\nfireauth.storage.SessionStorage = function() {\n  // Check is sessionStorage available in the current environment.\n  if (!fireauth.storage.SessionStorage.isAvailable()) {\n    // In a Node.js environment, dom-storage module needs to be required.\n    if (fireauth.util.getEnvironment() == fireauth.util.Env.NODE) {\n      throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n          'The SessionStorage compatibility library was not found.');\n    }\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.WEB_STORAGE_UNSUPPORTED);\n  }\n\n  /**\n   * The underlying storage instance for temporary data.\n   * @private {!Storage}\n   */\n  this.storage_ = /** @type {!Storage} */ (\n      fireauth.storage.SessionStorage.getGlobalStorage() ||\n      firebase.INTERNAL['node']['sessionStorage']);\n  /** @public {string} The storage type identifier. */\n  this.type = fireauth.storage.Storage.Type.SESSION_STORAGE;\n};\n\n\n/** @return {?Storage|undefined} The global sessionStorage instance. */\nfireauth.storage.SessionStorage.getGlobalStorage = function() {\n  try {\n    var storage = goog.global['sessionStorage'];\n    // Try editing web storage. If an error is thrown, it may be disabled.\n    var key = fireauth.util.generateEventId();\n    if (storage) {\n      storage['setItem'](key, '1');\n      storage['removeItem'](key);\n    }\n    return storage;\n  } catch (e) {\n    // In some cases, browsers with web storage disabled throw an error simply\n    // on access.\n    return null;\n  }\n};\n\n\n/**\n * The key used to check if the storage instance is available.\n * @private {string}\n * @const\n */\nfireauth.storage.SessionStorage.STORAGE_AVAILABLE_KEY_ = '__sak';\n\n\n/** @return {boolean} Whether sessionStorage is available. */\nfireauth.storage.SessionStorage.isAvailable = function() {\n  // In Node.js sessionStorage is polyfilled.\n  var isNode = fireauth.util.getEnvironment() == fireauth.util.Env.NODE;\n  // Either window should provide this storage mechanism or in case of Node.js,\n  // firebase.INTERNAL should provide it.\n  var storage = fireauth.storage.SessionStorage.getGlobalStorage() ||\n      (isNode &&\n       firebase.INTERNAL['node'] &&\n       firebase.INTERNAL['node']['sessionStorage']);\n  if (!storage) {\n    return false;\n  }\n  try {\n    // setItem will throw an exception if we cannot access web storage (e.g.,\n    // Safari in private mode).\n    storage.setItem(\n        fireauth.storage.SessionStorage.STORAGE_AVAILABLE_KEY_, '1');\n    storage.removeItem(fireauth.storage.SessionStorage.STORAGE_AVAILABLE_KEY_);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Retrieves the value stored at the key.\n * @param {string} key\n * @return {!goog.Promise<*>}\n * @override\n */\nfireauth.storage.SessionStorage.prototype.get = function(key) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        var json = self.storage_.getItem(key);\n        return fireauth.util.parseJSON(json);\n      });\n};\n\n\n/**\n * Stores the value at the specified key.\n * @param {string} key\n * @param {*} value\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.SessionStorage.prototype.set = function(key, value) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        var obj = fireauth.util.stringifyJSON(value);\n        if (goog.isNull(obj)) {\n          self.remove(key);\n        } else {\n          self.storage_.setItem(key, obj);\n        }\n      });\n};\n\n\n/**\n * Removes the value at the specified key.\n * @param {string} key\n * @return {!goog.Promise<void>}\n * @override\n */\nfireauth.storage.SessionStorage.prototype.remove = function(key) {\n  var self = this;\n  return goog.Promise.resolve()\n      .then(function() {\n        self.storage_.removeItem(key);\n      });\n};\n\n\n/**\n * Adds a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.SessionStorage.prototype.addStorageListener = function(\n    listener) {};\n\n\n/**\n * Removes a listener to storage event change.\n * @param {function(!goog.events.BrowserEvent)} listener The storage event\n *     listener.\n * @override\n */\nfireauth.storage.SessionStorage.prototype.removeStorageListener = function(\n    listener) {};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.storage.Factory');\ngoog.provide('fireauth.storage.Factory.EnvConfig');\n\ngoog.require('fireauth.storage.AsyncStorage');\ngoog.require('fireauth.storage.HybridIndexedDB');\ngoog.require('fireauth.storage.InMemoryStorage');\ngoog.require('fireauth.storage.LocalStorage');\ngoog.require('fireauth.storage.NullStorage');\ngoog.require('fireauth.storage.SessionStorage');\ngoog.require('fireauth.util');\n\n\n/**\n * Factory manages the storage implementations and determines the correct one\n * for the current environment.\n * @param {!fireauth.storage.Factory.EnvConfigType} env The storage\n *     configuration for the current environment.\n * @constructor\n */\nfireauth.storage.Factory = function(env) {\n  /** @const @private {!fireauth.storage.Factory.EnvConfigType} */\n  this.env_ = env;\n};\n\n\n/**\n * Construct the singleton instance of the Factory, automatically detecting\n * the current environment.\n * @return {!fireauth.storage.Factory}\n */\nfireauth.storage.Factory.getInstance = function() {\n  if (!fireauth.storage.Factory.instance_) {\n    fireauth.storage.Factory.instance_ =\n        new fireauth.storage.Factory(fireauth.storage.Factory.getEnvConfig());\n  }\n  return fireauth.storage.Factory.instance_;\n};\n\n\n/**\n * @typedef {{\n *   persistent: function(new:fireauth.storage.Storage),\n *   temporary: function(new:fireauth.storage.Storage)\n * }}\n */\nfireauth.storage.Factory.EnvConfigType;\n\n\n/**\n * Configurations of storage for different environments.\n * @enum {!fireauth.storage.Factory.EnvConfigType}\n */\nfireauth.storage.Factory.EnvConfig = {\n  BROWSER: {\n    persistent: fireauth.storage.LocalStorage,\n    temporary: fireauth.storage.SessionStorage\n  },\n  NODE: {\n    persistent: fireauth.storage.LocalStorage,\n    temporary: fireauth.storage.SessionStorage\n  },\n  REACT_NATIVE: {\n    persistent: fireauth.storage.AsyncStorage,\n    temporary: fireauth.storage.NullStorage\n  },\n  WORKER: {\n    persistent: fireauth.storage.LocalStorage,\n    temporary: fireauth.storage.NullStorage\n  }\n};\n\n\n/**\n * Detects the current environment and returns the appropriate environment\n * configuration.\n * @return {!fireauth.storage.Factory.EnvConfigType}\n */\nfireauth.storage.Factory.getEnvConfig = function() {\n  var envMap = {};\n  envMap[fireauth.util.Env.BROWSER] =\n      fireauth.storage.Factory.EnvConfig.BROWSER;\n  envMap[fireauth.util.Env.NODE] =\n      fireauth.storage.Factory.EnvConfig.NODE;\n  envMap[fireauth.util.Env.REACT_NATIVE] =\n      fireauth.storage.Factory.EnvConfig.REACT_NATIVE;\n  envMap[fireauth.util.Env.WORKER] =\n      fireauth.storage.Factory.EnvConfig.WORKER;    \n  return envMap[fireauth.util.getEnvironment()];\n};\n\n\n/**\n * @return {!fireauth.storage.Storage} The persistent storage instance.\n */\nfireauth.storage.Factory.prototype.makePersistentStorage = function() {\n  if (fireauth.util.persistsStorageWithIndexedDB()) {\n    // If persistent storage is implemented using indexedDB, use indexedDB.\n    // Use HybridIndexedDB instead of indexedDB directly since this will\n    // fallback to a fallback storage when indexedDB is not supported (private\n    // browsing mode, etc).\n    return new fireauth.storage.HybridIndexedDB(\n        fireauth.util.isWorker() ?\n        new fireauth.storage.InMemoryStorage() : new this.env_.persistent());\n  }\n  return new this.env_.persistent();\n};\n\n\n/**\n * @return {!fireauth.storage.Storage} The temporary storage instance.\n */\nfireauth.storage.Factory.prototype.makeTemporaryStorage = function() {\n  return new this.env_.temporary();\n};\n\n\n/**\n * @return {!fireauth.storage.Storage} An in memory storage instance.\n */\nfireauth.storage.Factory.prototype.makeInMemoryStorage = function() {\n  return new fireauth.storage.InMemoryStorage();\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines utilities for session management.\n */\n\ngoog.provide('fireauth.authStorage');\ngoog.provide('fireauth.authStorage.Key');\ngoog.provide('fireauth.authStorage.Manager');\ngoog.provide('fireauth.authStorage.Persistence');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.storage.Factory');\ngoog.require('fireauth.storage.Storage');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\ngoog.require('goog.events');\ngoog.require('goog.object');\n\n\n\n/**\n * The namespace for Firebase Auth storage.\n * @private @const {string}\n */\nfireauth.authStorage.NAMESPACE_ = 'firebase';\n\n\n/**\n * The separator for Firebase Auth storage with App ID key.\n * @private @const {string}\n */\nfireauth.authStorage.SEPARATOR_ = ':';\n\n\n/**\n * @const {number} The IE 10 localStorage cross tab synchronization delay in\n *     milliseconds.\n */\nfireauth.authStorage.IE10_LOCAL_STORAGE_SYNC_DELAY = 10;\n\n\n/**\n * Enums for Auth state persistence.\n * @enum {string}\n */\nfireauth.authStorage.Persistence = {\n  // State will persist even when the browser window is closed or the activity\n  // is destroyed in react-native.\n  LOCAL: 'local',\n  // State is only stored in memory and will be cleared when the window or\n  // activity is refreshed.\n  NONE: 'none',\n  // State will only persist in current session/tab, relevant to web only, and\n  // will be cleared when the tab is closed.\n  SESSION: 'session'\n};\n\n\n/**\n * Validates that an argument is a valid persistence value. If an invalid type\n * is specified, an error is thrown synchronously.\n * @param {*} arg The argument to validate.\n */\nfireauth.authStorage.validatePersistenceArgument =\n    function(arg) {\n  // Invalid type error.\n  var invalidTypeError = new fireauth.AuthError(\n      fireauth.authenum.Error.INVALID_PERSISTENCE);\n  // Unsupported type error.\n  var unsupportedTypeError = new fireauth.AuthError(\n      fireauth.authenum.Error.UNSUPPORTED_PERSISTENCE);\n  // Check if the persistence type is a valid one.\n  // Throw invalid type error if not valid.\n  if (!goog.object.containsValue(fireauth.authStorage.Persistence, arg) ||\n      // goog.object.containsValue(fireauth.authStorage.Persistence, ['none'])\n      // returns true.\n      typeof arg !== 'string') {\n    throw invalidTypeError;\n  }\n  // Validate if the specified type is supported in the current environment.\n  switch (fireauth.util.getEnvironment()) {\n    case fireauth.util.Env.REACT_NATIVE:\n      // This is only supported in a browser.\n      if (arg === fireauth.authStorage.Persistence.SESSION) {\n        throw unsupportedTypeError;\n      }\n      break;\n    case fireauth.util.Env.NODE:\n      // Only none is supported in Node.js.\n      if (arg !== fireauth.authStorage.Persistence.NONE) {\n        throw unsupportedTypeError;\n      }\n      break;\n    case fireauth.util.Env.BROWSER:\n    default:\n      // This is restricted by what the browser supports.\n      if (!fireauth.util.isWebStorageSupported() &&\n          arg !== fireauth.authStorage.Persistence.NONE) {\n        throw unsupportedTypeError;\n      }\n      break;\n  }\n};\n\n\n/**\n * Storage key metadata.\n * @typedef {{name: string, persistent: !fireauth.authStorage.Persistence}}\n */\nfireauth.authStorage.Key;\n\n\n/**\n * Storage manager.\n * @param {string} namespace The optional namespace.\n * @param {string} separator The optional separator.\n * @param {boolean} safariLocalStorageNotSynced Whether browser has Safari\n *     iframe restriction with storage event triggering but storage not updated.\n * @param {boolean} runsInBackground Whether browser can detect storage event\n *     when it had already been pushed to the background. This may happen in\n *     some mobile browsers. A localStorage change in the foreground window\n *     will not be detected in the background window via the storage event.\n *     This was detected in iOS 7.x mobile browsers.\n * @param {boolean} webStorageSupported Whether browser web storage is\n *     supported.\n * @constructor @struct @final\n */\nfireauth.authStorage.Manager = function(\n    namespace,\n    separator,\n    safariLocalStorageNotSynced,\n    runsInBackground,\n    webStorageSupported) {\n  /** @const @private {string} Storage namespace. */\n  this.namespace_ = namespace;\n  /** @const @private {string} Storage namespace key separator. */\n  this.separator_ = separator;\n  /**\n   * @const @private {boolean} Whether browser has Safari iframe restriction\n   *     with storage event triggering but storage not updated.\n   */\n  this.safariLocalStorageNotSynced_ = safariLocalStorageNotSynced;\n  /**\n   *  @private {boolean} Whether browser can detect storage event when it\n   *     had already been pushed to the background. This may happen in some\n   *     mobile browsers.\n   */\n  this.runsInBackground_ = runsInBackground;\n  /**  @const @private {boolean} Whether browser web storage is supported. */\n  this.webStorageSupported_ = webStorageSupported;\n\n  /**\n   * @const @private {!Object.<string, !Array<function()>>} The storage event\n   *     key to listeners map.\n   */\n  this.listeners_ = {};\n\n  var storageFactory = fireauth.storage.Factory.getInstance();\n  try {\n    /**\n     * @private {!fireauth.storage.Storage} Persistence storage.\n     */\n    this.persistentStorage_ = storageFactory.makePersistentStorage();\n  } catch (e) {\n    // Default to in memory storage if the preferred persistent storage is not\n    // supported.\n    this.persistentStorage_ = storageFactory.makeInMemoryStorage();\n    // Do not use indexedDB fallback.\n    this.localStorageNotSynchronized_ = false;\n    // Do not set polling functions on window.localStorage.\n    this.runsInBackground_ = true;\n  }\n  try {\n    /**\n     * @private {!fireauth.storage.Storage} Temporary session storage.\n     */\n    this.temporaryStorage_ = storageFactory.makeTemporaryStorage();\n  } catch (e) {\n    // Default to in memory storage if the preferred temporary storage is not\n    // supported. This should be a different in memory instance as the\n    // persistent storage, since the same key could be available for both types\n    // of storage.\n    this.temporaryStorage_ = storageFactory.makeInMemoryStorage();\n  }\n  /**\n   * @private {!fireauth.storage.Storage} In memory storage.\n   */\n  this.inMemoryStorage_ = storageFactory.makeInMemoryStorage();\n\n  /**\n   * @const @private {function(!goog.events.BrowserEvent)|\n   *                  function(!Array<string>)} Storage change handler.\n   */\n  this.storageChangeEventHandler_ = goog.bind(this.storageChangeEvent_, this);\n  /** @private {!Object.<string, *>} Local map for localStorage. */\n  this.localMap_ = {};\n};\n\n\n/**\n * @return {!fireauth.authStorage.Manager} The default Auth storage manager\n *     instance.\n */\nfireauth.authStorage.Manager.getInstance = function() {\n  // Creates the default instance for Auth storage maanger.\n  if (!fireauth.authStorage.Manager.instance_) {\n    /**\n     * @private {?fireauth.authStorage.Manager} The default storage manager\n     *     instance.\n     */\n    fireauth.authStorage.Manager.instance_ = new fireauth.authStorage.Manager(\n        fireauth.authStorage.NAMESPACE_,\n        fireauth.authStorage.SEPARATOR_,\n        fireauth.util.isSafariLocalStorageNotSynced(),\n        fireauth.util.runsInBackground(),\n        fireauth.util.isWebStorageSupported());\n  }\n  return fireauth.authStorage.Manager.instance_;\n};\n\n\n/** Clears storage manager instances. This is used for testing. */\nfireauth.authStorage.Manager.clear = function() {\n  fireauth.authStorage.Manager.instance_ = null;\n};\n\n\n/**\n * Returns the storage corresponding to the specified persistence.\n * @param {!fireauth.authStorage.Persistence} persistent The type of storage\n *     persistence.\n * @return {!fireauth.storage.Storage} The corresponding storage instance.\n * @private\n */\nfireauth.authStorage.Manager.prototype.getStorage_ = function(persistent) {\n  switch (persistent) {\n    case fireauth.authStorage.Persistence.SESSION:\n      return this.temporaryStorage_;\n    case fireauth.authStorage.Persistence.NONE:\n      return this.inMemoryStorage_;\n    case fireauth.authStorage.Persistence.LOCAL:\n    default:\n      return this.persistentStorage_;\n  }\n};\n\n\n/**\n * Constructs the corresponding storage key name.\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {?string=} opt_id This ID associates storage values with specific\n *     apps.\n * @return {string} The corresponding key name with namespace prefixed.\n * @private\n */\nfireauth.authStorage.Manager.prototype.getKeyName_ = function(dataKey, opt_id) {\n  return this.namespace_ + this.separator_ + dataKey.name +\n      (opt_id ? this.separator_ + opt_id : '');\n};\n\n\n/**\n * Migrates window.localStorage to the provided persistent storage.\n * @param {fireauth.authStorage.Key} dataKey The key under which the persistent\n *     value is supposed to be stored.\n * @param {?string=} opt_id When operating in multiple app mode, this ID\n *     associates storage values with specific apps.\n * @return {!goog.Promise<void>} A promise that resolves when the data stored\n *     in window.localStorage is migrated to the provided persistent storage\n *     identified by the provided data key.\n */\nfireauth.authStorage.Manager.prototype.migrateFromLocalStorage =\n    function(dataKey, opt_id) {\n  var self = this;\n  var key = this.getKeyName_(dataKey, opt_id);\n  var storage = this.getStorage_(dataKey.persistent);\n  // Get data stored in the default persistent storage identified by dataKey.\n  return this.get(dataKey, opt_id).then(function(response) {\n    // Get the stored value in window.localStorage if available.\n    var oldStorageValue = null;\n    try {\n      oldStorageValue = fireauth.util.parseJSON(\n          goog.global['localStorage']['getItem'](key));\n    } catch (e) {\n      // Set value as null. This will resolve the promise immediately.\n    }\n    // If data is stored in window.localStorage but no data is available in\n    // default persistent storage, migrate data from window.localStorage to\n    // default persistent storage.\n    if (oldStorageValue && !response) {\n      // This condition may fail in situations where a user opens a tab with\n      // an old version while using a tab with a new version, or when a\n      // developer switches back and forth between and old and new version of\n      // the library.\n      goog.global['localStorage']['removeItem'](key);\n      // Migrate the value to new default persistent storage.\n      return self.set(dataKey, oldStorageValue, opt_id);\n    } else if (oldStorageValue &&\n               response &&\n               storage.type != fireauth.storage.Storage.Type.LOCAL_STORAGE) {\n      // Data stored in both localStorage and new persistent storage (eg.\n      // indexedDB) for some reason.\n      // This could happen if the developer is migrating back and forth.\n      // The new default persistent storage (eg. indexedDB) takes precedence.\n      goog.global['localStorage']['removeItem'](key);\n    }\n  });\n};\n\n\n/**\n * Gets the stored value from the corresponding storage.\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {?string=} opt_id When operating in multiple app mode, this ID\n *     associates storage values with specific apps.\n * @return {!goog.Promise} A Promise that resolves with the stored value.\n */\nfireauth.authStorage.Manager.prototype.get = function(dataKey, opt_id) {\n  var keyName = this.getKeyName_(dataKey, opt_id);\n  return this.getStorage_(dataKey.persistent).get(keyName);\n};\n\n\n/**\n * Removes the stored value from the corresponding storage.\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {?string=} opt_id When operating in multiple app mode, this ID\n *     associates storage values with specific apps.\n * @return {!goog.Promise<void>} A Promise that resolves when the operation is\n *     completed.\n */\nfireauth.authStorage.Manager.prototype.remove = function(dataKey, opt_id) {\n  var keyName = this.getKeyName_(dataKey, opt_id);\n  // Keep local map up to date for requested key if persistent storage is used.\n  if (dataKey.persistent == fireauth.authStorage.Persistence.LOCAL) {\n    this.localMap_[keyName] = null;\n  }\n  return this.getStorage_(dataKey.persistent).remove(keyName);\n};\n\n\n/**\n * Stores the value in the corresponding storage.\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {*} value The value to be stored.\n * @param {?string=} opt_id When operating in multiple app mode, this ID\n *     associates storage values with specific apps.\n * @return {!goog.Promise<void>} A Promise that resolves when the operation is\n *     completed.\n */\nfireauth.authStorage.Manager.prototype.set = function(dataKey, value, opt_id) {\n  var keyName = this.getKeyName_(dataKey, opt_id);\n  var self = this;\n  var storage = this.getStorage_(dataKey.persistent);\n  return storage.set(keyName, value)\n      .then(function() {\n        return storage.get(keyName);\n      })\n      .then(function(serializedValue) {\n        // Keep local map up to date for requested key if persistent storage is\n        // used.\n        if (dataKey.persistent == fireauth.authStorage.Persistence.LOCAL) {\n          self.localMap_[keyName] = serializedValue;\n        }\n      });\n};\n\n\n/**\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {?string} id When operating in multiple app mode, this ID associates\n *     storage values with specific apps.\n * @param {function()} listener The callback listener to run on storage event\n *     related to key.\n */\nfireauth.authStorage.Manager.prototype.addListener =\n    function(dataKey, id, listener) {\n  var key = this.getKeyName_(dataKey, id);\n  // Initialize local map for current key if web storage is supported.\n  if (this.webStorageSupported_) {\n    this.localMap_[key] = goog.global['localStorage']['getItem'](key);\n  }\n  if (goog.object.isEmpty(this.listeners_)) {\n    // Start listeners.\n    this.startListeners_();\n  }\n  if (!this.listeners_[key]) {\n    this.listeners_[key] = [];\n  }\n  this.listeners_[key].push(listener);\n};\n\n\n/**\n * @param {fireauth.authStorage.Key} dataKey The key under which the value is\n *     stored.\n * @param {?string} id When operating in multiple app mode, this ID associates\n *     storage values with specific apps.\n * @param {function()} listener The listener to remove.\n */\nfireauth.authStorage.Manager.prototype.removeListener =\n    function(dataKey, id, listener) {\n  var key = this.getKeyName_(dataKey, id);\n  if (this.listeners_[key]) {\n    goog.array.removeAllIf(\n        this.listeners_[key],\n        function(ele) {\n          return ele == listener;\n        });\n    if (this.listeners_[key].length == 0) {\n      delete this.listeners_[key];\n    }\n  }\n  if (goog.object.isEmpty(this.listeners_)) {\n    // Stop listeners.\n    this.stopListeners_();\n  }\n};\n\n\n/**\n * The delay to wait between continuous checks of localStorage on browsers where\n * tabs do not run in the background. After each interval wait, we check for\n * external changes in localStorage that were not detected in the current tab.\n * @const {number}\n * @private\n */\nfireauth.authStorage.Manager.LOCAL_STORAGE_POLLING_TIMER_ = 1000;\n\n\n/**\n * Starts all storage event listeners.\n * @private\n */\nfireauth.authStorage.Manager.prototype.startListeners_ = function() {\n  this.getStorage_(fireauth.authStorage.Persistence.LOCAL)\n      .addStorageListener(this.storageChangeEventHandler_);\n  // TODO: refactor this implementation to be handled by the underlying\n  // storage mechanism.\n  if (!this.runsInBackground_ &&\n      // Add an exception for browsers that persist storage with indexedDB, we\n      // should stick with indexedDB listener implementation in that case.\n      !fireauth.util.persistsStorageWithIndexedDB() &&\n      // Confirm browser web storage is supported as polling relies on it.\n      this.webStorageSupported_) {\n    this.startManualListeners_();\n  }\n};\n\n/**\n * Starts manual polling function to detect storage event changes.\n * @private\n */\nfireauth.authStorage.Manager.prototype.startManualListeners_ = function() {\n  var self = this;\n  this.stopManualListeners_();\n  /** @private {?number} The interval timer for manual storage checking. */\n  this.manualListenerTimer_ = setInterval(function() {\n    // Check all keys with listeners on them.\n    for (var key in self.listeners_) {\n      // Get value from localStorage.\n      var currentValue = goog.global['localStorage']['getItem'](key);\n      var oldValue = self.localMap_[key];\n      // If local map value does not match, trigger listener with storage event.\n      if (currentValue != oldValue) {\n        self.localMap_[key] = currentValue;\n        var event = new goog.events.BrowserEvent(/** @type {!Event} */ ({\n          type: 'storage',\n          key: key,\n          target: window,\n          oldValue: oldValue,\n          newValue: currentValue,\n          // Differentiate this simulated event from the real storage event.\n          poll: true\n        }));\n        self.storageChangeEvent_(event);\n      }\n    }\n  }, fireauth.authStorage.Manager.LOCAL_STORAGE_POLLING_TIMER_);\n};\n\n\n/**\n * Stops manual polling function to detect storage event changes.\n * @private\n */\nfireauth.authStorage.Manager.prototype.stopManualListeners_ = function() {\n  if (this.manualListenerTimer_) {\n    clearInterval(this.manualListenerTimer_);\n    this.manualListenerTimer_ = null;\n  }\n};\n\n\n/**\n * Stops all storage event listeners.\n * @private\n */\nfireauth.authStorage.Manager.prototype.stopListeners_ = function() {\n  this.getStorage_(fireauth.authStorage.Persistence.LOCAL)\n      .removeStorageListener(this.storageChangeEventHandler_);\n  this.stopManualListeners_();\n};\n\n\n/**\n * @param {!goog.events.BrowserEvent|!Array<string>} data The storage event\n *     triggered or the array of keys modified.\n * @private\n */\nfireauth.authStorage.Manager.prototype.storageChangeEvent_ = function(data) {\n  if (data && data.getBrowserEvent) {\n    var event = /** @type {!goog.events.BrowserEvent} */ (data);\n    var key = event.getBrowserEvent().key;\n    // Key would be null in some situations, like when localStorage is cleared\n    // from the browser developer tools.\n    if (key == null) {\n      // For all keys of interest.\n      for (var keyName in this.listeners_) {\n        // Check if something changed in this key's real value.\n        var storedValue = this.localMap_[keyName];\n        // localStorage returns null when a field is not found.\n        if (typeof storedValue === 'undefined') {\n          storedValue = null;\n        }\n        var realValue = goog.global['localStorage']['getItem'](keyName);\n        if (realValue !== storedValue) {\n          // Update local map with real value.\n          this.localMap_[keyName] = realValue;\n          // Trigger that key's listener.\n          this.callListeners_(keyName);\n        }\n      }\n      return;\n    }\n    // Check if the key is Firebase Auth related, otherwise ignore.\n    if (key.indexOf(this.namespace_ + this.separator_) != 0 ||\n        // Ignore keys that have no listeners.\n        !this.listeners_[key]) {\n      return;\n    }\n    // Check the mechanism how this event was detected.\n    // The first event will dictate the mechanism to be used.\n    // Do not use hasOwnProperty('poll') as poll gets obfuscated.\n    if (typeof event.getBrowserEvent().poll !== 'undefined') {\n      // Environment detects storage changes via polling.\n      // Remove storage event listener to prevent possible event duplication.\n      this.getStorage_(fireauth.authStorage.Persistence.LOCAL)\n          .removeStorageListener(this.storageChangeEventHandler_);\n    } else {\n      // Environment detects storage changes via storage event listener.\n      // Remove polling listener to prevent possible event duplication.\n      this.stopManualListeners_();\n    }\n    // Safari embedded iframe. Storage event will trigger with the delta changes\n    // but no changes will be applied to the iframe localStorage.\n    if (this.safariLocalStorageNotSynced_) {\n      // Get current iframe page value, old value and new value.\n      var currentValue = goog.global['localStorage']['getItem'](key);\n      var newValue = event.getBrowserEvent().newValue;\n      // Value not synchronized, synchronize manually.\n      if (newValue !== currentValue) {\n        if (newValue !== null) {\n          // Value changed from current value.\n          goog.global['localStorage']['setItem'](key, newValue);\n        } else {\n          // Current value deleted.\n          goog.global['localStorage']['removeItem'](key);\n        }\n      } else {\n        // Already detected and processed, do not trigger listeners again.\n        if (this.localMap_[key] === newValue &&\n            // Real storage event.\n            typeof event.getBrowserEvent().poll === 'undefined') {\n          return;\n        }\n      }\n    }\n    var self = this;\n    var triggerListeners = function() {\n      // Keep local map up to date in case storage event is triggered before\n      // poll.\n      if (typeof event.getBrowserEvent().poll === 'undefined' &&\n          self.localMap_[key] === goog.global['localStorage']['getItem'](key)) {\n        // Real storage event which has already been detected, do nothing.\n        // This seems to trigger in some IE browsers for some reason.\n        return;\n      }\n      self.localMap_[key] = goog.global['localStorage']['getItem'](key);\n      self.callListeners_(key);\n    };\n    if (fireauth.util.isIe10() &&\n        goog.global['localStorage']['getItem'](key) !==\n        event.getBrowserEvent().newValue &&\n        event.getBrowserEvent().newValue !== event.getBrowserEvent().oldValue) {\n      // IE 10 has this weird bug where a storage event would trigger with the\n      // correct key, oldValue and newValue but localStorage.getItem(key) does\n      // not yield the updated value until a few milliseconds. This ensures this\n      // recovers from that situation.\n      setTimeout(\n          triggerListeners, fireauth.authStorage.IE10_LOCAL_STORAGE_SYNC_DELAY);\n    } else {\n      triggerListeners();\n    }\n  } else {\n    var keys = /** @type {!Array<string>} */ (data);\n    goog.array.forEach(keys, goog.bind(this.callListeners_, this));\n  }\n};\n\n\n/**\n * Calls all listeners for specified storage event key.\n * @param {string} key The storage event key whose listeners are to be run.\n * @private\n */\nfireauth.authStorage.Manager.prototype.callListeners_ = function(key) {\n  if (this.listeners_[key]) {\n    goog.array.forEach(\n        this.listeners_[key],\n        function(listener) {\n          listener();\n        });\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the fireauth.storage.AuthEventManager class used by\n * the iframe to retrieve and delete Auth events triggered through an OAuth\n * flow.\n */\n\ngoog.provide('fireauth.storage.AuthEventManager');\ngoog.provide('fireauth.storage.AuthEventManager.Keys');\n\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.authStorage');\n\n\n/**\n * Defines the Auth event storage manager. It provides methods to\n * load and delete Auth events as well as listen to external OAuth changes on\n * them.\n * @param {string} appId The Auth event's application ID.\n * @param {?fireauth.authStorage.Manager=} opt_manager The underlying storage\n *     manager to use. If none is provided, the default global instance is used.\n * @constructor @struct @final\n */\nfireauth.storage.AuthEventManager = function(appId, opt_manager) {\n  /** @const @private{string} appId The Auth event's application ID. */\n  this.appId_ = appId;\n  /**\n   * @const @private{!fireauth.authStorage.Manager} The underlying storage\n   *     manager.\n   */\n  this.manager_ = opt_manager || fireauth.authStorage.Manager.getInstance();\n};\n\n\n/**\n * Valid keys for Auth event manager data.\n * @enum {!fireauth.authStorage.Key}\n */\nfireauth.storage.AuthEventManager.Keys = {\n  AUTH_EVENT: {\n    name: 'authEvent',\n    persistent: fireauth.authStorage.Persistence.LOCAL\n  },\n  REDIRECT_EVENT: {\n    name: 'redirectEvent',\n    persistent: fireauth.authStorage.Persistence.SESSION\n  }\n};\n\n\n/**\n * @return {!goog.Promise<?fireauth.AuthEvent>} A promise that resolves on\n *     success with the stored Auth event.\n */\nfireauth.storage.AuthEventManager.prototype.getAuthEvent = function() {\n  return this.manager_.get(\n      fireauth.storage.AuthEventManager.Keys.AUTH_EVENT, this.appId_)\n      .then(function(response) {\n        return fireauth.AuthEvent.fromPlainObject(response);\n      });\n};\n\n\n/**\n * Removes the identifier's Auth event if it exists.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.AuthEventManager.prototype.removeAuthEvent = function() {\n  return this.manager_.remove(\n      fireauth.storage.AuthEventManager.Keys.AUTH_EVENT, this.appId_);\n};\n\n\n/**\n * Adds a listener to Auth event for App ID provided.\n * @param {!function()} listener The listener to run on Auth event.\n */\nfireauth.storage.AuthEventManager.prototype.addAuthEventListener =\n    function(listener) {\n  this.manager_.addListener(\n      fireauth.storage.AuthEventManager.Keys.AUTH_EVENT, this.appId_, listener);\n};\n\n\n/**\n * Removes a listener to Auth event for App ID provided.\n * @param {!function()} listener The listener to run on Auth event.\n */\nfireauth.storage.AuthEventManager.prototype.removeAuthEventListener =\n    function(listener) {\n  this.manager_.removeListener(\n      fireauth.storage.AuthEventManager.Keys.AUTH_EVENT, this.appId_, listener);\n};\n\n\n/**\n * @return {!goog.Promise<?fireauth.AuthEvent>} A promise that resolves on\n *     success with the stored redirect Auth event.\n */\nfireauth.storage.AuthEventManager.prototype.getRedirectEvent =\n    function() {\n  return this.manager_.get(\n      fireauth.storage.AuthEventManager.Keys.REDIRECT_EVENT,\n      this.appId_).then(function(response) {\n        return fireauth.AuthEvent.fromPlainObject(response);\n      });\n};\n\n\n/**\n * Removes the identifier's redirect Auth event if it exists.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.AuthEventManager.prototype.removeRedirectEvent = function() {\n  return this.manager_.remove(\n      fireauth.storage.AuthEventManager.Keys.REDIRECT_EVENT, this.appId_);\n};\n","// Copyright 2012 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Base class for SHA-2 cryptographic hash.\n *\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Some code similar to SHA1 are borrowed from sha1.js written by mschilder@.\n *\n */\n\ngoog.provide('goog.crypt.Sha2');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.crypt.Hash');\n\n\n\n/**\n * SHA-2 cryptographic hash constructor.\n * This constructor should not be used directly to create the object. Rather,\n * one should use the constructor of the sub-classes.\n * @param {number} numHashBlocks The size of output in 16-byte blocks.\n * @param {!Array<number>} initHashBlocks The hash-specific initialization\n * @constructor\n * @extends {goog.crypt.Hash}\n * @struct\n */\ngoog.crypt.Sha2 = function(numHashBlocks, initHashBlocks) {\n  goog.crypt.Sha2.base(this, 'constructor');\n\n  this.blockSize = goog.crypt.Sha2.BLOCKSIZE_;\n\n  /**\n   * A chunk holding the currently processed message bytes. Once the chunk has\n   * 64 bytes, we feed it into computeChunk_ function and reset this.chunk_.\n   * @private {!Array<number>|!Uint8Array}\n   */\n  this.chunk_ = goog.global['Uint8Array'] ? new Uint8Array(this.blockSize) :\n                                            new Array(this.blockSize);\n\n  /**\n   * Current number of bytes in this.chunk_.\n   * @private {number}\n   */\n  this.inChunk_ = 0;\n\n  /**\n   * Total number of bytes in currently processed message.\n   * @private {number}\n   */\n  this.total_ = 0;\n\n\n  /**\n   * Holds the previous values of accumulated hash a-h in the computeChunk_\n   * function.\n   * @private {!Array<number>|!Int32Array}\n   */\n  this.hash_ = [];\n\n  /**\n   * The number of output hash blocks (each block is 4 bytes long).\n   * @private {number}\n   */\n  this.numHashBlocks_ = numHashBlocks;\n\n  /**\n   * @private {!Array<number>} initHashBlocks\n   */\n  this.initHashBlocks_ = initHashBlocks;\n\n  /**\n   * Temporary array used in chunk computation.  Allocate here as a\n   * member rather than as a local within computeChunk_() as a\n   * performance optimization to reduce the number of allocations and\n   * reduce garbage collection.\n   * @private {!Int32Array|!Array<number>}\n   */\n  this.w_ = goog.global['Int32Array'] ? new Int32Array(64) : new Array(64);\n\n  if (!goog.isDef(goog.crypt.Sha2.Kx_)) {\n    // This is the first time this constructor has been called.\n    if (goog.global['Int32Array']) {\n      // Typed arrays exist\n      goog.crypt.Sha2.Kx_ = new Int32Array(goog.crypt.Sha2.K_);\n    } else {\n      // Typed arrays do not exist\n      goog.crypt.Sha2.Kx_ = goog.crypt.Sha2.K_;\n    }\n  }\n\n  this.reset();\n};\ngoog.inherits(goog.crypt.Sha2, goog.crypt.Hash);\n\n\n/**\n * The block size\n * @private {number}\n */\ngoog.crypt.Sha2.BLOCKSIZE_ = 512 / 8;\n\n\n/**\n * Contains data needed to pad messages less than BLOCK_SIZE_ bytes.\n * @private {!Array<number>}\n */\ngoog.crypt.Sha2.PADDING_ = goog.array.concat(\n    128, goog.array.repeat(0, goog.crypt.Sha2.BLOCKSIZE_ - 1));\n\n\n/** @override */\ngoog.crypt.Sha2.prototype.reset = function() {\n  this.inChunk_ = 0;\n  this.total_ = 0;\n  this.hash_ = goog.global['Int32Array'] ?\n      new Int32Array(this.initHashBlocks_) :\n      goog.array.clone(this.initHashBlocks_);\n};\n\n\n/**\n * Helper function to compute the hashes for a given 512-bit message chunk.\n * @private\n */\ngoog.crypt.Sha2.prototype.computeChunk_ = function() {\n  var chunk = this.chunk_;\n  goog.asserts.assert(chunk.length == this.blockSize);\n  var rounds = 64;\n\n  // Divide the chunk into 16 32-bit-words.\n  var w = this.w_;\n  var index = 0;\n  var offset = 0;\n  while (offset < chunk.length) {\n    w[index++] = (chunk[offset] << 24) | (chunk[offset + 1] << 16) |\n        (chunk[offset + 2] << 8) | (chunk[offset + 3]);\n    offset = index * 4;\n  }\n\n  // Extend the w[] array to be the number of rounds.\n  for (var i = 16; i < rounds; i++) {\n    var w_15 = w[i - 15] | 0;\n    var s0 = ((w_15 >>> 7) | (w_15 << 25)) ^ ((w_15 >>> 18) | (w_15 << 14)) ^\n        (w_15 >>> 3);\n    var w_2 = w[i - 2] | 0;\n    var s1 = ((w_2 >>> 17) | (w_2 << 15)) ^ ((w_2 >>> 19) | (w_2 << 13)) ^\n        (w_2 >>> 10);\n\n    // As a performance optimization, construct the sum a pair at a time\n    // with casting to integer (bitwise OR) to eliminate unnecessary\n    // double<->integer conversions.\n    var partialSum1 = ((w[i - 16] | 0) + s0) | 0;\n    var partialSum2 = ((w[i - 7] | 0) + s1) | 0;\n    w[i] = (partialSum1 + partialSum2) | 0;\n  }\n\n  var a = this.hash_[0] | 0;\n  var b = this.hash_[1] | 0;\n  var c = this.hash_[2] | 0;\n  var d = this.hash_[3] | 0;\n  var e = this.hash_[4] | 0;\n  var f = this.hash_[5] | 0;\n  var g = this.hash_[6] | 0;\n  var h = this.hash_[7] | 0;\n  for (var i = 0; i < rounds; i++) {\n    var S0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^\n        ((a >>> 22) | (a << 10));\n    var maj = ((a & b) ^ (a & c) ^ (b & c));\n    var t2 = (S0 + maj) | 0;\n    var S1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^\n        ((e >>> 25) | (e << 7));\n    var ch = ((e & f) ^ ((~e) & g));\n\n    // As a performance optimization, construct the sum a pair at a time\n    // with casting to integer (bitwise OR) to eliminate unnecessary\n    // double<->integer conversions.\n    var partialSum1 = (h + S1) | 0;\n    var partialSum2 = (ch + (goog.crypt.Sha2.Kx_[i] | 0)) | 0;\n    var partialSum3 = (partialSum2 + (w[i] | 0)) | 0;\n    var t1 = (partialSum1 + partialSum3) | 0;\n\n    h = g;\n    g = f;\n    f = e;\n    e = (d + t1) | 0;\n    d = c;\n    c = b;\n    b = a;\n    a = (t1 + t2) | 0;\n  }\n\n  this.hash_[0] = (this.hash_[0] + a) | 0;\n  this.hash_[1] = (this.hash_[1] + b) | 0;\n  this.hash_[2] = (this.hash_[2] + c) | 0;\n  this.hash_[3] = (this.hash_[3] + d) | 0;\n  this.hash_[4] = (this.hash_[4] + e) | 0;\n  this.hash_[5] = (this.hash_[5] + f) | 0;\n  this.hash_[6] = (this.hash_[6] + g) | 0;\n  this.hash_[7] = (this.hash_[7] + h) | 0;\n};\n\n\n/** @override */\ngoog.crypt.Sha2.prototype.update = function(message, opt_length) {\n  if (!goog.isDef(opt_length)) {\n    opt_length = message.length;\n  }\n  // Process the message from left to right up to |opt_length| bytes.\n  // When we get a 512-bit chunk, compute the hash of it and reset\n  // this.chunk_. The message might not be multiple of 512 bits so we\n  // might end up with a chunk that is less than 512 bits. We store\n  // such partial chunk in this.chunk_ and it will be filled up later\n  // in digest().\n  var n = 0;\n  var inChunk = this.inChunk_;\n\n  // The input message could be either byte array of string.\n  if (goog.isString(message)) {\n    while (n < opt_length) {\n      this.chunk_[inChunk++] = message.charCodeAt(n++);\n      if (inChunk == this.blockSize) {\n        this.computeChunk_();\n        inChunk = 0;\n      }\n    }\n  } else if (goog.isArrayLike(message)) {\n    while (n < opt_length) {\n      var b = message[n++];\n      if (!('number' == typeof b && 0 <= b && 255 >= b && b == (b | 0))) {\n        throw new Error('message must be a byte array');\n      }\n      this.chunk_[inChunk++] = b;\n      if (inChunk == this.blockSize) {\n        this.computeChunk_();\n        inChunk = 0;\n      }\n    }\n  } else {\n    throw new Error('message must be string or array');\n  }\n\n  // Record the current bytes in chunk to support partial update.\n  this.inChunk_ = inChunk;\n\n  // Record total message bytes we have processed so far.\n  this.total_ += opt_length;\n};\n\n\n/** @override */\ngoog.crypt.Sha2.prototype.digest = function() {\n  var digest = [];\n  var totalBits = this.total_ * 8;\n\n  // Append pad 0x80 0x00*.\n  if (this.inChunk_ < 56) {\n    this.update(goog.crypt.Sha2.PADDING_, 56 - this.inChunk_);\n  } else {\n    this.update(\n        goog.crypt.Sha2.PADDING_, this.blockSize - (this.inChunk_ - 56));\n  }\n\n  // Append # bits in the 64-bit big-endian format.\n  for (var i = 63; i >= 56; i--) {\n    this.chunk_[i] = totalBits & 255;\n    totalBits /= 256;  // Don't use bit-shifting here!\n  }\n  this.computeChunk_();\n\n  // Finally, output the result digest.\n  var n = 0;\n  for (var i = 0; i < this.numHashBlocks_; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      digest[n++] = ((this.hash_[i] >> j) & 255);\n    }\n  }\n  return digest;\n};\n\n\n/**\n * Constants used in SHA-2.\n * @const\n * @private {!Array<number>}\n */\ngoog.crypt.Sha2.K_ = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\n\n/**\n * Sha2.K as an Int32Array if this JS supports typed arrays; otherwise,\n * the same array as Sha2.K.\n *\n * The compiler cannot remove an Int32Array, even if it is not needed\n * (There are certain cases where creating an Int32Array is not\n * side-effect free).  Instead, the first time we construct a Sha2\n * instance, we convert or assign Sha2.K as appropriate.\n * @private {undefined|!Array<number>|!Int32Array}\n */\ngoog.crypt.Sha2.Kx_;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the fireauth.storage.OAuthHandlerManager class which\n * provides utilities to the OAuth handler widget to set Auth events after an\n * IDP sign in attempt and to store state during the OAuth handshake with IDP.\n */\n\ngoog.provide('fireauth.storage.OAuthHandlerManager');\n\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.OAuthHelperState');\ngoog.require('fireauth.authStorage');\ngoog.require('fireauth.storage.AuthEventManager.Keys');\n\n\n/**\n * Defines the OAuth handler storage manager. It provides methods to\n * store, load and delete OAuth handler widget state, properties and setting\n * Auth events.\n * @param {?fireauth.authStorage.Manager=} opt_manager The underlying storage\n *     manager to use. If none is provided, the default global instance is used.\n * @constructor @struct @final\n */\nfireauth.storage.OAuthHandlerManager = function(opt_manager) {\n  /**\n   * @const @private{!fireauth.authStorage.Manager} The underlying storage\n   *     manager.\n   */\n  this.manager_ = opt_manager || fireauth.authStorage.Manager.getInstance();\n};\n\n\n/**\n * Valid keys for OAuth handler manager data.\n * @private @enum {!fireauth.authStorage.Key}\n */\nfireauth.storage.OAuthHandlerManager.Keys_ = {\n  OAUTH_HELPER_STATE: {\n    name: 'oauthHelperState',\n    persistent: fireauth.authStorage.Persistence.SESSION\n  },\n  SESSION_ID: {\n    name: 'sessionId',\n    persistent: fireauth.authStorage.Persistence.SESSION\n  }\n};\n\n\n/**\n * @param {string} appId The Auth state's application ID.\n * @return {!goog.Promise<?string|undefined>} A promise that resolves on success\n *     with the stored session ID.\n */\nfireauth.storage.OAuthHandlerManager.prototype.getSessionId = function(appId) {\n  return this.manager_.get(\n      fireauth.storage.OAuthHandlerManager.Keys_.SESSION_ID, appId);\n};\n\n\n/**\n * Removes the session ID string if it exists.\n * @param {string} appId The Auth state's application ID.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.removeSessionId =\n    function(appId) {\n  return this.manager_.remove(\n      fireauth.storage.OAuthHandlerManager.Keys_.SESSION_ID, appId);\n};\n\n\n/**\n * Stores the session ID string.\n * @param {string} appId The Auth state's application ID.\n * @param {string} sessionId The session ID string to store.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.setSessionId =\n    function(appId, sessionId) {\n  return this.manager_.set(\n      fireauth.storage.OAuthHandlerManager.Keys_.SESSION_ID, sessionId, appId);\n};\n\n\n/**\n * @return {!goog.Promise<?fireauth.OAuthHelperState>} A promise that resolves\n *     on success with the stored OAuth helper state.\n */\nfireauth.storage.OAuthHandlerManager.prototype.getOAuthHelperState =\n    function() {\n  return this.manager_.get(\n      fireauth.storage.OAuthHandlerManager.Keys_.OAUTH_HELPER_STATE)\n      .then(function(response) {\n        return fireauth.OAuthHelperState.fromPlainObject(response);\n      });\n};\n\n\n/**\n * Removes the current OAuth helper state if it exists.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.removeOAuthHelperState =\n    function() {\n  return this.manager_.remove(\n      fireauth.storage.OAuthHandlerManager.Keys_.OAUTH_HELPER_STATE);\n};\n\n\n/**\n * Stores the current OAuth helper state.\n * @param {!fireauth.OAuthHelperState} state The OAuth helper state.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.setOAuthHelperState =\n    function(state) {\n  return this.manager_.set(\n      fireauth.storage.OAuthHandlerManager.Keys_.OAUTH_HELPER_STATE,\n      state.toPlainObject());\n};\n\n\n/**\n * Stores the Auth event for specified identifier.\n * @param {string} appId The Auth state's application ID.\n * @param {!fireauth.AuthEvent} authEvent The Auth event.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.setAuthEvent =\n    function(appId, authEvent) {\n  return this.manager_.set(\n      fireauth.storage.AuthEventManager.Keys.AUTH_EVENT,\n      authEvent.toPlainObject(),\n      appId);\n};\n\n\n/**\n * Stores the redirect Auth event for specified identifier.\n * @param {string} appId The Auth state's application ID.\n * @param {!fireauth.AuthEvent} authEvent The redirect Auth event.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.OAuthHandlerManager.prototype.setRedirectEvent =\n    function(appId, authEvent) {\n  return this.manager_.set(\n      fireauth.storage.AuthEventManager.Keys.REDIRECT_EVENT,\n      authEvent.toPlainObject(),\n      appId);\n};\n","// Copyright 2011 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Abstract cryptographic hash interface.\n *\n * See goog.crypt.Sha1 and goog.crypt.Md5 for sample implementations.\n *\n */\n\ngoog.provide('goog.crypt.Hash');\n\n\n\n/**\n * Create a cryptographic hash instance.\n *\n * @constructor\n * @struct\n */\ngoog.crypt.Hash = function() {\n  /**\n   * The block size for the hasher.\n   * @type {number}\n   */\n  this.blockSize = -1;\n};\n\n\n/**\n * Resets the internal accumulator.\n */\ngoog.crypt.Hash.prototype.reset = goog.abstractMethod;\n\n\n/**\n * Adds a byte array (array with values in [0-255] range) or a string (must\n * only contain 8-bit, i.e., Latin1 characters) to the internal accumulator.\n *\n * Many hash functions operate on blocks of data and implement optimizations\n * when a full chunk of data is readily available. Hence it is often preferable\n * to provide large chunks of data (a kilobyte or more) than to repeatedly\n * call the update method with few tens of bytes. If this is not possible, or\n * not feasible, it might be good to provide data in multiplies of hash block\n * size (often 64 bytes). Please see the implementation and performance tests\n * of your favourite hash.\n *\n * @param {Array<number>|Uint8Array|string} bytes Data used for the update.\n * @param {number=} opt_length Number of bytes to use.\n */\ngoog.crypt.Hash.prototype.update = goog.abstractMethod;\n\n\n/**\n * @return {!Array<number>} The finalized hash computed\n *     from the internal accumulator.\n */\ngoog.crypt.Hash.prototype.digest = goog.abstractMethod;\n","// Copyright 2012 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview SHA-256 cryptographic hash.\n *\n * Usage:\n *   var sha256 = new goog.crypt.Sha256();\n *   sha256.update(bytes);\n *   var hash = sha256.digest();\n *\n */\n\ngoog.provide('goog.crypt.Sha256');\n\ngoog.require('goog.crypt.Sha2');\n\n\n\n/**\n * SHA-256 cryptographic hash constructor.\n *\n * @constructor\n * @extends {goog.crypt.Sha2}\n * @final\n * @struct\n */\ngoog.crypt.Sha256 = function() {\n  goog.crypt.Sha256.base(\n      this, 'constructor', 8, goog.crypt.Sha256.INIT_HASH_BLOCK_);\n};\ngoog.inherits(goog.crypt.Sha256, goog.crypt.Sha2);\n\n\n/** @private {!Array<number>} */\ngoog.crypt.Sha256.INIT_HASH_BLOCK_ = [\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c,\n  0x1f83d9ab, 0x5be0cd19\n];\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines Cordova utility and helper functions.\n * The following plugins must be installed:\n * cordova plugin add cordova-plugin-buildinfo\n * cordova plugin add cordova-universal-links-plugin-fix\n * cordova plugin add cordova-plugin-browsertab\n * cordova plugin add cordova-plugin-inappbrowser\n * iOS custom scheme support:\n * cordova plugin add cordova-plugin-customurlscheme --variable \\\n * URL_SCHEME=com.firebase.example\n * Console logging in iOS:\n * cordova plugin add cordova-plugin-console\n */\n\ngoog.provide('fireauth.CordovaHandler');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.AuthProvider');\ngoog.require('fireauth.DynamicLink');\ngoog.require('fireauth.OAuthSignInHandler');\ngoog.require('fireauth.UniversalLinkSubscriber');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.iframeclient.IfcHandler');\ngoog.require('fireauth.storage.AuthEventManager');\ngoog.require('fireauth.storage.OAuthHandlerManager');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\ngoog.require('goog.Uri');\ngoog.require('goog.array');\ngoog.require('goog.crypt');\ngoog.require('goog.crypt.Sha256');\n\n\n/**\n * Cordova environment utility and helper functions.\n * @param {string} authDomain The application authDomain.\n * @param {string} apiKey The API key.\n * @param {string} appName The App name.\n * @param {?string=} opt_clientVersion The optional client version string.\n * @param {number=} opt_initialTimeout Initial Auth event timeout.\n * @param {number=} opt_redirectTimeout Redirect result timeout.\n * @param {?string=} opt_endpointId The endpoint ID (staging, test Gaia, etc).\n * @constructor\n * @implements {fireauth.OAuthSignInHandler}\n */\nfireauth.CordovaHandler = function(authDomain, apiKey, appName,\n    opt_clientVersion, opt_initialTimeout, opt_redirectTimeout,\n    opt_endpointId) {\n  /** @private {string} The application authDomain. */\n  this.authDomain_ = authDomain;\n  /** @private {string} The application API key. */\n  this.apiKey_ = apiKey;\n  /** @private {string} The application name. */\n  this.appName_ = appName;\n  /** @private {?string} The client version */\n  this.clientVersion_ = opt_clientVersion || null;\n  /** @private {?string} The Auth endpoint ID. */\n  this.endpointId_ = opt_endpointId || null;\n  /** @private {string} The storage key. */\n  this.storageKey_ = fireauth.util.createStorageKey(apiKey, appName);\n  /**\n   * @private {!fireauth.storage.OAuthHandlerManager} The OAuth handler\n   *     storage manager reference, used to save a partial Auth event when\n   *     redirect operation is triggered.\n   */\n  this.savePartialEventManager_ = new fireauth.storage.OAuthHandlerManager();\n  /**\n   * @private {!fireauth.storage.AuthEventManager} The Auth event storage\n   *     manager reference. This is used to get back the saved partial Auth\n   *     event and then delete on successful handling.\n   */\n  this.getAndDeletePartialEventManager_ =\n      new fireauth.storage.AuthEventManager(this.storageKey_);\n  /**\n   * @private {?goog.Promise<!fireauth.AuthEvent>} A promise that resolves with\n   *     the OAuth redirect URL response.\n   */\n  this.initialAuthEvent_ = null;\n  /**\n   * @private {!Array<!function(?fireauth.AuthEvent)>} The Auth event\n   *     listeners.\n   */\n  this.authEventListeners_ = [];\n  /** @private {number} The initial Auth event timeout. */\n  this.initialTimeout_ = opt_initialTimeout ||\n      fireauth.CordovaHandler.INITIAL_TIMEOUT_MS_;\n  /** @private {number} The return to app after redirect timeout. */\n  this.redirectTimeout_ = opt_redirectTimeout ||\n      fireauth.CordovaHandler.REDIRECT_TIMEOUT_MS_;\n  /**\n   * @private {?goog.Promise} The last pending redirect promise. This is null if\n   *     already completed.\n   */\n  this.pendingRedirect_ = null;\n  /**\n   * @private {?Object} The inAppBrowser reference window if available. This is\n   *     relevant to iOS 7 and 8 embedded webviews.\n   */\n  this.inAppBrowserRef_ = null;\n};\n\n\n/**\n * The total number of chars used to generate the session ID string.\n * @const {number}\n * @private\n */\nfireauth.CordovaHandler.SESSION_ID_TOTAL_CHARS_ = 20;\n\n\n/**\n * The default initial Auth event timeout in ms.\n * @const {number}\n * @private\n */\nfireauth.CordovaHandler.INITIAL_TIMEOUT_MS_ = 500;\n\n\n/**\n * The default timeout in milliseconds for a pending redirect operation after\n * returning to the app.\n * @const {number}\n * @private\n */\nfireauth.CordovaHandler.REDIRECT_TIMEOUT_MS_ = 2000;\n\n\n/**\n * Constructs a Cordova configuration error message.\n * @param {?string=} opt_message The optional error message to be used. This\n *     will override the existing default one.\n * @return {!fireauth.AuthError} The Cordova invalid configuration error with\n *     the custom message provided. If no message is provided, the default\n *     message is used.\n * @private\n */\nfireauth.CordovaHandler.getError_ = function(opt_message) {\n  return new fireauth.AuthError(\n      fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION,\n      opt_message);\n};\n\n\n/**\n * Initializes the Cordova environment and waits for it to be ready.\n * @return {!goog.Promise} A promise that resolves if the current environment is\n *     a Cordova environment.\n * @override\n */\nfireauth.CordovaHandler.prototype.initializeAndWait = function() {\n  if (this.isReady_) {\n    return this.isReady_;\n  }\n  this.isReady_ = fireauth.util.checkIfCordova().then(function() {\n    // Check all dependencies installed.\n    // Note that cordova-universal-links-plugin has been abandoned.\n    // A fork with latest fixes is available at:\n    // https://www.npmjs.com/package/cordova-universal-links-plugin-fix\n    var subscribe = fireauth.util.getObjectRef(\n        'universalLinks.subscribe', goog.global);\n    if (typeof subscribe !== 'function') {\n      throw fireauth.CordovaHandler.getError_(\n          'cordova-universal-links-plugin-fix is not installed');\n    }\n    // https://www.npmjs.com/package/cordova-plugin-buildinfo\n    var appIdentifier =\n        fireauth.util.getObjectRef('BuildInfo.packageName', goog.global);\n    if (typeof appIdentifier === 'undefined') {\n      throw fireauth.CordovaHandler.getError_(\n          'cordova-plugin-buildinfo is not installed');\n    }\n    // https://github.com/google/cordova-plugin-browsertab\n    var openUrl = fireauth.util.getObjectRef(\n        'cordova.plugins.browsertab.openUrl', goog.global);\n    if (typeof openUrl !== 'function') {\n      throw fireauth.CordovaHandler.getError_(\n          'cordova-plugin-browsertab is not installed');\n    }\n    // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/\n    var openInAppBrowser = fireauth.util.getObjectRef(\n        'cordova.InAppBrowser.open', goog.global);\n    if (typeof openInAppBrowser !== 'function') {\n      throw fireauth.CordovaHandler.getError_(\n          'cordova-plugin-inappbrowser is not installed');\n    }\n  }, function(error) {\n    // If not supported.\n    throw new fireauth.AuthError(fireauth.authenum.Error.CORDOVA_NOT_READY);\n  });\n  return this.isReady_;\n};\n\n\n/**\n * Generates a session ID. Used to prevent session fixation attacks.\n * @param {number} numOfChars The number of characters to generate.\n * @return {string} The generated session ID.\n * @private\n */\nfireauth.CordovaHandler.prototype.generateSessionId_ = function(numOfChars) {\n  var chars = [];\n  var allowedChars =\n      '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  while (numOfChars > 0) {\n    var index = Math.floor(Math.random() * allowedChars.length);\n    chars.push(allowedChars.charAt(index));\n    numOfChars--;\n  }\n  return chars.join('');\n};\n\n\n/**\n * Computes the sha256 hash of a session ID.\n * @param {string} str The string to hash.\n * @return {string} The hashed string.\n * @private\n */\nfireauth.CordovaHandler.prototype.computeSecureHash_ = function(str) {\n  // sha256 the sessionId. This will be passed to the OAuth backend.\n  // When exchanging the Auth code with a firebase ID token, the raw session ID\n  // needs to be provided.\n  var sha256 = new goog.crypt.Sha256();\n  sha256.update(str);\n  return goog.crypt.byteArrayToHex(sha256.digest());\n};\n\n\n/**\n * Waits for popup window to close and time out if the result is unhandled.\n * This is not supported in Cordova.\n * @param {!Window} popupWin The popup window.\n * @param {!function(!fireauth.AuthError)} onError The on error callback.\n * @return {!goog.Promise}\n * @override\n */\nfireauth.CordovaHandler.prototype.startPopupTimeout =\n    function(popupWin, onError, timeoutDuration) {\n  // Not supported operation, check processPopup for details.\n  onError(new fireauth.AuthError(\n      fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  return goog.Promise.resolve();\n};\n\n\n/**\n * Processes the popup request. This is not supported in Cordova.\n * @param {?Window} popupWin The popup window reference.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {function()} onInitialize The function to call on initialization.\n * @param {function(*)} onError The function to call on error.\n * @param {string=} opt_eventId The optional event ID.\n * @param {boolean=} opt_alreadyRedirected Whether popup is already redirected\n *     to final destination.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise} The popup window promise.\n * @override\n */\nfireauth.CordovaHandler.prototype.processPopup = function(\n    popupWin,\n    mode,\n    provider,\n    onInitialize,\n    onError,\n    opt_eventId,\n    opt_alreadyRedirected,\n    opt_tenantId) {\n  // Popups not supported in Cordova as the activity could be destroyed in\n  // some cases. Redirect works better as getRedirectResult can be used as a\n  // fallback to get the result when the activity is detroyed.\n  return goog.Promise.reject(new fireauth.AuthError(\n      fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n};\n\n\n/**\n * @return {boolean} Whether the handler will unload the current page on\n *     redirect operations.\n * @override\n */\nfireauth.CordovaHandler.prototype.unloadsOnRedirect = function() {\n  // Does not necessarily unload the page on redirect.\n  return false;\n};\n\n\n/**\n * @return {boolean} Whether the handler should be initialized early.\n * @override\n */\nfireauth.CordovaHandler.prototype.shouldBeInitializedEarly = function() {\n  // Initialize early to detect incoming link. This is not an expensive\n  // operation, unlike embedding an iframe.\n  return true;\n};\n\n\n/**\n * @return {boolean} Whether the sign-in handler in the current environment\n *     has volatile session storage.\n * @override\n */\nfireauth.CordovaHandler.prototype.hasVolatileStorage = function() {\n  // An activity can be destroyed and thereby sessionStorage wiped out.\n  return true;\n};\n\n\n/**\n * Processes the OAuth redirect request. Will resolve when the OAuth response\n * is detected in the incoming link and the corresponding Auth event is\n * triggered.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {?string=} opt_eventId The optional event ID.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise}\n * @override\n */\nfireauth.CordovaHandler.prototype.processRedirect = function(\n    mode,\n    provider,\n    opt_eventId,\n    opt_tenantId) {\n  // If there is already a pending redirect, throw an error.\n  if (this.pendingRedirect_) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.REDIRECT_OPERATION_PENDING));\n  }\n  var self = this;\n  var doc = goog.global.document;\n  // On close timer promise.\n  var onClose = null;\n  // Auth event detection callback;\n  var authEventCallback = null;\n  // On resume (return from the redirect operation).\n  var onResume = null;\n  // On visibility change used to detect return to app in certain versions,\n  // currently iOS.\n  var onVisibilityChange = null;\n  // When the processRedirect promise completes, clean up any remaining\n  // temporary listeners and timers.\n  var cleanup = function() {\n    // Remove current resume listener.\n    if (onResume) {\n      doc.removeEventListener('resume', onResume, false);\n    }\n    // Remove visibility change listener.\n    if (onVisibilityChange) {\n      doc.removeEventListener('visibilitychange', onVisibilityChange, false);\n    }\n    // Cancel onClose promise if not already cancelled.\n    if (onClose) {\n      onClose.cancel();\n    }\n    // Remove Auth event callback.\n    if (authEventCallback) {\n      self.removeAuthEventListener(authEventCallback);\n    }\n    // Clear any pending redirect now that it is completed.\n    self.pendingRedirect_ = null;\n  };\n  // Save the pending redirect promise and clear it on completion.\n  this.pendingRedirect_ = goog.Promise.resolve().then(function() {\n    // Validate provider.\n    // Fail fast in this case.\n    fireauth.AuthProvider.checkIfOAuthSupported(provider);\n    return self.getInitialAuthEvent_();\n  }).then(function() {\n    return self.processRedirectInternal_(\n        mode, provider, opt_eventId, opt_tenantId);\n  }).then(function() {\n    // Wait for result (universal link) before resolving this operation.\n    // This ensures that if the activity is not destroyed, we can still\n    // return the result of this operation.\n    return new goog.Promise(function(resolve, reject) {\n      /**\n       * @param {?fireauth.AuthEvent} event The Auth event detected.\n       * @return {boolean}\n       */\n      authEventCallback = function(event) {\n        // Auth event detected, resolve promise.\n        // Close SFSVC if still open.\n        var closeBrowsertab = fireauth.util.getObjectRef(\n            'cordova.plugins.browsertab.close', goog.global);\n        resolve();\n        // Close the SFSVC if it is still open (iOS 9+).\n        if (typeof closeBrowsertab === 'function') {\n          closeBrowsertab();\n        }\n        // Close inappbrowser emebedded webview in iOS7 and 8 case if still\n        // open.\n        if (self.inAppBrowserRef_ &&\n            typeof self.inAppBrowserRef_['close'] === 'function') {\n          self.inAppBrowserRef_['close']();\n          // Reset reference.\n          self.inAppBrowserRef_ = null;\n        }\n        return false;\n      };\n      // Wait and listen for the operation to complete (Auth event would\n      // trigger).\n      self.addAuthEventListener(authEventCallback);\n      // On resume (return from the redirect operation).\n      onResume = function() {\n        // Already resumed. Do not run again.\n        if (onClose) {\n          return;\n        }\n        // Wait for some time before throwing the error that the flow was\n        // cancelled by the user.\n        onClose = goog.Timer.promise(self.redirectTimeout_).then(function() {\n          // Throw the redirect cancelled by user error.\n          reject(new fireauth.AuthError(\n              fireauth.authenum.Error.REDIRECT_CANCELLED_BY_USER));\n        });\n      };\n      onVisibilityChange = function() {\n        // If app is visible, run onResume. Otherwise, ignore.\n        if (fireauth.util.isAppVisible()) {\n          onResume();\n        }\n      };\n      // Listen to resume event (will trigger when the user returns to the app).\n      doc.addEventListener('resume', onResume, false);\n      // Listen to visibility change. This is used for iOS Cordova Safari 7+.\n      // Does not work in Android stock browser versions older than 4.4.\n      // We rely on resume event in Android as it works reliably in all\n      // versions.\n      if (!fireauth.util.isAndroid()) {\n        doc.addEventListener('visibilitychange', onVisibilityChange, false);\n      }\n    }).thenCatch(function(error) {\n      // Remove any pending partial event.\n      return self.getPartialStoredEvent_().then(function() {\n        throw error;\n      });\n    });\n  }).thenAlways(cleanup);\n  // Return the pending redirect promise.\n  return this.pendingRedirect_;\n};\n\n/**\n * Processes the OAuth redirect request.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {?string=} opt_eventId The optional event ID.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise}\n * @private\n */\nfireauth.CordovaHandler.prototype.processRedirectInternal_ = function(\n    mode,\n    provider,\n    opt_eventId,\n    opt_tenantId) {\n  var self = this;\n  // https://github.com/google/cordova-plugin-browsertab\n  // Opens chrome custom tab in Android if chrome is installed,\n  // SFSafariViewController in iOS if supported.\n  // If the above are not supported, opens the system browser.\n  // Opening a system browser could result in an app being rejected in the App\n  // Store. The only solution here is to use an insecure embedded UIWebView.\n  // This applies to older iOS versions 8 and under.\n  // Generate a random session ID.\n  var sessionId = this.generateSessionId_(\n      fireauth.CordovaHandler.SESSION_ID_TOTAL_CHARS_);\n  // Create the partial Auth event.\n  var event = new fireauth.AuthEvent(\n      mode,\n      opt_eventId,\n      null,\n      sessionId,\n      new fireauth.AuthError(fireauth.authenum.Error.NO_AUTH_EVENT),\n      null,\n      opt_tenantId);\n  // Use buildinfo package to get app metadata.\n  // https://www.npmjs.com/package/cordova-plugin-buildinfo\n  // Get app identifier.\n  var appIdentifier =\n      fireauth.util.getObjectRef('BuildInfo.packageName', goog.global);\n  // initializeAndWait will ensure this does not happen.\n  if (typeof appIdentifier !== 'string') {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION);\n  }\n  // Get app display name.\n  var appDisplayName =\n      fireauth.util.getObjectRef('BuildInfo.displayName', goog.global);\n  // Construct additional params to pass to OAuth handler.\n  var additionalParams  = {};\n  // Append app identifier.\n  if (fireauth.util.isIOS()) {\n    // iOS app.\n    additionalParams['ibi'] = appIdentifier;\n  } else if (fireauth.util.isAndroid()) {\n    // Android app.\n    additionalParams['apn'] = appIdentifier;\n  } else {\n    // This should not happen as Cordova handler should not even be used in this\n    // case.\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  // Pass app display name.\n  if (appDisplayName) {\n    additionalParams['appDisplayName'] = appDisplayName;\n  }\n  // Hash the session ID and pass it to additional params.\n  var hashedSessionId = this.computeSecureHash_(sessionId);\n  // Append session ID.\n  additionalParams['sessionId'] = hashedSessionId;\n  // Construct OAuth handler URL.\n  var oauthHelperWidgetUrl =\n      fireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl(\n          this.authDomain_,\n          this.apiKey_,\n          this.appName_,\n          mode,\n          provider,\n          null,\n          opt_eventId,\n          this.clientVersion_,\n          additionalParams,\n          this.endpointId_,\n          opt_tenantId);\n  // Make sure handler initialized and ready.\n  // This should also ensure all plugins are installed.\n  return this.initializeAndWait().then(function() {\n    // Save partial Auth event.\n    return self.savePartialEventManager_.setAuthEvent(self.storageKey_, event);\n  }).then(function() {\n    // initializeAndWait will ensure this plugin is installed.\n    var isAvailable = /** @type {!function(!function(*))} */ (\n        fireauth.util.getObjectRef(\n            'cordova.plugins.browsertab.isAvailable', goog.global));\n    if (typeof isAvailable !== 'function') {\n      throw new fireauth.AuthError(\n          fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION);\n    }\n    var openUrl = null;\n    // Check if browsertab is supported.\n    isAvailable(function(result) {\n      if (result) {\n        // browsertab supported.\n        openUrl = /** @type {!function(string, ...*)} */ (\n            fireauth.util.getObjectRef(\n                'cordova.plugins.browsertab.openUrl', goog.global));\n        if (typeof openUrl !== 'function') {\n          throw new fireauth.AuthError(\n              fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION);\n        }\n        // Open OAuth handler.\n        openUrl(oauthHelperWidgetUrl);\n      } else {\n        // browsertab not supported, switch to inappbrowser.\n        openUrl = /** @type {!function(string, string, string=)} */ (\n            fireauth.util.getObjectRef(\n                'cordova.InAppBrowser.open', goog.global));\n        if (typeof openUrl !== 'function') {\n          throw new fireauth.AuthError(\n              fireauth.authenum.Error.INVALID_CORDOVA_CONFIGURATION);\n        }\n        // Open in embedded webview for iOS 7 and 8 as Apple rejects apps that\n        // switch context.\n        // _blank opens an embedded webview.\n        // _system opens the system browser.\n        // _system (opens a system browser) is used as a fallback when\n        // browsertab plugin is unable to open a chromecustomtab or SFSVC.\n        // This has to exclude all iOS older versions where switching to a\n        // browser is frowned upon by Apple and embedding a UIWebView is the\n        // only option but is insecure and deprecated by Google for OAuth\n        // sign-in. This will be applicable in old versions of Android.\n        self.inAppBrowserRef_ = openUrl(\n            oauthHelperWidgetUrl,\n            fireauth.util.isIOS7Or8() ? '_blank' : '_system',\n            'location=yes');\n      }\n    });\n  });\n};\n\n\n/**\n * Dispatches the detected Auth event to all subscribed listeners.\n * @param {!fireauth.AuthEvent} event A detected Auth event.\n * @private\n */\nfireauth.CordovaHandler.prototype.dispatchEvent_ = function(event) {\n  for (var i = 0; i < this.authEventListeners_.length; i++) {\n    try {\n      this.authEventListeners_[i](event);\n    } catch (e) {\n      // If any handler fails, ignore and run next handler.\n    }\n  }\n};\n\n\n/**\n * Resolves the first redirect Auth event and caches it.\n * @return {!goog.Promise<!fireauth.AuthEvent>} A promise that resolves with the\n *     initial Auth event response from a redirect operation. Initializes the\n *     internal Auth event listener which will dispatch Auth events to all\n *     subscribed listeners.\n * @private\n */\nfireauth.CordovaHandler.prototype.getInitialAuthEvent_ = function() {\n  var self = this;\n  if (!this.initialAuthEvent_) {\n    // Cache this result so on next call, it is not triggered again.\n    this.initialAuthEvent_ = this.initializeAndWait().then(function() {\n      return new goog.Promise(function(resolve, reject) {\n        /**\n         * @param {?fireauth.AuthEvent} event The Auth event detected.\n         * @return {boolean}\n         */\n        var authEventCallback = function(event) {\n          resolve(event);\n          // Remove on completion.\n          self.removeAuthEventListener(authEventCallback);\n          return false;\n        };\n        // Listen to Auth events. If resolved, resolve promise.\n        self.addAuthEventListener(authEventCallback);\n        // This should succeed as initializeAndWait should guarantee plugins are\n        // ready.\n        self.setAuthEventListener_();\n      });\n    });\n  }\n  return this.initialAuthEvent_;\n};\n\n\n/**\n * Gets and deletes the current stored partial event from storage.\n * @return {!goog.Promise<?fireauth.AuthEvent>} A promise that resolves with the\n *     stored Auth event.\n * @private\n */\nfireauth.CordovaHandler.prototype.getPartialStoredEvent_ = function() {\n  var event = null;\n  var self = this;\n  // Get any saved partial Auth event.\n  return this.getAndDeletePartialEventManager_.getAuthEvent()\n    .then(function(authEvent) {\n      // Save partial event locally.\n      event = authEvent;\n      // Delete partial event.\n      return self.getAndDeletePartialEventManager_.removeAuthEvent();\n    }).then(function() {\n      // Return the locally saved partial event.\n      return event;\n    });\n};\n\n\n/**\n * Extracts the Auth event pertaining to the incoming URL.\n * @param {!fireauth.AuthEvent} partialEvent The partial Auth event.\n * @param {string} url The incoming universal link.\n * @return {?fireauth.AuthEvent} The resolved Auth event corresponding to the\n *     callback URL. This is null if no event is found.\n * @private\n */\nfireauth.CordovaHandler.prototype.extractAuthEventFromUrl_ =\n    function(partialEvent, url) {\n  // Default no redirect event result.\n  var authEvent = null;\n  // Parse the deep link within the dynamic link URL.\n  var callbackUrl = fireauth.DynamicLink.parseDeepLink(url);\n  // Confirm it is actually a callback URL.\n  // Currently the universal link will be of this format:\n  // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>\n  // This is a fake URL but is not intended to take the user anywhere\n  // and just redirect to the app.\n  if (callbackUrl.indexOf('/__/auth/callback') != -1) {\n    // Check if there is an error in the URL.\n    // This mechanism is also used to pass errors back to the app:\n    // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>\n    var uri = goog.Uri.parse(callbackUrl);\n    // Get the error object corresponding to the stringified error if found.\n    var errorObject = fireauth.util.parseJSON(\n        uri.getParameterValue('firebaseError') || null);\n    var error = typeof errorObject === 'object' ?\n        fireauth.AuthError.fromPlainObject(\n            /** @type {?Object} */ (errorObject)) :\n        null;\n    if (error) {\n      // Construct the full failed Auth event.\n      authEvent = new fireauth.AuthEvent(\n          partialEvent.getType(),\n          partialEvent.getEventId(),\n          null,\n          null,\n          error,\n          null,\n          partialEvent.getTenantId());\n    } else {\n      // Construct the full successful Auth event.\n      authEvent = new fireauth.AuthEvent(\n          partialEvent.getType(),\n          partialEvent.getEventId(),\n          callbackUrl,\n          partialEvent.getSessionId(),\n          null,\n          null,\n          partialEvent.getTenantId());\n    }\n  }\n  return authEvent;\n};\n\n\n/**\n * Sets the internal Auth event listener. This listens to incoming universal\n * links and on detection, repackages them into an Auth event and then\n * dispatches the events in all event listeners.\n * @private\n */\nfireauth.CordovaHandler.prototype.setAuthEventListener_ = function() {\n  // https://github.com/nordnet/cordova-universal-links-plugin-fix\n  var self = this;\n  // Default no redirect event result.\n  var noEvent = new fireauth.AuthEvent(\n      fireauth.AuthEvent.Type.UNKNOWN,\n      null,\n      null,\n      null,\n      new fireauth.AuthError(fireauth.authenum.Error.NO_AUTH_EVENT));\n  var initialResolve = false;\n  // On initialization, if no incoming universal link detected, trigger\n  // no Auth event (no redirect operation previously called) after waiting\n  // for a short period of time.\n  var noEventTimer = goog.Timer.promise(this.initialTimeout_).then(function() {\n    // Delete any pending unhandled event.\n    return self.getPartialStoredEvent_().then(function(event) {\n      // On timeout trigger noEvent if not already resolved in link\n      // subscriber.\n      if (!initialResolve) {\n        self.dispatchEvent_(noEvent);\n      }\n    });\n  });\n  // No event name needed, subscribe to all incoming universal links.\n  var universalLinkCb = function(eventData) {\n    initialResolve = true;\n    // Cancel no event timer.\n    if (noEventTimer) {\n      noEventTimer.cancel();\n    }\n    // Incoming link detected.\n    // Check for any stored partial event.\n    self.getPartialStoredEvent_().then(function(event) {\n      // Initialize to an unknown event.\n      var authEvent = noEvent;\n      // Confirm OAuth response included.\n      if (event && eventData && eventData['url']) {\n        // Construct complete event. Default to unknown event if none found.\n        authEvent = self.extractAuthEventFromUrl_(event, eventData['url']) ||\n            noEvent;\n      }\n      // Dispatch Auth event.\n      self.dispatchEvent_(authEvent);\n    });\n  };\n  // iOS 7 or 8 custom URL schemes.\n  // This is also the current default behavior for iOS 9+.\n  // For this to work, cordova-plugin-customurlscheme needs to be installed.\n  // https://github.com/EddyVerbruggen/Custom-URL-scheme\n  // Do not overwrite the existing developer's URL handler.\n  var existingHandlerOpenURL = goog.global['handleOpenURL'];\n  goog.global['handleOpenURL'] = function(url) {\n    var appIdentifier =\n        fireauth.util.getObjectRef('BuildInfo.packageName', goog.global);\n    // Apply case insensitive match. While bundle IDs are case sensitive,\n    // when creating a new app, Apple verifies the Bundle ID using\n    // case-insensitive search. So it is not possible that an app in the app\n    // store try to impersonate another one by lower/upper casing characters.\n    if (url.toLowerCase().indexOf(appIdentifier.toLowerCase() + '://') == 0) {\n      universalLinkCb({\n        'url': url\n      });\n    }\n    // Call the developer's handler if it is present.\n    if (typeof existingHandlerOpenURL === 'function') {\n      try {\n        existingHandlerOpenURL(url);\n      } catch(e) {\n        // This doesn't swallow the error but also does not interrupt the flow.\n        console.error(e);\n      }\n    }\n  };\n  fireauth.UniversalLinkSubscriber.getInstance().subscribe(universalLinkCb);\n};\n\n\n/**\n * @param {!function(?fireauth.AuthEvent):boolean} listener The Auth event\n *     listener to add.\n * @override\n */\nfireauth.CordovaHandler.prototype.addAuthEventListener = function(listener) {\n  // TODO: consider creating an abstract base class that OAuth handlers\n  // extend with add, remove Auth event listeners and dispatcher methods.\n  this.authEventListeners_.push(listener);\n  // Set internal listener to Auth events. This will be ignored on subsequent\n  // calls.\n  this.getInitialAuthEvent_().thenCatch(function(error) {\n    // Suppress this error as it should be caught through other actionable\n    // public methods.\n    // This would typically happen on invalid Cordova setup, when the OAuth\n    // plugins are not installed. This should still trigger the Auth event\n    // as developers are not forced to use OAuth sign-in in their Cordova app.\n    // This is needed for onAuthStateChanged listener to trigger initially.\n    if (error.code === 'auth/invalid-cordova-configuration') {\n      var noEvent = new fireauth.AuthEvent(\n          fireauth.AuthEvent.Type.UNKNOWN,\n          null,\n          null,\n          null,\n          new fireauth.AuthError(fireauth.authenum.Error.NO_AUTH_EVENT));\n      listener(noEvent);\n    }\n  });\n};\n\n\n/**\n * @param {!function(?fireauth.AuthEvent):boolean} listener The Auth event\n *     listener to remove.\n * @override\n */\nfireauth.CordovaHandler.prototype.removeAuthEventListener = function(listener) {\n  goog.array.removeAllIf(this.authEventListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n\n","// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Namespace with crypto related helper functions.\n */\n\ngoog.provide('goog.crypt');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\n\n\n/**\n * Turns a string into an array of bytes; a \"byte\" being a JS number in the\n * range 0-255. Multi-byte characters are written as little-endian.\n * @param {string} str String value to arrify.\n * @return {!Array<number>} Array of numbers corresponding to the\n *     UCS character codes of each character in str.\n */\ngoog.crypt.stringToByteArray = function(str) {\n  var output = [], p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    // NOTE: c <= 0xffff since JavaScript strings are UTF-16.\n    if (c > 0xff) {\n      output[p++] = c & 0xff;\n      c >>= 8;\n    }\n    output[p++] = c;\n  }\n  return output;\n};\n\n\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param {!Uint8Array|!Array<number>} bytes Array of numbers representing\n *     characters.\n * @return {string} Stringification of the array.\n */\ngoog.crypt.byteArrayToString = function(bytes) {\n  var CHUNK_SIZE = 8192;\n\n  // Special-case the simple case for speed's sake.\n  if (bytes.length <= CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n\n  var str = '';\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = goog.array.slice(bytes, i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n  return str;\n};\n\n\n/**\n * Turns an array of numbers into the hex string given by the concatenation of\n * the hex values to which the numbers correspond.\n * @param {Uint8Array|Array<number>} array Array of numbers representing\n *     characters.\n * @param {string=} opt_separator Optional separator between values\n * @return {string} Hex string.\n */\ngoog.crypt.byteArrayToHex = function(array, opt_separator) {\n  return goog.array\n      .map(\n          array,\n          function(numByte) {\n            var hexByte = numByte.toString(16);\n            return hexByte.length > 1 ? hexByte : '0' + hexByte;\n          })\n      .join(opt_separator || '');\n};\n\n\n/**\n * Converts a hex string into an integer array.\n * @param {string} hexString Hex string of 16-bit integers (two characters\n *     per integer).\n * @return {!Array<number>} Array of {0,255} integers for the given string.\n */\ngoog.crypt.hexToByteArray = function(hexString) {\n  goog.asserts.assert(\n      hexString.length % 2 == 0, 'Key string length must be multiple of 2');\n  var arr = [];\n  for (var i = 0; i < hexString.length; i += 2) {\n    arr.push(parseInt(hexString.substring(i, i + 2), 16));\n  }\n  return arr;\n};\n\n\n/**\n * Converts a JS string to a UTF-8 \"byte\" array.\n * @param {string} str 16-bit unicode string.\n * @return {!Array<number>} UTF-8 byte array.\n */\ngoog.crypt.stringToUtf8ByteArray = function(str) {\n  // TODO(user): Use native implementations if/when available\n  var out = [], p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192;\n      out[p++] = (c & 63) | 128;\n    } else if (\n        ((c & 0xFC00) == 0xD800) && (i + 1) < str.length &&\n        ((str.charCodeAt(i + 1) & 0xFC00) == 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);\n      out[p++] = (c >> 18) | 240;\n      out[p++] = ((c >> 12) & 63) | 128;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    } else {\n      out[p++] = (c >> 12) | 224;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    }\n  }\n  return out;\n};\n\n\n/**\n * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\n * @param {Uint8Array|Array<number>} bytes UTF-8 byte array.\n * @return {string} 16-bit Unicode string.\n */\ngoog.crypt.utf8ByteArrayToString = function(bytes) {\n  // TODO(user): Use native implementations if/when available\n  var out = [], pos = 0, c = 0;\n  while (pos < bytes.length) {\n    var c1 = bytes[pos++];\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      var c2 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n    } else if (c1 > 239 && c1 < 365) {\n      // Surrogate Pair\n      var c2 = bytes[pos++];\n      var c3 = bytes[pos++];\n      var c4 = bytes[pos++];\n      var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) -\n          0x10000;\n      out[c++] = String.fromCharCode(0xD800 + (u >> 10));\n      out[c++] = String.fromCharCode(0xDC00 + (u & 1023));\n    } else {\n      var c2 = bytes[pos++];\n      var c3 = bytes[pos++];\n      out[c++] =\n          String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n    }\n  }\n  return out.join('');\n};\n\n\n/**\n * XOR two byte arrays.\n * @param {!Uint8Array|!Int8Array|!Array<number>} bytes1 Byte array 1.\n * @param {!Uint8Array|!Int8Array|!Array<number>} bytes2 Byte array 2.\n * @return {!Array<number>} Resulting XOR of the two byte arrays.\n */\ngoog.crypt.xorByteArray = function(bytes1, bytes2) {\n  goog.asserts.assert(\n      bytes1.length == bytes2.length, 'XOR array lengths must match');\n\n  var result = [];\n  for (var i = 0; i < bytes1.length; i++) {\n    result.push(bytes1[i] ^ bytes2[i]);\n  }\n  return result;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the fireauth.storage.PendingRedirectManager class which\n * provides utilities to store, retrieve and delete the state of whether there\n * is a pending redirect operation previously triggered.\n */\n\ngoog.provide('fireauth.storage.PendingRedirectManager');\n\ngoog.require('fireauth.authStorage');\n\n\n/**\n * Defines the pending redirect storage manager. It provides methods\n * to store, retrieve and delete the state of whether there is a pending\n * redirect operation previously triggered.\n * @param {string} appId The Auth state's application ID.\n * @param {?fireauth.authStorage.Manager=} opt_manager The underlying storage\n *     manager to use. If none is provided, the default global instance is used.\n * @constructor @struct @final\n */\nfireauth.storage.PendingRedirectManager = function(appId, opt_manager) {\n  /** @const @private{string} appId The Auth state's application ID. */\n  this.appId_ = appId;\n  /**\n   * @const @private{!fireauth.authStorage.Manager} The underlying storage\n   *     manager.\n   */\n  this.manager_ = opt_manager || fireauth.authStorage.Manager.getInstance();\n};\n\n\n/**\n * @const @private{!string} The pending redirect flag.\n */\nfireauth.storage.PendingRedirectManager.PENDING_FLAG_ = 'pending';\n\n\n/**\n * @const @private{!fireauth.authStorage.Key} The pending redirect status\n *     storage identifier key.\n */\nfireauth.storage.PendingRedirectManager.PENDING_REDIRECT_KEY_ = {\n  name: 'pendingRedirect',\n  persistent: fireauth.authStorage.Persistence.SESSION\n};\n\n\n/**\n * Stores the pending redirect operation for the provided application ID.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.PendingRedirectManager.prototype.setPendingStatus =\n    function() {\n  return this.manager_.set(\n      fireauth.storage.PendingRedirectManager.PENDING_REDIRECT_KEY_,\n      fireauth.storage.PendingRedirectManager.PENDING_FLAG_,\n      this.appId_);\n};\n\n\n/**\n * Removes the stored pending redirect operation for provided app ID.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.PendingRedirectManager.prototype.removePendingStatus =\n    function() {\n  return this.manager_.remove(\n      fireauth.storage.PendingRedirectManager.PENDING_REDIRECT_KEY_,\n      this.appId_);\n};\n\n\n/**\n * @return {!goog.Promise<boolean>} A promise that resolves with a boolean\n *     whether there is a pending redirect operaiton for the provided app ID.\n */\nfireauth.storage.PendingRedirectManager.prototype.getPendingStatus =\n    function() {\n  return this.manager_.get(\n      fireauth.storage.PendingRedirectManager.PENDING_REDIRECT_KEY_,\n      this.appId_).then(function(response) {\n        return response ==\n            fireauth.storage.PendingRedirectManager.PENDING_FLAG_;\n      });\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the Auth event manager instance.\n */\n\ngoog.provide('fireauth.AuthEventHandler');\ngoog.provide('fireauth.AuthEventManager');\ngoog.provide('fireauth.AuthEventManager.Result');\ngoog.provide('fireauth.PopupAuthEventProcessor');\ngoog.provide('fireauth.RedirectAuthEventProcessor');\n\ngoog.require('fireauth.AuthCredential');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.CordovaHandler');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.iframeclient.IfcHandler');\ngoog.require('fireauth.storage.PendingRedirectManager');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\ngoog.require('goog.array');\n\n\n/**\n * Initializes the Auth event manager which provides the mechanism to connect\n * external Auth events to their corresponding listeners.\n * @param {string} authDomain The Firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The App ID for the Auth instance that triggered this\n *     request.\n * @constructor\n */\nfireauth.AuthEventManager = function(authDomain, apiKey, appName) {\n  /**\n   * @private {!Object<string, boolean>} The map of processed auth event IDs.\n   */\n  this.processedEvents_ = {};\n  /** @private {number} The last saved processed event time in milliseconds. */\n  this.lastProcessedEventTime_ = 0;\n  /** @private {string} The Auth domain. */\n  this.authDomain_ = authDomain;\n  /** @private {string} The browser API key. */\n  this.apiKey_ = apiKey;\n  /** @private {string} The App name. */\n  this.appName_ = appName;\n  /**\n   * @private {!Array<!fireauth.AuthEventHandler>} List of subscribed handlers.\n   */\n  this.subscribedHandlers_ = [];\n  /**\n   * @private {boolean} Whether the Auth event manager instance is initialized.\n   */\n  this.initialized_ = false;\n  /** @private {function(?fireauth.AuthEvent)} The Auth event handler. */\n  this.authEventHandler_ = goog.bind(this.handleAuthEvent_, this);\n  /** @private {!fireauth.RedirectAuthEventProcessor} The redirect event\n   *      processor. */\n  this.redirectAuthEventProcessor_ =\n      new fireauth.RedirectAuthEventProcessor(this);\n  /** @private {!fireauth.PopupAuthEventProcessor} The popup event processor. */\n  this.popupAuthEventProcessor_ = new fireauth.PopupAuthEventProcessor(this);\n  /**\n   * @private {!fireauth.storage.PendingRedirectManager} The pending redirect\n   *     storage manager instance.\n   */\n  this.pendingRedirectStorageManager_ =\n      new fireauth.storage.PendingRedirectManager(\n          fireauth.AuthEventManager.getKey_(this.apiKey_, this.appName_));\n\n  /**\n   * @private {!Object.<!fireauth.AuthEvent.Type, !fireauth.AuthEventProcessor>}\n   *     Map containing Firebase event processor instances keyed by event type.\n   */\n  this.typeToManager_ = {};\n  this.typeToManager_[fireauth.AuthEvent.Type.UNKNOWN] =\n      this.redirectAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.SIGN_IN_VIA_REDIRECT] =\n      this.redirectAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.LINK_VIA_REDIRECT] =\n      this.redirectAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.REAUTH_VIA_REDIRECT] =\n      this.redirectAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.SIGN_IN_VIA_POPUP] =\n      this.popupAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.LINK_VIA_POPUP] =\n      this.popupAuthEventProcessor_;\n  this.typeToManager_[fireauth.AuthEvent.Type.REAUTH_VIA_POPUP] =\n      this.popupAuthEventProcessor_;\n  /**\n   * @private {!fireauth.OAuthSignInHandler} The OAuth sign in handler depending\n   *     on the current environment.\n   */\n  this.oauthSignInHandler_ =\n      fireauth.AuthEventManager.instantiateOAuthSignInHandler(\n          this.authDomain_, this.apiKey_, this.appName_,\n          firebase.SDK_VERSION || null,\n          fireauth.constants.clientEndpoint);\n};\n\n\n/**\n * @const {number} The number of milliseconds since the last processed\n *     event before the event duplication cache is cleared. This is currently\n *     10 minutes.\n */\nfireauth.AuthEventManager.EVENT_DUPLICATION_CACHE_DURATION = 10 * 60 * 1000;\n\n\n/**\n * @return {!fireauth.RedirectAuthEventProcessor} The redirect event processor.\n */\nfireauth.AuthEventManager.prototype.getRedirectAuthEventProcessor = function() {\n  return this.redirectAuthEventProcessor_;\n};\n\n\n/** @return {!fireauth.PopupAuthEventProcessor} The popup event processor. */\nfireauth.AuthEventManager.prototype.getPopupAuthEventProcessor = function() {\n  return this.popupAuthEventProcessor_;\n};\n\n\n/**\n * Instantiates an OAuth sign-in handler depending on the current environment\n * and returns it.\n * @param {string} authDomain The Firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The App ID for the Auth instance that triggered this\n *     request.\n * @param {?string} version The SDK client version.\n * @param {?string=} opt_endpointId The endpoint ID (staging, test Gaia, etc).\n * @return {!fireauth.OAuthSignInHandler} The OAuth sign in handler depending\n *     on the current environment.\n */\nfireauth.AuthEventManager.instantiateOAuthSignInHandler =\n    function(authDomain, apiKey, appName, version, opt_endpointId) {\n  // This assumes that android/iOS file environment must be a Cordova\n  // environment which is not true. This is the best way currently available\n  // to instantiate this synchronously without waiting for checkIfCordova to\n  // resolve. If it is determined that the Cordova was falsely detected, it will\n  // be caught via actionable public popup and redirect methods.\n  return fireauth.util.isAndroidOrIosFileEnvironment() ?\n      new fireauth.CordovaHandler(\n          authDomain, apiKey, appName, version, undefined, undefined,\n          opt_endpointId) :\n      new fireauth.iframeclient.IfcHandler(\n          authDomain, apiKey, appName, version, opt_endpointId);\n};\n\n\n/** Reset iframe. This will require reinitializing it.*/\nfireauth.AuthEventManager.prototype.reset = function() {\n  // Reset initialized status. This will force a popup request to re-initialize\n  // the iframe.\n  this.initialized_ = false;\n  // Remove any previous existing Auth event listener.\n  this.oauthSignInHandler_.removeAuthEventListener(this.authEventHandler_);\n  // Construct a new instance of OAuth sign in handler.\n\n  this.oauthSignInHandler_ =\n      fireauth.AuthEventManager.instantiateOAuthSignInHandler(\n          this.authDomain_, this.apiKey_, this.appName_,\n          firebase.SDK_VERSION || null);\n  this.processedEvents_ = {};\n};\n\n\n/**\n * Clears the cached redirect result as long as there is no pending redirect\n * result being processed. Unrecoverable errors will not be cleared.\n */\nfireauth.AuthEventManager.prototype.clearRedirectResult = function() {\n  this.redirectAuthEventProcessor_.clearRedirectResult();\n};\n\n\n/**\n * @typedef {{\n *   user: (?fireauth.AuthUser|undefined),\n *   credential: (?fireauth.AuthCredential|undefined),\n *   operationType: (?string|undefined),\n *   additionalUserInfo: (?fireauth.AdditionalUserInfo|undefined)\n * }}\n */\nfireauth.AuthEventManager.Result;\n\n\n/**\n * Whether to enable Auth event manager subscription.\n * @const {boolean}\n */\nfireauth.AuthEventManager.ENABLED = true;\n\n\n/**\n * Initializes the ifchandler and add Auth event listener on it.\n * @return {!goog.Promise} The promise that resolves when the iframe is ready.\n */\nfireauth.AuthEventManager.prototype.initialize = function() {\n  var self = this;\n  // Initialize once.\n  if (!this.initialized_) {\n    this.initialized_ = true;\n    // Listen to Auth events on iframe.\n    this.oauthSignInHandler_.addAuthEventListener(this.authEventHandler_);\n  }\n  var previousOauthSignInHandler = this.oauthSignInHandler_;\n  // This should initialize ifchandler underneath.\n  // Return on OAuth handler ready promise.\n  // Check for error in ifcHandler used to embed the iframe.\n  return this.oauthSignInHandler_.initializeAndWait()\n      .thenCatch(function(error) {\n        // Force ifchandler to reinitialize on retrial.\n        if (self.oauthSignInHandler_ == previousOauthSignInHandler) {\n          // If a new OAuth sign in handler was already created, do not reset.\n          self.reset();\n        }\n        throw error;\n      });\n};\n\n\n/**\n * Called after it is determined that there is no pending redirect result.\n * Will populate the redirect result if it is guaranteed to be null and will\n * force an early initialization of the OAuth sign in handler if the\n * environment requires it.\n * @private\n */\nfireauth.AuthEventManager.prototype.initializeWithNoPendingRedirectResult_ =\n    function() {\n  var self = this;\n  // Check if the OAuth sign in handler should be initialized early in all\n  // cases.\n  if (this.oauthSignInHandler_.shouldBeInitializedEarly()) {\n    this.initialize().thenCatch(function(error) {\n      // Current environment was falsely detected as Cordova, trigger a fake\n      // Auth event to notify getRedirectResult that operation is not supported.\n      var notSupportedEvent = new fireauth.AuthEvent(\n          fireauth.AuthEvent.Type.UNKNOWN,\n          null,\n          null,\n          null,\n          new fireauth.AuthError(\n              fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n      if (fireauth.AuthEventManager.isCordovaFalsePositive_(\n          /** @type {?fireauth.AuthError} */ (error))) {\n        self.handleAuthEvent_(notSupportedEvent);\n      }\n    });\n  }\n  // For environments where storage is volatile, we can't determine that\n  // there is no pending redirect response. This is true in Cordova\n  // where an activity would be destroyed in some cases and the\n  // sessionStorage is lost.\n  if (!this.oauthSignInHandler_.hasVolatileStorage()) {\n    // Since there is no redirect result, it is safe to default to empty\n    // redirect result instead of blocking on this.\n    // The downside here is that on iOS devices, calling signInWithPopup\n    // after getRedirectResult resolves and the iframe does not finish\n    // loading, the popup event propagating to the iframe would not be\n    // detected. This is because in iOS devices, storage events only trigger\n    // in iframes but are not actually saved in web storage. The iframe must\n    // be embedded and ready before the storage event propagates. Otherwise\n    // it won't be detected.\n    this.redirectAuthEventProcessor_.defaultToEmptyResponse();\n  }\n};\n\n\n/**\n * Subscribes an Auth event handler to list of handlers.\n * @param {!fireauth.AuthEventHandler} handler The instance to subscribe.\n */\nfireauth.AuthEventManager.prototype.subscribe = function(handler) {\n  if (!goog.array.contains(this.subscribedHandlers_, handler)) {\n    this.subscribedHandlers_.push(handler);\n  }\n  if (this.initialized_) {\n    return;\n  }\n  var self = this;\n  // Check pending redirect status.\n  this.pendingRedirectStorageManager_.getPendingStatus()\n      .then(function(status) {\n    // Pending redirect detected.\n    if (status) {\n      // Remove pending status and initialize.\n      self.pendingRedirectStorageManager_.removePendingStatus()\n          .then(function() {\n            self.initialize().thenCatch(function(error) {\n              // Current environment was falsely detected as Cordova, trigger a\n              // fake Auth event to notify getRedirectResult that operation is\n              // not supported.\n              var notSupportedEvent = new fireauth.AuthEvent(\n                 fireauth.AuthEvent.Type.UNKNOWN,\n                 null,\n                 null,\n                 null,\n                 new fireauth.AuthError(\n                     fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n              if (fireauth.AuthEventManager.isCordovaFalsePositive_(\n                  /** @type {?fireauth.AuthError} */ (error))) {\n                self.handleAuthEvent_(notSupportedEvent);\n              }\n            });\n          });\n    } else {\n      // No previous redirect, default to empty response.\n      self.initializeWithNoPendingRedirectResult_();\n    }\n  }).thenCatch(function(error) {\n    // Error checking pending status, default to empty response.\n    self.initializeWithNoPendingRedirectResult_();\n  });\n};\n\n\n/**\n * @param {!fireauth.AuthEventHandler} handler The possible subscriber.\n * @return {boolean} Whether the handle is subscribed.\n */\nfireauth.AuthEventManager.prototype.isSubscribed = function(handler) {\n  return goog.array.contains(this.subscribedHandlers_, handler);\n};\n\n\n/**\n * Unsubscribes an Auth event handler to list of handlers.\n * @param {!fireauth.AuthEventHandler} handler The instance to unsubscribe.\n */\nfireauth.AuthEventManager.prototype.unsubscribe = function(handler) {\n  goog.array.removeAllIf(this.subscribedHandlers_, function(ele) {\n    return ele == handler;\n  });\n};\n\n\n/**\n * @param {?fireauth.AuthEvent} authEvent External Auth event to check.\n * @return {boolean} Whether the event was previously processed.\n * @private\n */\nfireauth.AuthEventManager.prototype.hasProcessedAuthEvent_ =\n    function(authEvent) {\n  // Prevent duplicate event tracker from growing too large.\n  if (goog.now() - this.lastProcessedEventTime_ >=\n      fireauth.AuthEventManager.EVENT_DUPLICATION_CACHE_DURATION) {\n    this.processedEvents_ = {};\n    this.lastProcessedEventTime_ = 0;\n  }\n  if (authEvent && authEvent.getUid() &&\n      this.processedEvents_.hasOwnProperty(authEvent.getUid())) {\n    // If event is already processed, ignore it.\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Saves the provided event uid to prevent processing duplication.\n * @param {?fireauth.AuthEvent} authEvent External Auth event to track in\n *     processed list of events.\n * @private\n */\nfireauth.AuthEventManager.prototype.saveProcessedAuthEvent_ =\n    function(authEvent) {\n  if (authEvent &&\n      (authEvent.getSessionId() || authEvent.getEventId())) {\n    // Save processed event ID. We keep the cache for 10 minutes to prevent it\n    // from growing too large.\n    this.processedEvents_[\n        /** @type {string} */ (authEvent.getUid())] = true;\n    // Save last processing time.\n    this.lastProcessedEventTime_ = goog.now();\n  }\n};\n\n\n/**\n * Handles external Auth event detected by the OAuth sign-in handler.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @return {boolean} Whether the event found an appropriate owner that can\n *     handle it. This signals to the OAuth helper iframe that the event is safe\n *     to delete.\n * @private\n */\nfireauth.AuthEventManager.prototype.handleAuthEvent_ = function(authEvent) {\n  // This should not happen as fireauth.iframe.AuthRelay will not send null\n  // events.\n  if (!authEvent) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT);\n  }\n  if (this.hasProcessedAuthEvent_(authEvent)) {\n    // If event is already processed, ignore it.\n    return false;\n  }\n  // Initialize event processed status to false. When set to false, the event is\n  // not clear to delete in the OAuth helper iframe as the owner of this event\n  // could be a user in another tab.\n  var processed = false;\n  // Lookup a potential handler for this event.\n  for (var i = 0; i < this.subscribedHandlers_.length; i++) {\n    var potentialHandler = this.subscribedHandlers_[i];\n    if (potentialHandler.canHandleAuthEvent(\n        authEvent.getType(), authEvent.getEventId())) {\n      var eventManager = this.typeToManager_[authEvent.getType()];\n      if (eventManager) {\n        eventManager.processAuthEvent(authEvent, potentialHandler);\n        // Prevent events with event IDs or session IDs from duplicate\n        // processing.\n        this.saveProcessedAuthEvent_(authEvent);\n      }\n      // Event has been processed, free to clear in OAuth helper.\n      processed = true;\n      break;\n    }\n  }\n  // If no redirect response ready yet, default to an empty response.\n  this.redirectAuthEventProcessor_.defaultToEmptyResponse();\n  // Notify iframe of processed status.\n  return processed;\n};\n\n\n/**\n * The popup promise timeout delay with units in ms between the time the iframe\n * is ready (successfully embedded on the page) and the time the popup Auth\n * event is detected in the parent container.\n * @const {!fireauth.util.Delay}\n * @private\n */\nfireauth.AuthEventManager.POPUP_TIMEOUT_MS_ =\n    new fireauth.util.Delay(2000, 10000);\n\n\n/**\n * The redirect promise timeout delay with units in ms. Unlike the popup\n * timeout, this covers the entire duration from start to getRedirectResult\n * resolution.\n * @const {!fireauth.util.Delay}\n * @private\n */\nfireauth.AuthEventManager.REDIRECT_TIMEOUT_MS_ =\n    new fireauth.util.Delay(30000, 60000);\n\n\n/**\n * Returns the redirect result. If coming back from a successful redirect sign\n * in, will resolve to the signed in user. If coming back from an unsuccessful\n * redirect sign, will reject with the proper error. If no redirect operation\n * called, resolves with null.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthEventManager.prototype.getRedirectResult = function() {\n  return this.redirectAuthEventProcessor_.getRedirectResult();\n};\n\n\n/**\n * Processes the popup request. The popup instance must be provided externally\n * and on error, the requestor must close the window.\n * @param {?Window} popupWin The popup window reference.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {string=} opt_eventId The optional event ID.\n * @param {boolean=} opt_alreadyRedirected Whether popup is already redirected\n *     to final destination.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise} The popup window promise.\n */\nfireauth.AuthEventManager.prototype.processPopup =\n    function(popupWin, mode, provider, opt_eventId, opt_alreadyRedirected,\n             opt_tenantId) {\n  var self = this;\n  return this.oauthSignInHandler_.processPopup(\n      popupWin,\n      mode,\n      provider,\n      // On initialization, add Auth event listener if not already added.\n      function() {\n        if (!self.initialized_) {\n          self.initialized_ = true;\n          // Listen to Auth events on iframe.\n          self.oauthSignInHandler_.addAuthEventListener(self.authEventHandler_);\n        }\n      },\n      // On error, reset to force re-initialization on retrial.\n      function(error) {\n        self.reset();\n      },\n      opt_eventId,\n      opt_alreadyRedirected,\n      opt_tenantId);\n};\n\n\n/**\n * @param {?fireauth.AuthError} error The error to check for Cordova false\n *     positive.\n * @return {boolean} Whether the current environment was falsely identified as\n *     Cordova.\n * @private\n */\nfireauth.AuthEventManager.isCordovaFalsePositive_ = function(error) {\n  if (error && error['code'] == 'auth/cordova-not-ready') {\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Processes the redirect request.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {string=} opt_eventId The optional event ID.\n * @param {?string=} opt_tenantId The optional tenant ID.\n * @return {!goog.Promise}\n */\nfireauth.AuthEventManager.prototype.processRedirect =\n    function(mode, provider, opt_eventId, opt_tenantId) {\n  var self = this;\n  var error;\n  // Save pending status first.\n  return this.pendingRedirectStorageManager_.setPendingStatus()\n    .then(function() {\n      // Try to redirect.\n      return self.oauthSignInHandler_.processRedirect(\n          mode, provider, opt_eventId, opt_tenantId)\n        .thenCatch(function(e) {\n          if (fireauth.AuthEventManager.isCordovaFalsePositive_(\n              /** @type {?fireauth.AuthError} */ (e))) {\n            throw new fireauth.AuthError(\n                fireauth.authenum.Error.OPERATION_NOT_SUPPORTED);\n          }\n          // On failure, remove pending status and rethrow the error.\n          error = e;\n          return self.pendingRedirectStorageManager_.removePendingStatus()\n            .then(function() {\n              throw error;\n            });\n        })\n        .then(function() {\n          // Resolve, if the OAuth handler unloads the page on redirect.\n          if (!self.oauthSignInHandler_.unloadsOnRedirect()) {\n            // Relevant to Cordova case, will not matter in web case where\n            // browser redirects.\n            // In Cordova, the activity could still be running in the background\n            // so we need to wait for getRedirectResult to resolve before\n            // resolving this current promise.\n            // Otherwise, if the activity is destroyed, getRedirectResult would\n            // be used.\n            // At this point, authEvent should have been triggered.\n            // When this promise resolves, the developer should be able to\n            // call getRedirectResult to get the result of this operation.\n            // Remove pending status as result should be resolved.\n            return self.pendingRedirectStorageManager_.removePendingStatus()\n                .then(function() {\n                  // Ensure redirect result ready before resolving.\n                  return self.getRedirectResult();\n                }).then(function(result) {\n                  // Do nothing. Developer expected to call getRedirectResult to\n                  // get result.\n                }).thenCatch(function(error) {\n                  // Do nothing. Developer expected to call getRedirectResult to\n                  // get result.\n                });\n          } else {\n            // For environments that will unload the page on redirect, keep\n            // the promise pending on success. This makes it easier to reuse\n            // the same code for Cordova environment and browser environment.\n            // The developer can always add getRedirectResult on promise\n            // resolution and expect that when it runs, the redirect operation\n            // was completed.\n            return new goog.Promise(function(resolve, reject) {\n              // Keep this pending.\n            });\n          }\n        });\n    });\n};\n\n\n/**\n * Waits for popup window to close. When closed start timeout listener for popup\n * pending promise. If in the process, it was detected that the iframe does not\n * support web storage, the popup is closed and the web storage unsupported\n * error is thrown.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @param {!fireauth.AuthEvent.Type} mode The Auth event type.\n * @param {!Window} popupWin The popup window.\n * @param {?string=} opt_eventId The event ID.\n * @return {!goog.Promise}\n */\nfireauth.AuthEventManager.prototype.startPopupTimeout =\n    function(owner, mode, popupWin, opt_eventId) {\n  return this.oauthSignInHandler_.startPopupTimeout(\n      popupWin,\n      // On popup error such as popup closed by user or web storage not\n      // supported.\n      function(error) {\n        // Notify owner of the error.\n        owner.resolvePendingPopupEvent(mode, null, error, opt_eventId);\n      },\n      fireauth.AuthEventManager.POPUP_TIMEOUT_MS_.get());\n};\n\n\n\n/**\n * @private {!Object.<string, !fireauth.AuthEventManager>} Map containing\n *     Firebase event manager instances keyed by Auth event manager ID.\n */\nfireauth.AuthEventManager.manager_ = {};\n\n\n/**\n * The separator for manager keys to concatenate app name and apiKey.\n * @const {string}\n * @private\n */\nfireauth.AuthEventManager.KEY_SEPARATOR_ = ':';\n\n\n/**\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The Auth instance that initiated the Auth event.\n * @return {string} The key identifying the Auth event manager instance.\n * @private\n */\nfireauth.AuthEventManager.getKey_ = function(apiKey, appName) {\n  return apiKey + fireauth.AuthEventManager.KEY_SEPARATOR_ + appName;\n};\n\n\n/**\n * @param {string} authDomain The Firebase authDomain used to determine the\n *     OAuth helper page domain.\n * @param {string} apiKey The API key for sending backend Auth requests.\n * @param {string} appName The Auth instance that initiated the Auth event\n *     manager.\n * @return {!fireauth.AuthEventManager} the requested manager instance.\n */\nfireauth.AuthEventManager.getManager = function(authDomain, apiKey, appName) {\n  // Construct storage key.\n  var key = fireauth.AuthEventManager.getKey_(apiKey, appName);\n  if (!fireauth.AuthEventManager.manager_[key]) {\n    fireauth.AuthEventManager.manager_[key] =\n        new fireauth.AuthEventManager(authDomain, apiKey, appName);\n  }\n  return fireauth.AuthEventManager.manager_[key];\n};\n\n\n\n/**\n * The interface that represents a specific type of Auth event processor.\n * @interface\n */\nfireauth.AuthEventProcessor = function() {};\n\n\n/**\n * Completes the processing of an external Auth event detected by the embedded\n * iframe.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n */\nfireauth.AuthEventProcessor.prototype.processAuthEvent =\n    function(authEvent, owner) {};\n\n\n\n/**\n * Redirect Auth event manager.\n * @param {!fireauth.AuthEventManager} manager The parent Auth event manager.\n * @constructor\n * @implements {fireauth.AuthEventProcessor}\n */\nfireauth.RedirectAuthEventProcessor = function(manager) {\n  this.manager_ = manager;\n  // Only one redirect result can be tracked on first load.\n  /**\n   * @private {?function():!goog.Promise<!fireauth.AuthEventManager.Result>}\n   *     Redirect result resolver. This will be used to resolve the\n   *     getRedirectResult promise. When the redirect result is obtained, this\n   *     field will be set.\n   */\n  this.redirectedUserPromise_ = null;\n  /**\n   * @private {!Array<function(!fireauth.AuthEventManager.Result)>} Pending\n   *     promise redirect resolver. When the redirect result is obtained and the\n   *     user is detected, this will be called.\n   */\n  this.redirectResolve_ = [];\n  /**\n   * @private {!Array<function(*)>} Pending Promise redirect rejecter. When the\n   *     redirect result is obtained and an error is detected, this will be\n   *     called.\n   */\n  this.redirectReject_ = [];\n  /** @private {?goog.Promise} Pending timeout promise for redirect. */\n  this.redirectTimeoutPromise_ = null;\n  /**\n   * @private {boolean} Whether redirect result is resolved. This is true\n   *     when a valid Auth event has been triggered.\n   */\n  this.redirectResultResolved_ = false;\n  /**\n   * @private {boolean} Whether an unrecoverable error was detected. This\n   *     includes web storage unsupported or operation not allowed errors.\n   */\n  this.unrecoverableErrorDetected_ = false;\n};\n\n\n/** Reset any previous redirect result. */\nfireauth.RedirectAuthEventProcessor.prototype.reset = function() {\n  // Reset to allow override getRedirectResult. This is relevant for Cordova\n  // environment where redirect events do not necessarily unload the current\n  // page.\n  this.redirectedUserPromise_ = null;\n  if (this.redirectTimeoutPromise_) {\n    this.redirectTimeoutPromise_.cancel();\n    this.redirectTimeoutPromise_ = null;\n  }\n};\n\n\n/**\n * Completes the processing of an external Auth event detected by the embedded\n * iframe.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @override\n */\nfireauth.RedirectAuthEventProcessor.prototype.processAuthEvent =\n    function(authEvent, owner) {\n  // This should not happen as fireauth.iframe.AuthRelay will not send null\n  // events.\n  if (!authEvent) {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT));\n  }\n  // Reset any pending redirect result. This event will overwrite it.\n  this.reset();\n  this.redirectResultResolved_ = true;\n  var mode = authEvent.getType();\n  var eventId = authEvent.getEventId();\n  // Check if web storage is not supported in the iframe.\n  var isWebStorageNotSupported =\n      authEvent.getError() &&\n      authEvent.getError()['code'] == 'auth/web-storage-unsupported';\n  /// Check if operation is supported in this environment.\n  var isOperationNotSupported =\n      authEvent.getError() &&\n      authEvent.getError()['code'] == 'auth/operation-not-supported-in-this-' +\n          'environment';\n  this.unrecoverableErrorDetected_ =\n      !!(isWebStorageNotSupported || isOperationNotSupported);\n  // UNKNOWN mode is always triggered on load by iframe when no popup/redirect\n  // data is available. If web storage unsupported error is thrown, process as\n  // error and not as unknown event. If the operation is not supported in this\n  // environment, also treat as an error and not as an unknown event.\n  if (mode == fireauth.AuthEvent.Type.UNKNOWN &&\n      !isWebStorageNotSupported &&\n      !isOperationNotSupported) {\n    return this.processUnknownEvent_();\n  } else if (authEvent.hasError()) {\n    return this.processErrorEvent_(authEvent, owner);\n  } else if (owner.getAuthEventHandlerFinisher(mode, eventId)) {\n    return this.processSuccessEvent_(authEvent, owner);\n  } else {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT));\n  }\n};\n\n\n/**\n * Sets an empty redirect result response when no redirect result is available.\n */\nfireauth.RedirectAuthEventProcessor.prototype.defaultToEmptyResponse =\n    function() {\n  // If the first event does not resolve redirectResult and no subscriber can\n  // handle it, set redirect result to null.\n  // An example of this scenario would be a link via redirect that was triggered\n  // by a user that was not logged in. canHandleAuthEvent will be false for all\n  // subscribers. So make sure getRedirectResult when called will resolve to a\n  // null user.\n  if (!this.redirectResultResolved_) {\n    this.redirectResultResolved_ = true;\n    // No Auth event available, getRedirectResult should resolve with null.\n    this.setRedirectResult_(false, null, null);\n  }\n};\n\n\n/**\n * Clears the cached redirect result as long as there is no pending redirect\n * result being processed. Unrecoverable errors will not be cleared.\n */\nfireauth.RedirectAuthEventProcessor.prototype.clearRedirectResult = function() {\n  // Clear the result if it is already resolved and no unrecoverable errors are\n  // detected.\n  if (this.redirectResultResolved_ && !this.unrecoverableErrorDetected_) {\n    this.setRedirectResult_(false, null, null);\n  }\n};\n\n\n/**\n * Processes the unknown event.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.processUnknownEvent_ =\n    function() {\n  // No Auth event available, getRedirectResult should resolve with null.\n  this.setRedirectResult_(false, null, null);\n  return goog.Promise.resolve();\n};\n\n\n/**\n * Processes an error event.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.processErrorEvent_ =\n    function(authEvent, owner) {\n  // Set redirect result to resolve with null if event is not a redirect or\n  // reject with error if event is an error.\n  this.setRedirectResult_(true, null, authEvent.getError());\n  return goog.Promise.resolve();\n};\n\n\n/**\n * Processes a successful event.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.processSuccessEvent_ =\n    function(authEvent, owner) {\n  var self = this;\n  var eventId = authEvent.getEventId();\n  var mode = authEvent.getType();\n  var handler = owner.getAuthEventHandlerFinisher(mode, eventId);\n  var requestUri = /** @type {string} */ (authEvent.getUrlResponse());\n  var sessionId = /** @type {string} */ (authEvent.getSessionId());\n  var postBody = /** @type {?string} */ (authEvent.getPostBody());\n  var tenantId = /** @type {?string} */ (authEvent.getTenantId());\n  var isRedirect = fireauth.AuthEvent.isRedirect(authEvent);\n  // Complete sign in or link account operation and then pass result to\n  // relevant pending popup promise.\n  return handler(requestUri, sessionId, tenantId, postBody)\n      .then(function(popupRedirectResponse) {\n    // Flow completed.\n    // For a redirect operation resolve with the popupRedirectResponse,\n    // otherwise resolve with null.\n    self.setRedirectResult_(isRedirect, popupRedirectResponse, null);\n  }).thenCatch(function(error) {\n    // Flow not completed due to error.\n    // For a redirect operation reject with the error, otherwise resolve\n    // with null.\n    self.setRedirectResult_(\n        isRedirect, null, /** @type {!fireauth.AuthError} */ (error));\n    // Always resolve.\n    return;\n  });\n};\n\n\n/**\n * Sets redirect error result.\n * @param {!fireauth.AuthError} error The redirect operation error.\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.setRedirectReject_ =\n    function(error) {\n  // If a redirect error detected, reject getRedirectResult with that error.\n  this.redirectedUserPromise_ = function() {\n    return goog.Promise.reject(error);\n  };\n  // Reject all pending getRedirectResult promises.\n  if (this.redirectReject_.length) {\n    for (var i = 0; i < this.redirectReject_.length; i++) {\n      this.redirectReject_[i](error);\n    }\n  }\n};\n\n\n/**\n * Sets redirect success result.\n * @param {!fireauth.AuthEventManager.Result} popupRedirectResult The\n *     resolved user for a successful or null user redirect.\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.setRedirectResolve_ =\n    function(popupRedirectResult) {\n  // If a redirect user detected, resolve getRedirectResult with the\n  // popupRedirectResult.\n  // Result should not be null in this case.\n  this.redirectedUserPromise_ = function() {\n    return goog.Promise.resolve(\n        /** @type {!fireauth.AuthEventManager.Result} */ (popupRedirectResult));\n  };\n  // Resolve all pending getRedirectResult promises.\n  if (this.redirectResolve_.length) {\n    for (var i = 0; i < this.redirectResolve_.length; i++) {\n      this.redirectResolve_[i](\n          /** @type {!fireauth.AuthEventManager.Result} */ (\n              popupRedirectResult));\n    }\n  }\n};\n\n\n/**\n * @param {boolean} isRedirect Whether Auth event is a redirect event.\n * @param {?fireauth.AuthEventManager.Result} popupRedirectResult The\n *     resolved user for a successful redirect. This user is null if no redirect\n *     operation run.\n * @param {?fireauth.AuthError} error The redirect operation error.\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.setRedirectResult_ =\n    function(isRedirect, popupRedirectResult, error) {\n  if (isRedirect) {\n    // This is a redirect operation, either resolves with user or error.\n    if (error) {\n      // If a redirect error detected, reject getRedirectResult with that error.\n      this.setRedirectReject_(error);\n    } else {\n      // If a redirect user detected, resolve getRedirectResult with the\n      // popupRedirectResult.\n      // Result should not be null in this case.\n      this.setRedirectResolve_(\n          /** @type {!fireauth.AuthEventManager.Result} */ (\n              popupRedirectResult));\n    }\n  } else {\n    // Not a redirect, set redirectUser_ to return null.\n    this.setRedirectResolve_({\n      'user': null\n    });\n  }\n  // Reset all pending promises.\n  this.redirectResolve_ = [];\n  this.redirectReject_ = [];\n};\n\n\n/**\n * Returns the redirect result. If coming back from a successful redirect sign\n * in, will resolve to the signed in user. If coming back from an unsuccessful\n * redirect sign, will reject with the proper error. If no redirect operation\n * called, resolves with null.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.RedirectAuthEventProcessor.prototype.getRedirectResult = function() {\n  var self = this;\n  // Initial result could be overridden in the case of Cordova.\n  // Auth domain must be included for this to resolve.\n  // If still pending just return the pending promise.\n  var p = new goog.Promise(function(resolve, reject) {\n    // The following logic works if this method was called before Auth event\n    // is triggered.\n    if (!self.redirectedUserPromise_) {\n      // Save resolves and rejects of pending promise for redirect operation.\n      self.redirectResolve_.push(resolve);\n      self.redirectReject_.push(reject);\n      // Start timeout listener to getRedirectResult pending promise.\n      // Call this only when redirectedUserPromise_ is not determined.\n      self.startRedirectTimeout_();\n    } else {\n      // Called after Auth event is triggered.\n      self.redirectedUserPromise_().then(resolve, reject);\n    }\n  });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (p);\n};\n\n\n/**\n * Starts timeout listener for getRedirectResult pending promise. This method\n * should not be called again after getRedirectResult's redirectedUserPromise_\n * is determined.\n * @private\n */\nfireauth.RedirectAuthEventProcessor.prototype.startRedirectTimeout_ =\n    function() {\n  // Expire pending timeout promise for popup operation.\n  var self = this;\n  var error = new fireauth.AuthError(\n      fireauth.authenum.Error.TIMEOUT);\n  if (this.redirectTimeoutPromise_) {\n    this.redirectTimeoutPromise_.cancel();\n  }\n  // For redirect mode.\n  this.redirectTimeoutPromise_ =\n      goog.Timer.promise(fireauth.AuthEventManager.REDIRECT_TIMEOUT_MS_.get())\n      .then(function() {\n        // If not resolved yet, reject with timeout error.\n        if (!self.redirectedUserPromise_) {\n          // Consider redirect result resolved.\n          self.redirectResultResolved_ = true;\n          self.setRedirectResult_(true, null, error);\n        }\n      });\n\n};\n\n\n\n/**\n * Popup Auth event manager.\n * @param {!fireauth.AuthEventManager} manager The parent Auth event manager.\n * @constructor\n * @implements {fireauth.AuthEventProcessor}\n */\nfireauth.PopupAuthEventProcessor = function(manager) {\n  this.manager_ = manager;\n};\n\n\n/**\n * Completes the processing of an external Auth event detected by the embedded\n * iframe.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @override\n */\nfireauth.PopupAuthEventProcessor.prototype.processAuthEvent =\n    function(authEvent, owner) {\n  // This should not happen as fireauth.iframe.AuthRelay will not send null\n  // events.\n  if (!authEvent) {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT));\n  }\n  var mode = authEvent.getType();\n  var eventId = authEvent.getEventId();\n  if (authEvent.hasError()) {\n    return this.processErrorEvent_(authEvent, owner);\n  } else if (owner.getAuthEventHandlerFinisher(mode, eventId)) {\n    return this.processSuccessEvent_(authEvent, owner);\n  } else {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.INVALID_AUTH_EVENT));\n  }\n};\n\n\n/**\n * Processes an error event.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.PopupAuthEventProcessor.prototype.processErrorEvent_ =\n    function(authEvent, owner) {\n  var eventId = authEvent.getEventId();\n  var mode = authEvent.getType();\n  // For pending popup promises trigger rejects with the error.\n  owner.resolvePendingPopupEvent(mode, null, authEvent.getError(), eventId);\n  return goog.Promise.resolve();\n};\n\n\n/**\n * Processes a successful event.\n * @param {?fireauth.AuthEvent} authEvent External Auth event detected by\n *     iframe.\n * @param {!fireauth.AuthEventHandler} owner The owner of the event.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.PopupAuthEventProcessor.prototype.processSuccessEvent_ =\n    function(authEvent, owner) {\n  var eventId = authEvent.getEventId();\n  var mode = authEvent.getType();\n  var handler = owner.getAuthEventHandlerFinisher(mode, eventId);\n  // Successful operation, complete the exchange for an ID token.\n  var requestUri = /** @type {string} */ (authEvent.getUrlResponse());\n  var sessionId = /** @type {string} */ (authEvent.getSessionId());\n  var postBody = /** @type {?string} */ (authEvent.getPostBody());\n  var tenantId = /** @type {?string} */ (authEvent.getTenantId());\n  // Complete sign in or link account operation and then pass result to\n  // relevant pending popup promise.\n  return handler(requestUri, sessionId, tenantId, postBody)\n      .then(function(popupRedirectResponse) {\n    // Flow completed.\n    // Resolve pending popup promise if it exists.\n    owner.resolvePendingPopupEvent(mode, popupRedirectResponse, null, eventId);\n  }).thenCatch(function(error) {\n    // Flow not completed due to error.\n    // Resolve pending promise if it exists.\n    owner.resolvePendingPopupEvent(\n        mode, null, /** @type {!fireauth.AuthError} */ (error), eventId);\n    // Always resolve.\n    return;\n  });\n};\n\n\n\n/**\n * The interface that represents an Auth event handler. It provides the\n * ability for the Auth event manager to determine the owner of an Auth event,\n * the ability to resolve a pending popup event and the appropriate handler for\n * an event.\n * @interface\n */\nfireauth.AuthEventHandler = function() {};\n\n\n/**\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?string=} opt_eventId The event ID.\n * @return {boolean} Whether the Auth event handler can handler the provided\n *     event.\n */\nfireauth.AuthEventHandler.prototype.canHandleAuthEvent =\n    function(mode, opt_eventId) {};\n\n\n/**\n * Completes the pending popup operation. If error is not null, rejects with the\n * error. Otherwise, it resolves with the popup redirect result.\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?fireauth.AuthEventManager.Result} popupRedirectResult The result\n *     to resolve with when no error supplied.\n * @param {?fireauth.AuthError} error When supplied, the promise will reject.\n * @param {?string=} opt_eventId The event ID.\n */\nfireauth.AuthEventHandler.prototype.resolvePendingPopupEvent =\n    function(mode, popupRedirectResult, error, opt_eventId) {};\n\n\n/**\n * Returns the handler's appropriate popup and redirect sign in operation\n * finisher.\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?string=} opt_eventId The optional event ID.\n * @return {?function(string, string, ?string,\n *     ?string=):!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthEventHandler.prototype.getAuthEventHandlerFinisher =\n    function(mode, opt_eventId) {};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /**\n * @fileoverview Defines the firebase.auth.AuthSettings structure.\n */\n\ngoog.provide('fireauth.AuthSettings');\n\n\n/**\n * The class used to initialize an Auth settings object currently used to\n * enable or disable app verification for testing.\n * @constructor\n */\nfireauth.AuthSettings = function() {\n  this.appVerificationDisabledForTesting_ = false;\n  Object.defineProperty(\n      /** @type {!Object} */ (this),\n      'appVerificationDisabled',\n      {\n        /**\n         * @this {!Object}\n         * @return {boolean} The current status.\n         */\n        get: function() {\n          return this.getAppVerificationDisabledForTesting();\n        },\n        /**\n         * @this {!Object}\n         * @param {boolean} value The new status.\n         */\n        set: function(value) {\n          this.setAppVerificationDisabledForTesting(value);\n        },\n        enumerable: false\n      });\n};\n\n\n/**\n * Sets whether app verification is disable for testing.\n * @param {boolean} status App verification status for testing.\n */\nfireauth.AuthSettings.prototype.setAppVerificationDisabledForTesting =\n    function(status) {\n  this.appVerificationDisabledForTesting_ = status;\n};\n\n\n/**\n * @return {boolean} Whether app verification is enabled or disabled for\n *     testing.\n */\nfireauth.AuthSettings.prototype.getAppVerificationDisabledForTesting =\n    function() {\n  return this.appVerificationDisabledForTesting_;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the firebase.auth.ConfirmationResult. This is needed\n * to provide first class support for phone Auth API: signInWithPhoneNumber,\n * linkWithPhoneNumber and reauthenticateWithPhoneNumber.\n */\n\ngoog.provide('fireauth.ConfirmationResult');\n\ngoog.require('fireauth.PhoneAuthProvider');\ngoog.require('fireauth.object');\ngoog.require('goog.Promise');\n\n\n/**\n * The confirmation result class. This takes in the verification ID returned\n * from the phone Auth provider and the credential resolver to run when\n * confirming with a verification code.\n * @param {string} verificationId The verification ID returned from the Phone\n *     Auth provider after sending the verification code.\n * @param {!function(!fireauth.AuthCredential):\n *     !goog.Promise<!fireauth.AuthEventManager.Result>} credentialResolver a\n *     function that takes in an AuthCredential and returns a promise that\n *     resolves with a UserCredential object.\n * @constructor\n */\nfireauth.ConfirmationResult = function(verificationId, credentialResolver) {\n  /**\n   * @const @private {!function(!fireauth.AuthCredential):\n   *     !goog.Promise<!fireauth.AuthEventManager.Result>} A function that takes\n   *     in an AuthCredential and returns a promise that resolves with a\n   *     UserCredential object.\n   */\n  this.credentialResolver_ = credentialResolver;\n  // Set verificationId as read-only property.\n  fireauth.object.setReadonlyProperty(this, 'verificationId', verificationId);\n};\n\n\n/**\n * Confirms the verification code and returns a promise that resolves with the\n * User Credential object.\n * @param {string} verificationCode The phone Auth verification code to use to\n *     complete the Auth flow.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.ConfirmationResult.prototype.confirm = function(verificationCode) {\n  // Initialize a phone Auth credential with the verification ID and code.\n  var credential = fireauth.PhoneAuthProvider.credential(\n      this['verificationId'], verificationCode);\n  // Run the credential resolver with the phone Auth credential and return its\n  // result.\n  return this.credentialResolver_(credential);\n};\n\n\n/**\n * Initializes a ConfirmationResult using the provided phone number, app\n * verifier and returns it asynchronously. On code confirmation, the result will\n * resolve using the credential resolver provided.\n * @param {!fireauth.Auth} auth The corresponding Auth instance.\n * @param {string} phoneNumber The phone number to authenticate with.\n * @param {!firebase.auth.ApplicationVerifier} appVerifier The application\n *     verifier.\n * @param {!function(!fireauth.AuthCredential):\n *     !goog.Promise<!fireauth.AuthEventManager.Result>} credentialResolver a\n *     function that takes in an AuthCredential and returns a promise that\n *     resolves with a UserCredential object.\n * @return {!goog.Promise<!fireauth.ConfirmationResult>}\n */\nfireauth.ConfirmationResult.initialize =\n    function(auth, phoneNumber, appVerifier, credentialResolver) {\n  // Initialize a phone Auth provider instance using the provided Auth\n  // instance.\n  var phoneAuthProvider = new fireauth.PhoneAuthProvider(auth);\n  // Verify the phone number.\n  return phoneAuthProvider.verifyPhoneNumber(phoneNumber, appVerifier)\n      .then(function(verificationId) {\n        // When code is sent and verification ID is returned, initialize a\n        // ConfirmationResult with the returned verification ID and credential\n        // resolver, and return that instance.\n        return new fireauth.ConfirmationResult(\n            verificationId, credentialResolver);\n      });\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the firebase.auth.IdTokenResult class that is obtained\n * from getIdTokenResult. It contains the ID token JWT string and other helper\n * properties for getting different data associated with the token as well as\n * all the decoded payload claims.\n */\n\ngoog.provide('fireauth.IdTokenResult');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.IdToken');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\n\n\n\n/**\n * This is the ID token result object obtained from getIdTokenResult. It\n * contains the ID token JWT string and other helper properties for getting\n * different data associated with the token as well as all the decoded payload\n * claims.\n * @param {string} tokenString The JWT token.\n * @constructor\n */\nfireauth.IdTokenResult = function(tokenString) {\n  var idToken = fireauth.IdToken.parseIdTokenClaims(tokenString);\n  if (!idToken || !idToken['exp'] || !idToken['auth_time'] || !idToken['iat']) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INTERNAL_ERROR,\n        'An internal error occurred. The token obtained by Firebase appears ' +\n        'to be malformed. Please retry the operation.');\n  }\n  fireauth.object.setReadonlyProperties(this, {\n    'token': tokenString,\n    'expirationTime': fireauth.util.utcTimestampToDateString(\n        idToken['exp'] * 1000),\n    'authTime': fireauth.util.utcTimestampToDateString(\n        idToken['auth_time'] * 1000),\n    'issuedAtTime': fireauth.util.utcTimestampToDateString(\n        idToken['iat'] * 1000),\n    'signInProvider': (idToken['firebase'] &&\n                       idToken['firebase']['sign_in_provider']) ?\n                      idToken['firebase']['sign_in_provider'] : null,\n    'claims': idToken\n  });\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Utility for proactive refresh with exponential backoff\n * algorithm typically used to define a retry policy for certain async\n * operations.\n */\n\ngoog.provide('fireauth.ProactiveRefresh');\n\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.Timer');\n\n\n/**\n * The helper utility used to proactively refresh a certain operation based on\n * certain constraints with an exponential backoff retrial policy when\n * specific recoverable errors occur. Typically this is used to retry an\n * operation on network errors.\n * @param {!function():!goog.Promise} operation The promise returning operation\n *     to run.\n * @param {!function(*):boolean} retryPolicy A function that takes in an error\n *     and returns whether a retry policy should be implemented based on the\n *     error. If not, the operation will not run again.\n * @param {!function():number} getWaitDuration A function that returns the wait\n *     period before running again.\n * @param {number} lowerBound The lower bound duration to wait when an error\n *     occurs. This is the first interval to wait before rerunning after an\n *     error is detected.\n * @param {number} upperBound The upper bound duration to wait when an error\n *     keeps occurring. This upper bound should not be exceeded.\n * @param {boolean=} opt_runInBackground Whether to run in the background, when\n *     the tab is not visible. If the refresh should only run when the app is\n *     visible, the operation will block until the app is visible and then run.\n * @constructor @struct @final\n */\nfireauth.ProactiveRefresh = function(\n    operation,\n    retryPolicy,\n    getWaitDuration,\n    lowerBound,\n    upperBound,\n    opt_runInBackground) {\n  /**\n   * @const @private {!function():!goog.Promise} The promise returning operation\n   *     to run.\n   */\n  this.operation_ = operation;\n  /**\n   * @const @private {!function(*):boolean} The function that takes in an error\n   *     and returns whether a retry policy should be implemented based on the\n   *     error caught.\n   */\n  this.retryPolicy_ = retryPolicy;\n  /**\n   * @const @private {!function():number} The function that returns the wait\n   *     period after a successful operation before running again.\n   */\n  this.getWaitDuration_ = getWaitDuration;\n  /**\n   * @const @private {number} The lower bound duration to wait when an error\n   *     first occurs.\n   */\n  this.lowerBound_ = lowerBound;\n  /**\n   * @const @private {number} The upper bound duration to wait when an error\n   *     keeps occurring. This upper bound should not be exceeded.\n   */\n  this.upperBound_ = upperBound;\n  /**\n   * @const @private {boolean} Whether to run in the background, when the tab is\n   *     not visible.\n   */\n  this.runInBackground_ = !!opt_runInBackground;\n  /**\n   * @private {?goog.Promise} The pending promise for the next operation to run.\n   */\n  this.pending_ = null;\n  /**\n   * @private {number} The first wait interval when a new error occurs.\n   */\n  this.nextErrorWaitInterval_ = this.lowerBound_;\n  // Throw an error if the lower bound is greater than upper bound.\n  if (this.upperBound_ < this.lowerBound_) {\n    throw new Error('Proactive refresh lower bound greater than upper bound!');\n  }\n};\n\n\n/** Starts the proactive refresh based on the current configuration. */\nfireauth.ProactiveRefresh.prototype.start = function() {\n  // Set the next error wait interval to the lower bound. On each consecutive\n  // error, this will double in value until it reaches the upper bound.\n  this.nextErrorWaitInterval_ = this.lowerBound_;\n  // Start proactive refresh with clean slate (successful status).\n  this.process_(true);\n};\n\n\n/**\n * Returns the wait duration before the next run depending on the last run\n * status. If the last operation has succeeded, returns the getWaitDuration()\n * response. Otherwise, doubles the last error wait interval starting from\n * lowerBound and up to upperBound.\n * @param {boolean} hasSucceeded Whether last run succeeded.\n * @return {number} The wait time for the next run.\n * @private\n */\nfireauth.ProactiveRefresh.prototype.getNextRun_ = function(hasSucceeded) {\n  if (hasSucceeded) {\n    // If last operation succeeded, reset next error wait interval and return\n    // the default wait duration.\n    this.nextErrorWaitInterval_ = this.lowerBound_;\n    // Return typical wait duration interval after a successful operation.\n    return this.getWaitDuration_();\n  } else {\n    // Get next error wait interval.\n    var currentErrorWaitInterval = this.nextErrorWaitInterval_;\n    // Double interval for next consecutive error.\n    this.nextErrorWaitInterval_ *= 2;\n    // Make sure next wait interval does not exceed the maximum upper bound.\n    if (this.nextErrorWaitInterval_  > this.upperBound_) {\n      this.nextErrorWaitInterval_  = this.upperBound_;\n    }\n    return currentErrorWaitInterval;\n  }\n};\n\n\n/**\n * Processes one refresh call and sets the timer for the next call based on\n * the last recorded result.\n * @param {boolean} hasSucceeded Whether last run succeeded.\n * @private\n */\nfireauth.ProactiveRefresh.prototype.process_ = function(hasSucceeded) {\n  var self = this;\n  // Stop any other pending operation.\n  this.stop();\n  // Wait for next scheduled run based on whether an error occurred during last\n  // run.\n  this.pending_ = goog.Timer.promise(this.getNextRun_(hasSucceeded))\n      .then(function() {\n        // Block for conditions (if app is required to be visible) to be ready.\n        return self.waitUntilReady_();\n       })\n       .then(function() {\n         // Run the operation.\n         return self.operation_();\n       })\n      .then(function() {\n         // If successful, try again on next cycle with no previous error\n         // passed.\n         self.process_(true);\n       })\n      .thenCatch(function(error) {\n         // If an error occurs, only rerun when the error meets the retry\n         // policy.\n         if (self.retryPolicy_(error)) {\n           // Should retry with error to trigger exponentional backoff.\n           self.process_(false);\n         }\n         // Any other error is considered unrecoverable. Do not try again.\n       });\n};\n\n\n/**\n * Returns a promise which resolves when the current tab is visible.\n * This resolves quickly if refresh is supposed to run in the background too.\n * @return {!goog.Promise} The promise that resolves when the tab is visible or\n *     that requirement is not needed.\n * @private\n */\nfireauth.ProactiveRefresh.prototype.waitUntilReady_ = function() {\n  // Wait until app is in foreground if required.\n  if (this.runInBackground_) {\n    // If runs in background, resolve quickly.\n    return goog.Promise.resolve();\n  } else {\n    // Wait for the app to be visible before resolving the promise.\n    return fireauth.util.onAppVisible();\n  }\n};\n\n\n/** Stops the proactive refresh from running again. */\nfireauth.ProactiveRefresh.prototype.stop = function() {\n  // If there is a pending promise.\n  if (this.pending_) {\n    // Cancel the pending promise and nullify it.\n    this.pending_.cancel();\n    this.pending_ = null;\n  }\n};\n\n\n/** @return {boolean} Whether the proactive refresh is running or not. */\nfireauth.ProactiveRefresh.prototype.isRunning = function() {\n  return !!this.pending_;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the user info pertaining to an identity provider and\n * the Firebase user object.\n */\n\ngoog.provide('fireauth.AuthUser');\ngoog.provide('fireauth.AuthUser.AccountInfo');\ngoog.provide('fireauth.AuthUserInfo');\ngoog.provide('fireauth.TokenRefreshTime');\ngoog.provide('fireauth.UserEvent');\ngoog.provide('fireauth.UserEventType');\ngoog.provide('fireauth.UserMetadata');\n\ngoog.require('fireauth.ActionCodeSettings');\ngoog.require('fireauth.AdditionalUserInfo');\ngoog.require('fireauth.AuthCredential');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.AuthEventHandler');\ngoog.require('fireauth.AuthEventManager');\ngoog.require('fireauth.AuthProvider');\ngoog.require('fireauth.ConfirmationResult');\ngoog.require('fireauth.IdTokenResult');\ngoog.require('fireauth.PhoneAuthProvider');\ngoog.require('fireauth.ProactiveRefresh');\ngoog.require('fireauth.RpcHandler');\ngoog.require('fireauth.StsTokenManager');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.constants.AuthEventType');\ngoog.require('fireauth.deprecation');\ngoog.require('fireauth.idp');\ngoog.require('fireauth.iframeclient.IfcHandler');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\ngoog.require('goog.events');\ngoog.require('goog.events.Event');\ngoog.require('goog.events.EventTarget');\ngoog.require('goog.object');\n\n\n\n/**\n * Initializes an instance of a user metadata object.\n * @param {?string=} opt_createdAt The optional creation date UTC timestamp.\n * @param {?string=} opt_lastLoginAt The optional last login date UTC timestamp.\n * @constructor\n */\nfireauth.UserMetadata = function(opt_createdAt, opt_lastLoginAt) {\n  /** @private {?string} The created at UTC timestamp. */\n  this.createdAt_ = opt_createdAt || null;\n  /** @private {?string} The last login at UTC timestamp. */\n  this.lastLoginAt_ = opt_lastLoginAt || null;\n  fireauth.object.setReadonlyProperties(this, {\n    'lastSignInTime': fireauth.util.utcTimestampToDateString(\n        opt_lastLoginAt || null),\n    'creationTime': fireauth.util.utcTimestampToDateString(\n        opt_createdAt || null),\n  });\n};\n\n\n/**\n * @return {!fireauth.UserMetadata} A clone of the current user metadata object.\n */\nfireauth.UserMetadata.prototype.clone = function() {\n  return new fireauth.UserMetadata(this.createdAt_, this.lastLoginAt_);\n};\n\n\n/**\n * @return {!Object} The object representation of the user metadata instance.\n */\nfireauth.UserMetadata.prototype.toPlainObject = function() {\n  return {\n    'lastLoginAt': this.lastLoginAt_,\n    'createdAt': this.createdAt_\n  };\n};\n\n\n/**\n * Initializes an instance of the user info for an identity provider.\n * @param {string} uid The user ID.\n * @param {!fireauth.idp.ProviderId} providerId The provider ID.\n * @param {?string=} opt_email The optional user email.\n * @param {?string=} opt_displayName The optional display name.\n * @param {?string=} opt_photoURL The optional photo URL.\n * @param {?string=} opt_phoneNumber The optional phone number.\n * @constructor\n */\nfireauth.AuthUserInfo = function(\n    uid,\n    providerId,\n    opt_email,\n    opt_displayName,\n    opt_photoURL,\n    opt_phoneNumber) {\n  fireauth.object.setReadonlyProperties(this, {\n    'uid': uid,\n    'displayName': opt_displayName || null,\n    'photoURL': opt_photoURL || null,\n    'email': opt_email || null,\n    'phoneNumber': opt_phoneNumber || null,\n    'providerId': providerId\n  });\n};\n\n\n\n/**\n * User custom event.\n * @param {string} type The event type.\n * @param {?Object=} opt_properties The optional properties to set to the custom\n *     event using same keys as object provided.\n * @constructor\n * @extends {goog.events.Event}\n */\nfireauth.UserEvent = function(type, opt_properties) {\n  goog.events.Event.call(this, type);\n  // If optional properties provided.\n  // Add each property to custom event.\n  for (var key in opt_properties) {\n    this[key] = opt_properties[key];\n  }\n};\ngoog.inherits(fireauth.UserEvent, goog.events.Event);\n\n\n/**\n * Events dispatched by pages on containers.\n * @enum {string}\n */\nfireauth.UserEventType = {\n  /** Dispatched when token is changed due to Auth event. */\n  TOKEN_CHANGED: 'tokenChanged',\n\n  /** Dispatched when user is deleted. */\n  USER_DELETED: 'userDeleted',\n\n  /**\n   * Dispatched when user session is invalidated. This could happen when the\n   * following errors occur: user-disabled or user-token-expired.\n   */\n  USER_INVALIDATED: 'userInvalidated'\n};\n\n\n/**\n * Defines the proactive token refresh time constraints in milliseconds.\n * @enum {number}\n */\nfireauth.TokenRefreshTime = {\n  /**\n   * The offset time before token natural expiration to run the refresh.\n   * This is currently 5 minutes.\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\n   * This is the first retrial wait after an error. This is currently\n   * 30 seconds.\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\n   * This is the maximum retrial wait, currently 16 minutes.\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n\n\n\n/**\n * The Firebase user.\n * @param {!Object} appOptions The application options.\n * @param {!Object} stsTokenResponse The server STS token response.\n * @param {?Object=} opt_accountInfo The optional user account info.\n * @constructor\n * @extends {goog.events.EventTarget}\n * @implements {fireauth.AuthEventHandler}\n */\nfireauth.AuthUser =\n    function(appOptions, stsTokenResponse, opt_accountInfo) {\n  /** @private {!Array<!goog.Promise<*, *>|!goog.Promise<void>>} List of pending\n   *      promises. */\n  this.pendingPromises_ = [];\n  // User is only created via Auth so API key should always be available.\n  /** @private {string} The API key. */\n  this.apiKey_ = /** @type {string} */ (appOptions['apiKey']);\n  // This is needed to associate a user to the corresponding Auth instance.\n  /** @private {string} The App name. */\n  this.appName_ = /** @type {string} */ (appOptions['appName']);\n  /** @private {?string} The Auth domain. */\n  this.authDomain_ = appOptions['authDomain'] || null;\n  var clientFullVersion = firebase.SDK_VERSION ?\n      fireauth.util.getClientVersion(\n          fireauth.util.ClientImplementation.JSCORE, firebase.SDK_VERSION) :\n      null;\n  /** @private {!fireauth.RpcHandler} The RPC handler instance. */\n  this.rpcHandler_ = new fireauth.RpcHandler(\n      this.apiKey_,\n      // Get the client Auth endpoint used.\n      fireauth.constants.getEndpointConfig(fireauth.constants.clientEndpoint),\n      clientFullVersion);\n  // TODO: Consider having AuthUser take a fireauth.StsTokenManager\n  // instance instead of a token response but make sure lastAccessToken_ also\n  // initialized at the right time. In this case initializeFromIdTokenResponse\n  // will take in a token response object and convert it to an instance of\n  // fireauth.StsTokenManager to properly initialize user.\n  /** @private {!fireauth.StsTokenManager} The STS token manager instance. */\n  this.stsTokenManager_ = new fireauth.StsTokenManager(this.rpcHandler_);\n\n  this.setLastAccessToken_(\n      stsTokenResponse[fireauth.RpcHandler.AuthServerField.ID_TOKEN]);\n  // STS token manager will always be populated using server response.\n  this.stsTokenManager_.parseServerResponse(stsTokenResponse);\n  fireauth.object.setReadonlyProperty(\n      this, 'refreshToken', this.stsTokenManager_.getRefreshToken());\n  this.setAccountInfo(/** @type {!fireauth.AuthUser.AccountInfo} */ (\n      opt_accountInfo || {}));\n  // Add call to superclass constructor.\n  fireauth.AuthUser.base(this, 'constructor');\n  /** @private {boolean} Whether popup and redirect is enabled on the user. */\n  this.popupRedirectEnabled_ = false;\n  if (this.authDomain_ &&\n      fireauth.AuthEventManager.ENABLED &&\n      // Make sure popup and redirects are supported in the current environment.\n      fireauth.util.isPopupRedirectSupported()) {\n    // Get the Auth event manager associated with this user.\n    this.authEventManager_ = fireauth.AuthEventManager.getManager(\n        this.authDomain_, this.apiKey_, this.appName_);\n  }\n  /** @private {!Array<!function(!fireauth.AuthUser):!goog.Promise>} The list of\n   *      state change listeners. This is needed to make sure state changes are\n   *      resolved before resolving user API promises. For example redirect\n   *      operations should make sure the associated event ID is saved before\n   *      redirecting.\n   */\n  this.stateChangeListeners_ = [];\n  /**\n   * @private {?fireauth.AuthError} The user invalidation error if it exists.\n   */\n  this.userInvalidatedError_ = null;\n  /**\n   * @private {!fireauth.ProactiveRefresh} The reference to the proactive token\n   *     refresher utility for the current user.\n   */\n  this.proactiveRefresh_ = this.initializeProactiveRefreshUtility_();\n  /**\n   * @private {!function(!Object)} The handler for user token changes used to\n   *     realign the proactive token refresh with external token refresh calls.\n   */\n  this.userTokenChangeListener_ = goog.bind(this.handleUserTokenChange_, this);\n  var self = this;\n  /** @private {?string} The current user's language code. */\n  this.languageCode_ = null;\n  /**\n   * @private {function(!goog.events.Event)} The on language code changed event\n   *     handler.\n   */\n  this.onLanguageCodeChanged_ = function(event) {\n    // Update the user language code.\n    self.setLanguageCode(event.languageCode);\n  };\n  /**\n   * @private {?goog.events.EventTarget} The language code change event\n   *     dispatcher.\n   */\n  this.languageCodeChangeEventDispatcher_ = null;\n\n  /** @private {!Array<string>} The current Firebase frameworks. */\n  this.frameworks_ = [];\n  /**\n   * @private {function(!goog.events.Event)} The on framework list changed event\n   *     handler.\n   */\n  this.onFrameworkChanged_ = function(event) {\n    // Update the Firebase frameworks.\n    self.setFramework(event.frameworks);\n  };\n  /**\n   * @private {?goog.events.EventTarget} The framework change event dispatcher.\n   */\n  this.frameworkChangeEventDispatcher_ = null;\n};\ngoog.inherits(fireauth.AuthUser, goog.events.EventTarget);\n\n\n/**\n * Updates the user language code.\n * @param {?string} languageCode The current language code to use in user\n *     requests.\n */\nfireauth.AuthUser.prototype.setLanguageCode = function(languageCode) {\n  // Save current language.\n  this.languageCode_ = languageCode;\n  // Update the custom locale header.\n  this.rpcHandler_.updateCustomLocaleHeader(languageCode);\n};\n\n\n/** @return {?string} The current user's language code. */\nfireauth.AuthUser.prototype.getLanguageCode = function() {\n  return this.languageCode_;\n};\n\n\n/**\n * Listens to language code changes triggered by the provided dispatcher.\n * @param {?goog.events.EventTarget} dispatcher The language code changed event\n *     dispatcher.\n */\nfireauth.AuthUser.prototype.setLanguageCodeChangeDispatcher =\n    function(dispatcher) {\n  // Remove any previous listener.\n  if (this.languageCodeChangeEventDispatcher_) {\n    goog.events.unlisten(\n        this.languageCodeChangeEventDispatcher_,\n        fireauth.constants.AuthEventType.LANGUAGE_CODE_CHANGED,\n        this.onLanguageCodeChanged_);\n  }\n  // Update current dispatcher.\n  this.languageCodeChangeEventDispatcher_ = dispatcher;\n  // Using an event listener makes it easy for non-currentUsers to detect\n  // language changes on the parent Auth instance. A developer could still call\n  // APIs that require localization on signed out user references.\n  if (dispatcher) {\n    goog.events.listen(\n        dispatcher,\n        fireauth.constants.AuthEventType.LANGUAGE_CODE_CHANGED,\n        this.onLanguageCodeChanged_);\n  }\n};\n\n\n/**\n * Updates the Firebase frameworks on the current user.\n * @param {!Array<string>} framework The list of Firebase frameworks.\n */\nfireauth.AuthUser.prototype.setFramework = function(framework) {\n  // Save current frameworks.\n  this.frameworks_ = framework;\n  // Update the client version in RPC handler with the new frameworks.\n  this.rpcHandler_.updateClientVersion(firebase.SDK_VERSION ?\n        fireauth.util.getClientVersion(\n            fireauth.util.ClientImplementation.JSCORE, firebase.SDK_VERSION,\n            this.frameworks_) :\n        null);\n};\n\n\n/** @return {!Array<string>} The current Firebase frameworks. */\nfireauth.AuthUser.prototype.getFramework = function() {\n  return goog.array.clone(this.frameworks_);\n};\n\n\n/**\n * Listens to framework changes triggered by the provided dispatcher.\n * @param {?goog.events.EventTarget} dispatcher The framework changed event\n *     dispatcher.\n */\nfireauth.AuthUser.prototype.setFrameworkChangeDispatcher =\n    function(dispatcher) {\n  // Remove any previous listener.\n  if (this.frameworkChangeEventDispatcher_) {\n    goog.events.unlisten(\n        this.frameworkChangeEventDispatcher_,\n        fireauth.constants.AuthEventType.FRAMEWORK_CHANGED,\n        this.onFrameworkChanged_);\n  }\n  // Update current dispatcher.\n  this.frameworkChangeEventDispatcher_ = dispatcher;\n  // Using an event listener makes it easy for non-currentUsers to detect\n  // framework changes on the parent Auth instance.\n  if (dispatcher) {\n    goog.events.listen(\n        dispatcher,\n        fireauth.constants.AuthEventType.FRAMEWORK_CHANGED,\n        this.onFrameworkChanged_);\n  }\n};\n\n\n/**\n * Handles user token changes. Currently used to realign the proactive token\n * refresh internal timing with successful external token refreshes.\n * @param {!Object} event The token change event.\n * @private\n */\nfireauth.AuthUser.prototype.handleUserTokenChange_ = function(event) {\n  // If an external service refreshes the token, reset the proactive token\n  // refresh utility in case it is still running so the next run time is\n  // up to date.\n  // This will currently also trigger when the proactive refresh succeeds.\n  // This is not ideal but should not have any downsides. It just adds a\n  // redundant reset which can be optimized not to run in the future.\n  if (this.proactiveRefresh_.isRunning()) {\n    this.proactiveRefresh_.stop();\n    this.proactiveRefresh_.start();\n  }\n};\n\n\n/**\n * @return {!fireauth.Auth} The corresponding Auth instance that created the\n *     current user.\n * @private\n */\nfireauth.AuthUser.prototype.getAuth_ = function() {\n  try {\n    // Get the Auth instance for the current app identified by the App name.\n    // This could fail if, for example, the App instance was deleted.\n    return firebase['app'](this.appName_)['auth']();\n  } catch (e) {\n    // Throw appropriate error.\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INTERNAL_ERROR,\n        'No firebase.auth.Auth instance is available for the Firebase App ' +\n        '\\'' + this.appName_ + '\\'!');\n  }\n};\n\n\n/**\n * @return {string} The user's API key.\n */\nfireauth.AuthUser.prototype.getApiKey = function() {\n  return this.apiKey_;\n};\n\n\n/**\n * Used to initialize the current user's proactive token refresher utility.\n * @return {!fireauth.ProactiveRefresh} The user's proactive token refresh\n *     utility.\n * @private\n */\nfireauth.AuthUser.prototype.initializeProactiveRefreshUtility_ = function() {\n  var self = this;\n  return new fireauth.ProactiveRefresh(\n      // Force ID token refresh right before expiration.\n      function() {\n        // Keep in mind when this fails for any reason other than a network\n        // error, it will effectively stop the proactive refresh.\n        return self.getIdToken(true);\n      },\n      // Retry only on network errors.\n      function(error) {\n        if (error && error.code == 'auth/network-request-failed') {\n          return true;\n        }\n        return false;\n      },\n      // Return next time to run with offset applied.\n      function() {\n        // Get time until expiration minus the refresh offset.\n        var waitInterval =\n            self.stsTokenManager_.getExpirationTime() - goog.now() -\n            fireauth.TokenRefreshTime.OFFSET_DURATION;\n        // Set to zero if wait interval is negative.\n        return waitInterval > 0 ? waitInterval : 0;\n      },\n      // Retrial minimum wait.\n      fireauth.TokenRefreshTime.RETRIAL_MIN_WAIT,\n      // Retrial maximum wait.\n      fireauth.TokenRefreshTime.RETRIAL_MAX_WAIT,\n      // Do not run in background as it is common to have multiple tabs open\n      // in a browser and this could increase QPS on server.\n      false);\n};\n\n\n/** Starts token proactive refresh. */\nfireauth.AuthUser.prototype.startProactiveRefresh = function() {\n  // Only allow if not destroyed and not already started.\n  if (!this.destroyed_ && !this.proactiveRefresh_.isRunning()) {\n    this.proactiveRefresh_.start();\n    // Unlisten any previous token change listener.\n    goog.events.unlisten(\n        this,\n        fireauth.UserEventType.TOKEN_CHANGED,\n        this.userTokenChangeListener_);\n    // Listen to token changes to reset the token refresher.\n    goog.events.listen(\n        this,\n        fireauth.UserEventType.TOKEN_CHANGED,\n        this.userTokenChangeListener_);\n  }\n};\n\n\n/** Stops token proactive refresh. */\nfireauth.AuthUser.prototype.stopProactiveRefresh = function() {\n  // Remove internal token change listener.\n  goog.events.unlisten(\n      this,\n      fireauth.UserEventType.TOKEN_CHANGED,\n      this.userTokenChangeListener_);\n  // Stop proactive token refresh.\n  this.proactiveRefresh_.stop();\n};\n\n\n/**\n * Sets latest access token for the AuthUser object.\n * @param {string} lastAccessToken\n * @private\n */\nfireauth.AuthUser.prototype.setLastAccessToken_ = function(lastAccessToken) {\n  /** @private {?string} Latest access token. */\n  this.lastAccessToken_ = lastAccessToken;\n  fireauth.object.setReadonlyProperty(this, '_lat', lastAccessToken);\n};\n\n\n/**\n * @param {!function(!fireauth.AuthUser):!goog.Promise} listener The listener\n *     to state changes to add.\n */\nfireauth.AuthUser.prototype.addStateChangeListener = function(listener) {\n  this.stateChangeListeners_.push(listener);\n};\n\n\n/**\n * @param {!function(!fireauth.AuthUser):!goog.Promise} listener The listener\n *     to state changes to remove.\n */\nfireauth.AuthUser.prototype.removeStateChangeListener = function(listener) {\n  goog.array.removeAllIf(this.stateChangeListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n\n\n/**\n * Executes all state change listener promises and when all fulfilled, resolves\n * with the current user.\n * @return {!goog.Promise} A promise that resolves when all state listeners\n *     fulfilled.\n * @private\n */\nfireauth.AuthUser.prototype.notifyStateChangeListeners_ = function() {\n  var promises = [];\n  var self = this;\n  for (var i = 0; i < this.stateChangeListeners_.length; i++) {\n    // Run listener with Auth user instance and add to list of promises.\n    promises.push(this.stateChangeListeners_[i](this));\n  }\n  return goog.Promise.allSettled(promises).then(function(results) {\n    // State change errors should be recoverable even if errors occur.\n    return self;\n  });\n};\n\n\n/**\n * Sets the user current pending popup event ID.\n * @param {string} eventId The pending popup event ID.\n */\nfireauth.AuthUser.prototype.setPopupEventId = function(eventId) {\n  // Saving a popup event in a separate property other than redirectEventId\n  // would prevent a pending redirect event from being overwritten by a newly\n  // called popup operation.\n  this.popupEventId_ = eventId;\n};\n\n\n/**\n * @return {?string} The pending popup event ID.\n */\nfireauth.AuthUser.prototype.getPopupEventId = function() {\n  return this.popupEventId_ || null;\n};\n\n\n/**\n * Sets the user current pending redirect event ID.\n * @param {string} eventId The pending redirect event ID.\n */\nfireauth.AuthUser.prototype.setRedirectEventId = function(eventId) {\n  this.redirectEventId_ = eventId;\n};\n\n\n/**\n * @return {?string} The pending redirect event ID.\n */\nfireauth.AuthUser.prototype.getRedirectEventId = function() {\n  return this.redirectEventId_ || null;\n};\n\n\n/**\n * Subscribes to Auth event manager to handle popup and redirect events.\n * This is an explicit operation as users could exist in temporary states. For\n * example a user change could be detected in another tab. When syncing to those\n * changes, a temporary user is retrieved from storage and then copied to\n * existing user. The temporary user should not subscribe to Auth event changes.\n */\nfireauth.AuthUser.prototype.enablePopupRedirect = function() {\n  // Subscribe to Auth event manager if available.\n  if (this.authEventManager_ && !this.popupRedirectEnabled_) {\n    this.popupRedirectEnabled_ = true;\n    this.authEventManager_.subscribe(this);\n  }\n};\n\n\n/**\n * getAccountInfo users field.\n * @const {string}\n */\nfireauth.AuthUser.GET_ACCOUNT_INFO_USERS = 'users';\n\n\n/**\n * getAccountInfo response user fields.\n * @enum {string}\n */\nfireauth.AuthUser.GetAccountInfoField = {\n  CREATED_AT: 'createdAt',\n  DISPLAY_NAME: 'displayName',\n  EMAIL: 'email',\n  EMAIL_VERIFIED: 'emailVerified',\n  LAST_LOGIN_AT: 'lastLoginAt',\n  LOCAL_ID: 'localId',\n  PASSWORD_HASH: 'passwordHash',\n  PASSWORD_UPDATED_AT: 'passwordUpdatedAt',\n  PHONE_NUMBER: 'phoneNumber',\n  PHOTO_URL: 'photoUrl',\n  PROVIDER_USER_INFO: 'providerUserInfo',\n  TENANT_ID: 'tenantId'\n};\n\n\n/**\n * setAccountInfo response user fields.\n * @enum {string}\n */\nfireauth.AuthUser.SetAccountInfoField = {\n  DISPLAY_NAME: 'displayName',\n  EMAIL: 'email',\n  PHOTO_URL: 'photoUrl',\n  PROVIDER_ID: 'providerId',\n  PROVIDER_USER_INFO: 'providerUserInfo'\n};\n\n\n/**\n * getAccountInfo response provider user info fields.\n * @enum {string}\n */\nfireauth.AuthUser.GetAccountInfoProviderField = {\n  DISPLAY_NAME: 'displayName',\n  EMAIL: 'email',\n  PHOTO_URL: 'photoUrl',\n  PHONE_NUMBER: 'phoneNumber',\n  PROVIDER_ID: 'providerId',\n  RAW_ID: 'rawId'\n};\n\n\n/**\n * verifyAssertion response fields.\n * @enum {string}\n */\nfireauth.AuthUser.VerifyAssertionField = {\n  ID_TOKEN: 'idToken',\n  PROVIDER_ID: 'providerId'\n};\n\n\n/** @return {!fireauth.StsTokenManager} The STS token manager instance */\nfireauth.AuthUser.prototype.getStsTokenManager = function() {\n  return this.stsTokenManager_;\n};\n\n\n/**\n * Sets the user account info.\n * @param {!fireauth.AuthUser.AccountInfo} accountInfo The account information\n *     from the default provider.\n */\nfireauth.AuthUser.prototype.setAccountInfo = function(accountInfo) {\n  fireauth.object.setReadonlyProperties(this, {\n    'uid': accountInfo['uid'],\n    'displayName': accountInfo['displayName'] || null,\n    'photoURL': accountInfo['photoURL'] || null,\n    'email': accountInfo['email'] || null,\n    'emailVerified': accountInfo['emailVerified'] || false,\n    'phoneNumber': accountInfo['phoneNumber'] || null,\n    'isAnonymous': accountInfo['isAnonymous'] || false,\n    'tenantId': accountInfo['tenantId'] || null,\n    'metadata': new fireauth.UserMetadata(\n        accountInfo['createdAt'], accountInfo['lastLoginAt']),\n    'providerData': []\n  });\n  // Sets the tenant ID on RPC handler. For requests with ID tokens, the source\n  // of truth is the tenant ID in the ID token. If the request body has a\n  // tenant ID (optional here), the backend will confirm it matches the\n  // tenant ID in the ID token, otherwise throw an error. If no tenant ID is\n  // passed in the request, it will be determined from the ID token.\n  this.rpcHandler_.updateTenantId(this['tenantId']);\n};\n\n\n/**\n * Type specifying the parameters that can be passed to the\n * {@code fireauth.AuthUser} constructor.\n * @typedef {{\n *   uid: (?string|undefined),\n *   displayName: (?string|undefined),\n *   photoURL: (?string|undefined),\n *   email: (?string|undefined),\n *   emailVerified: ?boolean,\n *   phoneNumber: (?string|undefined),\n *   isAnonymous: ?boolean,\n *   createdAt: (?string|undefined),\n *   lastLoginAt: (?string|undefined),\n *   tenantId: (?string|undefined)\n * }}\n */\nfireauth.AuthUser.AccountInfo;\n\n\n/**\n * The provider for all fireauth.AuthUser objects is 'firebase'.\n */\nfireauth.object.setReadonlyProperty(fireauth.AuthUser.prototype, 'providerId',\n    fireauth.idp.ProviderId.FIREBASE);\n\n\n/**\n * Returns nothing. This can be used to consume the output of a Promise.\n * @private\n */\nfireauth.AuthUser.returnNothing_ = function() {\n  // Return nothing. Intentionally left empty.\n};\n\n\n/**\n * Ensures the user is still logged in before moving to the next promise\n * resolution.\n * @return {!goog.Promise<undefined,undefined>}\n * @private\n */\nfireauth.AuthUser.prototype.checkDestroyed_ = function() {\n  var self = this;\n  return goog.Promise.resolve().then(function() {\n    if (self.destroyed_) {\n      throw new fireauth.AuthError(fireauth.authenum.Error.MODULE_DESTROYED);\n    }\n  });\n};\n\n\n/**\n * @return {!Array<!fireauth.idp.ProviderId>} The list of provider IDs.\n */\nfireauth.AuthUser.prototype.getProviderIds = function() {\n  return goog.array.map(this['providerData'], function(userInfo) {\n    return userInfo['providerId'];\n  });\n};\n\n\n/**\n * Adds the provided user info to list of providers' data.\n * @param {?fireauth.AuthUserInfo} providerData Provider data to store for user.\n */\nfireauth.AuthUser.prototype.addProviderData = function(providerData) {\n  if (!providerData) {\n    return;\n  }\n  this.removeProviderData(providerData['providerId']);\n  this['providerData'].push(providerData);\n};\n\n\n/**\n * @param {!fireauth.idp.ProviderId} providerId The provider ID whose\n *     data should be removed.\n */\nfireauth.AuthUser.prototype.removeProviderData = function(providerId) {\n  goog.array.removeAllIf(this['providerData'], function(userInfo) {\n    return userInfo['providerId'] == providerId;\n  });\n};\n\n\n/**\n * @param {string} propName The property name to modify.\n * @param {?string|boolean} value The new value to set.\n */\nfireauth.AuthUser.prototype.updateProperty = function(propName, value) {\n  // User ID is required.\n  if (propName == 'uid' && !value) {\n    return;\n  }\n  if (this.hasOwnProperty(propName)) {\n    fireauth.object.setReadonlyProperty(this, propName, value);\n  }\n};\n\n\n/**\n * @param {!fireauth.AuthUser} otherUser The other user to compare to.\n * @return {boolean} True if both User objects have the same user ID.\n */\nfireauth.AuthUser.prototype.hasSameUserIdAs = function(otherUser) {\n  var thisId = this['uid'];\n  var thatId = otherUser['uid'];\n  if (thisId === undefined || thisId === null || thisId === '' ||\n      thatId === undefined || thatId === null || thatId === '') {\n    return false;\n  }\n  return thisId == thatId;\n};\n\n\n/**\n * Copies all properties and STS token manager instance from userToCopy to\n * current user without triggering any Auth state change or token change\n * listener.\n * @param {!fireauth.AuthUser} userToCopy The updated user to overwrite current\n *     user.\n */\nfireauth.AuthUser.prototype.copy = function(userToCopy) {\n  var self = this;\n  // Copy to self.\n  if (self == userToCopy) {\n    return;\n  }\n  fireauth.object.setReadonlyProperties(this, {\n    'uid': userToCopy['uid'],\n    'displayName': userToCopy['displayName'],\n    'photoURL': userToCopy['photoURL'],\n    'email': userToCopy['email'],\n    'emailVerified': userToCopy['emailVerified'],\n    'phoneNumber': userToCopy['phoneNumber'],\n    'isAnonymous': userToCopy['isAnonymous'],\n    'tenantId': userToCopy['tenantId'],\n    'providerData': []\n  });\n  // This should always be available but just in case there is a conflict with\n  // a user from an older version.\n  if (userToCopy['metadata']) {\n    fireauth.object.setReadonlyProperty(\n        this,\n        'metadata',\n        /** @type{!fireauth.UserMetadata} */ (userToCopy['metadata']).clone());\n  } else {\n    // User to copy has no metadata. Align with that.\n    fireauth.object.setReadonlyProperty(\n        this, 'metadata', new fireauth.UserMetadata());\n  }\n  goog.array.forEach(userToCopy['providerData'], function(userInfo) {\n    self.addProviderData(userInfo);\n  });\n  this.stsTokenManager_.copy(userToCopy.getStsTokenManager());\n  fireauth.object.setReadonlyProperty(\n      this, 'refreshToken', this.stsTokenManager_.getRefreshToken());\n};\n\n\n/**\n * Set the Auth user redirect storage manager.\n * @param {?fireauth.storage.RedirectUserManager} redirectStorageManager The\n *     utility used to store or delete the user on redirect.\n */\nfireauth.AuthUser.prototype.setRedirectStorageManager =\n    function(redirectStorageManager) {\n  /**\n   * @private {?fireauth.storage.RedirectUserManager} The redirect user storage\n   *     manager.\n   */\n  this.redirectStorageManager_ = redirectStorageManager;\n};\n\n\n/**\n * Refreshes the current user, if signed in.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.reload = function() {\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(this.checkDestroyed_().then(function() {\n    return self.reloadWithoutSaving_()\n        .then(function() {\n          return self.notifyStateChangeListeners_();\n        })\n        .then(fireauth.AuthUser.returnNothing_);\n  }));\n};\n\n\n/**\n * Refreshes the current user, if signed in.\n * @return {!goog.Promise<string>} Promise that resolves with the idToken.\n * @private\n */\nfireauth.AuthUser.prototype.reloadWithoutSaving_ = function() {\n  var self = this;\n  // ID token is required to refresh the user's data.\n  // If this is called after invalidation, getToken will throw the cached error.\n  return this.getIdToken().then(function(idToken) {\n    var isAnonymous = self['isAnonymous'];\n    return self.setUserAccountInfoFromToken_(idToken)\n        .then(function(user) {\n          if (!isAnonymous) {\n            // Preserves the not anonymous status of the stored user,\n            // even if no more credentials (federated or email/password)\n            // linked to the user.\n            self.updateProperty('isAnonymous', false);\n          }\n          return idToken;\n        });\n  });\n};\n\n\n/**\n * This operation resolves with the Firebase ID token result which contains\n * the entire payload claims.\n * @param {boolean=} opt_forceRefresh Whether to force refresh token exchange.\n * @return {!goog.Promise<!fireauth.IdTokenResult>} A Promise that resolves with\n *     the ID token result.\n */\nfireauth.AuthUser.prototype.getIdTokenResult = function(opt_forceRefresh) {\n  return this.getIdToken(opt_forceRefresh).then(function(idToken) {\n    return new fireauth.IdTokenResult(idToken);\n  });\n};\n\n\n/**\n * This operation resolves with the Firebase ID token.\n * @param {boolean=} opt_forceRefresh Whether to force refresh token exchange.\n * @return {!goog.Promise<string>} A Promise that resolves with the ID token.\n */\nfireauth.AuthUser.prototype.getIdToken = function(opt_forceRefresh) {\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(this.checkDestroyed_().then(function() {\n    return self.stsTokenManager_.getToken(opt_forceRefresh);\n  }).then(function(response) {\n    if (!response) {\n      // If the user exists, the token manager should be initialized.\n      throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n    }\n    // Only if the access token is refreshed, notify Auth listeners.\n    if (response['accessToken'] != self.lastAccessToken_) {\n      self.setLastAccessToken_(response['accessToken']);\n      // Auth state change, notify listeners.\n      self.notifyAuthListeners_();\n    }\n    self.updateProperty('refreshToken', response['refreshToken']);\n    return response['accessToken'];\n  }));\n};\n\n\n/**\n * Checks if the error corresponds to a user invalidation action.\n * @param {*} error The error returned by a user operation.\n * @return {boolean} Whether the user is invalidated based on the error\n *     provided.\n * @private\n */\nfireauth.AuthUser.isUserInvalidated_ = function(error) {\n  return !!(error &&\n      (error.code == 'auth/user-disabled' ||\n       error.code == 'auth/user-token-expired'));\n};\n\n\n/**\n * Updates the current tokens using a server response, if new tokens are\n * present and are different from the current ones, and notify the Auth\n * listeners.\n * @param {!Object} response The response from the server.\n * @private\n */\nfireauth.AuthUser.prototype.updateTokensIfPresent_ = function(response) {\n  if (response[fireauth.RpcHandler.AuthServerField.ID_TOKEN] &&\n      this.lastAccessToken_ != response[\n          fireauth.RpcHandler.AuthServerField.ID_TOKEN]) {\n    this.stsTokenManager_.parseServerResponse(response);\n    this.notifyAuthListeners_();\n    this.setLastAccessToken_(response[\n        fireauth.RpcHandler.AuthServerField.ID_TOKEN]);\n    // Update refresh token property.\n    this.updateProperty(\n        'refreshToken', this.stsTokenManager_.getRefreshToken());\n  }\n};\n\n\n/**\n * Called internally on Auth (access token) changes to notify listeners.\n * @private\n */\nfireauth.AuthUser.prototype.notifyAuthListeners_ = function() {\n  this.dispatchEvent(\n      new fireauth.UserEvent(fireauth.UserEventType.TOKEN_CHANGED));\n};\n\n\n/**\n * Called internally on user deletion to notify listeners.\n * @private\n */\nfireauth.AuthUser.prototype.notifyUserDeletedListeners_ = function() {\n  this.dispatchEvent(\n      new fireauth.UserEvent(fireauth.UserEventType.USER_DELETED));\n};\n\n\n/**\n * Called internally on user session invalidation to notify listeners.\n * @private\n */\nfireauth.AuthUser.prototype.notifyUserInvalidatedListeners_ = function() {\n  this.dispatchEvent(\n      new fireauth.UserEvent(fireauth.UserEventType.USER_INVALIDATED));\n};\n\n\n/**\n * Queries the backend using the provided ID token for all linked accounts to\n * build the Firebase user object.\n * @param {!string} idToken The ID token string.\n * @return {!goog.Promise<undefined>}\n * @private\n */\nfireauth.AuthUser.prototype.setUserAccountInfoFromToken_ = function(idToken) {\n  return this.rpcHandler_.getAccountInfoByIdToken(idToken)\n      .then(goog.bind(this.parseAccountInfo_, this));\n};\n\n\n/**\n * Parses the response from the getAccountInfo endpoint.\n * @param {!Object} resp The backend response.\n * @private\n */\nfireauth.AuthUser.prototype.parseAccountInfo_ = function(resp) {\n  var users = resp[fireauth.AuthUser.GET_ACCOUNT_INFO_USERS];\n  if (!users || !users.length) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n  var user = users[0];\n  var accountInfo = /** @type {!fireauth.AuthUser.AccountInfo} */ ({\n    'uid': /** @type {string} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.LOCAL_ID]),\n    'displayName': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.DISPLAY_NAME]),\n    'photoURL': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.PHOTO_URL]),\n    'email': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.EMAIL]),\n    'emailVerified':\n        !!user[fireauth.AuthUser.GetAccountInfoField.EMAIL_VERIFIED],\n    'phoneNumber': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.PHONE_NUMBER]),\n    'lastLoginAt': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.LAST_LOGIN_AT]),\n    'createdAt': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.CREATED_AT]),\n    'tenantId': /** @type {?string|undefined} */ (\n        user[fireauth.AuthUser.GetAccountInfoField.TENANT_ID])\n  });\n  this.setAccountInfo(accountInfo);\n  var linkedAccounts = this.extractLinkedAccounts_(user);\n  for (var i = 0; i < linkedAccounts.length; i++) {\n    this.addProviderData(linkedAccounts[i]);\n  }\n  // Sets the isAnonymous flag based on email, passwordHash and providerData.\n  var isAnonymous = !(this['email'] &&\n      user[fireauth.AuthUser.GetAccountInfoField.PASSWORD_HASH]) &&\n      !(this['providerData'] && this['providerData'].length);\n  this.updateProperty('isAnonymous', isAnonymous);\n};\n\n\n/**\n * Extracts the linked accounts from getAccountInfo response and returns an\n * array of corresponding provider data.\n * @param {!Object} resp The response object.\n * @return {!Array.<!fireauth.AuthUserInfo>} The linked accounts.\n * @private\n */\nfireauth.AuthUser.prototype.extractLinkedAccounts_ = function(resp) {\n  var providerInfo =\n      resp[fireauth.AuthUser.GetAccountInfoField.PROVIDER_USER_INFO];\n  if (!providerInfo || !providerInfo.length) {\n    return [];\n  }\n\n  return goog.array.map(providerInfo, function(info) {\n    return new fireauth.AuthUserInfo(\n        info[fireauth.AuthUser.GetAccountInfoProviderField.RAW_ID],\n        info[fireauth.AuthUser.GetAccountInfoProviderField.PROVIDER_ID],\n        info[fireauth.AuthUser.GetAccountInfoProviderField.EMAIL],\n        info[fireauth.AuthUser.GetAccountInfoProviderField.DISPLAY_NAME],\n        info[fireauth.AuthUser.GetAccountInfoProviderField.PHOTO_URL],\n        info[fireauth.AuthUser.GetAccountInfoProviderField.PHONE_NUMBER]);\n  });\n};\n\n\n/**\n * Reauthenticates a user using a fresh credential, to be used before operations\n * such as updatePassword that require tokens from recent login attempts. It\n * also returns any additional user info data or credentials returned form the\n * backend. It has been deprecated in favor of reauthenticateWithCredential.\n * @param {!fireauth.AuthCredential} credential\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.reauthenticateAndRetrieveDataWithCredential =\n    function(credential) {\n  fireauth.deprecation.log(\n      fireauth.deprecation.Deprecations.REAUTH_WITH_CREDENTIAL);\n  return this.reauthenticateWithCredential(credential);\n};\n\n\n/**\n * Reauthenticates a user using a fresh credential, to be used before operations\n * such as updatePassword that require tokens from recent login attempts. It\n * also returns any additional user info data or credentials returned form the\n * backend.\n * @param {!fireauth.AuthCredential} credential\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.reauthenticateWithCredential =\n    function(credential) {\n  var self = this;\n  var userCredential = null;\n  // Register this pending promise but bypass user invalidation check.\n  return this.registerPendingPromise_(\n      // Match ID token from credential with the current user UID.\n      credential.matchIdTokenWithUid(this.rpcHandler_, this['uid'])\n      .then(function(response) {\n        // If the credential is valid and matches the current user ID, then\n        // update the tokens accordingly.\n        self.updateTokensIfPresent_(response);\n        // Get user credential.\n        userCredential = self.getUserCredential_(\n            response, fireauth.constants.OperationType.REAUTHENTICATE);\n        // This could potentially validate an invalidated user. This happens in\n        // the case a password reset was applied. The refresh token is expired.\n        // Reauthentication should revalidate the user.\n        // User would remain non current if already signed out, but should be\n        // enabled again.\n        self.userInvalidatedError_ = null;\n        return self.reload();\n      }).then(function() {\n        // Return user credential after reauthenticated user is reloaded.\n        return userCredential;\n      }),\n      // Skip invalidation check as reauthentication could revalidate a user.\n      true);\n};\n\n\n/**\n * Reloads the user and then checks if a provider is already linked. If so,\n * this returns a Promise that rejects. Note that state change listeners are not\n * notified on success, so that operations using this can make changes and then\n * do one final listener notification.\n * @param {string} providerId\n * @return {!goog.Promise<void>}\n * @private\n */\nfireauth.AuthUser.prototype.checkIfAlreadyLinked_ =\n    function(providerId) {\n  var self = this;\n  // Reload first in case the user was updated elsewhere.\n  return this.reloadWithoutSaving_()\n      .then(function() {\n        if (goog.array.contains(self.getProviderIds(), providerId)) {\n          return self.notifyStateChangeListeners_()\n              .then(function() {\n                  throw new fireauth.AuthError(\n                      fireauth.authenum.Error.PROVIDER_ALREADY_LINKED);\n              });\n        }\n      });\n};\n\n\n/**\n * Links a provider to the current user and returns any additional user info\n * data or credentials returned form the backend. It has been deprecated in\n * favor of linkWithCredential.\n * @param {!fireauth.AuthCredential} credential The credential from the Auth\n *     provider.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.linkAndRetrieveDataWithCredential =\n    function(credential) {\n  fireauth.deprecation.log(\n      fireauth.deprecation.Deprecations.LINK_WITH_CREDENTIAL);\n  return this.linkWithCredential(credential);\n};\n\n\n/**\n * Links a provider to the current user and returns any additional user info\n * data or credentials returned form the backend.\n * @param {!fireauth.AuthCredential} credential The credential from the Auth\n *     provider.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.linkWithCredential = function(credential) {\n  var self = this;\n  var userCredential = null;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      this.checkIfAlreadyLinked_(credential['providerId'])\n      .then(function() {\n        return self.getIdToken();\n      })\n      .then(function(idToken) {\n        return credential.linkToIdToken(self.rpcHandler_, idToken);\n      })\n      .then(function(response) {\n        // Get user credential.\n        userCredential = self.getUserCredential_(\n            response, fireauth.constants.OperationType.LINK);\n        // Finalize linking.\n        return self.finalizeLinking_(response);\n      })\n      .then(function(user) {\n        // Return user credential after finalizing linking.\n        return userCredential;\n      })\n  );\n};\n\n\n/**\n * Links a phone number using the App verifier instance and returns a\n * promise that resolves with the confirmation result which on confirmation\n * will resolve with the UserCredential object.\n * @param {string} phoneNumber The phone number to authenticate with.\n * @param {!firebase.auth.ApplicationVerifier} appVerifier The application\n *     verifier.\n * @return {!goog.Promise<!fireauth.ConfirmationResult>}\n */\nfireauth.AuthUser.prototype.linkWithPhoneNumber =\n    function(phoneNumber, appVerifier) {\n  var self = this;\n  return /** @type {!goog.Promise<!fireauth.ConfirmationResult>} */ (\n      this.registerPendingPromise_(\n          // Check if linked already. If so, throw an error.\n          // This is redundant but is needed to prevent the need to send the\n          // SMS (worth the cost).\n          this.checkIfAlreadyLinked_(fireauth.idp.ProviderId.PHONE)\n              .then(function() {\n                return fireauth.ConfirmationResult.initialize(\n                    self.getAuth_(),\n                    phoneNumber,\n                    appVerifier,\n                    // This will check again if the credential is linked.\n                    goog.bind(self.linkWithCredential, self));\n              })));\n};\n\n\n/**\n * Reauthenticates a user with a phone number using the App verifier instance\n * and returns a promise that resolves with the confirmation result which on\n * confirmation will resolve with the UserCredential object.\n * @param {string} phoneNumber The phone number to authenticate with.\n * @param {!firebase.auth.ApplicationVerifier} appVerifier The application\n *     verifier.\n * @return {!goog.Promise<!fireauth.ConfirmationResult>}\n */\nfireauth.AuthUser.prototype.reauthenticateWithPhoneNumber =\n    function(phoneNumber, appVerifier) {\n  var self = this;\n  return /** @type {!goog.Promise<!fireauth.ConfirmationResult>} */ (\n      this.registerPendingPromise_(\n          // Wrap this operation in a Promise since self.getAuth_() may throw an\n          // error synchronously.\n          goog.Promise.resolve().then(function() {\n            return fireauth.ConfirmationResult.initialize(\n                // Get corresponding Auth instance.\n                self.getAuth_(),\n                phoneNumber,\n                appVerifier,\n                goog.bind(self.reauthenticateWithCredential,\n                    self));\n          }),\n          // Skip invalidation check as reauthentication could revalidate a\n          // user.\n          true));\n};\n\n\n/**\n * Converts an ID token response (eg. verifyAssertion) to a UserCredential\n * object.\n * @param {!Object} idTokenResponse The ID token response.\n * @param {!fireauth.constants.OperationType} operationType The operation type\n *     to set in the user credential.\n * @return {!fireauth.AuthEventManager.Result} The UserCredential object\n *     constructed from the response.\n * @private\n */\nfireauth.AuthUser.prototype.getUserCredential_ =\n    function(idTokenResponse, operationType) {\n  // Get credential if available in the response.\n  var credential = fireauth.AuthProvider.getCredentialFromResponse(\n      idTokenResponse);\n  // Get additional user info data if available in the response.\n  var additionalUserInfo = fireauth.AdditionalUserInfo.fromPlainObject(\n      idTokenResponse);\n  // Return the readonly copy of the user credential object.\n  return fireauth.object.makeReadonlyCopy({\n    // Return the current user reference.\n    'user': this,\n    // Return any credential passed from the backend.\n    'credential': credential,\n    // Return any additional IdP data passed from the backend.\n    'additionalUserInfo': additionalUserInfo,\n    // Return the operation type in the user credential object.\n    'operationType': operationType\n  });\n};\n\n\n/**\n * Finalizes a linking flow, updating idToken and user's data using the\n * RPC linking response.\n * @param {!Object} response The RPC linking response.\n * @return {!goog.Promise<!fireauth.AuthUser>}\n * @private\n */\nfireauth.AuthUser.prototype.finalizeLinking_ = function(response) {\n  // The response may contain a new access token,\n  // so we should update them just like a new sign in.\n  this.updateTokensIfPresent_(response);\n  // This will take care of saving the updated state.\n  var self = this;\n  return this.reload().then(function() {\n    return self;\n  });\n};\n\n\n/**\n * Updates the user's email.\n * @param {string} newEmail The new email.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.updateEmail = function(newEmail) {\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(this.getIdToken()\n      .then(function(idToken) {\n        return self.rpcHandler_.updateEmail(idToken, newEmail);\n      })\n      .then(function(response) {\n        // Calls to SetAccountInfo may invalidate old tokens.\n        self.updateTokensIfPresent_(response);\n        // Reloads the user to update emailVerified.\n        return self.reload();\n      }));\n};\n\n\n/**\n * Updates the user's phone number.\n * @param {!fireauth.PhoneAuthCredential} phoneCredential\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.updatePhoneNumber = function(phoneCredential) {\n  var self = this;\n  return this.registerPendingPromise_(this.getIdToken()\n      .then(function(idToken) {\n        // The backend always overwrites the existing phone number during a\n        // link operation.\n        return phoneCredential.linkToIdToken(self.rpcHandler_, idToken);\n      })\n      .then(function(response) {\n        self.updateTokensIfPresent_(response);\n        return self.reload();\n      }));\n};\n\n\n/**\n * Updates the user's password.\n * @param {string} newPassword The new password.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.updatePassword = function(newPassword) {\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      this.getIdToken()\n      .then(function(idToken) {\n        return self.rpcHandler_.updatePassword(idToken, newPassword);\n      })\n      .then(function(response) {\n        self.updateTokensIfPresent_(response);\n        // Reloads the user in case email has also been updated and the user\n        // was anonymous.\n        return self.reload();\n      }));\n};\n\n\n/**\n * Updates the user's profile data.\n * @param {!Object} profile The profile data to update.\n * @return {!goog.Promise<undefined>}\n */\nfireauth.AuthUser.prototype.updateProfile = function(profile) {\n  if (profile['displayName'] === undefined &&\n      profile['photoURL'] === undefined) {\n    // No change, directly return.\n    return this.checkDestroyed_();\n  }\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      this.getIdToken().then(function(idToken) {\n        // Translate the request into one that the backend accepts.\n        var profileRequest = {\n          'displayName': profile['displayName'],\n          'photoUrl': profile['photoURL']\n        };\n        return self.rpcHandler_.updateProfile(idToken, profileRequest);\n      })\n      .then(function(response) {\n        // Calls to SetAccountInfo may invalidate old tokens.\n        self.updateTokensIfPresent_(response);\n        // Update properties.\n        self.updateProperty('displayName',\n            response[fireauth.AuthUser.SetAccountInfoField.DISPLAY_NAME] ||\n            null);\n        self.updateProperty('photoURL',\n            response[fireauth.AuthUser.SetAccountInfoField.PHOTO_URL] || null);\n        goog.array.forEach(self['providerData'], function(userInfo) {\n          // Check if password provider is linked.\n          if (userInfo['providerId'] === fireauth.idp.ProviderId.PASSWORD) {\n            // If so, update both fields in that provider.\n            fireauth.object.setReadonlyProperty(\n                userInfo, 'displayName', self['displayName']);\n            fireauth.object.setReadonlyProperty(\n                userInfo, 'photoURL', self['photoURL']);\n          }\n        });\n        // Notify changes and resolve.\n        return self.notifyStateChangeListeners_();\n      })\n      .then(fireauth.AuthUser.returnNothing_));\n};\n\n\n/**\n * Unlinks a provider from an account.\n * @param {!fireauth.idp.ProviderId} providerId The ID of the provider to\n *     unlink.\n * @return {!goog.Promise<!fireauth.AuthUser>}\n */\nfireauth.AuthUser.prototype.unlink = function(providerId) {\n  var self = this;\n  // Make sure we have updated user providers to avoid removing a linked\n  // provider that hasn't been updated in current copy of user.\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      this.reloadWithoutSaving_()\n      .then(function(idToken) {\n        // Provider already unlinked.\n        if (!goog.array.contains(self.getProviderIds(), providerId)) {\n          return self.notifyStateChangeListeners_()\n              .then(function() {\n                throw new fireauth.AuthError(\n                    fireauth.authenum.Error.NO_SUCH_PROVIDER);\n              });\n        }\n        // We delete the providerId given.\n        return self.rpcHandler_\n            .deleteLinkedAccounts(idToken, [providerId])\n            .then(function(resp) {\n              // Construct the set of provider IDs returned by server.\n              var remainingProviderIds = {};\n              var userInfo = resp[fireauth.AuthUser.SetAccountInfoField.\n                  PROVIDER_USER_INFO] || [];\n              goog.array.forEach(userInfo, function(obj) {\n                remainingProviderIds[\n                    obj[fireauth.AuthUser.SetAccountInfoField.PROVIDER_ID]] =\n                    true;\n              });\n\n              // Remove all provider data objects where the provider ID no\n              // longer exists in this user.\n              goog.array.forEach(self.getProviderIds(), function(pId) {\n                if (!remainingProviderIds[pId]) {\n                  // This provider no longer linked, remove it from user.\n                  self.removeProviderData(pId);\n                }\n              });\n\n              // Remove the phone number if the phone provider was unlinked.\n              if (!remainingProviderIds[fireauth.PhoneAuthProvider[\n                      'PROVIDER_ID']]) {\n                fireauth.object.setReadonlyProperty(self, 'phoneNumber', null);\n              }\n\n              return self.notifyStateChangeListeners_();\n            });\n      }));\n};\n\n\n/**\n * Deletes the user, triggering an Auth token change if successful.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.delete = function() {\n  // Notice the way of declaring the method, it's to avoid a weird bug on IE8.\n  var self = this;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      this.getIdToken()\n      .then(function(idToken) {\n        return self.rpcHandler_.deleteAccount(idToken);\n      })\n      .then(function() {\n        self.notifyUserDeletedListeners_();\n      }))\n      .then(function() {\n        // Destroying after the registered promise is handled ensures it won't\n        // be canceled.\n        self.destroy();\n      });\n};\n\n\n/**\n * Tells the Auth event manager if this user is the owner of a detected Auth\n * event. A user can handle linkWithPopup and linkWithRedirect operations.\n * In addition, the event ID should match the user's event IDs.\n * @param {!fireauth.AuthEvent.Type} mode The Auth operation mode (popup,\n *     redirect).\n * @param {?string=} opt_eventId The event ID.\n * @return {boolean} Whether the Auth event handler can handler the provided\n *     event.\n * @override\n */\nfireauth.AuthUser.prototype.canHandleAuthEvent = function(mode, opt_eventId) {\n  if (mode == fireauth.AuthEvent.Type.LINK_VIA_POPUP &&\n      this.getPopupEventId() == opt_eventId &&\n      this.pendingPopupResolvePromise_) {\n    // The link via popup event's ID matches the user's popup event ID which\n    // makes this user the owner of this event.\n    return true;\n  } else if (mode == fireauth.AuthEvent.Type.REAUTH_VIA_POPUP &&\n      this.getPopupEventId() == opt_eventId &&\n      this.pendingPopupResolvePromise_) {\n    // The reauth via popup event's ID matches the user's popup event ID which\n    // makes this user the owner of this event.\n    return true;\n  } else if (mode == fireauth.AuthEvent.Type.LINK_VIA_REDIRECT &&\n             this.getRedirectEventId() == opt_eventId) {\n    // The link via redirect event's ID matches the user's redirect event ID\n    // which makes this user the owner of this event.\n    return true;\n  } else if (mode == fireauth.AuthEvent.Type.REAUTH_VIA_REDIRECT &&\n             this.getRedirectEventId() == opt_eventId) {\n    // The reauth via redirect event's ID matches the user's redirect event ID\n    // which makes this user the owner of this event.\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Completes the pending popup operation. If error is not null, rejects with the\n * error. Otherwise, it resolves with the popup redirect result.\n * @param {!fireauth.AuthEvent.Type} mode The Auth operation mode (popup,\n *     redirect).\n * @param {?fireauth.AuthEventManager.Result} popupRedirectResult The result\n *     to resolve with when no error supplied.\n * @param {?fireauth.AuthError} error When supplied, the promise will reject.\n * @param {?string=} opt_eventId The event ID.\n * @override\n */\nfireauth.AuthUser.prototype.resolvePendingPopupEvent =\n    function(mode, popupRedirectResult, error, opt_eventId) {\n  // Only handles popup events with event IDs that match a pending popup ID.\n  if ((mode != fireauth.AuthEvent.Type.LINK_VIA_POPUP &&\n       mode != fireauth.AuthEvent.Type.REAUTH_VIA_POPUP) ||\n      opt_eventId != this.getPopupEventId()) {\n    return;\n  }\n  if (error && this.pendingPopupRejectPromise_) {\n    // Reject with error for supplied mode.\n    this.pendingPopupRejectPromise_(error);\n  } else if (popupRedirectResult &&\n             !error &&\n             this.pendingPopupResolvePromise_) {\n    // Resolve with result for supplied mode.\n    this.pendingPopupResolvePromise_(popupRedirectResult);\n  }\n  // Now that event is resolved, delete timeout promise.\n  if (this.popupTimeoutPromise_) {\n    this.popupTimeoutPromise_.cancel();\n    this.popupTimeoutPromise_ = null;\n  }\n  // Delete pending promises.\n  delete this.pendingPopupResolvePromise_;\n  delete this.pendingPopupRejectPromise_;\n};\n\n\n/**\n * Returns the handler's appropriate popup and redirect sign in operation\n * finisher. Can handle link or reauth events that match existing event IDs.\n * @param {!fireauth.AuthEvent.Type} mode The Auth operation mode (popup,\n *     redirect).\n * @param {?string=} opt_eventId The optional event ID.\n * @return {?function(string, string, ?string,\n *     ?string=):!goog.Promise<!fireauth.AuthEventManager.Result>}\n * @override\n */\nfireauth.AuthUser.prototype.getAuthEventHandlerFinisher =\n    function(mode, opt_eventId) {\n  if (mode == fireauth.AuthEvent.Type.LINK_VIA_POPUP &&\n      opt_eventId == this.getPopupEventId()) {\n    // Link with popup ID matches popup event ID.\n    return goog.bind(this.finishPopupAndRedirectLink, this);\n  } else if (mode == fireauth.AuthEvent.Type.REAUTH_VIA_POPUP &&\n      opt_eventId == this.getPopupEventId()) {\n    // Reauth with popup ID matches popup event ID.\n    return goog.bind(this.finishPopupAndRedirectReauth, this);\n  } else if (mode == fireauth.AuthEvent.Type.LINK_VIA_REDIRECT &&\n             this.getRedirectEventId() == opt_eventId) {\n    // Link with redirect ID matches redirect event ID.\n    return goog.bind(this.finishPopupAndRedirectLink, this);\n  } else if (mode == fireauth.AuthEvent.Type.REAUTH_VIA_REDIRECT &&\n             this.getRedirectEventId() == opt_eventId) {\n    // Reauth with redirect ID matches redirect event ID.\n    return goog.bind(this.finishPopupAndRedirectReauth, this);\n  }\n  return null;\n};\n\n\n/**\n * @return {string} The generated event ID used to identify a popup or redirect\n *     event.\n * @private\n */\nfireauth.AuthUser.prototype.generateEventId_ = function() {\n  return fireauth.util.generateEventId(this['uid'] + ':::');\n};\n\n\n/**\n * Links to Auth provider via popup.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.linkWithPopup = function(provider) {\n  var self = this;\n  // Additional check to return to fail when the provider is already linked.\n  var additionalCheck = function() {\n    return self.checkIfAlreadyLinked_(provider['providerId'])\n        .then(function() {\n          // Notify state listeners after the check as it will update the user\n          // state.\n          return self.notifyStateChangeListeners_();\n        });\n  };\n  return this.runOperationWithPopup_(\n      fireauth.AuthEvent.Type.LINK_VIA_POPUP, provider, additionalCheck, false);\n};\n\n\n/**\n * Reauthenticate to Auth provider via popup.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.reauthenticateWithPopup = function(provider) {\n  // No additional check needed before running this operation.\n  var additionalCheck = function() {\n    return goog.Promise.resolve();\n  };\n  return this.runOperationWithPopup_(\n      fireauth.AuthEvent.Type.REAUTH_VIA_POPUP,\n      provider,\n      additionalCheck,\n      // Do not update token and skip session invalidation check.\n      true);\n};\n\n\n/**\n * Runs a specific OAuth operation using the Auth provider via popup.\n * @param {!fireauth.AuthEvent.Type} mode The mode of operation (link or\n *     reauth).\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {!function():!goog.Promise} additionalCheck The additional check to\n *     run before proceeding with the popup processing.\n * @param {boolean} isReauthOperation whether this is a reauth operation or not.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n * @private\n */\nfireauth.AuthUser.prototype.runOperationWithPopup_ =\n    function(mode, provider, additionalCheck, isReauthOperation) {\n  // Check if popup and redirect are supported in this environment.\n  if (!fireauth.util.isPopupRedirectSupported()) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  // Quickly throw user invalidation error if already invalidated.\n  if (this.userInvalidatedError_ &&\n      // Skip invalidation check as reauthentication could revalidate a user.\n      !isReauthOperation) {\n    return goog.Promise.reject(this.userInvalidatedError_);\n  }\n  var self = this;\n  // Popup the window immediately to make sure the browser associates the\n  // popup with the click that triggered it.\n\n  // Get provider settings.\n  var settings = fireauth.idp.getIdpSettings(provider['providerId']);\n  // There could multiple users at the same time and multiple users could have\n  // the same UID. So try to ensure event ID uniqueness.\n  var eventId = this.generateEventId_();\n  // If incapable of redirecting popup from opener, popup destination URL\n  // directly. This could also happen in a sandboxed iframe.\n  var oauthHelperWidgetUrl = null;\n  if ((!fireauth.util.runsInBackground() || fireauth.util.isIframe()) &&\n      this.authDomain_ &&\n      provider['isOAuthProvider']) {\n    oauthHelperWidgetUrl =\n        fireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl(\n            this.authDomain_,\n            this.apiKey_,\n            this.appName_,\n            mode,\n            provider,\n            null,\n            eventId,\n            firebase.SDK_VERSION || null,\n            null,\n            null,\n            this['tenantId']);\n  }\n  // The popup must have a name, otherwise when successive popups are triggered\n  // they will all render in the same instance and none will succeed since the\n  // popup cancel of first window will close the shared popup window instance.\n  var popupWin =\n      fireauth.util.popup(\n          oauthHelperWidgetUrl,\n          fireauth.util.generateRandomString(),\n          settings && settings.popupWidth,\n          settings && settings.popupHeight);\n  var p = additionalCheck().then(function() {\n    // Auth event manager must be available for account linking or\n    // reauthentication to be possible.\n    self.getAuthEventManager();\n    if (!isReauthOperation) {\n      // Some operations like reauthenticate do not require this.\n      return self.getIdToken().then(function(idToken) {});\n    }\n  }).then(function() {\n    // Process popup request.\n    return self.authEventManager_.processPopup(\n        popupWin, mode, provider, eventId, !!oauthHelperWidgetUrl,\n        self['tenantId']);\n  }).then(function() {\n    return new goog.Promise(function(resolve, reject) {\n      // Expire other pending promises if still available.\n      self.resolvePendingPopupEvent(\n          mode,\n          null,\n          new fireauth.AuthError(fireauth.authenum.Error.EXPIRED_POPUP_REQUEST),\n          // Existing popup event ID.\n          self.getPopupEventId());\n      // Save current pending promises.\n      self.pendingPopupResolvePromise_ = resolve;\n      self.pendingPopupRejectPromise_ = reject;\n      // Overwrite popup event ID with new one.\n      self.setPopupEventId(eventId);\n      // Keep track of timeout promise to cancel it on promise resolution before\n      // it times out.\n      self.popupTimeoutPromise_ =\n          self.authEventManager_.startPopupTimeout(\n              self, mode, /** @type {!Window} */ (popupWin), eventId);\n    });\n  }).then(function(result) {\n    // On resolution, close popup if still opened and pass result through.\n    if (popupWin) {\n      fireauth.util.closeWindow(popupWin);\n    }\n    if (result) {\n      return fireauth.object.makeReadonlyCopy(result);\n    }\n    return null;\n  }).thenCatch(function(error) {\n    if (popupWin) {\n      fireauth.util.closeWindow(popupWin);\n    }\n    throw error;\n  });\n  // Register this pending promise. This will also check for user invalidation.\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(\n          p,\n          // Skip invalidation check as reauthentication could revalidate a\n          // user.\n          isReauthOperation));\n};\n\n\n/**\n * Links to Auth provider via redirect.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.linkWithRedirect = function(provider) {\n  var mode = fireauth.AuthEvent.Type.LINK_VIA_REDIRECT;\n  var self = this;\n  // Additional check to return to fail when the provider is already linked.\n  var additionalCheck = function() {\n    return self.checkIfAlreadyLinked_(provider['providerId']);\n  };\n  return this.runOperationWithRedirect_(mode, provider, additionalCheck, false);\n};\n\n\n/**\n * Reauthenticates to Auth provider via redirect.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.reauthenticateWithRedirect = function(provider) {\n  // No additional check needed.\n  var additionalCheck = function() {\n    return goog.Promise.resolve();\n  };\n  return this.runOperationWithRedirect_(\n      fireauth.AuthEvent.Type.REAUTH_VIA_REDIRECT,\n      provider,\n      additionalCheck,\n      // Do not update token and skip session invalidation check.\n      true);\n};\n\n\n\n/**\n * Runs a specific OAuth operation using the Auth provider via redirect.\n * @param {!fireauth.AuthEvent.Type} mode The mode of operation (link or\n *     reauth).\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @param {!function():!goog.Promise} additionalCheck The additional check to\n *     run before proceeding with the redirect processing.\n * @param {boolean} isReauthOperation whether this is a reauth operation or not.\n * @return {!goog.Promise<void>}\n * @private\n */\nfireauth.AuthUser.prototype.runOperationWithRedirect_ =\n    function(mode, provider, additionalCheck, isReauthOperation) {\n  // Check if popup and redirect are supported in this environment.\n  if (!fireauth.util.isPopupRedirectSupported()) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  // Quickly throw user invalidation error if already invalidated.\n  if (this.userInvalidatedError_ &&\n      // Skip invalidation check as reauthentication could revalidate a user.\n      !isReauthOperation) {\n    return goog.Promise.reject(this.userInvalidatedError_);\n  }\n  var self = this;\n  var errorThrown = null;\n  // There could multiple users at the same time and multiple users could have\n  // the same UID. So try to ensure event ID uniqueness.\n  var eventId = this.generateEventId_();\n  var p = additionalCheck().then(function() {\n    // Auth event manager must be available for account linking or\n    // reauthentication to be possible.\n    self.getAuthEventManager();\n    if (!isReauthOperation) {\n      // Some operations like reauthenticate do not require this.\n      return self.getIdToken().then(function(idToken) {});\n    }\n  }).then(function() {\n    // Process redirect operation.\n    self.setRedirectEventId(eventId);\n    // Before redirecting save the event ID.\n    // It is important that the user redirect event ID is updated in storage\n    // before redirecting.\n    return self.notifyStateChangeListeners_();\n  }).then(function(user) {\n    if (self.redirectStorageManager_) {\n      // Save the user before redirecting in case it is not current so that it\n      // can be retrieved after reloading for linking or reauthentication to\n      // succeed.\n      return self.redirectStorageManager_.setRedirectUser(self);\n    }\n    return user;\n  }).then(function(user) {\n    // Complete the redirect operation.\n    return self.authEventManager_.processRedirect(\n        mode, provider, eventId, self['tenantId']);\n  }).thenCatch(function(error) {\n    // Catch error if any is generated.\n    errorThrown = error;\n    if (self.redirectStorageManager_) {\n      // If an error is detected, delete the redirected user from storage.\n      return self.redirectStorageManager_.removeRedirectUser();\n    }\n    // No storage manager, just throw error.\n    throw errorThrown;\n  }).then(function() {\n    // Rethrow the error.\n    if (errorThrown) {\n      throw errorThrown;\n    }\n  });\n  // Register this pending promise. This will also check for user invalidation.\n  return /** @type {!goog.Promise<void>} */ (this.registerPendingPromise_(\n      p,\n      // Skip invalidation check as reauthentication could revalidate a user.\n      isReauthOperation));\n};\n\n\n/**\n * @return {!fireauth.AuthEventManager} The user's Auth event manager.\n */\nfireauth.AuthUser.prototype.getAuthEventManager = function() {\n  // Either return the manager instance if available, otherwise throw an error.\n  if (this.authEventManager_ && this.popupRedirectEnabled_) {\n    return this.authEventManager_;\n  } else if (this.authEventManager_ && !this.popupRedirectEnabled_) {\n    // This should not happen as Auth will enable a user after it is created.\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR);\n  }\n  throw new fireauth.AuthError(fireauth.authenum.Error.MISSING_AUTH_DOMAIN);\n};\n\n\n/**\n * Finishes the popup and redirect account linking operations.\n * @param {string} requestUri The callback URL with the OAuth response.\n * @param {string} sessionId The session ID used to generate the authUri.\n * @param {?string} tenantId The tenant ID.\n * @param {?string=} opt_postBody The optional POST body content.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.finishPopupAndRedirectLink =\n    function(requestUri, sessionId, tenantId, opt_postBody) {\n  var self = this;\n  // Now that popup has responded, delete popup timeout promise.\n  if (this.popupTimeoutPromise_) {\n    this.popupTimeoutPromise_.cancel();\n    this.popupTimeoutPromise_ = null;\n  }\n  var userCredential = null;\n  // This routine could be run before init state, make sure it waits for that to\n  // complete otherwise this would fail as user not loaded from storage yet.\n  var p = this.getIdToken()\n      .then(function(idToken) {\n        var request = {\n          'requestUri': requestUri,\n          'postBody': opt_postBody,\n          'sessionId': sessionId,\n          // To link a tenant user, the tenant ID will be passed to the\n          // backend as part of the ID token.\n          'idToken': idToken\n        };\n        // This operation should fail if new ID token differs from old one.\n        // So this can be treate as a profile update operation.\n        return self.rpcHandler_.verifyAssertionForLinking(request);\n      })\n      .then(function(response) {\n        // Get user credential.\n        userCredential = self.getUserCredential_(\n            response, fireauth.constants.OperationType.LINK);\n        // Finalizes the linking process.\n        return self.finalizeLinking_(response);\n      })\n      .then(function(user) {\n        // Return the user credential response.\n        return userCredential;\n      });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * Finishes the popup and redirect account reauthentication operations.\n * @param {string} requestUri The callback URL with the OAuth response.\n * @param {string} sessionId The session ID used to generate the authUri.\n * @param {?string} tenantId The tenant ID.\n * @param {?string=} opt_postBody The optional POST body content.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.AuthUser.prototype.finishPopupAndRedirectReauth =\n    function(requestUri, sessionId, tenantId, opt_postBody) {\n  var self = this;\n  // Now that popup has responded, delete popup timeout promise.\n  if (this.popupTimeoutPromise_) {\n    this.popupTimeoutPromise_.cancel();\n    this.popupTimeoutPromise_ = null;\n  }\n  var userCredential = null;\n  // This routine could be run before init state, make sure it waits for that to\n  // complete otherwise this would fail as user not loaded from storage yet.\n  var p = goog.Promise.resolve()\n      .then(function() {\n        var request = {\n          'requestUri': requestUri,\n          'sessionId': sessionId,\n          'postBody': opt_postBody,\n          // To reauthenticate a tenant user, the tenant ID will be passed to\n          // the backend explicitly.\n          // Even if tenant ID is null, still pass it to RPC handler explicitly\n          // so that it won't be overridden by RPC handler's tenant ID.\n          'tenantId': tenantId\n        };\n        // Finish sign in by calling verifyAssertionForExisting and then\n        // matching the returned ID token's UID with the current user's.\n        return fireauth.AuthCredential.verifyTokenResponseUid(\n            self.rpcHandler_.verifyAssertionForExisting(request),\n            self['uid']);\n      }).then(function(response) {\n        // Get credential from response if available.\n        // Get user credential.\n        userCredential = self.getUserCredential_(\n            response, fireauth.constants.OperationType.REAUTHENTICATE);\n        // If the credential is valid and matches the current user ID, then\n        // update the tokens accordingly.\n        self.updateTokensIfPresent_(response);\n        // This could potentially validate an invalidated user. This happens in\n        // the case a password reset was applied. The refresh token is expired.\n        // Reauthentication should revalidate the user.\n        // User would remain non current if already signed out, but should be\n        // enabled again.\n        self.userInvalidatedError_ = null;\n        return self.reload();\n      })\n      .then(function() {\n        // Return the user credential response.\n        return userCredential;\n      });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(\n          p,\n          // Skip invalidation check as reauthentication could revalidate a\n          // user.\n          true));\n};\n\n\n/**\n * Sends the email verification email to the email in the user's account.\n * @param {?Object=} opt_actionCodeSettings The optional action code settings\n *     object.\n * @return {!goog.Promise<void>}\n */\nfireauth.AuthUser.prototype.sendEmailVerification =\n    function(opt_actionCodeSettings) {\n  var self = this;\n  var idToken = null;\n  // Register this pending promise. This will also check for user invalidation.\n  return this.registerPendingPromise_(\n      // Wrap in promise as ActionCodeSettings constructor could throw a\n      // synchronous error if invalid arguments are specified.\n      this.getIdToken().then(function(latestIdToken) {\n        idToken = latestIdToken;\n        if (typeof opt_actionCodeSettings !== 'undefined' &&\n            // Ignore empty objects.\n            !goog.object.isEmpty(opt_actionCodeSettings)) {\n          return new fireauth.ActionCodeSettings(\n              /** @type {!Object} */ (opt_actionCodeSettings)).buildRequest();\n        }\n        return {};\n      })\n      .then(function(additionalRequestData) {\n        return self.rpcHandler_.sendEmailVerification(\n            /** @type {string} */ (idToken), additionalRequestData);\n      })\n      .then(function(email) {\n        if (self['email'] != email) {\n          // Our local copy does not have an email. If the email changed,\n          // reload the user.\n          return self.reload();\n        }\n      })\n      .then(function() {\n        // Return nothing.\n      }));\n};\n\n\n/**\n * Destroys the user object and makes further operations invalid. Sensitive\n * fields (refreshToken) are also cleared.\n */\nfireauth.AuthUser.prototype.destroy = function() {\n  // Cancel all pending promises.\n  for (var i = 0; i < this.pendingPromises_.length; i++) {\n    this.pendingPromises_[i].cancel(fireauth.authenum.Error.MODULE_DESTROYED);\n  }\n  // Stop listening to language code changes.\n  this.setLanguageCodeChangeDispatcher(null);\n  // Stop listening to framework changes.\n  this.setFrameworkChangeDispatcher(null);\n  // Empty pending promises array.\n  this.pendingPromises_ = [];\n  this.destroyed_ = true;\n  // Stop proactive refresh if running.\n  this.stopProactiveRefresh();\n  fireauth.object.setReadonlyProperty(this, 'refreshToken', null);\n  // Make sure the destroyed user is unsubscribed from Auth event handling.\n  if (this.authEventManager_) {\n    this.authEventManager_.unsubscribe(this);\n  }\n};\n\n\n/**\n * Takes in a pending promise, saves it and adds a clean up callback which\n * forgets the pending promise after it is fulfilled and echoes the promise\n * back. If in the process, a user invalidation error is detected, caches the\n * error so next time a call is made on the user, the operation will fail with\n * the cached error.\n * @param {!goog.Promise<*, *>|!goog.Promise<void>} p The pending promise.\n * @param {boolean=} opt_skipInvalidationCheck Whether to skip invalidation\n *     check.\n * @return {!goog.Promise<*, *>|!goog.Promise<void>}\n * @private\n */\nfireauth.AuthUser.prototype.registerPendingPromise_ =\n    function(p, opt_skipInvalidationCheck) {\n  var self = this;\n  // Check if user invalidation occurs.\n  var processedP = this.checkIfInvalidated_(p, opt_skipInvalidationCheck);\n  // Save created promise in pending list.\n  this.pendingPromises_.push(processedP);\n  processedP.thenAlways(function() {\n    // When fulfilled, remove from pending list.\n    goog.array.remove(self.pendingPromises_, processedP);\n  });\n  // Return the promise.\n  return processedP;\n};\n\n\n/**\n * Check if user invalidation occurs. If so, it caches the error so it can be\n * thrown immediately the next time an operation is run on the user.\n * @param {!goog.Promise<*, *>|!goog.Promise<void>} p The pending promise.\n * @param {boolean=} opt_skipInvalidationCheck Whether to skip invalidation\n *     check.\n * @return {!goog.Promise<*, *>|!goog.Promise<void>}\n * @private\n */\nfireauth.AuthUser.prototype.checkIfInvalidated_ =\n    function(p, opt_skipInvalidationCheck) {\n  var self = this;\n  // Already invalidated, reject with token expired error.\n  // Unless invalidation check is to be skipped.\n  if (this.userInvalidatedError_ && !opt_skipInvalidationCheck) {\n    // Cancel pending promise.\n    p.cancel();\n    // Reject with cached error.\n    return goog.Promise.reject(this.userInvalidatedError_);\n  }\n  return p.thenCatch(function(error) {\n    // Session invalidated.\n    if (fireauth.AuthUser.isUserInvalidated_(error)) {\n      // Notify listeners of invalidated session.\n      if (!self.userInvalidatedError_) {\n        self.notifyUserInvalidatedListeners_();\n      }\n      // Cache the invalidation error.\n      self.userInvalidatedError_ = /** @type {!fireauth.AuthError} */ (error);\n    }\n    // Rethrow the error.\n    throw error;\n  });\n};\n\n\n/**\n * @return {!Object} The object representation of the user instance.\n * @override\n */\nfireauth.AuthUser.prototype.toJSON = function() {\n  // Return the plain object representation in case JSON.stringify is called on\n  // a user instance.\n  return this.toPlainObject();\n};\n\n\n/**\n * @return {!Object} The object representation of the user instance.\n */\nfireauth.AuthUser.prototype.toPlainObject = function() {\n  var obj = {\n    'uid': this['uid'],\n    'displayName': this['displayName'],\n    'photoURL': this['photoURL'],\n    'email': this['email'],\n    'emailVerified': this['emailVerified'],\n    'phoneNumber': this['phoneNumber'],\n    'isAnonymous': this['isAnonymous'],\n    'tenantId': this['tenantId'],\n    'providerData': [],\n    'apiKey': this.apiKey_,\n    'appName': this.appName_,\n    'authDomain': this.authDomain_,\n    'stsTokenManager': this.stsTokenManager_.toPlainObject(),\n    // Redirect event ID must be maintained in case there is a pending redirect\n    // event.\n    'redirectEventId': this.getRedirectEventId()\n  };\n  // Extend user plain object with metadata object.\n  if (this['metadata']) {\n    goog.object.extend(obj, this['metadata'].toPlainObject());\n  }\n  goog.array.forEach(this['providerData'], function(userInfo) {\n    obj['providerData'].push(fireauth.object.makeWritableCopy(userInfo));\n  });\n  return obj;\n};\n\n\n/**\n * Converts a plain user object to {@code fireauth.AuthUser}.\n * @param {!Object} user The object representation of the user instance.\n * @return {?fireauth.AuthUser} The Firebase user object corresponding to\n *     object.\n */\nfireauth.AuthUser.fromPlainObject = function(user) {\n  if (!user['apiKey']) {\n    return null;\n  }\n  var options = {\n    'apiKey': user['apiKey'],\n    'authDomain': user['authDomain'],\n    'appName': user['appName']\n  };\n  // Convert to server response format. Constructor does not take\n  // stsTokenManager toPlainObject as that format is different than the return\n  // server response which is always used to initialize a user instance. It is\n  // also difficult to have toPlainObject equal server response due to expiresIn\n  // field in server response. toPlainObject will return an expiration time\n  // instead.\n  var stsTokenManagerResponse = {};\n  if (user['stsTokenManager'] &&\n      user['stsTokenManager']['accessToken'] &&\n      user['stsTokenManager']['expirationTime']) {\n    stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.ID_TOKEN] =\n        user['stsTokenManager']['accessToken'];\n    // Refresh token could be expired.\n    stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.REFRESH_TOKEN] =\n        user['stsTokenManager']['refreshToken'] || null;\n    stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.EXPIRES_IN] =\n        (user['stsTokenManager']['expirationTime'] - goog.now()) / 1000;\n  } else {\n    // Token response is a required field.\n    return null;\n  }\n  var firebaseUser = new fireauth.AuthUser(options,\n      stsTokenManagerResponse,\n      /** @type {!fireauth.AuthUser.AccountInfo} */ (user));\n  if (user['providerData']) {\n    goog.array.forEach(user['providerData'], function(userInfo) {\n      if (userInfo) {\n        firebaseUser.addProviderData(/** @type {!fireauth.AuthUserInfo} */ (\n            fireauth.object.makeReadonlyCopy(userInfo)));\n      }\n    });\n  }\n  // Redirect event ID must be restored to complete any pending link with\n  // redirect operation owned by this user.\n  if (user['redirectEventId']) {\n    firebaseUser.setRedirectEventId(user['redirectEventId']);\n  }\n  return firebaseUser;\n};\n\n\n\n/**\n * Factory method for initializing a Firebase user object and populating its\n * user info. This is the recommended way for initializing a user externally.\n * On sign in/up operation, the server returns a token response. The response is\n * all that is needed to initialize this user.\n * @param {!Object} appOptions The application options.\n * @param {!Object} stsTokenResponse The server STS token response.\n * @param {?fireauth.storage.RedirectUserManager=}\n *     opt_redirectStorageManager The utility used to store and delete a user on\n *     link with redirect.\n * @param {?Array<string>=} opt_frameworks The list of frameworks to log on the\n *     user on initialization.\n * @return {!goog.Promise<!fireauth.AuthUser>}\n */\nfireauth.AuthUser.initializeFromIdTokenResponse = function(appOptions,\n    stsTokenResponse, opt_redirectStorageManager, opt_frameworks) {\n  // Initialize the Firebase Auth user.\n  var user = new fireauth.AuthUser(\n      appOptions, stsTokenResponse);\n  // If redirect storage manager provided, set it.\n  if (opt_redirectStorageManager) {\n    user.setRedirectStorageManager(opt_redirectStorageManager);\n  }\n  // If frameworks provided, set it.\n  if (opt_frameworks) {\n    user.setFramework(opt_frameworks);\n  }\n  // Updates the user info and data and resolves with a user instance.\n  return user.reload().then(function() {\n    return user;\n  });\n};\n\n\n/**\n * Returns an AuthUser copy of the provided user using the provided parameters\n * without making any network request.\n * @param {!fireauth.AuthUser} user The user to be copied.\n * @param {?Object=} opt_appOptions The application options.\n * @param {?fireauth.storage.RedirectUserManager=}\n *     opt_redirectStorageManager The utility used to store and delete a user on\n *     link with redirect.\n * @param {?Array<string>=} opt_frameworks The list of frameworks to log on the\n *     user on initialization.\n * @return {!fireauth.AuthUser}\n */\nfireauth.AuthUser.copyUser = function(user, opt_appOptions,\n    opt_redirectStorageManager, opt_frameworks) {\n  var appOptions = opt_appOptions || {\n    'apiKey': user.apiKey_,\n    'authDomain': user.authDomain_,\n    'appName': user.appName_\n  };\n  var newUser = new fireauth.AuthUser(\n      appOptions, user.getStsTokenManager().toServerResponse());\n  // If redirect storage manager provided, set it.\n  if (opt_redirectStorageManager) {\n    newUser.setRedirectStorageManager(opt_redirectStorageManager);\n  }\n  // If frameworks provided, set it.\n  if (opt_frameworks) {\n    newUser.setFramework(opt_frameworks);\n  }\n  // Copy remaining properties.\n  newUser.copy(user);\n  return newUser;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Utility class to retrieve and cache STS token.\n */\ngoog.provide('fireauth.StsTokenManager');\ngoog.provide('fireauth.StsTokenManager.Response');\ngoog.provide('fireauth.StsTokenManager.ResponseData');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.RpcHandler');\ngoog.require('fireauth.authenum.Error');\ngoog.require('goog.Promise');\ngoog.require('goog.asserts');\n\n\n\n/**\n * Creates STS token manager.\n *\n * @param {!fireauth.RpcHandler} rpcHandler Handler for RPC requests.\n * @constructor\n */\nfireauth.StsTokenManager = function(rpcHandler) {\n  /**\n   * @const @private {!fireauth.RpcHandler} The RPC handler used to request STS\n   *     tokens.\n   */\n  this.rpcHandler_ = rpcHandler;\n  /** @private {?string} The STS refresh token. */\n  this.refreshToken_ = null;\n  /** @private {?string} The STS ID token. */\n  this.accessToken_ = null;\n  /** @private {number} The STS expiration timestamp. */\n  this.expirationTime_ = 0;\n};\n\n\n/**\n * @return {!Object} The plain object representation of the STS token manager.\n */\nfireauth.StsTokenManager.prototype.toPlainObject = function() {\n  return {\n    'apiKey': this.rpcHandler_.getApiKey(),\n    'refreshToken': this.refreshToken_,\n    'accessToken': this.accessToken_,\n    'expirationTime': this.expirationTime_\n  };\n};\n\n\n/**\n * @param {!fireauth.RpcHandler} rpcHandler The RPC handler for the token\n *     manager.\n * @param {?Object} obj The plain object whose STS token manager instance is to\n *     be returned.\n * @return {?fireauth.StsTokenManager} The STS token manager instance from the\n *     plain object provided using the RPC handler provided.\n */\nfireauth.StsTokenManager.fromPlainObject = function(rpcHandler, obj) {\n  var stsTokenManager = null;\n  if (obj && obj['apiKey']) {\n    // These should be always equals and must be enforced in internal use.\n    goog.asserts.assert(obj['apiKey'] == rpcHandler.getApiKey());\n    stsTokenManager = new fireauth.StsTokenManager(rpcHandler);\n    stsTokenManager.setRefreshToken(obj['refreshToken']);\n    stsTokenManager.setAccessToken(\n        obj['accessToken'], obj['expirationTime'] || 0);\n  }\n  return stsTokenManager;\n};\n\n\n/**\n * @typedef {{\n *   accessToken: (?string),\n *   expirationTime: (number),\n *   refreshToken: (?string)\n * }}\n */\nfireauth.StsTokenManager.Response;\n\n\n/**\n * @typedef {{\n *   access_token: (?string|undefined),\n *   expires_in: (number|undefined),\n *   refresh_token: (?string|undefined)\n * }}\n */\nfireauth.StsTokenManager.ResponseData;\n\n\n/**\n * @param {?string} refreshToken The STS refresh token.\n */\nfireauth.StsTokenManager.prototype.setRefreshToken = function(refreshToken) {\n  this.refreshToken_ = refreshToken;\n};\n\n\n/**\n * @param {?string} accessToken The STS access token.\n * @param {number} expirationTime  The STS token expiration time.\n */\nfireauth.StsTokenManager.prototype.setAccessToken = function(\n    accessToken, expirationTime) {\n  this.accessToken_ = accessToken;\n  this.expirationTime_ = expirationTime;\n};\n\n\n/**\n * @return {?string} The refresh token.\n */\nfireauth.StsTokenManager.prototype.getRefreshToken = function() {\n  return this.refreshToken_;\n};\n\n\n/**\n * @return {number} The STS access token expiration time.\n */\nfireauth.StsTokenManager.prototype.getExpirationTime = function() {\n  return this.expirationTime_;\n};\n\n\n/**\n * The number of milliseconds before the official expiration time of a token\n * to refresh that token, to provide a buffer for RPCs to complete.\n * @const {number}\n * @private\n */\nfireauth.StsTokenManager.TOKEN_REFRESH_BUFFER_ = 30 * 1000;\n\n\n/**\n * @return {boolean} Whether the STS access token is expired or not.\n * @private\n */\nfireauth.StsTokenManager.prototype.isExpired_ = function() {\n  return goog.now() >\n      this.expirationTime_ - fireauth.StsTokenManager.TOKEN_REFRESH_BUFFER_;\n};\n\n\n/**\n * Parses a response from the server that contains STS tokens (e.g. from\n * VerifyAssertion or VerifyPassword) and save the access token, refresh token,\n * and expiration time.\n * @param {!Object} response The backend response.\n * @return {!string} The STS access token.\n */\nfireauth.StsTokenManager.prototype.parseServerResponse = function(response) {\n  var idToken = response[fireauth.RpcHandler.AuthServerField.ID_TOKEN];\n  var refreshToken =\n      response[fireauth.RpcHandler.AuthServerField.REFRESH_TOKEN];\n  var expirationTime = fireauth.StsTokenManager.calcOffsetTimestamp_(\n      response[fireauth.RpcHandler.AuthServerField.EXPIRES_IN]);\n  this.setAccessToken(idToken, expirationTime);\n  this.setRefreshToken(refreshToken);\n  return idToken;\n};\n\n\n/**\n * Converts STS token manager instance to server response object.\n * @return {!Object}\n */\nfireauth.StsTokenManager.prototype.toServerResponse = function() {\n  var stsTokenManagerResponse = {};\n  stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.ID_TOKEN] =\n      this.accessToken_;\n  // Refresh token could be expired.\n  stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.REFRESH_TOKEN] =\n      this.getRefreshToken();\n  stsTokenManagerResponse[fireauth.RpcHandler.AuthServerField.EXPIRES_IN] =\n      (this.getExpirationTime() - goog.now()) / 1000;\n  return stsTokenManagerResponse;\n};\n\n\n/**\n * Copies IdToken, refreshToken and expirationTime from tokenManagerToCopy.\n * @param {!fireauth.StsTokenManager} tokenManagerToCopy\n */\nfireauth.StsTokenManager.prototype.copy = function(tokenManagerToCopy) {\n  this.accessToken_ = tokenManagerToCopy.accessToken_;\n  this.refreshToken_ = tokenManagerToCopy.refreshToken_;\n  this.expirationTime_ = tokenManagerToCopy.expirationTime_;\n};\n\n\n/**\n * @param {number|string} offset The offset to add to the current time, in\n *     seconds.\n * @return {number} The timestamp corresponding to the current time plus offset.\n * @private\n */\nfireauth.StsTokenManager.calcOffsetTimestamp_ = function(offset) {\n  return goog.now() + parseInt(offset, 10) * 1000;\n};\n\n\n/**\n * Exchanges the current refresh token with an access and refresh token.\n * @return {!goog.Promise<?fireauth.StsTokenManager.Response>}\n * @private\n */\nfireauth.StsTokenManager.prototype.exchangeRefreshToken_ = function() {\n  var data = {\n    'grant_type': 'refresh_token',\n    'refresh_token': this.refreshToken_\n  };\n  return this.requestToken_(data);\n};\n\n\n/**\n * Sends a request to STS token endpoint for an access/refresh token.\n * @param {!Object} data The request data to send to STS token endpoint.\n * @return {!goog.Promise<?fireauth.StsTokenManager.Response>}\n * @private\n */\nfireauth.StsTokenManager.prototype.requestToken_ = function(data) {\n  var self = this;\n  // Send RPC request to STS token endpoint.\n  return this.rpcHandler_.requestStsToken(data).then(function(resp) {\n    var response = /** @type {!fireauth.StsTokenManager.ResponseData} */ (resp);\n    self.accessToken_ =\n        response[fireauth.RpcHandler.StsServerField.ACCESS_TOKEN];\n    // Update expiration time.\n    self.expirationTime_ = fireauth.StsTokenManager.calcOffsetTimestamp_(\n        response[fireauth.RpcHandler.StsServerField.EXPIRES_IN]);\n    self.refreshToken_ =\n        response[fireauth.RpcHandler.StsServerField.REFRESH_TOKEN];\n    return /** @type {fireauth.StsTokenManager.Response} */ ({\n      'accessToken': self.accessToken_,\n      'expirationTime': self.expirationTime_,\n      'refreshToken': self.refreshToken_\n    });\n  }).thenCatch(function(error) {\n    // Refresh token expired or user deleted. In this case, reset refresh token\n    // to prevent sending the request again to the STS server unless\n    // the token is manually updated, perhaps via successful reauthentication.\n    if (error['code'] == 'auth/user-token-expired') {\n      self.refreshToken_ = null;\n    }\n    throw error;\n  });\n};\n\n\n/** @return {boolean} Whether the refresh token is expired. */\nfireauth.StsTokenManager.prototype.isRefreshTokenExpired = function() {\n  return !!(this.accessToken_ && !this.refreshToken_);\n};\n\n\n/**\n * Returns an STS token. If the cached one is unexpired it is directly returned.\n * Otherwise the existing ID token or refresh token is exchanged for a new one.\n * If there is no user signed in, returns null.\n *\n * @param {boolean=} opt_forceRefresh Whether to force refresh token exchange.\n * @return {!goog.Promise<?fireauth.StsTokenManager.Response>}\n */\nfireauth.StsTokenManager.prototype.getToken = function(opt_forceRefresh) {\n  var self = this;\n  var forceRefresh = !!opt_forceRefresh;\n  // Refresh token is expired.\n  if (this.isRefreshTokenExpired()) {\n    return goog.Promise.reject(\n        new fireauth.AuthError(fireauth.authenum.Error.TOKEN_EXPIRED));\n  }\n  if (!forceRefresh && this.accessToken_ && !this.isExpired_()) {\n    // Cached STS access token not expired, return it.\n    return /** @type {!goog.Promise} */ (goog.Promise.resolve({\n      'accessToken': self.accessToken_,\n      'expirationTime': self.expirationTime_,\n      'refreshToken': self.refreshToken_\n    }));\n  } else if (this.refreshToken_) {\n    // Expired but refresh token available, exchange refresh token for STS\n    // token.\n    return this.exchangeRefreshToken_();\n  } else {\n    // No token, return null token.\n    return goog.Promise.resolve(\n        /** @type {?fireauth.StsTokenManager.Response} */ (null));\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the fireauth.storage.RedirectUserManager class which\n * provides utilities to store, retrieve and delete an Auth user during a\n * redirect operation.\n */\n\ngoog.provide('fireauth.storage.RedirectUserManager');\n\ngoog.require('fireauth.AuthUser');\ngoog.require('fireauth.authStorage');\n\n\n/**\n * Defines the Auth redirect user storage manager. It provides methods\n * to store, load and delete a user going through a link with redirect\n * operation.\n * @param {string} appId The Auth state's application ID.\n * @param {?fireauth.authStorage.Manager=} opt_manager The underlying storage\n *     manager to use. If none is provided, the default global instance is used.\n * @constructor @struct @final\n */\nfireauth.storage.RedirectUserManager = function(appId, opt_manager) {\n  /** @const @private{string} appId The Auth state's application ID. */\n  this.appId_ = appId;\n  /**\n   * @const @private{!fireauth.authStorage.Manager} The underlying storage\n   *     manager.\n   */\n  this.manager_ = opt_manager || fireauth.authStorage.Manager.getInstance();\n};\n\n\n/**\n * @const @private{!fireauth.authStorage.Key} The Auth redirect user storage\n *     identifier.\n */\nfireauth.storage.RedirectUserManager.REDIRECT_USER_KEY_ = {\n  name: 'redirectUser',\n  persistent: fireauth.authStorage.Persistence.SESSION\n};\n\n\n/**\n * Stores the user being redirected for the provided application ID.\n * @param {!fireauth.AuthUser} redirectUser The user being redirected.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.RedirectUserManager.prototype.setRedirectUser =\n    function(redirectUser) {\n  return this.manager_.set(\n      fireauth.storage.RedirectUserManager.REDIRECT_USER_KEY_,\n      redirectUser.toPlainObject(),\n      this.appId_);\n};\n\n\n/**\n * Removes the stored redirected user for provided app ID.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.RedirectUserManager.prototype.removeRedirectUser =\n    function() {\n  return this.manager_.remove(\n      fireauth.storage.RedirectUserManager.REDIRECT_USER_KEY_, this.appId_);\n};\n\n\n/**\n * @param {?string=} opt_authDomain The optional Auth domain to override if\n *     provided.\n * @return {!goog.Promise<?fireauth.AuthUser>} A promise that resolves with\n *     the stored redirected user for the provided app ID.\n */\nfireauth.storage.RedirectUserManager.prototype.getRedirectUser =\n    function(opt_authDomain) {\n  return this.manager_.get(\n      fireauth.storage.RedirectUserManager.REDIRECT_USER_KEY_, this.appId_)\n      .then(function(response) {\n        // If potential user saved, override Auth domain if authDomain is\n        // provided.\n        if (response && opt_authDomain) {\n          response['authDomain'] = opt_authDomain;\n        }\n        return fireauth.AuthUser.fromPlainObject(response || {});\n      });\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the fireauth.storage.UserManager class which provides\n * utilities to retrieve, store and delete the currently logged in user and to\n * listen to external authentication changes for the same app.\n * With the ability to modify Auth state persistence. The behavior is as\n * follows:\n * Common cases:\n * <ul>\n * <li>Initially, local and session storage will be checked and the state will\n *     be loaded from there without changing it unless the developer calls\n *     setPersistence explicitly. The requirement is that at any time, Auth\n *     state can be saved using one type only of persistence and never more than\n *     one.</li>\n * <li>If the developer tries to sign in with no persistence specified, the\n *     default setting will be used (local in a browser).</li>\n * <li>If the user is not signed in and persistence is set, any future sign-in\n *     attempt will use that type of persistence.</li>\n * <li>If the user is signed in and the developer then switches persistence,\n *     that existing signed in user will change persistence to the new one. All\n *     future sign-in attempts will use that same persistence.</li>\n * <li>When signInWithRedirect is called, the current persistence type is passed\n *     along with that request and on redirect back to app will pass that type\n *     to determine how that state is saved (overriding the default). If the\n *     persistence is explicitly specified on that page, it will change that\n *     redirected Auth state persistence. This is the only time the persistence\n *     is passed from one page to another.\n *     So internally, on redirect, the redirect state is retrieved and then we\n *     check: If the persistence was explicitly provided, we override the\n *     previous type and save the Auth state using that. If no persistence was\n *     explicitly provided, we use the previous persistence type that was passed\n *     in the redirect response.</li>\n * </ul>\n * Behavior across tabs:\n * <ul>\n * <li>User can sign in using session storage on multiple tabs. Each tab cannot\n *     see the state of the other tab.</li>\n * <li>Any attempt to sign in using local storage will be detected and\n *     synchronized on all tabs. If the user was previously signed in on a\n *     specific tab using session storage, that state will be cleared.</li>\n * <li>If the user was previously signed in using local storage and then signs\n *     in using session storage, the user will be signed in on the current tab\n *     only and signed out on all other tabs.</li>\n * <li>Similar logic is applied to the none state. In one tab, switching to\n *     none state will delete any previously saved state in local\n *     persistence in other tabs.</li>\n * </ul>\n */\n\ngoog.provide('fireauth.storage.UserManager');\n\ngoog.require('fireauth.AuthUser');\ngoog.require('fireauth.authStorage');\ngoog.require('goog.Promise');\n\n\n/**\n * Defines the Auth user storage manager. It provides methods to\n * store, load and delete an authenticated current user. It also provides\n * methods to listen to external user changes (updates, sign in, sign out, etc.)\n * @param {string} appId The Auth state's application ID.\n * @param {?fireauth.authStorage.Manager=} opt_manager The underlying storage\n *     manager to use. If none is provided, the default global instance is used.\n * @constructor @struct @final\n */\nfireauth.storage.UserManager = function(appId, opt_manager) {\n  /** @const @private{string} appId The Auth state's application ID. */\n  this.appId_ = appId;\n  /**\n   * @const @private{!fireauth.authStorage.Manager} The underlying storage\n   *     manager.\n   */\n  this.manager_ = opt_manager || fireauth.authStorage.Manager.getInstance();\n  /**\n   * @private {?fireauth.authStorage.Key} The current Auth user storage\n   *     identifier.\n   */\n  this.currentAuthUserKey_ = null;\n  /**\n   * @private {!goog.Promise} Storage operation serializer promise. This will\n   *     initialize the current persistence used and clean up any duplicate\n   *     states or temporary values (persistence for pending redirect).\n   *     Afterwards this is used to queue storage requests to make sure\n   *     storage operations are always synchronized and read/write events are\n   *     processed on the same storage.\n   */\n  this.onReady_ = this.initialize_();\n  // This internal listener will always run before the external ones.\n  // This is needed to queue processing of this first before any getCurrentUser\n  // is called from external listeners.\n  this.manager_.addListener(\n      fireauth.storage.UserManager.getAuthUserKey_(\n          fireauth.authStorage.Persistence.LOCAL),\n      this.appId_,\n      goog.bind(this.switchToLocalOnExternalEvent_, this));\n};\n\n\n/**\n * Switches to local storage on external storage event. This will happen when\n * state is specified as local in an external tab while it is none or session\n * in the current one. If a user signs in in an external tab, the current window\n * should detect this, clear existing storage and switch to local storage.\n * @private\n */\nfireauth.storage.UserManager.prototype.switchToLocalOnExternalEvent_ =\n    function() {\n  var self = this;\n  var localKey = fireauth.storage.UserManager.getAuthUserKey_(\n      fireauth.authStorage.Persistence.LOCAL);\n  // Wait for any pending operation to finish first.\n  // Block next read/write operation until persistence is transitioned to\n  // local.\n  this.waitForReady_(function() {\n    return goog.Promise.resolve().then(function() {\n      // If current persistence is not already local.\n      if (self.currentAuthUserKey_ &&\n          self.currentAuthUserKey_.persistent !=\n          fireauth.authStorage.Persistence.LOCAL) {\n        // Check if new current user is available in local storage.\n        return self.manager_.get(localKey, self.appId_);\n      }\n      return null;\n    }).then(function(response) {\n      // Sign in on an external tab.\n      if (response) {\n        // Remove any existing non-local user.\n        return self.removeAllExcept_(\n            fireauth.authStorage.Persistence.LOCAL).then(function() {\n              // Set persistence to local.\n              self.currentAuthUserKey_ = localKey;\n            });\n      }\n    });\n  });\n};\n\n\n/**\n * Removes all states stored in all supported persistence types excluding the\n * specified one.\n * @param {?fireauth.authStorage.Persistence} persistence The type of storage\n *     persistence to switch to.\n * @return {!goog.Promise} The promise that resolves when all stored values are\n *     removed for types of storage excluding specified persistence. This helps\n *     ensure there is always one type of persistence at any time.\n * @private\n */\nfireauth.storage.UserManager.prototype.removeAllExcept_ =\n    function(persistence) {\n  var promises = [];\n  // Queue all promises to remove current user in any other persistence type.\n  for (var key in fireauth.authStorage.Persistence) {\n    // Skip specified persistence.\n    if (fireauth.authStorage.Persistence[key] !== persistence) {\n      var storageKey = fireauth.storage.UserManager.getAuthUserKey_(\n          fireauth.authStorage.Persistence[key]);\n      promises.push(this.manager_.remove(\n          /** @type {!fireauth.authStorage.Key} */ (storageKey),\n          this.appId_));\n    }\n  }\n  // Clear persistence key (only useful for initial load upon returning from a\n  // a redirect sign-in operation).\n  promises.push(this.manager_.remove(\n      fireauth.storage.UserManager.PERSISTENCE_KEY_,\n      this.appId_));\n  return goog.Promise.all(promises);\n};\n\n\n/**\n * Initializes the current persistence state. This will check the 3 supported\n * types. The first one that is found will be the current persistence. All\n * others will be cleared. If none is found we check PERSISTENCE_KEY_ which\n * when specified means that the operation is returning from a\n * signInWithRedirect call. This persistence will be applied.\n * Otherwise the default local persistence is used.\n * @return {!goog.Promise} A promise that resolves when the current persistence\n *     is resolved.\n * @private\n */\nfireauth.storage.UserManager.prototype.initialize_ = function() {\n  var self = this;\n  // Local key.\n  var localKey = fireauth.storage.UserManager.getAuthUserKey_(\n      fireauth.authStorage.Persistence.LOCAL);\n  // Session key.\n  var sessionKey = fireauth.storage.UserManager.getAuthUserKey_(\n      fireauth.authStorage.Persistence.SESSION);\n  // In memory key. This is unlikely to contain anything on load.\n  var inMemoryKey = fireauth.storage.UserManager.getAuthUserKey_(\n      fireauth.authStorage.Persistence.NONE);\n  // Migrate any old currentUser from localStorage to indexedDB.\n  // This keeps any user signed in without the need for reauthentication and\n  // minimizes risks of dangling Auth states.\n  return this.manager_.migrateFromLocalStorage(\n      localKey, this.appId_).then(function() {\n    // Check if state is stored in session storage.\n    return self.manager_.get(sessionKey, self.appId_);\n  }).then(function(response) {\n    if (response) {\n      // Session storage is being used.\n      return sessionKey;\n    } else {\n      // Session storage is empty. Check in memory storage.\n      return self.manager_.get(inMemoryKey, self.appId_)\n          .then(function(response) {\n            if (response) {\n              // In memory storage being used.\n              return inMemoryKey;\n            } else {\n              // Check local storage.\n              return self.manager_.get(localKey, self.appId_)\n                  .then(function(response) {\n                    if (response) {\n                      // Local storage being used.\n                      return localKey;\n                    } else {\n                      // Nothing found in any supported storage.\n                      // Check current user persistence in storage.\n                      return self.manager_.get(\n                          fireauth.storage.UserManager.PERSISTENCE_KEY_,\n                          self.appId_).then(function(persistence) {\n                            if (persistence) {\n                              // Sign in with redirect operation, apply this\n                              // persistence to any current user.\n                              return fireauth.storage.UserManager\n                                  .getAuthUserKey_(persistence);\n                            } else {\n                              // No persistence found, use the default.\n                              return localKey;\n                            }\n                          });\n                    }\n                  });\n            }\n          });\n    }\n  }).then(function(currentKey) {\n    // Set current key according to the persistence detected.\n    self.currentAuthUserKey_ = currentKey;\n    // Make sure only one state available. Clean up everything else.\n    return self.removeAllExcept_(currentKey.persistent);\n  }).thenCatch(function(error) {\n    // If an error occurs in the process and no current key detected, set to\n    // persistence value to default.\n    if (!self.currentAuthUserKey_) {\n      self.currentAuthUserKey_ = localKey;\n    }\n  });\n};\n\n\n/**\n * @const @private {string} The Auth current user storage identifier name.\n */\nfireauth.storage.UserManager.AUTH_USER_KEY_NAME_ = 'authUser';\n\n\n/**\n * @const @private{!fireauth.authStorage.Key} The Auth user storage persistence\n *     identifier. This is needed to remember the previous persistence state for\n *     sign-in with redirect.\n */\nfireauth.storage.UserManager.PERSISTENCE_KEY_ = {\n  name: 'persistence',\n  persistent: fireauth.authStorage.Persistence.SESSION\n};\n\n\n/**\n * Returns the Auth user key corresponding to the persistence type provided.\n * @param {!fireauth.authStorage.Persistence} persistence The key for the\n *     specified type of persistence.\n * @return {!fireauth.authStorage.Key} The corresponding Auth user storage\n *     identifier.\n * @private\n */\nfireauth.storage.UserManager.getAuthUserKey_ = function(persistence) {\n  return {\n    name: fireauth.storage.UserManager.AUTH_USER_KEY_NAME_,\n    persistent: persistence\n  };\n};\n\n\n/**\n * Sets the persistence to the specified type.\n * If an existing user already is in storage, it copies that value to the new\n * storage and clears all the others.\n * @param {!fireauth.authStorage.Persistence} persistence The type of storage\n *     persistence to switch to.\n * @return {!goog.Promise} A promise that resolves when persistence change is\n *     applied.\n */\nfireauth.storage.UserManager.prototype.setPersistence = function(persistence) {\n  var currentUser = null;\n  var self = this;\n  // Validate the persistence type provided. This will throw a synchronous error\n  // if invalid.\n  fireauth.authStorage.validatePersistenceArgument(persistence);\n  // Wait for turn in queue.\n  return this.waitForReady_(function() {\n    // If persistence hasn't changed, do nothing.\n    if (persistence != self.currentAuthUserKey_.persistent) {\n      // Persistence changed. Copy from current storage to new one.\n      return self.manager_.get(\n        /** @type {!fireauth.authStorage.Key} */ (self.currentAuthUserKey_),\n        self.appId_).then(function(result) {\n        // Save current user.\n        currentUser = result;\n        // Clear from current storage.\n        return self.removeAllExcept_(persistence);\n      }).then(function() {\n        // Update persistence key to the new one.\n        self.currentAuthUserKey_ =\n            fireauth.storage.UserManager.getAuthUserKey_(persistence);\n        // Copy current storage type to the new one.\n        if (currentUser) {\n          return self.manager_.set(\n              /** @type {!fireauth.authStorage.Key} */ (\n                  self.currentAuthUserKey_),\n              currentUser,\n              self.appId_);\n        }\n      });\n    }\n    // No change in persistence type.\n    return goog.Promise.resolve();\n  });\n};\n\n\n/**\n * Saves the current persistence type so it can be retrieved after a page\n * redirect. This is relevant for signInWithRedirect.\n * @return {!goog.Promise} Promise that resolve when current persistence is\n *     saved.\n */\nfireauth.storage.UserManager.prototype.savePersistenceForRedirect = function() {\n  var self = this;\n  return this.waitForReady_(function() {\n    // Save persistence to survive redirect.\n    return self.manager_.set(\n        fireauth.storage.UserManager.PERSISTENCE_KEY_,\n        self.currentAuthUserKey_.persistent,\n        self.appId_);\n  });\n};\n\n\n/**\n * Stores the current Auth user for the provided application ID.\n * @param {!fireauth.AuthUser} currentUser The app current Auth user to save.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.UserManager.prototype.setCurrentUser = function(currentUser) {\n  var self = this;\n  // Wait for any pending persistence change to be resolved.\n  return this.waitForReady_(function() {\n    return self.manager_.set(\n        /** @type {!fireauth.authStorage.Key} */ (self.currentAuthUserKey_),\n        currentUser.toPlainObject(),\n        self.appId_);\n  });\n};\n\n\n/**\n * Removes the stored current user for provided app ID.\n * @return {!goog.Promise<void>} A promise that resolves on success.\n */\nfireauth.storage.UserManager.prototype.removeCurrentUser = function() {\n  var self = this;\n  // Wait for any pending persistence change to be resolved.\n  return this.waitForReady_(function() {\n    return self.manager_.remove(\n        /** @type {!fireauth.authStorage.Key} */ (self.currentAuthUserKey_),\n        self.appId_);\n  });\n};\n\n\n/**\n * @param {?string=} opt_authDomain The optional Auth domain to override if\n *     provided.\n * @return {!goog.Promise<?fireauth.AuthUser>} A promise that resolves with\n *     the stored current user for the provided app ID.\n */\nfireauth.storage.UserManager.prototype.getCurrentUser =\n    function(opt_authDomain) {\n  var self = this;\n  // Wait for any pending persistence change to be resolved.\n  return this.waitForReady_(function() {\n    return self.manager_.get(\n        /** @type {!fireauth.authStorage.Key} */ (self.currentAuthUserKey_),\n        self.appId_).then(function(response) {\n          // If potential user saved, override Auth domain if authDomain is\n          // provided.\n          // This is useful in cases where on one page the developer initializes\n          // the Auth instance without authDomain and signs in user using\n          // headless methods. On another page, Auth is initialized with\n          // authDomain for the purpose of linking with a popup. The loaded user\n          // (stored without the authDomain) must have this field updated with\n          // the current authDomain.\n          if (response && opt_authDomain) {\n            response['authDomain'] = opt_authDomain;\n          }\n          return fireauth.AuthUser.fromPlainObject(response || {});\n        });\n  });\n};\n\n\n/**\n * Serializes storage access operations especially since persistence\n * could be updated from one type to the other while read/write operations\n * occur.\n * @param {function():!goog.Promise<T>} cb The promise return callback to chain\n *     when pending operations are resolved.\n * @return {!goog.Promise<T>} The resulting promise that resolves when provided\n *     promise finally resolves.\n * @template T\n * @private\n */\nfireauth.storage.UserManager.prototype.waitForReady_ = function(cb) {\n  // Wait for any pending persistence change to be resolved before running\n  // storage related operation. Chain to onReady so next call will wait for\n  // this operation to resolve.\n  // While an error is unlikely, run callback even if it happens, otherwise\n  // no storage related event will be allowed to complete after an error.\n  this.onReady_ = this.onReady_.then(cb, cb);\n  return this.onReady_;\n};\n\n\n/**\n * Adds a listener to Auth current user change event for app ID provided.\n * @param {!function()} listener The listener to run on current user change\n *     event.\n */\nfireauth.storage.UserManager.prototype.addCurrentUserChangeListener =\n    function(listener) {\n  // When this is triggered, getCurrentUser is called, that will have to wait\n  // for switchToLocalOnExternalEvent_ to resolve which is ahead of it in the\n  // queue.\n  this.manager_.addListener(\n      fireauth.storage.UserManager.getAuthUserKey_(\n          fireauth.authStorage.Persistence.LOCAL),\n      this.appId_,\n      listener);\n};\n\n\n/**\n * Removes a listener to Auth current user change event for app ID provided.\n * @param {!function()} listener The listener to remove from current user change\n *     event changes.\n */\nfireauth.storage.UserManager.prototype.removeCurrentUserChangeListener =\n    function(listener) {\n  this.manager_.removeListener(\n      fireauth.storage.UserManager.getAuthUserKey_(\n          fireauth.authStorage.Persistence.LOCAL),\n      this.appId_,\n      listener);\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview The headless Auth class used for authenticating Firebase users.\n */\n\ngoog.provide('fireauth.Auth');\n\ngoog.require('fireauth.ActionCodeInfo');\ngoog.require('fireauth.ActionCodeSettings');\ngoog.require('fireauth.AdditionalUserInfo');\ngoog.require('fireauth.AuthCredential');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthEvent');\ngoog.require('fireauth.AuthEventHandler');\ngoog.require('fireauth.AuthEventManager');\ngoog.require('fireauth.AuthProvider');\ngoog.require('fireauth.AuthSettings');\ngoog.require('fireauth.AuthUser');\ngoog.require('fireauth.ConfirmationResult');\ngoog.require('fireauth.EmailAuthProvider');\ngoog.require('fireauth.RpcHandler');\ngoog.require('fireauth.UserEventType');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.deprecation');\ngoog.require('fireauth.idp');\ngoog.require('fireauth.iframeclient.IfcHandler');\ngoog.require('fireauth.object');\ngoog.require('fireauth.storage.RedirectUserManager');\ngoog.require('fireauth.storage.UserManager');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\ngoog.require('goog.events');\ngoog.require('goog.events.Event');\ngoog.require('goog.events.EventTarget');\ngoog.require('goog.object');\n\n\n\n/**\n * Creates the Firebase Auth corresponding for the App provided.\n *\n * @param {!firebase.app.App} app The corresponding Firebase App.\n * @constructor\n * @implements {fireauth.AuthEventHandler}\n * @implements {firebase.Service}\n * @extends {goog.events.EventTarget}\n */\nfireauth.Auth = function(app) {\n  /** @private {boolean} Whether this instance is deleted. */\n  this.deleted_ = false;\n  /** The Auth instance's settings object. */\n  fireauth.object.setReadonlyProperty(\n      this, 'settings', new fireauth.AuthSettings());\n  /** Auth's corresponding App. */\n  fireauth.object.setReadonlyProperty(this, 'app', app);\n  // Initialize RPC handler.\n  // API key is required for web client RPC calls.\n  if (this.app_().options && this.app_().options['apiKey']) {\n    var clientFullVersion = firebase.SDK_VERSION ?\n        fireauth.util.getClientVersion(\n            fireauth.util.ClientImplementation.JSCORE, firebase.SDK_VERSION) :\n        null;\n    this.rpcHandler_ = new fireauth.RpcHandler(\n        this.app_().options && this.app_().options['apiKey'],\n        // Get the client Auth endpoint used.\n        fireauth.constants.getEndpointConfig(fireauth.constants.clientEndpoint),\n        clientFullVersion);\n  } else {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_API_KEY);\n  }\n  /** @private {!Array<!goog.Promise<*, *>|!goog.Promise<void>>} List of\n   *      pending promises. */\n  this.pendingPromises_ = [];\n  /** @private {!Array<!function(?string)>} Auth token listeners. */\n  this.authListeners_ = [];\n  /** @private {!Array<!function(?string)>} User change listeners. */\n  this.userChangeListeners_ = [];\n  /**\n   * @private {!firebase.Subscribe} The subscribe function to the Auth ID token\n   *     change observer. This will trigger on ID token changes, including\n   *     token refresh on the same user.\n   */\n  this.onIdTokenChanged_ = firebase.INTERNAL.createSubscribe(\n      goog.bind(this.initIdTokenChangeObserver_, this));\n  /**\n   * @private {?string|undefined} The UID of the user that last triggered the\n   *     user state change listener.\n   */\n  this.userStateChangeUid_ = undefined;\n  /**\n   * @private {!firebase.Subscribe} The subscribe function to the user state\n   *     change observer.\n   */\n  this.onUserStateChanged_ = firebase.INTERNAL.createSubscribe(\n      goog.bind(this.initUserStateObserver_, this));\n  // Set currentUser to null.\n  this.setCurrentUser_(null);\n  /**\n   * @private {!fireauth.storage.UserManager} The Auth user storage\n   *     manager instance.\n   */\n  this.userStorageManager_ =\n      new fireauth.storage.UserManager(this.getStorageKey());\n  /**\n   * @private {!fireauth.storage.RedirectUserManager} The redirect user\n   *     storagemanager instance.\n   */\n  this.redirectUserStorageManager_ =\n      new fireauth.storage.RedirectUserManager(this.getStorageKey());\n  /**\n   * @private {!goog.Promise<undefined>} Promise that resolves when initial\n   *     state is loaded from storage.\n   */\n  this.authStateLoaded_ = this.registerPendingPromise_(this.initAuthState_());\n  /**\n   * @private {!goog.Promise<undefined>} Promise that resolves when state and\n   *     redirect result is ready, after which sign in and sign out operations\n   *     are safe to execute.\n   */\n  this.redirectStateIsReady_ = this.registerPendingPromise_(\n      this.initAuthRedirectState_());\n  /** @private {boolean} Whether initial state has already been resolved. */\n  this.isStateResolved_ = false;\n  /**\n   * @private {!function()} The syncAuthChanges function with context set to\n   *     auth instance.\n   */\n  this.getSyncAuthUserChanges_ = goog.bind(this.syncAuthUserChanges_, this);\n  /** @private {!function(!fireauth.AuthUser):!goog.Promise} The handler for\n   *      user state changes. */\n  this.userStateChangeListener_ =\n      goog.bind(this.handleUserStateChange_, this);\n  /** @private {!function(!Object)} The handler for user token changes. */\n  this.userTokenChangeListener_ =\n      goog.bind(this.handleUserTokenChange_, this);\n  /** @private {!function(!Object)} The handler for user deletion. */\n  this.userDeleteListener_ = goog.bind(this.handleUserDelete_, this);\n  /** @private {!function(!Object)} The handler for user invalidation. */\n  this.userInvalidatedListener_ = goog.bind(this.handleUserInvalidated_, this);\n  /**\n   * @private {?fireauth.AuthEventManager} The Auth event manager instance.\n   */\n  this.authEventManager_ = null;\n  // TODO: find better way to enable or disable auth event manager.\n  if (fireauth.AuthEventManager.ENABLED) {\n    // Initialize Auth event manager to handle popup and redirect operations.\n    this.initAuthEventManager_();\n  }\n\n  // Export INTERNAL namespace.\n  this.INTERNAL = {};\n  this.INTERNAL['delete'] = goog.bind(this.delete, this);\n  this.INTERNAL['logFramework'] = goog.bind(this.logFramework, this);\n  /**\n   * @private {number} The number of Firebase services subscribed to Auth\n   *     changes.\n   */\n  this.firebaseServices_ = 0;\n  // Add call to superclass constructor.\n  fireauth.Auth.base(this, 'constructor');\n  // Initialize readable/writable Auth properties.\n  this.initializeReadableWritableProps_();\n  /**\n   * @private {!Array<string>} List of Firebase frameworks/libraries used. This\n   *     is currently only used to log FirebaseUI.\n   */\n  this.frameworks_ = [];\n};\ngoog.inherits(fireauth.Auth, goog.events.EventTarget);\n\n\n/**\n * Language code change custom event.\n * @param {?string} languageCode The new language code.\n * @constructor\n * @extends {goog.events.Event}\n */\nfireauth.Auth.LanguageCodeChangeEvent = function(languageCode) {\n  goog.events.Event.call(\n      this, fireauth.constants.AuthEventType.LANGUAGE_CODE_CHANGED);\n  this.languageCode = languageCode;\n};\ngoog.inherits(fireauth.Auth.LanguageCodeChangeEvent, goog.events.Event);\n\n\n/**\n * Framework change custom event.\n * @param {!Array<string>} frameworks The new frameworks array.\n * @constructor\n * @extends {goog.events.Event}\n */\nfireauth.Auth.FrameworkChangeEvent = function(frameworks) {\n  goog.events.Event.call(\n      this, fireauth.constants.AuthEventType.FRAMEWORK_CHANGED);\n  this.frameworks = frameworks;\n};\ngoog.inherits(fireauth.Auth.FrameworkChangeEvent, goog.events.Event);\n\n\n/**\n * Changes the Auth state persistence to the specified one.\n * @param {!fireauth.authStorage.Persistence} persistence The Auth state\n *     persistence mechanism.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.setPersistence = function(persistence) {\n  // TODO: fix auth.delete() behavior and how this affects persistence\n  // change after deletion.\n  // Throw an error if already destroyed.\n  // Set current persistence.\n  var p = this.userStorageManager_.setPersistence(persistence);\n  return /** @type {!goog.Promise<void>} */ (this.registerPendingPromise_(p));\n};\n\n\n/**\n * Get rid of Closure warning - the property is adding in the constructor.\n * @type {!firebase.app.App}\n */\nfireauth.Auth.prototype.app;\n\n\n/**\n * Sets the language code.\n * @param {?string} languageCode\n */\nfireauth.Auth.prototype.setLanguageCode = function(languageCode) {\n  // Don't do anything if no change detected.\n  if (this.languageCode_ !== languageCode && !this.deleted_) {\n    this.languageCode_ = languageCode;\n    // Update custom Firebase locale field.\n    this.rpcHandler_.updateCustomLocaleHeader(this.languageCode_);\n    // Notify external language code change listeners.\n    this.notifyLanguageCodeListeners_();\n  }\n};\n\n\n/**\n * Returns the current auth instance's language code if available.\n * @return {?string}\n */\nfireauth.Auth.prototype.getLanguageCode = function() {\n  return this.languageCode_;\n};\n\n\n/**\n * Sets the current language to the default device/browser preference.\n */\nfireauth.Auth.prototype.useDeviceLanguage = function() {\n  this.setLanguageCode(fireauth.util.getUserLanguage());\n};\n\n\n/**\n * @param {string} frameworkId The framework identifier.\n */\nfireauth.Auth.prototype.logFramework = function(frameworkId) {\n  // Theoretically multiple frameworks could be used\n  // (angularfire and FirebaseUI). Once a framework is used, it is not going\n  // to be unused, so no point adding a method to remove the framework ID.\n  this.frameworks_.push(frameworkId);\n  // Update the client version in RPC handler with the new frameworks.\n  this.rpcHandler_.updateClientVersion(firebase.SDK_VERSION ?\n        fireauth.util.getClientVersion(\n            fireauth.util.ClientImplementation.JSCORE, firebase.SDK_VERSION,\n            this.frameworks_) :\n        null);\n  this.dispatchEvent(new fireauth.Auth.FrameworkChangeEvent(\n      this.frameworks_));\n};\n\n\n/** @return {!Array<string>} The current Firebase frameworks. */\nfireauth.Auth.prototype.getFramework = function() {\n  return goog.array.clone(this.frameworks_);\n};\n\n\n/**\n * Updates the framework list on the provided user and configures the user to\n * listen to the Auth instance for any framework ID changes.\n * @param {!fireauth.AuthUser} user The user to whose framework list needs to be\n *     updated.\n * @private\n */\nfireauth.Auth.prototype.setUserFramework_ = function(user) {\n  // Sets the framework ID on the user.\n  user.setFramework(this.frameworks_);\n  // Sets current Auth instance as framework list change dispatcher on the user.\n  user.setFrameworkChangeDispatcher(this);\n};\n\n\n/**\n * Sets the tenant ID.\n * @param {?string} tenantId The tenant ID of the tenant project if available.\n */\nfireauth.Auth.prototype.setTenantId = function(tenantId) {\n  // Don't do anything if no change detected.\n  if (this.tenantId_ !== tenantId && !this.deleted_) {\n    this.tenantId_ = tenantId;\n    this.rpcHandler_.updateTenantId(this.tenantId_);\n  }\n};\n\n\n/**\n * Returns the current Auth instance's tenant ID.\n * @return {?string}\n */\nfireauth.Auth.prototype.getTenantId = function() {\n  return this.tenantId_;\n};\n\n\n/**\n * Initializes readable/writable properties on Auth.\n * @suppress {invalidCasts}\n * @private\n */\nfireauth.Auth.prototype.initializeReadableWritableProps_ = function() {\n  Object.defineProperty(/** @type {!Object} */ (this), 'lc', {\n    /**\n     * @this {!Object}\n     * @return {?string} The current language code.\n     */\n    get: function() {\n      return this.getLanguageCode();\n    },\n    /**\n     * @this {!Object}\n     * @param {string} value The new language code.\n     */\n    set: function(value) {\n      this.setLanguageCode(value);\n    },\n    enumerable: false\n  });\n  // Initialize to null.\n  /** @private {?string} The current Auth instance's language code. */\n  this.languageCode_ = null;\n\n  // Initialize tenant ID.\n  Object.defineProperty(/** @type {!Object} */ (this), 'ti', {\n    /**\n     * @this {!Object}\n     * @return {?string} The current tenant ID.\n     */\n    get: function() {\n      return this.getTenantId();\n    },\n    /**\n     * @this {!Object}\n     * @param {?string} value The new tenant ID.\n     */\n    set: function(value) {\n      this.setTenantId(value);\n    },\n    enumerable: false\n  });\n  // Initialize to null.\n  /** @private {?string} The current Auth instance's tenant ID. */\n  this.tenantId_ = null;\n};\n\n\n/**\n * Notifies all external listeners of the language code change.\n * @private\n */\nfireauth.Auth.prototype.notifyLanguageCodeListeners_ = function() {\n  // Notify external listeners on the language code change.\n  this.dispatchEvent(new fireauth.Auth.LanguageCodeChangeEvent(\n      this.getLanguageCode()));\n};\n\n\n\n\n\n/**\n * @return {!Object} The object representation of the Auth instance.\n * @override\n */\nfireauth.Auth.prototype.toJSON = function() {\n  // Return the plain object representation in case JSON.stringify is called on\n  // an Auth instance.\n  return {\n    'apiKey': this.app_().options['apiKey'],\n    'authDomain': this.app_().options['authDomain'],\n    'appName': this.app_().name,\n    'currentUser': this.currentUser_() && this.currentUser_().toPlainObject()\n  };\n};\n\n\n/**\n * Returns the Auth event manager promise.\n * @return {!goog.Promise<!fireauth.AuthEventManager>}\n * @private\n */\nfireauth.Auth.prototype.getAuthEventManager_ = function() {\n  // Either return cached Auth event manager promise provider if available or a\n  // promise that rejects with missing Auth domain error.\n  return this.eventManagerProviderPromise_ ||\n      goog.Promise.reject(\n          new fireauth.AuthError(fireauth.authenum.Error.MISSING_AUTH_DOMAIN));\n};\n\n\n/**\n * Initializes the Auth event manager when state is ready.\n * @private\n */\nfireauth.Auth.prototype.initAuthEventManager_ = function() {\n  // Initialize Auth event manager on initState.\n  var self = this;\n  var authDomain = this.app_().options['authDomain'];\n  var apiKey = this.app_().options['apiKey'];\n  // Make sure environment also supports popup and redirect.\n  if (authDomain && fireauth.util.isPopupRedirectSupported()) {\n    // Auth domain is required for Auth event manager to resolve.\n    // Auth state has to be loaded first. One reason is to process link events.\n    this.eventManagerProviderPromise_ = this.authStateLoaded_.then(function() {\n      if (self.deleted_) {\n        return;\n      }\n      // By this time currentUser should be ready if available and will be able\n      // to resolve linkWithRedirect if detected.\n      self.authEventManager_ = fireauth.AuthEventManager.getManager(\n          authDomain, apiKey, self.app_().name);\n      // Subscribe Auth instance.\n      self.authEventManager_.subscribe(self);\n      // Subscribe current user by enabling popup and redirect on that user.\n      if (self.currentUser_()) {\n        self.currentUser_().enablePopupRedirect();\n      }\n      // If a redirect user is present, subscribe to popup and redirect events.\n      // In case current user was not available and the developer called link\n      // with redirect on a signed out user, this will work and the linked\n      // logged out user will be returned in getRedirectResult.\n      // current user and redirect user are the same (was already logged in),\n      // currentUser will have priority as it is subscribed before redirect\n      // user. This change will also allow further popup and redirect events on\n      // the redirect user going forward.\n      if (self.redirectUser_) {\n        self.redirectUser_.enablePopupRedirect();\n        // Set the user language for the redirect user.\n        self.setUserLanguage_(\n            /** @type {!fireauth.AuthUser} */ (self.redirectUser_));\n        // Set the user Firebase frameworks for the redirect user.\n        self.setUserFramework_(\n            /** @type {!fireauth.AuthUser} */ (self.redirectUser_));\n        // Reference to redirect user no longer needed.\n        self.redirectUser_ = null;\n      }\n      return self.authEventManager_;\n    });\n  }\n};\n\n\n/**\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?string=} opt_eventId The event ID.\n * @return {boolean} Whether the auth event handler can handler the provided\n *     event.\n * @override\n */\nfireauth.Auth.prototype.canHandleAuthEvent = function(mode, opt_eventId) {\n  // Only sign in events are handled.\n  switch (mode) {\n    // Accept all general sign in with redirect and unknowns.\n    // Migrating redirect events to use session storage will prevent this event\n    // from leaking to other tabs.\n    case fireauth.AuthEvent.Type.UNKNOWN:\n    case fireauth.AuthEvent.Type.SIGN_IN_VIA_REDIRECT:\n      return true;\n    case fireauth.AuthEvent.Type. SIGN_IN_VIA_POPUP:\n      // Pending sign in with popup event must match the stored popup event ID.\n      return this.popupEventId_ == opt_eventId &&\n          !!this.pendingPopupResolvePromise_;\n    default:\n      return false;\n  }\n};\n\n\n/**\n * Completes the pending popup operation. If error is not null, rejects with the\n * error. Otherwise, it resolves with the popup redirect result.\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?fireauth.AuthEventManager.Result} popupRedirectResult The result\n *     to resolve with when no error supplied.\n * @param {?fireauth.AuthError} error When supplied, the promise will reject.\n * @param {?string=} opt_eventId The event ID.\n * @override\n */\nfireauth.Auth.prototype.resolvePendingPopupEvent =\n    function(mode, popupRedirectResult, error, opt_eventId) {\n  // Only handles popup events of type sign in and which match popup event ID.\n  if (mode != fireauth.AuthEvent.Type.SIGN_IN_VIA_POPUP ||\n      this.popupEventId_ != opt_eventId) {\n    return;\n  }\n  if (error && this.pendingPopupRejectPromise_) {\n    // Reject with error for supplied mode.\n    this.pendingPopupRejectPromise_(error);\n  } else if (popupRedirectResult &&\n             !error &&\n             this.pendingPopupResolvePromise_) {\n    // Resolve with result for supplied mode.\n    this.pendingPopupResolvePromise_(popupRedirectResult);\n  }\n  // Now that event is resolved, delete popup timeout promise.\n  if (this.popupTimeoutPromise_) {\n    this.popupTimeoutPromise_.cancel();\n    this.popupTimeoutPromise_ = null;\n  }\n  // Delete pending promises.\n  delete this.pendingPopupResolvePromise_;\n  delete this.pendingPopupRejectPromise_;\n};\n\n\n/**\n * Returns the handler's appropriate popup and redirect sign in operation\n * finisher.\n * @param {!fireauth.AuthEvent.Type} mode The Auth type mode.\n * @param {?string=} opt_eventId The optional event ID.\n * @return {?function(string, string, ?string,\n *     ?string=):!goog.Promise<!fireauth.AuthEventManager.Result>}\n * @override\n */\nfireauth.Auth.prototype.getAuthEventHandlerFinisher =\n    function(mode, opt_eventId) {\n  // Sign in events will be completed by finishPopupAndRedirectSignIn.\n  if (mode == fireauth.AuthEvent.Type.SIGN_IN_VIA_REDIRECT) {\n    return goog.bind(this.finishPopupAndRedirectSignIn, this);\n  } else if (mode == fireauth.AuthEvent.Type.SIGN_IN_VIA_POPUP &&\n             this.popupEventId_ == opt_eventId &&\n             this.pendingPopupResolvePromise_) {\n    return goog.bind(this.finishPopupAndRedirectSignIn, this);\n  }\n  return null;\n};\n\n\n/**\n * Finishes the popup and redirect sign in operations.\n * @param {string} requestUri The callback url with the oauth response.\n * @param {string} sessionId The session id used to generate the authUri.\n * @param {?string} tenantId The tenant ID.\n * @param {?string=} opt_postBody The optional POST body content.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.finishPopupAndRedirectSignIn =\n    function(requestUri, sessionId, tenantId, opt_postBody) {\n  var self = this;\n  // Verify assertion request.\n  var request = {\n    'requestUri': requestUri,\n    'postBody': opt_postBody,\n    'sessionId': sessionId,\n    // Even if tenant ID is null, still pass it to RPC handler explicitly so\n    // that it won't be overridden by RPC handler's tenant ID.\n    'tenantId': tenantId\n  };\n  // Now that popup has responded, delete popup timeout promise.\n  if (this.popupTimeoutPromise_) {\n    this.popupTimeoutPromise_.cancel();\n    this.popupTimeoutPromise_ = null;\n  }\n  // This routine could be run before init state, make sure it waits for that to\n  // complete.\n  var credential = null;\n  var additionalUserInfo = null;\n  var idTokenResolver = self.rpcHandler_.verifyAssertion(request)\n      .then(function(response) {\n        // Get Auth credential from verify assert request and save it.\n        credential = fireauth.AuthProvider.getCredentialFromResponse(response);\n        // Get additional IdP data if available in the response.\n        additionalUserInfo = fireauth.AdditionalUserInfo.fromPlainObject(\n            response);\n        return response;\n      });\n  // When state is ready, run verify assertion request.\n  // This will only run either after initial and redirect state is ready for\n  // popups or after initial state is ready for redirect resolution.\n  var p = self.authStateLoaded_.then(function() {\n    return idTokenResolver;\n  }).then(function(idTokenResponse) {\n    // Use ID token response to sign in the Auth user.\n    return self.signInWithIdTokenResponse(idTokenResponse);\n  }).then(function() {\n    // On sign in success, construct redirect and popup result and return a\n    // readonly copy of it.\n    return fireauth.object.makeReadonlyCopy({\n      'user': self.currentUser_(),\n      'credential': credential,\n      'additionalUserInfo': additionalUserInfo,\n      // Sign in operation type.\n      'operationType': fireauth.constants.OperationType.SIGN_IN\n    });\n  });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * @return {string} The generated event ID used to identify a popup event.\n * @private\n */\nfireauth.Auth.prototype.generateEventId_ = function() {\n  return fireauth.util.generateEventId();\n};\n\n\n/**\n * Signs in to Auth provider via popup.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInWithPopup = function(provider) {\n  // Check if popup and redirect are supported in this environment.\n  if (!fireauth.util.isPopupRedirectSupported()) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  var mode = fireauth.AuthEvent.Type.SIGN_IN_VIA_POPUP;\n  var self = this;\n  // Popup the window immediately to make sure the browser associates the\n  // popup with the click that triggered it.\n\n  // Get provider settings.\n  var settings = fireauth.idp.getIdpSettings(provider['providerId']);\n  // There could multiple sign in with popup events in different windows.\n  // We need to match the correct popup to the correct pending promise.\n  var eventId = this.generateEventId_();\n  // If incapable of redirecting popup from opener, popup destination URL\n  // directly. This could also happen in a sandboxed iframe.\n  var oauthHelperWidgetUrl = null;\n  if ((!fireauth.util.runsInBackground() || fireauth.util.isIframe()) &&\n      this.app_().options['authDomain'] &&\n      provider['isOAuthProvider']) {\n    oauthHelperWidgetUrl =\n        fireauth.iframeclient.IfcHandler.getOAuthHelperWidgetUrl(\n            this.app_().options['authDomain'],\n            this.app_().options['apiKey'],\n            this.app_().name,\n            mode,\n            provider,\n            null,\n            eventId,\n            firebase.SDK_VERSION || null,\n            null,\n            null,\n            this.getTenantId());\n  }\n  // The popup must have a name, otherwise when successive popups are triggered\n  // they will all render in the same instance and none will succeed since the\n  // popup cancel of first window will close the shared popup window instance.\n  var popupWin =\n      fireauth.util.popup(\n          oauthHelperWidgetUrl,\n          fireauth.util.generateRandomString(),\n          settings && settings.popupWidth,\n          settings && settings.popupHeight);\n  // Auth event manager must be available for popup sign in to be possible.\n  var p = this.getAuthEventManager_().then(function(manager) {\n    // Process popup request tagging it with newly created event ID.\n    return manager.processPopup(\n        popupWin, mode, provider, eventId, !!oauthHelperWidgetUrl,\n        self.getTenantId());\n  }).then(function() {\n    return new goog.Promise(function(resolve, reject) {\n      // Expire other pending promises if still available..\n      self.resolvePendingPopupEvent(\n          mode,\n          null,\n          new fireauth.AuthError(fireauth.authenum.Error.EXPIRED_POPUP_REQUEST),\n          // Existing pending popup event ID.\n          self.popupEventId_);\n      // Save current pending promises.\n      self.pendingPopupResolvePromise_ = resolve;\n      self.pendingPopupRejectPromise_ = reject;\n      // Overwrite popup event ID with new one corresponding to popup.\n      self.popupEventId_ = eventId;\n      // Keep track of timeout promise to cancel it on promise resolution before\n      // it times out.\n      self.popupTimeoutPromise_ =\n          self.authEventManager_.startPopupTimeout(\n              self, mode, /** @type {!Window} */ (popupWin), eventId);\n    });\n  }).then(function(result) {\n    // On resolution, close popup if still opened and pass result through.\n    if (popupWin) {\n      fireauth.util.closeWindow(popupWin);\n    }\n    if (result) {\n      return fireauth.object.makeReadonlyCopy(result);\n    }\n    return null;\n  }).thenCatch(function(error) {\n    if (popupWin) {\n      fireauth.util.closeWindow(popupWin);\n    }\n    throw error;\n  });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * Signs in to Auth provider via redirect.\n * @param {!fireauth.AuthProvider} provider The Auth provider to sign in with.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.signInWithRedirect = function(provider) {\n  // Check if popup and redirect are supported in this environment.\n  if (!fireauth.util.isPopupRedirectSupported()) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  var self = this;\n  var mode = fireauth.AuthEvent.Type.SIGN_IN_VIA_REDIRECT;\n  // Auth event manager must be available for sign in via redirect to be\n  // possible.\n  var p = this.getAuthEventManager_().then(function(manager) {\n    // Remember current persistence to apply it on the next page.\n    // This is the only time the state is passed to the next page (when user is\n    // not already logged in).\n    // This is not needed for link and reauthenticate as the user is already\n    // stored with specified persistence.\n    return self.userStorageManager_.savePersistenceForRedirect();\n  }).then(function() {\n    // Process redirect operation.\n    return self.authEventManager_.processRedirect(\n        mode, provider, undefined, self.getTenantId());\n  });\n  return /** @type {!goog.Promise<void>} */ (this.registerPendingPromise_(p));\n};\n\n\n/**\n * Returns the redirect result. If coming back from a successful redirect sign\n * in, will resolve to the signed in user. If coming back from an unsuccessful\n * redirect sign, will reject with the proper error. If no redirect operation\n * called, resolves with null.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n * @private\n */\nfireauth.Auth.prototype.getRedirectResultWithoutClearing_ = function() {\n  // Check if popup and redirect are supported in this environment.\n  if (!fireauth.util.isPopupRedirectSupported()) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED));\n  }\n  var self = this;\n  // Auth event manager must be available for get redirect result to be\n  // possible.\n  var p = this.getAuthEventManager_().then(function(manager) {\n    // Return redirect result when resolved.\n    return self.authEventManager_.getRedirectResult();\n  }).then(function(result) {\n    if (result) {\n      return fireauth.object.makeReadonlyCopy(result);\n    }\n    return null;\n  });\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * In addition to returning the redirect result as in\n * `getRedirectResultWithoutClearing_`, this will also clear the cached\n * redirect result for security reasons.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.getRedirectResult = function() {\n  return this.getRedirectResultWithoutClearing_()\n        .then((result) => {\n          if (this.authEventManager_) {\n            this.authEventManager_.clearRedirectResult();\n          }\n          return result;\n        })\n        .thenCatch((error) => {\n          if (this.authEventManager_) {\n            this.authEventManager_.clearRedirectResult();\n          }\n          throw error;\n        });\n};\n\n\n/**\n * Asynchronously sets the provided user as currentUser on the current Auth\n * instance.\n * @param {?fireauth.AuthUser} user The user to be copied to Auth instance.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.updateCurrentUser = function(user) {\n  if (!user) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.NULL_USER));\n  }\n  if (this.tenantId_ != user['tenantId']) {\n    return goog.Promise.reject(new fireauth.AuthError(\n        fireauth.authenum.Error.TENANT_ID_MISMATCH));\n  }\n  var self = this;\n  var options = {};\n  options['apiKey'] = this.app_().options['apiKey'];\n  options['authDomain'] = this.app_().options['authDomain'];\n  options['appName'] = this.app_().name;\n  var newUser = fireauth.AuthUser.copyUser(user, options,\n      self.redirectUserStorageManager_, self.getFramework());\n  return this.registerPendingPromise_(\n      this.redirectStateIsReady_.then(function() {\n        if (self.app_().options['apiKey'] != user.getApiKey()) {\n          // Throws auth/invalid-user-token if user doesn't belong to app.\n          // Throws auth/user-token-expired if token expires.\n          return newUser.reload();\n        }\n      }).then(function() {\n        if (self.currentUser_() && user['uid'] == self.currentUser_()['uid']) {\n          // Same user signed in. Update user data and notify Auth listeners.\n          // No need to resubscribe to user events.\n          // TODO: Check if the user to copy is older than current user and skip\n          // the copy logic in that case.\n          self.currentUser_().copy(user);\n          return self.handleUserStateChange_(user);\n        }\n        self.setCurrentUser_(newUser);\n        // Enable popup and redirect events.\n        newUser.enablePopupRedirect();\n        // Save user changes.\n        return self.handleUserStateChange_(newUser);\n      }).then(function(user) {\n        self.notifyAuthListeners_();\n      }));\n};\n\n\n/**\n * Completes the headless sign in with the server response containing the STS\n * access and refresh tokens, and sets the Auth user as current user while\n * setting all listeners to it and saving it to storage.\n * @param {!Object<string, string>} idTokenResponse The ID token response from\n *     the server.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.signInWithIdTokenResponse =\n    function(idTokenResponse) {\n  var self = this;\n  var options = {};\n  options['apiKey'] = self.app_().options['apiKey'];\n  options['authDomain'] = self.app_().options['authDomain'];\n  options['appName'] = self.app_().name;\n  // Wait for state to be ready.\n  // This is used internally and is also used for redirect sign in so there is\n  // no need for waiting for redirect result to resolve since redirect result\n  // depends on it.\n  return this.authStateLoaded_.then(function() {\n    // Initialize an Auth user using the provided ID token response.\n    return fireauth.AuthUser.initializeFromIdTokenResponse(\n        options,\n        idTokenResponse,\n        /** @type {!fireauth.storage.RedirectUserManager} */ (\n            self.redirectUserStorageManager_),\n        // Pass frameworks so they are logged in getAccountInfo while populating\n        // the user info.\n        self.getFramework());\n  }).then(function(user) {\n    // Check if the same user is already signed in.\n    if (self.currentUser_() &&\n        user['uid'] == self.currentUser_()['uid']) {\n      // Same user signed in. Update user data and notify Auth listeners.\n      // No need to resubscribe to user events.\n      self.currentUser_().copy(user);\n      return self.handleUserStateChange_(user);\n    }\n    // New user.\n    // Set current user and attach all listeners to it.\n    self.setCurrentUser_(user);\n    // Enable popup and redirect events.\n    user.enablePopupRedirect();\n    // Save user changes.\n    return self.handleUserStateChange_(user);\n  }).then(function() {\n    // Notify external Auth listeners only when state is ready.\n    self.notifyAuthListeners_();\n  });\n};\n\n\n/**\n * Updates the current auth user and attaches event listeners to changes on it.\n * Also removes all event listeners from previously signed in user.\n * @param {?fireauth.AuthUser} user The current user instance.\n * @private\n */\nfireauth.Auth.prototype.setCurrentUser_ = function(user) {\n  // Must be called first before updating currentUser reference.\n  this.attachEventListeners_(user);\n  // Update currentUser property.\n  fireauth.object.setReadonlyProperty(this, 'currentUser', user);\n  if (user) {\n    // If a user is available, set the language code on it and set current Auth\n    // instance as language code change dispatcher.\n    this.setUserLanguage_(user);\n    // Set the current frameworks used on the user and set current Auth instance\n    // as the framework change dispatcher.\n    this.setUserFramework_(user);\n  }\n};\n\n\n/**\n * Signs out the current user while deleting the Auth user from storage and\n * removing all listeners from it.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.signOut = function() {\n  var self = this;\n  // Wait for final state to be ready first, otherwise a signed out user could\n  // come back to life.\n  var p = this.redirectStateIsReady_.then(function() {\n    // Clear any cached redirect result on sign out, even if user is already\n    // signed out. For example, sign in could fail due to account conflict\n    // error, the error in redirect result should still be cleared. There is\n    // also the use case where you keep a reference to a signed out user and\n    // call signedOutUser.linkWithRedirect(provider). Even though the user is\n    // signed out, getRedirectResult() will resolve with the modified signed\n    // out user. This could also throw an error\n    // (provider already linked, etc).\n    if (self.authEventManager_) {\n      self.authEventManager_.clearRedirectResult();\n    }\n    // Ignore if already signed out.\n    if (!self.currentUser_()) {\n      return goog.Promise.resolve();\n    }\n    // Detach all event listeners.\n    // Set current user to null.\n    self.setCurrentUser_(null);\n    // Remove current user from storage\n    return /** @type {!fireauth.storage.UserManager} */ (\n        self.userStorageManager_).removeCurrentUser()\n        .then(function() {\n          // Notify external Auth listeners of this Auth change event.\n          self.notifyAuthListeners_();\n        });\n  });\n  return /** @type {!goog.Promise<void>} */ (this.registerPendingPromise_(p));\n};\n\n\n/**\n * @return {!goog.Promise} A promise that resolved when any stored redirect user\n *     is loaded and removed from session storage and then stored locally.\n * @private\n */\nfireauth.Auth.prototype.initRedirectUser_ = function() {\n  var self = this;\n  var authDomain = this.app_().options['authDomain'];\n  // Get any saved redirect user and delete from session storage.\n  // Override user's authDomain with app's authDomain if there is a mismatch.\n  var p = /** @type {!fireauth.storage.RedirectUserManager} */ (\n      this.redirectUserStorageManager_).getRedirectUser(authDomain)\n          .then(function(user) {\n            // Save redirect user.\n            self.redirectUser_ = user;\n            if (user) {\n              // Set redirect storage manager on user.\n              user.setRedirectStorageManager(\n                  /** @type {!fireauth.storage.RedirectUserManager} */ (\n                      self.redirectUserStorageManager_));\n            }\n            // Delete redirect user.\n            return /** @type {!fireauth.storage.RedirectUserManager} */ (\n                self.redirectUserStorageManager_).removeRedirectUser();\n          });\n  return /** @type {!goog.Promise<undefined>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * Loads the initial Auth state for current application from web storage and\n * initializes Auth user accordingly to reflect that state. This routine does\n * not wait for any pending redirect result to be resolved.\n * @return {!goog.Promise<undefined>} Promise that resolves when state is ready,\n *     loaded from storage.\n * @private\n */\nfireauth.Auth.prototype.initAuthState_ = function() {\n  // Load current user from storage.\n  var self = this;\n  var authDomain = this.app_().options['authDomain'];\n  // Get any saved redirected user first.\n  var p = this.initRedirectUser_().then(function() {\n    // Override user's authDomain with app's authDomain if there is a mismatch.\n    return /** @type {!fireauth.storage.UserManager} */ (\n        self.userStorageManager_).getCurrentUser(authDomain);\n  }).then(function(user) {\n    // Logged in user.\n    if (user) {\n      // Set redirect storage manager on user.\n      user.setRedirectStorageManager(\n          /** @type {!fireauth.storage.RedirectUserManager} */ (\n              self.redirectUserStorageManager_));\n      // If the current user is undergoing a redirect operation, do not reload\n      // as that could could potentially delete the user if the token is\n      // expired. Instead any token problems will be detected via the\n      // verifyAssertion flow or the remaining flow. This is critical for\n      // reauthenticateWithRedirect as this flow is potentially used to recover\n      // from a token expiration error.\n      if (self.redirectUser_ &&\n          self.redirectUser_.getRedirectEventId() ==\n          user.getRedirectEventId()) {\n        return user;\n      }\n      // Confirm user valid first before setting listeners.\n      return user.reload().then(function() {\n        // Force user saving after reload as state change listeners not\n        // subscribed yet below via setCurrentUser_. Changes may have happened\n        // externally such as email actions or changes on another device.\n        return self.userStorageManager_.setCurrentUser(user).then(function() {\n          return user;\n        });\n      }).thenCatch(function(error) {\n        if (error['code'] == 'auth/network-request-failed') {\n          // Do not delete the user from storage if connection is lost or app is\n          // offline.\n          return user;\n        }\n        // Invalid user, could be deleted, remove from storage and resolve with\n        // null.\n        return /** @type {!fireauth.storage.UserManager} */(\n            self.userStorageManager_).removeCurrentUser();\n      });\n    }\n    // No logged in user, resolve with null;\n    return null;\n  }).then(function(user) {\n    // Even though state not ready yet pending any redirect result.\n    // Current user needs to be available for link with redirect to complete.\n    // This will also set listener on the user changes in case state changes\n    // occur they would get updated in storage too.\n    self.setCurrentUser_(user || null);\n  });\n  // In case the app is deleted before it is initialized with state from\n  // storage.\n  return /** @type {!goog.Promise<undefined>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * After initial Auth state is loaded, waits for any pending redirect result,\n * resolves it and then adds the external Auth state change listeners and\n * triggers first state of all observers.\n * @return {!goog.Promise<undefined>} Promise that resolves when state is ready\n *     taking into account any pending redirect result.\n * @private\n */\nfireauth.Auth.prototype.initAuthRedirectState_ = function() {\n  var self = this;\n  // Wait first for state to be loaded from storage.\n  return this.authStateLoaded_.then(function() {\n    // Resolve any pending redirect result.\n    return self.getRedirectResultWithoutClearing_();\n  }).thenCatch(function(error) {\n    // Ignore any error in the process. Redirect could be not supported.\n    return;\n  }).then(function() {\n    // Make sure instance was not deleted before proceeding.\n    if (self.deleted_) {\n      return;\n    }\n    // Between init Auth state and get redirect result resolution there\n    // could have been a sign in attempt in another window.\n    // Force sync and then add listener to run sync on change below.\n    return self.getSyncAuthUserChanges_();\n  }).thenCatch(function(error) {\n    // Ignore any error in the process.\n    return;\n  }).then(function() {\n    // Now that final state is ready, make sure instance was not deleted before\n    // proceeding.\n    if (self.deleted_) {\n      return;\n    }\n    // Initial state has been resolved.\n    self.isStateResolved_ = true;\n    // Add user state change listener so changes are synchronized with\n    // other windows and tabs.\n    /** @type {!fireauth.storage.UserManager} */ (self.userStorageManager_\n        ).addCurrentUserChangeListener(self.getSyncAuthUserChanges_);\n  });\n};\n\n\n/**\n * Synchronizes current Auth to stored auth state, used when external state\n * changes occur.\n * @return {!goog.Promise<void>}\n * @private\n */\nfireauth.Auth.prototype.syncAuthUserChanges_ = function() {\n  // Get Auth user state from storage and compare to current state.\n  // Safe to run when no external change is detected.\n  var self = this;\n  var authDomain = this.app_().options['authDomain'];\n  // Override user's authDomain with app's authDomain if there is a mismatch.\n  return /** @type {!fireauth.storage.UserManager} */ (\n      this.userStorageManager_).getCurrentUser(authDomain)\n      .then(function(user) {\n        // In case this was deleted.\n        if (self.deleted_) {\n          return;\n        }\n        // Since the authDomain could be modified here, saving to storage here\n        // could trigger an infinite loop of changes between this tab and\n        // another tab using different Auth domain but since sync Auth user\n        // changes does not save changes to storage, except for getToken below\n        // if the token needs refreshing but will stop triggering the first time\n        // the token is refreshed on one of the first tab that refreshes it.\n        // The latter should not happen anyway since getToken should be valid\n        // at all times since anything that triggers the storage change should\n        // have communicated with the backend and that requires a valid token.\n        // In addition, authDomain difference is an edge case to begin with.\n\n        // If the same user is to be synchronized.\n        if (self.currentUser_() &&\n            user &&\n            self.currentUser_().hasSameUserIdAs(user)) {\n          // Data update, simply copy data changes.\n          self.currentUser_().copy(user);\n          // If tokens changed from previous user tokens, this will trigger\n          // notifyAuthListeners_.\n          return self.currentUser_().getIdToken();\n        } else if (!self.currentUser_() && !user) {\n          // No change, do nothing (was signed out and remained signed out).\n          return;\n        } else {\n          // Update current Auth state. Either a new login or logout.\n          self.setCurrentUser_(user);\n          // If a new user is signed in, enabled popup and redirect on that\n          // user.\n          if (user) {\n            user.enablePopupRedirect();\n            // Set redirect storage manager on user.\n            user.setRedirectStorageManager(\n                /** @type {!fireauth.storage.RedirectUserManager} */ (\n                    self.redirectUserStorageManager_));\n          }\n          if (self.authEventManager_) {\n            self.authEventManager_.subscribe(self);\n          }\n          // Notify external Auth changes of Auth change event.\n          self.notifyAuthListeners_();\n        }\n      });\n};\n\n\n/**\n * Updates the language code on the provided user and configures the user to\n * listen to the Auth instance for any language code changes.\n * @param {!fireauth.AuthUser} user The user to whose language needs to be set.\n * @private\n */\nfireauth.Auth.prototype.setUserLanguage_ = function(user) {\n  // Sets the current language code on the user.\n  user.setLanguageCode(this.getLanguageCode());\n  // Sets current Auth instance as language code change dispatcher on the user.\n  user.setLanguageCodeChangeDispatcher(this);\n};\n\n\n/**\n * Handles user state changes.\n * @param {!fireauth.AuthUser} user The user which triggered the state changes.\n * @return {!goog.Promise} The promise that resolves when state changes are\n *     handled.\n * @private\n */\nfireauth.Auth.prototype.handleUserStateChange_ = function(user) {\n  // Save Auth user state changes.\n  return /** @type {!fireauth.storage.UserManager} */ (\n      this.userStorageManager_).setCurrentUser(user);\n};\n\n\n/**\n * Handles user token changes.\n * @param {!Object} event The token change event.\n * @private\n */\nfireauth.Auth.prototype.handleUserTokenChange_ = function(event) {\n  // This is only called when user is ready and Auth state has been resolved.\n  // Notify external Auth change listeners.\n  this.notifyAuthListeners_();\n  // Save user token changes.\n  this.handleUserStateChange_(/** @type {!fireauth.AuthUser} */ (\n      this.currentUser_()));\n};\n\n\n/**\n * Handles user deletion events.\n * @param {!Object} event The user delete event.\n * @private\n */\nfireauth.Auth.prototype.handleUserDelete_ = function(event) {\n  // A deleted user will be treated like a sign out event.\n  this.signOut();\n};\n\n\n/**\n * Handles user invalidation events.\n * @param {!Object} event The user invalidation event.\n * @private\n */\nfireauth.Auth.prototype.handleUserInvalidated_ = function(event) {\n  // An invalidated user will be treated like a sign out event.\n  this.signOut();\n};\n\n\n/**\n * Detaches all previous listeners on current user and reattach new listeners to\n * provided user if not null.\n * @param {?fireauth.AuthUser} user The user to attach event listeners to.\n * @private\n */\nfireauth.Auth.prototype.attachEventListeners_ = function(user) {\n  // Remove existing event listeners from previous current user if available.\n  if (this.currentUser_()) {\n    this.currentUser_().removeStateChangeListener(\n        this.userStateChangeListener_);\n    goog.events.unlisten(\n        this.currentUser_(),\n        fireauth.UserEventType.TOKEN_CHANGED,\n        this.userTokenChangeListener_);\n    goog.events.unlisten(\n        this.currentUser_(),\n        fireauth.UserEventType.USER_DELETED,\n        this.userDeleteListener_);\n    goog.events.unlisten(\n        this.currentUser_(),\n        fireauth.UserEventType.USER_INVALIDATED,\n        this.userInvalidatedListener_);\n    // Stop proactive token refresh on the current user.\n    this.currentUser_().stopProactiveRefresh();\n  }\n  // If a new user is provided, attach event listeners to state, token, user\n  // invalidation and delete events.\n  if (user) {\n    user.addStateChangeListener(this.userStateChangeListener_);\n    goog.events.listen(\n        user,\n        fireauth.UserEventType.TOKEN_CHANGED,\n        this.userTokenChangeListener_);\n    goog.events.listen(\n        user,\n        fireauth.UserEventType.USER_DELETED,\n        this.userDeleteListener_);\n     goog.events.listen(\n        user,\n        fireauth.UserEventType.USER_INVALIDATED,\n        this.userInvalidatedListener_);\n    // Start proactive token refresh on new user if there is at least one\n    // Firebase service subscribed to Auth changes.\n    if (this.firebaseServices_ > 0) {\n      user.startProactiveRefresh();\n    }\n  }\n};\n\n\n/**\n * Signs in with ID token promise provider.\n * @param {!goog.Promise<!Object>} idTokenPromise\n *     The rpc handler method that returns a promise which resolves with an ID\n *     token.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n * @private\n */\nfireauth.Auth.prototype.signInWithIdTokenProvider_ = function(idTokenPromise) {\n  var self = this;\n  var credential = null;\n  var additionalUserInfo = null;\n  return /** @type {!goog.Promise<!fireauth.AuthEventManager.Result>} */ (\n      this.registerPendingPromise_(\n          idTokenPromise\n          .then(function(idTokenResponse) {\n            // Get credential if available in the response.\n            credential = fireauth.AuthProvider.getCredentialFromResponse(\n                idTokenResponse);\n            // Get additional IdP data if available in the response.\n            additionalUserInfo = fireauth.AdditionalUserInfo.fromPlainObject(\n                idTokenResponse);\n            // When custom token is exchanged for idToken, continue sign in with\n            // ID token and return firebase Auth user.\n            return self.signInWithIdTokenResponse(idTokenResponse);\n          })\n          .then(function() {\n            // Resolve promise with a readonly user credential object.\n            return fireauth.object.makeReadonlyCopy({\n              // Return the current user reference.\n              'user': self.currentUser_(),\n              // Return any credential passed from the backend.\n              'credential': credential,\n              // Return any additional IdP data passed from the backend.\n              'additionalUserInfo': additionalUserInfo,\n              // Sign in operation type.\n              'operationType': fireauth.constants.OperationType.SIGN_IN\n            });\n          })));\n};\n\n\n/**\n * Initializes the Auth state change observer returned by the\n * firebase.INTERNAL.createSubscribe helper.\n * @param {!firebase.Observer} observer The Auth state change observer.\n * @private\n */\nfireauth.Auth.prototype.initIdTokenChangeObserver_ = function(observer) {\n  var self = this;\n  // Adds a listener that will transmit the event everytime it's called.\n  this.addAuthTokenListener(function(accessToken) {\n    observer.next(self.currentUser_());\n  });\n};\n\n\n/**\n * Initializes the user state change observer returned by the\n * firebase.INTERNAL.createSubscribe helper.\n * @param {!firebase.Observer} observer The user state change observer.\n * @private\n */\nfireauth.Auth.prototype.initUserStateObserver_ = function(observer) {\n  var self = this;\n  // Adds a listener that will transmit the event everytime it's called.\n  this.addUserChangeListener_(function(accessToken) {\n    observer.next(self.currentUser_());\n  });\n};\n\n\n/**\n * Adds an observer for Auth state changes, we need to wrap the call as\n * the args checking code needs a method defined on the prototype this way,\n * not within the constructor, and we also have to implement the behavior\n * that will trigger an observer right away if state is ready.\n * @param {!firebase.Observer|function(?fireauth.AuthUser)}\n *     nextOrObserver An observer object or a function triggered on change.\n * @param {function(!fireauth.AuthError)=} opt_error Optional A function\n *     triggered on Auth error.\n * @param {function()=} opt_completed Optional A function triggered when the\n *     observer is removed.\n * @return {!function()} The unsubscribe function for the observer.\n */\nfireauth.Auth.prototype.onIdTokenChanged = function(\n    nextOrObserver, opt_error, opt_completed) {\n  var self = this;\n  // State already determined. Trigger immediately, otherwise initState will\n  // take care of notifying all pending listeners on initialization.\n  // In this case we do not trigger synchronously and trigger via a resolved\n  // promise as required by specs.\n  if (this.isStateResolved_) {\n    // The observer cannot be called synchronously. We're using the\n    // native Promise implementation as otherwise it creates weird behavior\n    // where the order of promises resolution would not be as expected.\n    // It is due to the fact fireauth and firebase.app use their own\n    // and different promises library and this leads to calls resolutions order\n    // being different from the promises registration order.\n    Promise.resolve().then(function() {\n      if (goog.isFunction(nextOrObserver)) {\n        nextOrObserver(self.currentUser_());\n      } else if (goog.isFunction(nextOrObserver['next'])) {\n        nextOrObserver['next'](self.currentUser_());\n      }\n    });\n  }\n  return this.onIdTokenChanged_(\n      /** @type {!firebase.Observer|function(*)|undefined} */ (nextOrObserver),\n      /** @type {function(!Error)|undefined} */ (opt_error),\n      opt_completed);\n};\n\n\n/**\n * Adds an observer for user state changes, we need to wrap the call as\n * the args checking code needs a method defined on the prototype this way,\n * not within the constructor, and we also have to implement the behavior\n * that will trigger an observer right away if state is ready.\n * @param {!firebase.Observer|function(?fireauth.AuthUser)}\n *     nextOrObserver An observer object or a function triggered on change.\n * @param {function(!fireauth.AuthError)=} opt_error Optional A function\n *     triggered on Auth error.\n * @param {function()=} opt_completed Optional A function triggered when the\n *     observer is removed.\n * @return {!function()} The unsubscribe function for the observer.\n */\nfireauth.Auth.prototype.onAuthStateChanged = function(\n    nextOrObserver, opt_error, opt_completed) {\n  var self = this;\n  // State already determined. Trigger immediately, otherwise initState will\n  // take care of notifying all pending listeners on initialization.\n  // In this case we do not trigger synchronously and trigger via a resolved\n  // promise as required by specs.\n  if (this.isStateResolved_) {\n    // The observer cannot be called synchronously. We're using the\n    // native Promise implementation as otherwise it creates weird behavior\n    // where the order of promises resolution would not be as expected.\n    // It is due to the fact fireauth and firebase.app use their own\n    // and different promises library and this leads to calls resolutions order\n    // being different from the promises registration order.\n    Promise.resolve().then(function() {\n      // This ensures that the first time notifyAuthListeners_ is triggered,\n      // it has the correct UID before triggering the user state change\n      // listeners.\n      self.userStateChangeUid_ = self.getUid();\n      if (goog.isFunction(nextOrObserver)) {\n        nextOrObserver(self.currentUser_());\n      } else if (goog.isFunction(nextOrObserver['next'])) {\n        nextOrObserver['next'](self.currentUser_());\n      }\n    });\n  }\n  return this.onUserStateChanged_(\n      /** @type {!firebase.Observer|function(*)|undefined} */ (nextOrObserver),\n      /** @type {function(!Error)|undefined} */ (opt_error),\n      opt_completed);\n};\n\n\n/**\n * Returns an STS token. If the cached one is unexpired it is directly returned.\n * Otherwise the existing ID token or refresh token is exchanged for a new one.\n * If there is no user signed in, returns null.\n *\n * This method is called getIdTokenInternal as the symbol getIdToken is not\n * obfuscated, which could lead to developers incorrectly calling\n * firebase.auth().getIdToken().\n *\n * @param {boolean=} opt_forceRefresh Whether to force refresh token exchange.\n * @return {!goog.Promise<?Object>}\n */\nfireauth.Auth.prototype.getIdTokenInternal = function(opt_forceRefresh) {\n  var self = this;\n  // Wait for state to be ready.\n  var p = this.redirectStateIsReady_.then(function() {\n    // Call user's underlying getIdToken method.\n    if (self.currentUser_()) {\n      return self.currentUser_().getIdToken(opt_forceRefresh)\n          .then(function(stsAccessToken) {\n            // This is used internally by other services which expect the access\n            // token to be returned in an object.\n            return {\n              'accessToken': stsAccessToken\n            };\n          });\n    }\n    // No logged in user, return null token.\n    return null;\n  });\n  return /** @type {!goog.Promise<?Object>} */ (\n      this.registerPendingPromise_(p));\n};\n\n\n/**\n * Signs in a user asynchronously using a custom token and returns any\n * additional user info data or credentials returned form the backend.\n * @param {string} token The custom token to sign in with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInWithCustomToken = function(token) {\n  var self = this;\n  // Wait for the redirect state to be determined before proceeding. If critical\n  // errors like web storage unsupported are detected, fail before RPC, instead\n  // of after.\n  return this.redirectStateIsReady_.then(function() {\n    return self.signInWithIdTokenProvider_(\n        self.getRpcHandler().verifyCustomToken(token));\n  }).then(function(result) {\n    var user = result['user'];\n    // Manually sets the isAnonymous flag to false as the GetAccountInfo\n    // response will look like an anonymous user (no credentials visible).\n    user.updateProperty('isAnonymous', false);\n    // Save isAnonymous flag changes to current user in storage.\n    self.handleUserStateChange_(user);\n    return result;\n  });\n};\n\n\n/**\n * Sign in using an email and password and returns any additional user info\n * data or credentials returned form the backend.\n * @param {string} email The email to sign in with.\n * @param {string} password The password to sign in with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInWithEmailAndPassword =\n    function(email, password) {\n  var self = this;\n  // Wait for the redirect state to be determined before proceeding. If critical\n  // errors like web storage unsupported are detected, fail before RPC, instead\n  // of after.\n  return this.redirectStateIsReady_.then(function() {\n    return self.signInWithIdTokenProvider_(\n        self.getRpcHandler().verifyPassword(email, password));\n  });\n};\n\n\n/**\n * Creates a new email and password account and returns any additional user\n * info data or credentials returned form the backend.\n * @param {string} email The email to sign up with.\n * @param {string} password The password to sign up with.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.createUserWithEmailAndPassword =\n    function(email, password) {\n  var self = this;\n  // Wait for the redirect state to be determined before proceeding. If critical\n  // errors like web storage unsupported are detected, fail before RPC, instead\n  // of after.\n  return this.redirectStateIsReady_.then(function() {\n    return self.signInWithIdTokenProvider_(\n        self.getRpcHandler().createAccount(email, password));\n  });\n};\n\n\n/**\n * Logs into Firebase with the given 3rd party credentials and returns any\n * additional user info data or credentials returned form the backend.\n * @param {!fireauth.AuthCredential} credential The Auth credential.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInWithCredential = function(credential) {\n  // Credential could be extended in the future, so leave it to credential to\n  // decide how to retrieve ID token.\n  var self = this;\n  // Wait for the redirect state to be determined before proceeding. If critical\n  // errors like web storage unsupported are detected, fail before RPC, instead\n  // of after.\n  return this.redirectStateIsReady_.then(function() {\n    // Return the full response object and not just the user.\n    return self.signInWithIdTokenProvider_(\n        credential.getIdTokenProvider(self.getRpcHandler()));\n  });\n};\n\n\n/**\n * Logs into Firebase with the given 3rd party credentials and returns any\n * additional user info data or credentials returned form the backend. It has\n * been deprecated in favor of signInWithCredential.\n * @param {!fireauth.AuthCredential} credential The Auth credential.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInAndRetrieveDataWithCredential =\n    function(credential) {\n  fireauth.deprecation.log(\n      fireauth.deprecation.Deprecations.SIGN_IN_WITH_CREDENTIAL);\n  return this.signInWithCredential(credential);\n};\n\n\n/**\n * Signs in a user anonymously and returns any additional user info data or\n * credentials returned form the backend.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInAnonymously = function() {\n  var self = this;\n  // Wait for the redirect state to be determined before proceeding. If critical\n  // errors like web storage unsupported are detected, fail before RPC, instead\n  // of after.\n  return this.redirectStateIsReady_.then(function() {\n    var user = self.currentUser_();\n    // If an anonymous user is already signed in, no need to sign him again.\n    if (user && user['isAnonymous']) {\n      var additionalUserInfo = fireauth.object.makeReadonlyCopy({\n        'providerId': null,\n        'isNewUser': false\n      });\n      return fireauth.object.makeReadonlyCopy({\n        // Return the signed in user reference.\n        'user': user,\n        // Do not return credential for anonymous user.\n        'credential': null,\n        // Return any additional IdP data.\n        'additionalUserInfo': additionalUserInfo,\n        // Sign in operation type.\n        'operationType': fireauth.constants.OperationType.SIGN_IN\n      });\n    } else {\n      // No anonymous user currently signed in.\n      return self.signInWithIdTokenProvider_(\n          self.getRpcHandler().signInAnonymously())\n          .then(function(result) {\n            var user = result['user'];\n            // Manually sets the isAnonymous flag to true as\n            // initializeFromIdTokenResponse uses the default value of false and\n            // even though getAccountInfo sets that to true, it will be reverted\n            // to false in reloadWithoutSaving.\n            // TODO: consider optimizing this and cleaning these manual\n            // overwrites.\n            user.updateProperty('isAnonymous', true);\n            // Save isAnonymous flag changes to current user in storage.\n            self.handleUserStateChange_(user);\n            return result;\n          });\n    }\n  });\n};\n\n\n/**\n * @return {string} The key used for storing Auth state.\n */\nfireauth.Auth.prototype.getStorageKey = function() {\n  return fireauth.util.createStorageKey(\n      this.app_().options['apiKey'],\n      this.app_().name);\n};\n\n\n/**\n * @return {!firebase.app.App} The Firebase App this auth object is connected\n *     to.\n * @private\n */\nfireauth.Auth.prototype.app_ = function() {\n  return this['app'];\n};\n\n\n/**\n * @return {!fireauth.RpcHandler} The RPC handler.\n */\nfireauth.Auth.prototype.getRpcHandler = function() {\n  return this.rpcHandler_;\n};\n\n\n/**\n * @return {?fireauth.AuthUser} The currently logged in user.\n * @private\n */\nfireauth.Auth.prototype.currentUser_ = function() {\n  return this['currentUser'];\n};\n\n\n/** @return {?string} The current user UID if available, null if not. */\nfireauth.Auth.prototype.getUid = function() {\n  return (this.currentUser_() && this.currentUser_()['uid']) || null;\n};\n\n\n/**\n * @return {?string} The last cached access token.\n * @private\n */\nfireauth.Auth.prototype.getLastAccessToken_ = function() {\n  return (this.currentUser_() && this.currentUser_()['_lat']) || null;\n};\n\n\n\n/**\n * Called internally on Auth state change to notify listeners.\n * @private\n */\nfireauth.Auth.prototype.notifyAuthListeners_ = function() {\n  // Only run when state is resolved. After state is resolved, the Auth listener\n  // will always trigger.\n  if (this.isStateResolved_) {\n    for (var i = 0; i < this.authListeners_.length; i++) {\n      if (this.authListeners_[i]) {\n        this.authListeners_[i](this.getLastAccessToken_());\n      }\n    }\n    // Trigger user change only if UID changed.\n    if (this.userStateChangeUid_ !== this.getUid() &&\n        this.userChangeListeners_.length) {\n      // Update user state change UID.\n      this.userStateChangeUid_ = this.getUid();\n      // Trigger all subscribed user state change listeners.\n      for (var i = 0; i < this.userChangeListeners_.length; i++) {\n        if (this.userChangeListeners_[i]) {\n          this.userChangeListeners_[i](this.getLastAccessToken_());\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * Attaches a listener function to Auth state change.\n * This is used only by internal Firebase services.\n * @param {!function(?string)} listener The auth state change listener.\n */\nfireauth.Auth.prototype.addAuthTokenListenerInternal = function(listener) {\n  this.addAuthTokenListener(listener);\n  // This is not exact science but should be good enough to detect Firebase\n  // services subscribing to Auth token changes.\n  // This is needed to start proactive token refresh on a user.\n  this.firebaseServices_++;\n  if (this.firebaseServices_ > 0 && this.currentUser_()) {\n    // Start proactive token refresh on the current user.\n    this.currentUser_().startProactiveRefresh();\n  }\n};\n\n\n/**\n * Detaches the provided listener from Auth state change event.\n * This is used only by internal Firebase services.\n * @param {!function(?string)} listener The Auth state change listener.\n */\nfireauth.Auth.prototype.removeAuthTokenListenerInternal = function(listener) {\n  // This is unlikely to be called by Firebase services. Services are unlikely\n  // to remove Auth token listeners.\n  // Make sure listener is still subscribed before decrementing.\n  var self = this;\n  goog.array.forEach(this.authListeners_, function(ele) {\n    // This covers the case where the same listener is subscribed more than\n    // once.\n    if (ele == listener) {\n      self.firebaseServices_--;\n    }\n  });\n  if (this.firebaseServices_ < 0) {\n    this.firebaseServices_ = 0;\n  }\n  if (this.firebaseServices_ == 0 && this.currentUser_()) {\n    // Stop proactive token refresh on the current user.\n    this.currentUser_().stopProactiveRefresh();\n  }\n  this.removeAuthTokenListener(listener);\n};\n\n\n/**\n * Attaches a listener function to Auth state change.\n * @param {!function(?string)} listener The Auth state change listener.\n */\nfireauth.Auth.prototype.addAuthTokenListener = function(listener) {\n  var self = this;\n  // Save listener.\n  this.authListeners_.push(listener);\n  // Make sure redirect state is ready and then trigger listener.\n  this.registerPendingPromise_(this.redirectStateIsReady_.then(function() {\n    // Do nothing if deleted.\n    if (self.deleted_) {\n      return;\n    }\n    // Make sure listener is still subscribed.\n    if (goog.array.contains(self.authListeners_, listener)) {\n      // Trigger the first call for this now that redirect state is resolved.\n      listener(self.getLastAccessToken_());\n    }\n  }));\n};\n\n\n/**\n * Detaches the provided listener from Auth state change event.\n * @param {!function(?string)} listener The Auth state change listener.\n */\nfireauth.Auth.prototype.removeAuthTokenListener = function(listener) {\n  // Remove from Auth listeners.\n  goog.array.removeAllIf(this.authListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n\n\n/**\n * Attaches a listener function to user state change.\n * @param {!function(?string)} listener The user state change listener.\n * @private\n */\nfireauth.Auth.prototype.addUserChangeListener_ = function(listener) {\n  var self = this;\n  // Save listener.\n  this.userChangeListeners_.push(listener);\n  // Make sure redirect state is ready and then trigger listener.\n  this.registerPendingPromise_(this.redirectStateIsReady_.then(function() {\n    // Do nothing if deleted.\n    if (self.deleted_) {\n      return;\n    }\n    // Make sure listener is still subscribed.\n    if (goog.array.contains(self.userChangeListeners_, listener)) {\n      // Confirm UID change before triggering.\n      if (self.userStateChangeUid_ !== self.getUid()) {\n        self.userStateChangeUid_ = self.getUid();\n        // Trigger the first call for this now that redirect state is resolved.\n        listener(self.getLastAccessToken_());\n      }\n    }\n  }));\n};\n\n\n/**\n * Deletes the Auth instance, handling cancellation of all pending async Auth\n * operations.\n * @return {!Promise<void>}\n */\nfireauth.Auth.prototype.delete = function() {\n  this.deleted_ = true;\n  // Cancel all pending promises.\n  for (var i = 0; i < this.pendingPromises_.length; i++) {\n    this.pendingPromises_[i].cancel(fireauth.authenum.Error.MODULE_DESTROYED);\n  }\n\n  // Empty pending promises array.\n  this.pendingPromises_ = [];\n  // Remove current user change listener.\n  if (this.userStorageManager_) {\n    this.userStorageManager_.removeCurrentUserChangeListener(\n        this.getSyncAuthUserChanges_);\n  }\n  // Unsubscribe from Auth event handling.\n  if (this.authEventManager_) {\n    this.authEventManager_.unsubscribe(this);\n    this.authEventManager_.clearRedirectResult();\n  }\n  return Promise.resolve();\n};\n\n\n/** @return {boolean} Whether Auth instance has pending promises. */\nfireauth.Auth.prototype.hasPendingPromises = function() {\n  return this.pendingPromises_.length != 0;\n};\n\n\n/**\n * Takes in a pending promise, saves it and adds a clean up callback which\n * forgets the pending promise after it is fulfilled and echoes the promise\n * back.\n * @param {!goog.Promise<*, *>|!goog.Promise<void>} p The pending promise.\n * @return {!goog.Promise<*, *>|!goog.Promise<void>}\n * @private\n */\nfireauth.Auth.prototype.registerPendingPromise_ = function(p) {\n  var self = this;\n  // Save created promise in pending list.\n  this.pendingPromises_.push(p);\n  p.thenAlways(function() {\n    // When fulfilled, remove from pending list.\n    goog.array.remove(self.pendingPromises_, p);\n  });\n  // Return the promise.\n  return p;\n};\n\n\n/**\n * Gets the list of possible sign in methods for the given email address.\n * @param {string} email The email address.\n * @return {!goog.Promise<!Array<string>>}\n */\nfireauth.Auth.prototype.fetchSignInMethodsForEmail = function(email) {\n  return /** @type {!goog.Promise<!Array<string>>} */ (\n      this.registerPendingPromise_(\n          this.getRpcHandler().fetchSignInMethodsForIdentifier(email)));\n};\n\n\n/**\n * @param {string} emailLink The email link.\n * @return {boolean} Whether the link is a sign in with email link.\n */\nfireauth.Auth.prototype.isSignInWithEmailLink = function(emailLink) {\n  return  !!fireauth.EmailAuthProvider\n      .getActionCodeUrlFromSignInEmailLink(emailLink);\n};\n\n\n/**\n * Sends the sign-in with email link for the email account provided.\n * @param {string} email The email account to sign in with.\n * @param {!Object} actionCodeSettings The action code settings object.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.sendSignInLinkToEmail = function(\n    email, actionCodeSettings) {\n  var self = this;\n  return this.registerPendingPromise_(\n      // Wrap in promise as ActionCodeSettings constructor could throw a\n      // synchronous error if invalid arguments are specified.\n      goog.Promise.resolve()\n          .then(function() {\n            var actionCodeSettingsBuilder =\n                new fireauth.ActionCodeSettings(actionCodeSettings);\n            if (!actionCodeSettingsBuilder.canHandleCodeInApp()) {\n              throw new fireauth.AuthError(\n                  fireauth.authenum.Error.ARGUMENT_ERROR,\n                  fireauth.ActionCodeSettings.RawField.HANDLE_CODE_IN_APP +\n                  ' must be true when sending sign in link to email');\n            }\n            return actionCodeSettingsBuilder.buildRequest();\n          }).then(function(additionalRequestData) {\n            return self.getRpcHandler().sendSignInLinkToEmail(\n                email, additionalRequestData);\n          }).then(function(email) {\n            // Do not return the email.\n          }));\n};\n\n\n/**\n * Verifies an email action code for password reset and returns a promise\n * that resolves with the associated email if verified.\n * @param {string} code The email action code to verify for password reset.\n * @return {!goog.Promise<string>}\n */\nfireauth.Auth.prototype.verifyPasswordResetCode = function(code) {\n  return this.checkActionCode(code).then(function(info) {\n    return info['data']['email'];\n  });\n};\n\n\n/**\n * Requests resetPassword endpoint for password reset, verifies the action code\n * and updates the new password, returns an empty promise.\n * @param {string} code The email action code to confirm for password reset.\n * @param {string} newPassword The new password.\n * @return {!goog.Promise<undefined, !fireauth.AuthError>}\n */\nfireauth.Auth.prototype.confirmPasswordReset = function(code, newPassword) {\n  return this.registerPendingPromise_(\n      this.getRpcHandler().confirmPasswordReset(code, newPassword)\n      .then(function(email) {\n        // Do not return the email.\n      }));\n};\n\n\n/**\n * Verifies an email action code and returns an empty promise if verified.\n * @param {string} code The email action code to verify for password reset.\n * @return {!goog.Promise<!Object>}\n */\nfireauth.Auth.prototype.checkActionCode = function(code) {\n  return this.registerPendingPromise_(\n      this.getRpcHandler().checkActionCode(code)\n      .then(function(response) {\n        return new fireauth.ActionCodeInfo(response);\n      }));\n};\n\n\n/**\n * Applies an out-of-band email action code, such as an email verification code.\n * @param {string} code The email action code.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.applyActionCode = function(code) {\n  return this.registerPendingPromise_(\n      this.getRpcHandler().applyActionCode(code)\n      .then(function(email) {\n        // Returns nothing.\n      }));\n};\n\n\n/**\n * Sends the password reset email for the email account provided.\n * @param {string} email The email account with the password to be reset.\n * @param {?Object=} opt_actionCodeSettings The optional action code settings\n *     object.\n * @return {!goog.Promise<void>}\n */\nfireauth.Auth.prototype.sendPasswordResetEmail =\n    function(email, opt_actionCodeSettings) {\n  var self = this;\n  return this.registerPendingPromise_(\n      // Wrap in promise as ActionCodeSettings constructor could throw a\n      // synchronous error if invalid arguments are specified.\n      goog.Promise.resolve().then(function() {\n        if (typeof opt_actionCodeSettings !== 'undefined' &&\n            // Ignore empty objects.\n            !goog.object.isEmpty(opt_actionCodeSettings)) {\n          return new fireauth.ActionCodeSettings(\n              /** @type {!Object} */ (opt_actionCodeSettings)).buildRequest();\n        }\n        return {};\n      })\n      .then(function(additionalRequestData) {\n        return self.getRpcHandler().sendPasswordResetEmail(\n            email, additionalRequestData);\n      }).then(function(email) {\n        // Do not return the email.\n      }));\n};\n\n\n/**\n * Signs in with a phone number using the app verifier instance and returns a\n * promise that resolves with the confirmation result which on confirmation\n * will resolve with the UserCredential object.\n * @param {string} phoneNumber The phone number to authenticate with.\n * @param {!firebase.auth.ApplicationVerifier} appVerifier The application\n *     verifier.\n * @return {!goog.Promise<!fireauth.ConfirmationResult>}\n */\nfireauth.Auth.prototype.signInWithPhoneNumber =\n    function(phoneNumber, appVerifier) {\n  return /** @type {!goog.Promise<!fireauth.ConfirmationResult>} */ (\n      this.registerPendingPromise_(fireauth.ConfirmationResult.initialize(\n          this,\n          phoneNumber,\n          appVerifier,\n          // This will wait for redirectStateIsReady to resolve first.\n          goog.bind(this.signInWithCredential, this))));\n};\n\n\n/**\n * Signs in a Firebase User with the provided email and the passwordless\n * sign-in email link.\n * @param {string} email The email account to sign in with.\n * @param {?string=} opt_link The optional link which contains the OTP needed\n *     to complete the sign in with email link. If not specified, the current\n *     URL is used instead.\n * @return {!goog.Promise<!fireauth.AuthEventManager.Result>}\n */\nfireauth.Auth.prototype.signInWithEmailLink = function(email, opt_link) {\n  return this.registerPendingPromise_(goog.Promise.resolve().then(() => {\n      const link = opt_link || fireauth.util.getCurrentUrl();\n      const credential = fireauth.EmailAuthProvider.credentialWithLink(\n          email, link);\n      // Check if the tenant ID in the email link matches the tenant ID on Auth\n      // instance.\n      const actionCodeUrl =\n          fireauth.EmailAuthProvider.getActionCodeUrlFromSignInEmailLink(link);\n      if (!actionCodeUrl) {\n        throw new fireauth.AuthError(\n            fireauth.authenum.Error.ARGUMENT_ERROR, 'Invalid email link!');\n      }\n      if (actionCodeUrl['tenantId'] !== this.getTenantId()) {\n        throw new fireauth.AuthError(\n            fireauth.authenum.Error.TENANT_ID_MISMATCH);\n      }\n      return this.signInWithCredential(credential);\n  }));\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /**\n * @fileoverview Defines the grecaptcha interface.\n */\n\ngoog.provide('fireauth.grecaptcha');\n\n\n/**\n * The reCAPTCHA interface for initializing and managing visible v2\n * reCAPTCHAs as well as invisible ones.\n * @interface\n */\nfireauth.grecaptcha = function() {};\n\n\n/**\n * Creates a new instance of the recaptcha client.\n *\n * @param {!Element|string} elementOrId Element or element ID for the\n *     placeholder to render the reCAPTCHA client.\n * @param {!Object} params Parameters for the recaptcha client.\n * @return {number} The client ID.\n */\nfireauth.grecaptcha.prototype.render = function(elementOrId, params) {};\n\n\n/**\n * Resets a client with the given ID.  If an ID is not provided, resets the\n * default client.\n *\n * @param {number=} id The ID of the recaptcha client.\n * @param {?Object=} params Parameters for the recaptcha client.\n */\nfireauth.grecaptcha.prototype.reset = function(id, params) {};\n\n\n/**\n * Gets the response for the client with the given ID.  If an ID is not\n * provided, gets the response for the default client.\n *\n * @param {number=} id The ID of the recaptcha client.\n * @return {?string}\n */\nfireauth.grecaptcha.prototype.getResponse = function(id) {};\n\n\n/**\n * Programmatically triggers the invisible reCAPTCHA.\n *\n * @param {number=} opt_id The ID of the recaptcha client. Defaults to the\n *     first widget created if unspecified.\n */\nfireauth.grecaptcha.prototype.execute = function(opt_id) {};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /**\n * @fileoverview Defines the mock grecaptcha utilities used for development\n * testing.\n */\ngoog.provide('fireauth.GRecaptchaMockFactory');\ngoog.provide('fireauth.RecaptchaMock');\n\ngoog.require('fireauth.grecaptcha');\ngoog.require('fireauth.util');\ngoog.require('goog.dom');\ngoog.require('goog.events');\ngoog.require('goog.events.EventType');\n\n\n/**\n * The mock grecaptcha factory.\n * @constructor\n * @implements {fireauth.grecaptcha}\n */\nfireauth.GRecaptchaMockFactory = function() {\n  /**\n   * @const @private {!Object<string, !fireauth.RecaptchaMock>} The hash map\n   *     that stores the widget ID to mock reCAPTCHA instances.\n   */\n  this.map_ = {};\n  /**\n   * @private {number} The current widget ID counter, incremented each time\n   *     a new mock reCAPTCHA is created.\n   */\n  this.counter_ = fireauth.GRecaptchaMockFactory.START_INSTANCE_ID;\n};\n\n\n/**\n * @const {number} The start ID of the first created mock reCAPTCHA.\n */\nfireauth.GRecaptchaMockFactory.START_INSTANCE_ID = 1000000000000;\n\n\n/** @const {number} The reCAPTCHA expiration time in milliseconds. */\nfireauth.GRecaptchaMockFactory.EXPIRATION_TIME_MS = 60000;\n\n\n/** @const {number} The reCAPTCHA auto solving time in milliseconds. */\nfireauth.GRecaptchaMockFactory.SOLVE_TIME_MS = 500;\n\n\n/**\n * @private {?fireauth.GRecaptchaMockFactory} The singleton instance\n *     for grecaptcha mock object.\n */\nfireauth.GRecaptchaMockFactory.instance_ = null;\n\n\n/**\n * @return {!fireauth.GRecaptchaMockFactory} The singleton grecaptcha mock\n *     instance.\n */\nfireauth.GRecaptchaMockFactory.getInstance = function() {\n  // Check if there is an existing instance. Otherwise, create one and cache it.\n  if (!fireauth.GRecaptchaMockFactory.instance_) {\n    fireauth.GRecaptchaMockFactory.instance_ =\n        new fireauth.GRecaptchaMockFactory();\n  }\n  return fireauth.GRecaptchaMockFactory.instance_;\n};\n\n\n/**\n * Creates a new instance of the mock reCAPTCHA widget.\n *\n * @param {(!Element|string)} elementOrId Element or element ID for the\n *     placeholder to render the reCAPTCHA client.\n * @param {!Object} params Parameters for the reCAPTCHA client.\n * @return {number} The client ID.\n * @override\n */\nfireauth.GRecaptchaMockFactory.prototype.render =\n    function(elementOrId, params) {\n  this.map_[this.counter_.toString()] =\n      new fireauth.RecaptchaMock(elementOrId, params);\n  return this.counter_++;\n};\n\n\n/**\n * Resets a reCAPTCHA with the given ID. If an ID is not provided, resets the\n * first instance.\n *\n * @param {number=} opt_id The id of the reCAPTCHA client. Defaults to the first\n *     widget created if unspecified.\n * @override\n */\nfireauth.GRecaptchaMockFactory.prototype.reset = function(opt_id) {\n  var mock = this.getMock_(opt_id);\n  var id = this.getId_(opt_id);\n  if (mock && id) {\n    mock.delete();\n    delete this.map_[/** @type {string} */ (id)];\n  }\n};\n\n\n/**\n * Gets the response for the client with the given ID. If an ID is not\n * provided, gets the response for the default client.\n *\n * @param {number=} opt_id The ID of the reCAPTCHA widget. Defaults to the first\n *     widget created if unspecified.\n * @return {?string}\n * @override\n */\nfireauth.GRecaptchaMockFactory.prototype.getResponse = function(opt_id) {\n  var mock = this.getMock_(opt_id);\n  return mock ? mock.getResponse() : null;\n};\n\n\n/**\n * Programmatically triggers the invisible reCAPTCHA.\n *\n * @param {number=} opt_id The ID of the recaptcha client. Defaults to the first\n *     widget created if unspecified.\n * @override\n */\nfireauth.GRecaptchaMockFactory.prototype.execute = function(opt_id) {\n  var mock = this.getMock_(opt_id);\n  if (mock) {\n    mock.execute();\n  }\n};\n\n\n/**\n * @param {number=} opt_id The optional ID to lookup.\n * @return {?fireauth.RecaptchaMock} The corresponding reCAPTCHA mock if found.\n * @private\n */\nfireauth.GRecaptchaMockFactory.prototype.getMock_ = function(opt_id) {\n  var id = this.getId_(opt_id);\n  return id ? this.map_[id] || null : null;\n};\n\n\n/**\n * @param {number=} opt_id The optional ID to lookup.\n * @return {?string} The corresponding reCAPTCHA mock ID if found.\n * @private\n */\nfireauth.GRecaptchaMockFactory.prototype.getId_ = function(opt_id) {\n  var id = typeof opt_id === 'undefined' ?\n      fireauth.GRecaptchaMockFactory.START_INSTANCE_ID : opt_id;\n  return id ? id.toString() : null;\n};\n\n\n/**\n * Mock single reCAPTCHA instance.\n * @param {(!Element|string)} elementOrId Element or element ID for the\n *     placeholder to render the reCAPTCHA client.\n * @param {!Object} params Parameters for the reCAPTCHA client.\n * @constructor\n */\nfireauth.RecaptchaMock = function(elementOrId, params) {\n  /** @private {boolean} Whether the instance was deleted. */\n  this.deleted_ = false;\n  /** @const @private {!Object} The reCAPTCHA parameters. */\n  this.params_ = params;\n  /** @private {?string} The simulated response token if available. */\n  this.responseToken_ = null;\n  /**\n   * @private {?number} The timer ID for response callback/expiration callback\n   *     to trigger.\n   */\n  this.timerId_ = null;\n  /** @const @private {boolean} Whether the reCAPTCHA is visible or not. */\n  this.isVisible_ = this.params_['size'] !== 'invisible';\n  /**\n   * @const @private {?Element} The container or button trigger of the\n   *     reCAPTCHA.\n   */\n  this.element_ = goog.dom.getElement(elementOrId);\n  var self = this;\n  /** @private {function(?)} The on click handler for invisible reCAPTCHAs. */\n  this.onClickHandler_ = function(event) {\n    self.execute();\n  };\n  if (this.isVisible_) {\n    // For a visible reCAPTCHA, simulate reCAPTCHA continuously solved\n    // and then expired.\n    this.execute();\n  } else {\n    // Trigger on button click on when execute is directly called.\n    goog.events.listen(\n        this.element_,\n        goog.events.EventType.CLICK,\n        this.onClickHandler_);\n  }\n};\n\n\n/** @return {?string} The current reCAPTCHA response. */\nfireauth.RecaptchaMock.prototype.getResponse = function() {\n  this.checkIfDeleted_();\n  return this.responseToken_;\n};\n\n\n/** Starts the reCAPTCHA mock solving/expiration cycle. */\nfireauth.RecaptchaMock.prototype.execute = function() {\n  this.checkIfDeleted_();\n  var self = this;\n  if (this.timerId_) {\n    return;\n  }\n  // Wait for expected delay before auto-solving.\n  this.timerId_ = setTimeout(function() {\n    // Generate random string as reCAPTCHA response token.\n    self.responseToken_ = fireauth.util.generateRandomAlphaNumericString(50);\n    // Trigger developer's callbacks.\n    var callback = self.params_['callback'];\n    var expirationCallback = self.params_['expired-callback'];\n    if (callback) {\n      try {\n        callback(self.responseToken_);\n      } catch (e) {}\n    }\n    // Wait for token to expire before triggering expiration callback and\n    // resetting token response.\n    self.timerId_ = setTimeout(function() {\n      self.timerId_ = null;\n      self.responseToken_ = null;\n      if (expirationCallback) {\n        try {\n          expirationCallback();\n        } catch (e) {}\n      }\n      if (self.isVisible_) {\n        self.execute();\n      }\n    }, fireauth.GRecaptchaMockFactory.EXPIRATION_TIME_MS);\n  }, fireauth.GRecaptchaMockFactory.SOLVE_TIME_MS);\n};\n\n\n/** Deletes the current mock instance. */\nfireauth.RecaptchaMock.prototype.delete = function() {\n  this.checkIfDeleted_();\n  this.deleted_ = true;\n  clearTimeout(this.timerId_);\n  this.timerId_ = null;\n  goog.events.unlisten(\n      this.element_,\n      goog.events.EventType.CLICK,\n      this.onClickHandler_);\n};\n\n\n/**\n * Checks whether the instance was deleted.\n * @private\n */\nfireauth.RecaptchaMock.prototype.checkIfDeleted_ = function() {\n  // This error should never be thrown externally.\n  // GRecaptchaMockFactory will ensure that a deleted instance is removed.\n  if (this.deleted_) {\n    throw new Error('reCAPTCHA mock was already deleted!');\n  }\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /**\n * @fileoverview Defines the RecaptchaLoader implementation used to mock loading\n * of grecaptcha dependencies.\n */\n\ngoog.provide('fireauth.RecaptchaMockLoader');\n\ngoog.require('fireauth.GRecaptchaMockFactory');\ngoog.require('fireauth.RecaptchaLoader');\ngoog.require('goog.Promise');\n\n\n/**\n * Defines a mock reCAPTCHA loader by implementing the fireauth.RecaptchaLoader\n * interface.\n * @constructor\n * @implements {fireauth.RecaptchaLoader}\n */\nfireauth.RecaptchaMockLoader = function() {};\n\n\n/**\n * Loads the grecaptcha mock library if it is not loaded and returns a promise\n * that resolves on success. If the right conditions are available, will reload\n * the dependencies for a specified language code.\n * @param {?string} hl The reCAPTCHA language code.\n * @return {!goog.Promise<!fireauth.grecaptcha>} A promise that resolves when\n *     grecaptcha is loaded.\n * @override\n */\nfireauth.RecaptchaMockLoader.prototype.loadRecaptchaDeps =\n    function(hl) {\n  return goog.Promise.resolve(\n  \t/** @type {!fireauth.grecaptcha} */ (fireauth.GRecaptchaMockFactory.getInstance()));\n};\n\n\n/**\n * Decrements the reCAPTCHA instance counter.\n * @override\n */\nfireauth.RecaptchaMockLoader.prototype.clearSingleRecaptcha =\n    function() {};\n\n\n/**\n * @private {?fireauth.RecaptchaMockLoader} The singleton instance\n *     for the mock reCAPTCHA dependency loader.\n */\nfireauth.RecaptchaMockLoader.instance_ = null;\n\n\n/**\n * @return {!fireauth.RecaptchaMockLoader} The singleton mock reCAPTCHA\n *     dependency loader instance.\n */\nfireauth.RecaptchaMockLoader.getInstance = function() {\n  // Check if there is an existing instance. Otherwise create one and cache it.\n  if (!fireauth.RecaptchaMockLoader.instance_) {\n    fireauth.RecaptchaMockLoader.instance_ =\n        new fireauth.RecaptchaMockLoader();\n  }\n  return fireauth.RecaptchaMockLoader.instance_;\n};\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n /**\n * @fileoverview Defines the RecaptchaLoader implementation used to load all\n * the grecaptcha dependencies.\n */\n\ngoog.provide('fireauth.RecaptchaRealLoader');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.RecaptchaLoader');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.html.TrustedResourceUrl');\ngoog.require('goog.net.jsloader');\ngoog.require('goog.string.Const');\n\n\n/**\n * Utility to help load reCAPTCHA dependencies for specified languages.\n * @constructor\n * @implements {fireauth.RecaptchaLoader}\n */\nfireauth.RecaptchaRealLoader = function() {\n  /**\n   * @private {number} The reCAPTCHA instance counter. This is used to track the\n   *     number of reCAPTCHAs rendered on the page. This is needed to allow\n   *     localization of the reCAPTCHA. Localization is applied by loading the\n   *     grecaptcha SDK with the hl field provided. However, this will break\n   *     existing reCAPTCHAs. So we should only support i18n when there are no\n   *     other widgets rendered on this screen. If the developer is already\n   *     using reCAPTCHA in another context, we will disable localization so we\n   *     don't accidentally break existing reCAPTCHA widgets.\n   */\n  this.counter_ = goog.global['grecaptcha'] ? Infinity : 0;\n  /** @private {?string} The current reCAPTCHA language code. */\n  this.hl_ = null;\n  /** @const @private {string} The reCAPTCHA callback name. */\n  this.cbName_ = '__rcb' + Math.floor(Math.random() * 1000000).toString();\n};\n\n\n/** @private @const {!goog.string.Const} The reCAPTCHA javascript source URL. */\nfireauth.RecaptchaRealLoader.RECAPTCHA_SRC_ = goog.string.Const.from(\n    'https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit' +\n    '&hl=%{hl}');\n\n\n/**\n * The default timeout delay (units in milliseconds) for requests loading\n * the external reCAPTCHA dependencies.\n * @const {!fireauth.util.Delay}\n * @private\n */\nfireauth.RecaptchaRealLoader.DEFAULT_DEPENDENCY_TIMEOUT_ =\n    new fireauth.util.Delay(30000, 60000);\n\n\n/**\n * Loads the grecaptcha client library if it is not loaded and returns a promise\n * that resolves on success. If the right conditions are available, will reload\n * the dependencies for a specified language code.\n * @param {?string} hl The reCAPTCHA language code.\n * @return {!goog.Promise<!fireauth.grecaptcha>} A promise that resolves when\n *     grecaptcha is loaded.\n * @override\n */\nfireauth.RecaptchaRealLoader.prototype.loadRecaptchaDeps =\n    function(hl) {\n  var self = this;\n  return new goog.Promise(function(resolve, reject) {\n    var timer = setTimeout(\n        function() {\n          reject(new fireauth.AuthError(\n              fireauth.authenum.Error.NETWORK_REQUEST_FAILED));\n        },\n        fireauth.RecaptchaRealLoader.DEFAULT_DEPENDENCY_TIMEOUT_\n            .get()\n    );\n    // Load grecaptcha SDK if not already loaded or language changed since last\n    // load and no other rendered reCAPTCHA is visible,\n    if (!goog.global['grecaptcha'] || (hl !== self.hl_ && !self.counter_)) {\n      // reCAPTCHA saves the onload function and applies it on subsequent\n      // reloads. This means that the callback name has to remain the same.\n      goog.global[self.cbName_] = function() {\n        if (!goog.global['grecaptcha']) {\n          clearTimeout(timer);\n          // This should not happen.\n          reject(new fireauth.AuthError(\n              fireauth.authenum.Error.INTERNAL_ERROR));\n        } else {\n          // Update the current language code.\n          self.hl_ = hl;\n          var render = goog.global['grecaptcha']['render'];\n          // Wrap grecaptcha.render to keep track of rendered grecaptcha. This\n          // helps detect if the developer rendered a non\n          // firebase.auth.RecaptchaVerifier reCAPTCHA.\n          goog.global['grecaptcha']['render'] =\n              function(container, parameters) {\n            var widgetId = render(container, parameters);\n            // Increment only after render succeeds, in case an error is thrown\n            // during rendering.\n            self.counter_++;\n            return widgetId;\n          };\n          clearTimeout(timer);\n          resolve(goog.global['grecaptcha']);\n        }\n        delete goog.global[self.cbName_];\n      };\n      // Construct reCAPTCHA URL and on load, run the temporary function.\n      var url = goog.html.TrustedResourceUrl.format(\n          fireauth.RecaptchaRealLoader.RECAPTCHA_SRC_,\n          {'onload': self.cbName_, 'hl': hl || ''});\n      // TODO: eventually, replace all dependencies on goog.net.jsloader.\n      goog.Promise.resolve(goog.net.jsloader.safeLoad(url))\n          .thenCatch(function(error) {\n            clearTimeout(timer);\n            // In case library fails to load, typically due to a network error,\n            // reset cached loader to null to force a refresh on a retrial.\n            reject(new fireauth.AuthError(\n                fireauth.authenum.Error.INTERNAL_ERROR,\n                'Unable to load external reCAPTCHA dependencies!'));\n          });\n    } else {\n      clearTimeout(timer);\n      resolve(goog.global['grecaptcha']);\n    }\n  });\n};\n\n\n/**\n * Decrements the reCAPTCHA instance counter.\n * @override\n */\nfireauth.RecaptchaRealLoader.prototype.clearSingleRecaptcha =\n    function() {\n  this.counter_--;\n};\n\n\n/**\n * @private {?fireauth.RecaptchaRealLoader} The singleton instance\n *     for reCAPTCHA dependency loader.\n */\nfireauth.RecaptchaRealLoader.instance_ = null;\n\n\n/**\n * @return {!fireauth.RecaptchaRealLoader} The singleton reCAPTCHA\n *     dependency loader instance.\n */\nfireauth.RecaptchaRealLoader.getInstance = function() {\n  // Check if there is an existing instance. Otherwise create one and cache it.\n  if (!fireauth.RecaptchaRealLoader.instance_) {\n    fireauth.RecaptchaRealLoader.instance_ =\n        new fireauth.RecaptchaRealLoader();\n  }\n  return fireauth.RecaptchaRealLoader.instance_;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines the reCAPTCHA app verifier and its base class. The\n * former is currently used for web phone authentication whereas the latter is\n * used for the mobile app verification web fallback.\n */\ngoog.provide('fireauth.BaseRecaptchaVerifier');\ngoog.provide('fireauth.RecaptchaVerifier');\n\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.RecaptchaMockLoader');\ngoog.require('fireauth.RecaptchaRealLoader');\ngoog.require('fireauth.RpcHandler');\ngoog.require('fireauth.authenum.Error');\ngoog.require('fireauth.constants');\ngoog.require('fireauth.object');\ngoog.require('fireauth.util');\ngoog.require('goog.Promise');\ngoog.require('goog.array');\ngoog.require('goog.dom');\n\n\n/**\n * Creates the firebase base reCAPTCHA app verifier independent of Firebase\n * App or Auth instances.\n *\n * @param {string} apiKey The API key used to initialize the RPC handler for\n *     querying the Auth backend.\n * @param {!Element|string} container The reCAPTCHA container parameter. This\n *     has different meaning depending on whether the reCAPTCHA is hidden or\n *     visible.\n * @param {?Object=} opt_parameters The optional reCAPTCHA parameters.\n * @param {?(function():?string)=} opt_getLanguageCode The language code getter\n *     function.\n * @param {?string=} opt_clientVersion The optional client version to append to\n *     RPC header.\n * @param {?Object=} opt_rpcHandlerConfig The optional RPC handler\n *     configuration, typically passed when different Auth endpoints are to be\n *     used.\n * @param {boolean=} opt_isTestingMode Whether the reCAPTCHA is to be rendered\n *     in testing mode.\n * @constructor\n */\nfireauth.BaseRecaptchaVerifier = function(apiKey, container, opt_parameters,\n    opt_getLanguageCode, opt_clientVersion, opt_rpcHandlerConfig,\n    opt_isTestingMode) {\n  // Set the type readonly property needed for full implementation of the\n  // firebase.auth.ApplicationVerifier interface.\n  fireauth.object.setReadonlyProperty(this, 'type', 'recaptcha');\n  /**\n   * @private {?goog.Promise<void>} The cached reCAPTCHA ready response. This is\n   *     null until the first time it is triggered or when an error occurs in\n   *     getting ready.\n   */\n  this.cachedReadyPromise_ = null;\n  /** @private {?number} The reCAPTCHA widget ID. Null when not rendered. */\n  this.widgetId_ = null;\n  /** @private {boolean} Whether the instance is already destroyed. */\n  this.destroyed_ = false;\n  /** @private {!Element|string} The reCAPTCHA container. */\n  this.container_ = container;\n  /**\n   * @private {?fireauth.grecaptcha} The reCAPTCHA client library namespace.\n   */\n  this.grecaptcha_ = null;\n  /**\n   * @const @private {!fireauth.RecaptchaLoader} The grecaptcha loader.\n   */\n  this.recaptchaLoader_ = !!opt_isTestingMode ?\n      fireauth.RecaptchaMockLoader.getInstance() :\n      fireauth.RecaptchaRealLoader.getInstance();\n  // If no parameters passed, use default settings.\n  // Currently, visible recaptcha is the default setting as invisible reCAPTCHA\n  // is not yet supported by the backend.\n  /** @private {!Object} The reCAPTCHA parameters. */\n  this.parameters_ = opt_parameters || {\n    'theme': 'light',\n    'type': 'image'\n  };\n  /** @private {!Array<!goog.Promise<*>|!goog.Promise<void>>} List of\n   *      pending promises. */\n  this.pendingPromises_ = [];\n  if (this.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.SITEKEY]) {\n    // sitekey should not be provided.\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        'sitekey should not be provided for reCAPTCHA as one is ' +\n        'automatically provisioned for the current project.');\n  }\n  /** @private {boolean} Whether the reCAPTCHA is invisible or not. */\n  this.isInvisible_ =\n      this.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.SIZE] ===\n      'invisible';\n  // Check if DOM is supported.\n  if (!fireauth.util.isDOMSupported()) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.OPERATION_NOT_SUPPORTED,\n        'RecaptchaVerifier is only supported in a browser HTTP/HTTPS ' +\n        'environment with DOM support.');\n  }\n  // reCAPTCHA container must be valid and if visible, not empty.\n  // An invisible reCAPTCHA will not render in its container. That container\n  // will execute the reCAPTCHA when it is clicked.\n  if (!goog.dom.getElement(container) ||\n      (!this.isInvisible_ && goog.dom.getElement(container).hasChildNodes())) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        'reCAPTCHA container is either not found or already contains inner ' +\n        'elements!');\n  }\n  /**\n   * @private {!fireauth.RpcHandler} The RPC handler for querying the auth\n   *     backend.\n   */\n  this.rpcHandler_ = new fireauth.RpcHandler(\n      apiKey,\n      opt_rpcHandlerConfig || null,\n      opt_clientVersion || null);\n  /**\n   * @private {function():?string} Current language code getter.\n   */\n  this.getLanguageCode_ = opt_getLanguageCode || function() {return null;};\n  var self = this;\n  /**\n   * @private {!Array<function(?string)>} The token change listeners.\n   */\n  this.tokenListeners_ = [];\n  // Wrap token callback.\n  var existingCallback =\n      this.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.CALLBACK];\n  this.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.CALLBACK] =\n      function(response) {\n    // Dispatch internal event for the token response.\n    self.dispatchEvent_(response);\n    if (typeof existingCallback === 'function') {\n      existingCallback(response);\n    } else if (typeof existingCallback === 'string') {\n      // Check if the provided callback is a global function name.\n      var cb = fireauth.util.getObjectRef(existingCallback, goog.global);\n      if (typeof cb === 'function') {\n        // If so, trigger it.\n        cb(response);\n      }\n    }\n  };\n  // Wrap expired token callback.\n  var existingExpiredCallback = this.parameters_[\n    fireauth.BaseRecaptchaVerifier.ParamName.EXPIRED_CALLBACK];\n  this.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.EXPIRED_CALLBACK] =\n      function() {\n    // Dispatch internal event for the token expiration.\n    self.dispatchEvent_(null);\n    if (typeof existingExpiredCallback === 'function') {\n      existingExpiredCallback();\n    } else if (typeof existingExpiredCallback === 'string') {\n      // Check if the provided expired callback is a global function name.\n      var cb = fireauth.util.getObjectRef(existingExpiredCallback, goog.global);\n      if (typeof cb === 'function') {\n        // If so, trigger it.\n        cb();\n      }\n    }\n  };\n};\n\n\n/**\n * grecaptcha parameter names.\n * @enum {string}\n */\nfireauth.BaseRecaptchaVerifier.ParamName = {\n  CALLBACK: 'callback',\n  EXPIRED_CALLBACK: 'expired-callback',\n  SITEKEY: 'sitekey',\n  SIZE: 'size'\n};\n\n\n/**\n * Dispatches the token change event to all subscribed listeners.\n * @param {?string} token The current detected token, null for none.\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.dispatchEvent_ = function(token) {\n  for (var i = 0; i < this.tokenListeners_.length; i++) {\n    try {\n      this.tokenListeners_[i](token);\n    } catch (e) {\n      // If any handler fails, ignore and run next handler.\n    }\n  }\n};\n\n\n/**\n * Add a reCAPTCHA token change listener.\n * @param {function(?string)} listener The token listener to add.\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.addTokenChangeListener_ =\n    function(listener) {\n  this.tokenListeners_.push(listener);\n};\n\n\n/**\n * Remove a reCAPTCHA token change listener.\n * @param {function(?string)} listener The token listener to remove.\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.removeTokenChangeListener_ =\n    function(listener) {\n  goog.array.removeAllIf(this.tokenListeners_, function(ele) {\n    return ele == listener;\n  });\n};\n\n\n/**\n * Takes in a pending promise, saves it and adds a clean up callback which\n * forgets the pending promise after it is fulfilled and echoes the promise\n * back.\n * @param {!goog.Promise<*, *>|!goog.Promise<void>} p The pending promise.\n * @return {!goog.Promise<*, *>|!goog.Promise<void>}\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.registerPendingPromise_ = function(p) {\n  var self = this;\n  // Save created promise in pending list.\n  this.pendingPromises_.push(p);\n  p.thenAlways(function() {\n    // When fulfilled, remove from pending list.\n    goog.array.remove(self.pendingPromises_, p);\n  });\n  // Return the promise.\n  return p;\n};\n\n\n/** @return {boolean} Whether verifier instance has pending promises. */\nfireauth.BaseRecaptchaVerifier.prototype.hasPendingPromises = function() {\n  return this.pendingPromises_.length != 0;\n};\n\n\n/**\n * Gets the current RecaptchaVerifier in a ready state for rendering by first\n * checking that the environment supports a reCAPTCHA, loading reCAPTCHA\n * dependencies if not already available and then getting the Firebase project's\n * provisioned reCAPTCHA configuration.\n * @return {!goog.Promise<void>} The promise that resolves when recaptcha\n *     is ready for rendering.\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.isReady_ = function() {\n  var self = this;\n  // If previously called, return the cached response.\n  if (this.cachedReadyPromise_) {\n    return this.cachedReadyPromise_;\n  }\n  this.cachedReadyPromise_ = this.registerPendingPromise_(goog.Promise.resolve()\n      .then(function() {\n        // Verify environment first.\n        // Fail quickly from a worker environment or non-HTTP/HTTPS environment.\n        if (fireauth.util.isHttpOrHttps() && !fireauth.util.isWorker()) {\n          // Wait for DOM to be ready as this feature depends on that.\n          return fireauth.util.onDomReady();\n        } else {\n          throw new fireauth.AuthError(\n              fireauth.authenum.Error.OPERATION_NOT_SUPPORTED,\n              'RecaptchaVerifier is only supported in a browser HTTP/HTTPS ' +\n              'environment.');\n        }\n      })\n      .then(function() {\n        // Load external reCAPTCHA dependencies if not already there, taking\n        // into account the current language code.\n        return self.recaptchaLoader_.loadRecaptchaDeps(self.getLanguageCode_());\n      })\n      .then(function(grecaptcha) {\n        self.grecaptcha_ = grecaptcha;\n        // Load Firebase project's reCAPTCHA configuration.\n        return self.rpcHandler_.getRecaptchaParam();\n      })\n      .then(function(result) {\n        // Update the reCAPTCHA parameters.\n        self.parameters_[fireauth.BaseRecaptchaVerifier.ParamName.SITEKEY] =\n            result[fireauth.RpcHandler.AuthServerField.RECAPTCHA_SITE_KEY];\n      }).thenCatch(function(error) {\n        // Anytime an error occurs, reset the cached ready promise to rerun on\n        // retrial.\n        self.cachedReadyPromise_ = null;\n        // Rethrow the error.\n        throw error;\n      }));\n  // Return the cached/pending ready promise.\n  return this.cachedReadyPromise_;\n};\n\n/**\n * Renders the reCAPTCHA and returns the allocated widget ID.\n * @return {!goog.Promise<number>} The promise that resolves with the reCAPTCHA\n *     widget ID when it is rendered.\n */\nfireauth.BaseRecaptchaVerifier.prototype.render = function() {\n  this.checkIfDestroyed_();\n  var self = this;\n  // Get reCAPTCHA ready.\n  return this.registerPendingPromise_(this.isReady_().then(function() {\n    if (self.widgetId_ === null) {\n      // For a visible reCAPTCHA, embed in a wrapper DIV container to allow\n      // re-rendering in the same developer provided container.\n      var container = self.container_;\n      if (!self.isInvisible_) {\n        // Get outer container (the developer provided container).\n        var outerContainer = goog.dom.getElement(container);\n        // Create wrapper temp DIV container.\n        container = goog.dom.createDom(goog.dom.TagName.DIV);\n        // Add temp DIV to outer container.\n        outerContainer.appendChild(container);\n      }\n      // If not initialized, initialize reCAPTCHA and return its widget ID.\n      self.widgetId_ = self.grecaptcha_.render(container, self.parameters_);\n    }\n    return self.widgetId_;\n  }));\n};\n\n\n/**\n * Gets the reCAPTCHA ready and waits for the reCAPTCHA token to be available\n * before resolving the promise returned.\n * @return {!goog.Promise<string>} The promise that resolves with the reCAPTCHA\n *     token when reCAPTCHA challenge is solved.\n */\nfireauth.BaseRecaptchaVerifier.prototype.verify = function() {\n  // Fail if reCAPTCHA is already destroyed.\n  this.checkIfDestroyed_();\n  var self = this;\n  // Render reCAPTCHA.\n  return this.registerPendingPromise_(this.render().then(function(widgetId) {\n    return new goog.Promise(function(resolve, reject) {\n      // Get current reCAPTCHA token.\n      var recaptchaToken = self.grecaptcha_.getResponse(widgetId);\n      if (recaptchaToken) {\n        // Unexpired token already available. Resolve pending promise with that\n        // token.\n        resolve(recaptchaToken);\n      } else {\n        // No token available. Listen to token change.\n        var cb = function(token) {\n          if (!token) {\n            // Ignore token expirations.\n            return;\n          }\n          // Remove temporary token change listener.\n          self.removeTokenChangeListener_(cb);\n          // Resolve with new token.\n          resolve(token);\n        };\n        // Add temporary token change listener.\n        self.addTokenChangeListener_(cb);\n        if (self.isInvisible_) {\n          // Execute invisible reCAPTCHA to force a challenge.\n          // This should do nothing if already triggered either by developer or\n          // by a button click.\n          self.grecaptcha_.execute(/** @type {number} */ (self.widgetId_));\n        }\n      }\n    });\n  }));\n};\n\n\n/**\n * Resets the reCAPTCHA widget.\n */\nfireauth.BaseRecaptchaVerifier.prototype.reset = function() {\n  this.checkIfDestroyed_();\n  if (this.widgetId_ !== null) {\n    this.grecaptcha_.reset(this.widgetId_);\n  }\n};\n\n\n/**\n * Throws an error if the reCAPTCHA verifier is already cleared.\n * @private\n */\nfireauth.BaseRecaptchaVerifier.prototype.checkIfDestroyed_ = function() {\n  if (this.destroyed_) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.INTERNAL_ERROR,\n        'RecaptchaVerifier instance has been destroyed.');\n  }\n};\n\n\n/**\n * Removes the reCAPTCHA from the DOM.\n */\nfireauth.BaseRecaptchaVerifier.prototype.clear = function() {\n  this.checkIfDestroyed_();\n  this.destroyed_ = true;\n  // Decrement reCAPTCHA instance counter.\n  this.recaptchaLoader_.clearSingleRecaptcha();\n  // Cancel all pending promises.\n  for (var i = 0; i < this.pendingPromises_.length; i++) {\n    this.pendingPromises_[i].cancel(\n        'RecaptchaVerifier instance has been destroyed.');\n  }\n  if (!this.isInvisible_) {\n    goog.dom.removeChildren(goog.dom.getElement(this.container_));\n  }\n};\n\n\n/**\n * Creates the Firebase reCAPTCHA app verifier, publicly available, for the\n * Firebase app provided, used for web phone authentication.\n * This is a subclass of fireauth.BaseRecaptchaVerifier.\n *\n * @param {!Element|string} container The reCAPTCHA container parameter. This\n *     has different meaning depending on whether the reCAPTCHA is hidden or\n *     visible.\n * @param {?Object=} opt_parameters The optional reCAPTCHA parameters.\n * @param {?firebase.app.App=} opt_app The corresponding Firebase app.\n * @constructor\n * @extends {fireauth.BaseRecaptchaVerifier}\n */\nfireauth.RecaptchaVerifier = function(container, opt_parameters, opt_app) {\n  var isTestingMode = false;\n  var apiKey;\n  try {\n    /** @private {!firebase.app.App} The corresponding Firebase app instance. */\n    this.app_ = opt_app || firebase.app();\n  } catch (error) {\n    throw new fireauth.AuthError(\n        fireauth.authenum.Error.ARGUMENT_ERROR,\n        'No firebase.app.App instance is currently initialized.');\n  }\n  // API key is required for web client RPC calls.\n  if (this.app_.options && this.app_.options['apiKey']) {\n    apiKey = this.app_.options['apiKey'];\n  } else {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INVALID_API_KEY);\n  }\n  var self = this;\n  // Construct the language code getter based on the underlying Auth instance.\n  var getLanguageCode = function() {\n    var languageCode;\n    // Get the latest language setting.\n    // reCAPTCHA does not support updating the language of an already\n    // rendered reCAPTCHA. Reloading the SDK with the new hl will break\n    // the existing rendered localized reCAPTCHA. We will need to\n    // document that a new fireauth.BaseRecaptchaVerifier instance needs\n    // to be instantiated after the language is updated. Otherwise, the\n    // old language code will remain active on the existing instance.\n    try {\n      languageCode = self.app_['auth']().getLanguageCode();\n    } catch (e) {\n      languageCode = null;\n    }\n    return languageCode;\n  };\n  // Get the framework version from Auth instance.\n  var frameworkVersion = null;\n  try {\n    frameworkVersion = this.app_['auth']().getFramework();\n  } catch (e) {\n    // Do nothing.\n  }\n  try {\n    isTestingMode =\n        this.app_['auth']()['settings']['appVerificationDisabledForTesting'];\n  } catch (e) {\n    // Do nothing.\n  }\n  // Get the client version based on the Firebase JS version.\n  var clientFullVersion = firebase.SDK_VERSION ?\n      fireauth.util.getClientVersion(\n          fireauth.util.ClientImplementation.JSCORE, firebase.SDK_VERSION,\n          frameworkVersion) :\n      null;\n  // Call the superclass constructor with the computed API key, reCAPTCHA\n  // container, optional parameters, language code getter, Firebase JS client\n  // version and the current client configuration endpoints.\n  fireauth.RecaptchaVerifier.base(this, 'constructor', apiKey,\n      container, opt_parameters, getLanguageCode, clientFullVersion,\n      fireauth.constants.getEndpointConfig(fireauth.constants.clientEndpoint),\n      isTestingMode);\n};\ngoog.inherits(fireauth.RecaptchaVerifier, fireauth.BaseRecaptchaVerifier);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides function argument validation for third-party calls\n * that cannot be validated with Closure compiler.\n */\n\ngoog.provide('fireauth.args');\ngoog.provide('fireauth.args.Argument');\n\ngoog.require('fireauth.Auth');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthUser');\ngoog.require('fireauth.authenum.Error');\n\n\n/**\n * Represents an argument to a function. Fields:\n * <ul>\n * <li> name: A label for the argument. For example, the names of the arguments\n *      to a signIn() function might be \"email\" and \"password\".\n * <li> typeLabel: A label for the expected type of the argument, starting with\n *      an article, for example, \"an object\" or \"a valid credential\".\n * <li> optional: Whether or not this argument is optional. Optional arguments\n *      cannot come after non-optional arguments in the input to validate().\n * <li> validator: A function that takes the passed value of this argument\n *      and returns whether the value is valid or not.\n * </ul>\n * @typedef {{\n *   name: string,\n *   typeLabel: string,\n *   optional: boolean,\n *   validator: function (*) : boolean,\n * }}\n */\nfireauth.args.Argument;\n\n\n/**\n * Validates the arguments to a method call and throws an error if invalid. This\n * can be used to validate external calls where the Closure compiler cannot\n * detect errors.\n *\n * Example usage:\n * function greet(recipient, opt_useFormalLanguage) {\n *   fireauth.args.validate('greet', [\n *     fireauth.args.string('recipient'),\n *     fireauth.args.bool('opt_useFormalLanguage', true)\n *   ], arguments);\n *   if (opt_useFormalLanguage) {\n *     console.log('Good day, ' + recipient + '.');\n *   } else {\n *     console.log('Wassup, ' + recipient + '?');\n *   }\n * }\n * greet('Mr. Manager', true); // Prints 'Good day, Mr. Manager.'\n * greet('Billy Bob'); // Prints 'Wassup, Billy Bob?'\n * greet(133); // Throws 'greet failed: First argument \"recipient\" must be a\n *             // valid string.'\n * greet(); // Throws 'greet failed: Expected 1-2 arguments but got 0.'\n * greet('Mr. Manager', true, 'ohno'); // Throws 'greet failed: Expected 1-2\n *                                     // arguments but got 3.'\n *\n * This can also be used to validate setters by passing an additional true\n * argument to fireauth.args.validate. This modifies the error message to be\n * relevant for that setter.\n *\n * @param {string} apiName The name of the method being called, to display in\n *     the error message for debugging purposes.\n * @param {!Array<!fireauth.args.Argument>} expected The expected arguments.\n * @param {!IArrayLike} actual The arguments object of the function whose\n *     parameters we want to validate.\n * @param {boolean=} opt_isSetter Whether the function is a setter which takes\n *     a single argument.\n */\nfireauth.args.validate = function(apiName, expected, actual, opt_isSetter) {\n  // Convert the arguments object into a real array.\n  var actualAsArray = Array.prototype.slice.call(actual);\n  var errorMessage = fireauth.args.validateAndGetMessage_(\n      expected, actualAsArray, opt_isSetter);\n  if (errorMessage) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.ARGUMENT_ERROR,\n        apiName + ' failed: ' + errorMessage);\n  }\n};\n\n\n/**\n * @param {!Array<!fireauth.args.Argument>} expected\n * @param {!Array<*>} actual\n * @param {boolean=} opt_isSetter Whether the function is a setter which takes\n *     a single argument.\n * @return {?string} The error message if there is an error, or otherwise\n *     null.\n * @private\n */\nfireauth.args.validateAndGetMessage_ =\n    function(expected, actual, opt_isSetter) {\n  var minNumArgs = fireauth.args.calcNumRequiredArgs_(expected);\n  var maxNumArgs = expected.length;\n  if (actual.length < minNumArgs || maxNumArgs < actual.length) {\n    return fireauth.args.makeLengthError_(minNumArgs, maxNumArgs,\n        actual.length);\n  }\n\n  for (var i = 0; i < actual.length; i++) {\n    // Argument is optional and undefined is explicitly passed.\n    var optionalUndefined = expected[i].optional && actual[i] === undefined;\n    // Check if invalid argument and the argument is not optional with undefined\n    // passed.\n    if (!expected[i].validator(actual[i]) && !optionalUndefined) {\n      return fireauth.args.makeErrorAtPosition_(i, expected[i], opt_isSetter);\n    }\n  }\n\n  return null;\n};\n\n\n/**\n * @param {!Array<!fireauth.args.Argument>} expected\n * @return {number} The number of required arguments.\n * @private\n */\nfireauth.args.calcNumRequiredArgs_ = function(expected) {\n  var numRequiredArgs = 0;\n  var isOptionalSection = false;\n  for (var i = 0; i < expected.length; i++) {\n    if (expected[i].optional) {\n      isOptionalSection = true;\n    } else {\n      if (isOptionalSection) {\n        throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n            'Argument validator encountered a required argument after an ' +\n            'optional argument.');\n      }\n      numRequiredArgs++;\n    }\n  }\n  return numRequiredArgs;\n};\n\n\n/**\n * @param {number} min The minimum number of arguments to the function,\n *     inclusive.\n * @param {number} max The maximum number of arguments to the function,\n *     inclusive.\n * @param {number} actual The actual number of arguments received.\n * @return {string} The error message.\n * @private\n */\nfireauth.args.makeLengthError_ = function(min, max, actual) {\n  var numExpectedString;\n  if (min == max) {\n    if (min == 1) {\n      numExpectedString = '1 argument';\n    } else {\n      numExpectedString = min + ' arguments';\n    }\n  } else {\n    numExpectedString = min + '-' + max + ' arguments';\n  }\n  return 'Expected ' + numExpectedString + ' but got ' + actual + '.';\n};\n\n\n/**\n * @param {number} position The position at which there was an error.\n * @param {!fireauth.args.Argument} expectedType The expected type of the\n *     argument, which was violated.\n * @param {boolean=} opt_isSetter Whether the function is a setter which takes\n *     a single argument.\n * @return {string} The error message.\n * @private\n */\nfireauth.args.makeErrorAtPosition_ =\n    function(position, expectedType, opt_isSetter) {\n  var ordinal = fireauth.args.makeOrdinal_(position);\n  var argName = expectedType.name ?\n      fireauth.args.quoteString_(expectedType.name) + ' ' : '';\n  // Add support to setters for readable/writable properties which take a\n  // required single argument.\n  var errorPrefix = !!opt_isSetter ? '' : ordinal + ' argument ';\n  return errorPrefix + argName + 'must be ' +\n      expectedType.typeLabel + '.';\n};\n\n\n/** @private {!Array<string>} The first few ordinal numbers. */\nfireauth.args.ORDINAL_NUMBERS_ = ['First', 'Second', 'Third', 'Fourth',\n  'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth'];\n\n\n/**\n * @param {number} cardinal An integer.\n * @return {string} The integer converted to an ordinal number, starting at\n *     \"First\". That is, makeOrdinal_(0) returns \"First\" and makeOrdinal_(1)\n *     returns \"Second\", etc.\n * @private\n */\nfireauth.args.makeOrdinal_ = function(cardinal) {\n  // We only support the first few ordinal numbers. We could provide a more\n  // robust solution, but it is unlikely that a function would need more than\n  // nine arguments.\n  if (cardinal < 0 || cardinal >= fireauth.args.ORDINAL_NUMBERS_.length) {\n    throw new fireauth.AuthError(fireauth.authenum.Error.INTERNAL_ERROR,\n        'Argument validator received an unsupported number of arguments.');\n  }\n  return fireauth.args.ORDINAL_NUMBERS_[cardinal];\n};\n\n\n/**\n * Specifies a string argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.string = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'a valid string',\n    optional: !!opt_optional,\n    validator: goog.isString\n  };\n};\n\n\n/**\n * Specifies a boolean argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.bool = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'a boolean',\n    optional: !!opt_optional,\n    validator: goog.isBoolean\n  };\n};\n\n\n/**\n * Specifies a number argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.number = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'a valid number',\n    optional: !!opt_optional,\n    validator: goog.isNumber\n  };\n};\n\n\n/**\n * Specifies an object argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.object = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'a valid object',\n    optional: !!opt_optional,\n    validator: goog.isObject\n  };\n};\n\n\n/**\n * Specifies a function argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.func = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'a function',\n    optional: !!opt_optional,\n    validator: goog.isFunction\n  };\n};\n\n\n/**\n * Specifies a null argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.null = function(opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: 'null',\n    optional: !!opt_optional,\n    validator: goog.isNull\n  };\n};\n\n\n/**\n * Specifies an HTML element argument.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.element = function(opt_name, opt_optional) {\n   return /** @type {!fireauth.args.Argument} */ ({\n    name: opt_name || '',\n    typeLabel: 'an HTML element',\n    optional: !!opt_optional,\n    validator: /** @type {function(!Element) : boolean} */ (\n        function(element) {\n          return !!(element && element instanceof Element);\n        })\n  });\n};\n\n\n/**\n * Specifies an instance of Firebase Auth.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.firebaseAuth = function(opt_optional) {\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: 'auth',\n    typeLabel: 'an instance of Firebase Auth',\n    optional: !!opt_optional,\n    validator: /** @type {function(!fireauth.Auth) : boolean} */ (\n        function(auth) {\n          return !!(auth && auth instanceof fireauth.Auth);\n        })\n  });\n};\n\n\n/**\n * Specifies an instance of Firebase User.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.firebaseUser = function(opt_optional) {\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: 'user',\n    typeLabel: 'an instance of Firebase User',\n    optional: !!opt_optional,\n    validator: /** @type {function(!fireauth.AuthUser) : boolean} */ (\n        function(user) {\n          return !!(user && user instanceof fireauth.AuthUser);\n        })\n  });\n};\n\n\n/**\n * Specifies an instance of Firebase App.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.firebaseApp = function(opt_optional) {\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: 'app',\n    typeLabel: 'an instance of Firebase App',\n    optional: !!opt_optional,\n    validator: /** @type {function(!firebase.app.App) : boolean} */ (\n        function(app) {\n          return !!(app && app instanceof firebase.app.App);\n        })\n  });\n};\n\n\n/**\n * Specifies an argument that implements the fireauth.AuthCredential interface.\n * @param {?fireauth.idp.ProviderId=} opt_requiredProviderId The required type\n *     of provider.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.authCredential =\n    function(opt_requiredProviderId, opt_name, opt_optional) {\n  var name = opt_name ||\n      (opt_requiredProviderId ?\n       opt_requiredProviderId + 'Credential' :\n       'credential');\n  var typeLabel = opt_requiredProviderId ?\n      'a valid ' + opt_requiredProviderId + ' credential' :\n      'a valid credential';\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: name,\n    typeLabel: typeLabel,\n    optional: !!opt_optional,\n    validator: /** @type {function(!fireauth.AuthCredential) : boolean} */ (\n        function(credential) {\n          if (!credential) {\n            return false;\n          }\n          // If opt_requiredProviderId is set, make sure it matches the\n          // credential's providerId.\n          var matchesRequiredProvider = !opt_requiredProviderId ||\n              (credential['providerId'] === opt_requiredProviderId);\n          return !!(credential.getIdTokenProvider && matchesRequiredProvider);\n        })\n  });\n};\n\n\n/**\n * Specifies an argument that implements the fireauth.AuthProvider interface.\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.authProvider = function(opt_name, opt_optional) {\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: opt_name || 'authProvider',\n    typeLabel: 'a valid Auth provider',\n    optional: !!opt_optional,\n    validator: /** @type {function(!fireauth.AuthProvider) : boolean} */ (\n        function(provider) {\n          return !!(provider &&\n                    provider['providerId'] &&\n                    provider.hasOwnProperty &&\n                    provider.hasOwnProperty('isOAuthProvider'));\n        })\n  });\n};\n\n\n/**\n * Specifies an argument that implements the firebase.auth.ApplicationVerifier\n * interface.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.applicationVerifier = function(opt_optional) {\n  return /** @type {!fireauth.args.Argument} */ ({\n    name: 'applicationVerifier',\n    typeLabel: 'an implementation of firebase.auth.ApplicationVerifier',\n    optional: !!opt_optional,\n    validator:\n        /** @type {function(!firebase.auth.ApplicationVerifier) : boolean} */ (\n        function(applicationVerifier) {\n          return !!(applicationVerifier &&\n                    goog.isString(applicationVerifier.type) &&\n                    goog.isFunction(applicationVerifier.verify));\n        })\n  });\n};\n\n\n/**\n * Specifies an argument that can be either of two argument types.\n * @param {!fireauth.args.Argument} optionA\n * @param {!fireauth.args.Argument} optionB\n * @param {?string=} opt_name The name of the argument.\n * @param {?boolean=} opt_optional Whether or not this argument is optional.\n *     Defaults to false.\n * @return {!fireauth.args.Argument}\n */\nfireauth.args.or = function(optionA, optionB, opt_name, opt_optional) {\n  return {\n    name: opt_name || '',\n    typeLabel: optionA.typeLabel + ' or ' + optionB.typeLabel,\n    optional: !!opt_optional,\n    validator: function(value) {\n      return optionA.validator(value) || optionB.validator(value);\n    }\n  };\n};\n\n\n/**\n * @param {string} str\n * @return {string} The string surrounded with quotes.\n * @private\n */\nfireauth.args.quoteString_ = function(str) {\n  return '\"' + str + '\"';\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides utilities for exporting public APIs, with error\n *     checking.\n */\n\ngoog.provide('fireauth.exportlib');\ngoog.provide('fireauth.exportlib.ExportedMethod');\n\ngoog.require('fireauth.args');\n\n\n/**\n * Type constant for Firebase Auth.\n * @const {string}\n */\nfireauth.exportlib.AUTH_TYPE = 'auth';\n\n\n/**\n * Represents an exported method, with the exported name of the method and the\n * expected arguments to that method.\n * @typedef {{\n *   name: string,\n *   args: (Array<!fireauth.args.Argument>|null|undefined)\n * }}\n */\nfireauth.exportlib.ExportedMethod;\n\n\n/**\n * Represents an exported property, with the exported name of the property and\n * the expected argument to the setter of this property.\n * @typedef {{\n *   name: string,\n *   arg: !fireauth.args.Argument\n * }}\n */\nfireauth.exportlib.ExportedProperty;\n\n\n/**\n * Exports prototype methods of an object.\n * @param {!Object} protObj The prototype of an object.\n * @param {!Object<string, fireauth.exportlib.ExportedMethod>} fnMap The map of\n *     prototype functions to their export name and expected arguments.\n */\nfireauth.exportlib.exportPrototypeMethods = function(protObj, fnMap) {\n  // This method exports methods by aliasing the unobfuscated function name\n  // (specified as a string in the \"name\" field of ExportedMethod) to the\n  // obfuscated function name (specified as a key of the fnMap object).\n  //\n  // To give a concrete example, let's say that we have this method:\n  // fireauth.Auth.prototype.fetchProvidersForEmail = function() { ... };\n  //\n  // In the exports file, we export as follows:\n  // fireauth.exportlib.exportPrototypeMethods(fireauth.Auth.prototype, {\n  //   fetchProvidersForEmail: {name: 'fetchProvidersForEmail', args: ...}\n  // });\n  //\n  // When the compiler obfuscates the code, the code above will become something\n  // like this:\n  // fireauth.Auth.prototype.qZ = function() { ... };\n  // fireauth.exportlib.exportPrototypeMethods(fireauth.Auth.prototype, {\n  //   qZ: {name: 'fetchProvidersForEmail', args: ...}\n  // });\n  //\n  // (Of course, fireauth.Auth and fireauth.exportlib.exportPrototypeMethods\n  // would also be obfuscated). Note that the key in fnMap is obfuscated but the\n  // \"name\" field in the ExportedMethod is not. Now, exportPrototypeMethods can\n  // export fetchProvidersForEmail by reading the key (\"qZ\") and the \"name\"\n  // field (\"fetchProvidersForEmail\") and essentially executing this:\n  // fireauth.Auth.prototype['fetchProvidersForEmail'] =\n  //     fireauth.Auth.prototype['qZ'];\n  for (var obfuscatedFnName in fnMap) {\n    var unobfuscatedFnName = fnMap[obfuscatedFnName].name;\n    protObj[unobfuscatedFnName] =\n        fireauth.exportlib.wrapMethodWithArgumentVerifier_(\n        unobfuscatedFnName, protObj[obfuscatedFnName],\n        fnMap[obfuscatedFnName].args);\n  }\n};\n\n\n/**\n * Exports properties of an object. See the docs for exportPrototypeMethods for\n * more information about how this works.\n * @param {!Object} protObj The prototype of an object.\n * @param {!Object<string, !fireauth.exportlib.ExportedProperty>} propMap The\n *     map of properties to their export names.\n */\nfireauth.exportlib.exportPrototypeProperties = function(protObj, propMap) {\n  for (var obfuscatedPropName in propMap) {\n    var unobfuscatedPropName = propMap[obfuscatedPropName].name;\n    // Don't alias a property to itself.\n    // Downside is that argument validation will not be possible. For now, to\n    // get around it, ensure unobfuscated property names are different\n    // than the corresponding obfuscated property names.\n    if (unobfuscatedPropName === obfuscatedPropName) {\n      continue;\n    }\n    /**\n     * @this {!Object}\n     * @param {string} obfuscatedPropName The obfuscated property name.\n     * @return {*} The value of the property.\n     */\n    var getter = function(obfuscatedPropName) {\n      return this[obfuscatedPropName];\n    };\n    /**\n     * @this {!Object}\n     * @param {string} unobfuscatedPropName The unobfuscated property name.\n     * @param {string} obfuscatedPropName The obfuscated property name.\n     * @param {!fireauth.args.Argument} expectedArg The expected argument to the\n     *     setter of this property.\n     * @param {*} value The new value of the property.\n     */\n    var setter = function(unobfuscatedPropName, obfuscatedPropName,\n                          expectedArg, value) {\n      // Validate the argument before setting it.\n      fireauth.args.validate(\n          unobfuscatedPropName, [expectedArg], [value], true);\n      this[obfuscatedPropName] = value;\n    };\n    // Get the expected argument.\n    var expectedArg = propMap[obfuscatedPropName].arg;\n    Object.defineProperty(protObj, unobfuscatedPropName, {\n      /**\n       * @this {!Object}\n       * @return {*} The value of the property.\n       */\n      get: goog.partial(getter, obfuscatedPropName),\n      /**\n       * @this {!Object}\n       * @param {*} value The new value of the property.\n       */\n      set: goog.partial(setter, unobfuscatedPropName, obfuscatedPropName,\n                        expectedArg),\n      enumerable: true\n    });\n  }\n};\n\n\n/**\n * Export a static method as a public API.\n * @param {!Object} parentObj The parent object to patch.\n * @param {string} name The public name of the method.\n * @param {!Function} func The method.\n * @param {?Array<!fireauth.args.Argument>=} opt_expectedArgs The expected\n *     arguments to the method.\n */\nfireauth.exportlib.exportFunction = function(parentObj, name, func,\n    opt_expectedArgs) {\n  parentObj[name] = fireauth.exportlib.wrapMethodWithArgumentVerifier_(\n      name, func, opt_expectedArgs);\n};\n\n\n/**\n * Wraps a method with a function that first verifies the arguments to the\n * method and then calls the original method.\n * @param {string} methodName The name of the method, which will be displayed\n *     on the error message if the arguments are not valid.\n * @param {!Function} method The method to be wrapped.\n * @param {?Array<!fireauth.args.Argument>=} opt_expectedArgs The expected\n *     arguments.\n * @return {!Function} The wrapped method.\n * @private\n */\nfireauth.exportlib.wrapMethodWithArgumentVerifier_ = function(methodName,\n    method, opt_expectedArgs) {\n  if (!opt_expectedArgs) {\n    return method;\n  }\n  var shortName = fireauth.exportlib.extractMethodNameFromFullPath_(methodName);\n  var wrapper = function() {\n    var argumentsAsArray = Array.prototype.slice.call(arguments);\n    fireauth.args.validate(shortName,\n        /** @type {!Array<!fireauth.args.Argument>} */ (opt_expectedArgs),\n        argumentsAsArray);\n    return method.apply(this, argumentsAsArray);\n  };\n  // Reattach all static stuff to wrapper.\n  for (var key in method) {\n    wrapper[key] = method[key];\n  }\n  // Reattach all prototype stuff to wrapper.\n  for (var key in method.prototype) {\n    wrapper.prototype[key] = method.prototype[key];\n  }\n  // Return wrapper with all of method's static and prototype methods and\n  // properties.\n  return wrapper;\n};\n\n\n/**\n * From a full path to a method (e.g. \"fireauth.GoogleAuthProvider.credential\"),\n * get just the method name (\"credential\").\n * @param {string} path The full path.\n * @return {string} The method name.\n * @private\n */\nfireauth.exportlib.extractMethodNameFromFullPath_ = function(path) {\n  var parts = path.split('.');\n  return parts[parts.length - 1];\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ngoog.provide('fireauth.exports');\n\ngoog.require('fireauth.ActionCodeInfo');\ngoog.require('fireauth.ActionCodeURL');\ngoog.require('fireauth.Auth');\ngoog.require('fireauth.AuthCredential');\ngoog.require('fireauth.AuthError');\ngoog.require('fireauth.AuthErrorWithCredential');\ngoog.require('fireauth.AuthSettings');\ngoog.require('fireauth.AuthUser');\ngoog.require('fireauth.ConfirmationResult');\ngoog.require('fireauth.EmailAuthCredential');\ngoog.require('fireauth.EmailAuthProvider');\ngoog.require('fireauth.FacebookAuthProvider');\ngoog.require('fireauth.GRecaptchaMockFactory');\ngoog.require('fireauth.GithubAuthProvider');\ngoog.require('fireauth.GoogleAuthProvider');\ngoog.require('fireauth.InvalidOriginError');\ngoog.require('fireauth.OAuthCredential');\ngoog.require('fireauth.OAuthProvider');\ngoog.require('fireauth.PhoneAuthCredential');\ngoog.require('fireauth.PhoneAuthProvider');\ngoog.require('fireauth.RecaptchaVerifier');\ngoog.require('fireauth.SAMLAuthCredential');\ngoog.require('fireauth.SAMLAuthProvider');\ngoog.require('fireauth.TwitterAuthProvider');\ngoog.require('fireauth.args');\ngoog.require('fireauth.authStorage.Persistence');\ngoog.require('fireauth.exportlib');\ngoog.require('fireauth.grecaptcha');\ngoog.require('fireauth.idp.ProviderId');\ngoog.require('goog.Promise');\n\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.Auth.prototype, {\n      applyActionCode: {\n        name: 'applyActionCode',\n        args: [fireauth.args.string('code')]\n      },\n      checkActionCode: {\n        name: 'checkActionCode',\n        args: [fireauth.args.string('code')]\n      },\n      confirmPasswordReset: {\n        name: 'confirmPasswordReset',\n        args: [\n          fireauth.args.string('code'),\n          fireauth.args.string('newPassword')\n        ]\n      },\n      createUserWithEmailAndPassword: {\n        name: 'createUserWithEmailAndPassword',\n        args: [fireauth.args.string('email'), fireauth.args.string('password')]\n      },\n      fetchSignInMethodsForEmail: {\n        name: 'fetchSignInMethodsForEmail',\n        args: [fireauth.args.string('email')]\n      },\n      getRedirectResult: {\n        name: 'getRedirectResult',\n        args: []\n      },\n      isSignInWithEmailLink: {\n        name: 'isSignInWithEmailLink',\n        args: [fireauth.args.string('emailLink')]\n      },\n      onAuthStateChanged: {\n        name: 'onAuthStateChanged',\n        args: [\n          fireauth.args.or(\n              fireauth.args.object(),\n              fireauth.args.func(),\n              'nextOrObserver'),\n          fireauth.args.func('opt_error', true),\n          fireauth.args.func('opt_completed', true)\n        ]\n      },\n      onIdTokenChanged: {\n        name: 'onIdTokenChanged',\n        args: [\n          fireauth.args.or(\n              fireauth.args.object(),\n              fireauth.args.func(),\n              'nextOrObserver'),\n          fireauth.args.func('opt_error', true),\n          fireauth.args.func('opt_completed', true)\n        ]\n      },\n      sendPasswordResetEmail: {\n        name: 'sendPasswordResetEmail',\n        args: [\n          fireauth.args.string('email'),\n          fireauth.args.or(\n              fireauth.args.object('opt_actionCodeSettings', true),\n              fireauth.args.null(null, true),\n              'opt_actionCodeSettings',\n              true)\n        ]\n      },\n      sendSignInLinkToEmail: {\n        name: 'sendSignInLinkToEmail',\n        args: [\n          fireauth.args.string('email'),\n          fireauth.args.object('actionCodeSettings')\n        ]\n      },\n      setPersistence: {\n        name: 'setPersistence',\n        args:  [fireauth.args.string('persistence')]\n      },\n      signInAndRetrieveDataWithCredential: {\n        name: 'signInAndRetrieveDataWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      signInAnonymously: {\n        name: 'signInAnonymously',\n        args: []\n      },\n      signInWithCredential: {\n        name: 'signInWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      signInWithCustomToken: {\n        name: 'signInWithCustomToken',\n        args: [fireauth.args.string('token')]\n      },\n      signInWithEmailAndPassword: {\n        name: 'signInWithEmailAndPassword',\n        args: [fireauth.args.string('email'), fireauth.args.string('password')]\n      },\n      signInWithEmailLink: {\n        name: 'signInWithEmailLink',\n        args: [\n          fireauth.args.string('email'), fireauth.args.string('emailLink', true)\n        ]\n      },\n      signInWithPhoneNumber: {\n        name: 'signInWithPhoneNumber',\n        args: [\n          fireauth.args.string('phoneNumber'),\n          fireauth.args.applicationVerifier()\n        ]\n      },\n      signInWithPopup: {\n        name: 'signInWithPopup',\n        args: [fireauth.args.authProvider()]\n      },\n      signInWithRedirect: {\n        name: 'signInWithRedirect',\n        args: [fireauth.args.authProvider()]\n      },\n      updateCurrentUser: {\n        name: 'updateCurrentUser',\n        args: [\n          fireauth.args.or(\n            fireauth.args.firebaseUser(),\n            fireauth.args.null(),\n            'user')\n        ]\n      },\n      signOut: {\n        name: 'signOut',\n        args: []\n      },\n      toJSON: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      },\n      useDeviceLanguage: {\n        name: 'useDeviceLanguage',\n        args: []\n      },\n      verifyPasswordResetCode: {\n        name: 'verifyPasswordResetCode',\n        args: [fireauth.args.string('code')]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeProperties(\n    fireauth.Auth.prototype, {\n      'lc': {\n        name: 'languageCode',\n        arg: fireauth.args.or(\n            fireauth.args.string(),\n            fireauth.args.null(),\n            'languageCode')\n      },\n      'ti': {\n        name: 'tenantId',\n        arg: fireauth.args.or(\n            fireauth.args.string(),\n            fireauth.args.null(),\n            'tenantId')\n      }\n    });\n\n// Exports firebase.auth.Auth.Persistence.\nfireauth.Auth['Persistence'] = fireauth.authStorage.Persistence;\nfireauth.Auth['Persistence']['LOCAL'] = fireauth.authStorage.Persistence.LOCAL;\nfireauth.Auth['Persistence']['SESSION'] =\n    fireauth.authStorage.Persistence.SESSION;\nfireauth.Auth['Persistence']['NONE'] = fireauth.authStorage.Persistence.NONE;\n\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.AuthUser.prototype, {\n      'delete': {\n        name: 'delete',\n        args: []\n      },\n      getIdTokenResult: {\n        name: 'getIdTokenResult',\n        args: [fireauth.args.bool('opt_forceRefresh', true)]\n      },\n      getIdToken: {\n        name: 'getIdToken',\n        args: [fireauth.args.bool('opt_forceRefresh', true)]\n      },\n      linkAndRetrieveDataWithCredential: {\n        name: 'linkAndRetrieveDataWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      linkWithCredential: {\n        name: 'linkWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      linkWithPhoneNumber: {\n        name: 'linkWithPhoneNumber',\n        args: [\n          fireauth.args.string('phoneNumber'),\n          fireauth.args.applicationVerifier()\n        ]\n      },\n      linkWithPopup: {\n        name: 'linkWithPopup',\n        args: [fireauth.args.authProvider()]\n      },\n      linkWithRedirect: {\n        name: 'linkWithRedirect',\n        args: [fireauth.args.authProvider()]\n      },\n      reauthenticateAndRetrieveDataWithCredential: {\n        name: 'reauthenticateAndRetrieveDataWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      reauthenticateWithCredential: {\n        name: 'reauthenticateWithCredential',\n        args: [fireauth.args.authCredential()]\n      },\n      reauthenticateWithPhoneNumber: {\n        name: 'reauthenticateWithPhoneNumber',\n        args: [\n          fireauth.args.string('phoneNumber'),\n          fireauth.args.applicationVerifier()\n        ]\n      },\n      reauthenticateWithPopup: {\n        name: 'reauthenticateWithPopup',\n        args: [fireauth.args.authProvider()]\n      },\n      reauthenticateWithRedirect: {\n        name: 'reauthenticateWithRedirect',\n        args: [fireauth.args.authProvider()]\n      },\n      reload: {\n        name: 'reload',\n        args: []\n      },\n      sendEmailVerification: {\n        name: 'sendEmailVerification',\n        args: [\n          fireauth.args.or(\n              fireauth.args.object('opt_actionCodeSettings', true),\n              fireauth.args.null(null, true),\n              'opt_actionCodeSettings',\n              true)\n        ]\n      },\n      toJSON: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      },\n      unlink: {\n        name: 'unlink',\n        args: [fireauth.args.string('provider')]\n      },\n      updateEmail: {\n        name: 'updateEmail',\n        args: [fireauth.args.string('email')]\n      },\n      updatePassword: {\n        name: 'updatePassword',\n        args: [fireauth.args.string('password')]\n      },\n      updatePhoneNumber: {\n        name: 'updatePhoneNumber',\n        args: [fireauth.args.authCredential(fireauth.idp.ProviderId.PHONE)]\n      },\n      updateProfile: {\n        name: 'updateProfile',\n        args: [fireauth.args.object('profile')]\n      }\n    });\n\n// Ensure internal grecaptcha mock API do not get obfuscated.\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.GRecaptchaMockFactory.prototype, {\n      execute: {\n        name: 'execute'\n      },\n      render: {\n        name: 'render'\n      },\n      reset: {\n        name: 'reset'\n      },\n      getResponse: {\n        name: 'getResponse'\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.grecaptcha.prototype, {\n      execute: {\n        name: 'execute'\n      },\n      render: {\n        name: 'render'\n      },\n      reset: {\n        name: 'reset'\n      },\n      getResponse: {\n        name: 'getResponse'\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    goog.Promise.prototype, {\n      thenAlways: {\n        name: 'finally'\n      },\n      thenCatch: {\n        name: 'catch'\n      },\n      then: {\n        name: 'then'\n      }\n    });\n\nfireauth.exportlib.exportPrototypeProperties(\n    fireauth.AuthSettings.prototype, {\n      'appVerificationDisabled': {\n        name: 'appVerificationDisabledForTesting',\n        arg: fireauth.args.bool('appVerificationDisabledForTesting')\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n   fireauth.ConfirmationResult.prototype, {\n      confirm: {\n        name: 'confirm',\n        args: [\n          fireauth.args.string('verificationCode')\n        ]\n      }\n    });\n\nfireauth.exportlib.exportFunction(\n    fireauth.AuthCredential, 'fromJSON',\n    fireauth.AuthCredential.fromPlainObject, [\n      fireauth.args.or(fireauth.args.string(), fireauth.args.object(), 'json')\n    ]);\n\nfireauth.exportlib.exportFunction(\n    fireauth.EmailAuthProvider, 'credential',\n    fireauth.EmailAuthProvider.credential, [\n      fireauth.args.string('email'),\n      fireauth.args.string('password')\n    ]);\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.EmailAuthCredential.prototype, {\n     toPlainObject: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.FacebookAuthProvider.prototype, {\n      addScope: {\n        name: 'addScope',\n        args: [fireauth.args.string('scope')]\n      },\n      setCustomParameters: {\n        name: 'setCustomParameters',\n        args: [fireauth.args.object('customOAuthParameters')]\n      }\n    });\nfireauth.exportlib.exportFunction(\n    fireauth.FacebookAuthProvider, 'credential',\n    fireauth.FacebookAuthProvider.credential, [\n      fireauth.args.or(fireauth.args.string(), fireauth.args.object(),\n          'token')\n    ]);\nfireauth.exportlib.exportFunction(\n    fireauth.EmailAuthProvider, 'credentialWithLink',\n    fireauth.EmailAuthProvider.credentialWithLink, [\n      fireauth.args.string('email'),\n      fireauth.args.string('emailLink')\n    ]);\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.GithubAuthProvider.prototype, {\n      addScope: {\n        name: 'addScope',\n        args: [fireauth.args.string('scope')]\n      },\n      setCustomParameters: {\n        name: 'setCustomParameters',\n        args: [fireauth.args.object('customOAuthParameters')]\n      }\n    });\nfireauth.exportlib.exportFunction(\n    fireauth.GithubAuthProvider, 'credential',\n    fireauth.GithubAuthProvider.credential, [\n      fireauth.args.or(fireauth.args.string(), fireauth.args.object(),\n          'token')\n    ]);\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.GoogleAuthProvider.prototype, {\n      addScope: {\n        name: 'addScope',\n        args: [fireauth.args.string('scope')]\n      },\n      setCustomParameters: {\n        name: 'setCustomParameters',\n        args: [fireauth.args.object('customOAuthParameters')]\n      }\n    });\nfireauth.exportlib.exportFunction(\n    fireauth.GoogleAuthProvider, 'credential',\n    fireauth.GoogleAuthProvider.credential, [\n      fireauth.args.or(fireauth.args.string(),\n          fireauth.args.or(fireauth.args.object(), fireauth.args.null()),\n          'idToken'),\n      fireauth.args.or(fireauth.args.string(), fireauth.args.null(),\n          'accessToken', true)\n    ]);\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.TwitterAuthProvider.prototype, {\n      setCustomParameters: {\n        name: 'setCustomParameters',\n        args: [fireauth.args.object('customOAuthParameters')]\n      }\n    });\nfireauth.exportlib.exportFunction(\n    fireauth.TwitterAuthProvider, 'credential',\n    fireauth.TwitterAuthProvider.credential, [\n      fireauth.args.or(fireauth.args.string(), fireauth.args.object(),\n          'token'),\n      fireauth.args.string('secret', true)\n    ]);\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.OAuthProvider.prototype, {\n      addScope: {\n        name: 'addScope',\n        args: [fireauth.args.string('scope')]\n      },\n      credential: {\n        name: 'credential',\n        args: [\n          fireauth.args.or(\n              fireauth.args.string(),\n              fireauth.args.or(fireauth.args.object(), fireauth.args.null()),\n              'optionsOrIdToken'),\n          fireauth.args.or(fireauth.args.string(), fireauth.args.null(),\n              'accessToken', true)\n        ]\n      },\n      setCustomParameters: {\n        name: 'setCustomParameters',\n        args: [fireauth.args.object('customOAuthParameters')]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.OAuthCredential.prototype, {\n     toPlainObject: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.SAMLAuthCredential.prototype, {\n     toPlainObject: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\n\nfireauth.exportlib.exportFunction(\n    fireauth.PhoneAuthProvider, 'credential',\n    fireauth.PhoneAuthProvider.credential, [\n      fireauth.args.string('verificationId'),\n      fireauth.args.string('verificationCode')\n    ]);\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.PhoneAuthProvider.prototype, {\n      verifyPhoneNumber: {\n        name: 'verifyPhoneNumber',\n        args: [\n          fireauth.args.string('phoneNumber'),\n          fireauth.args.applicationVerifier()\n        ]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.PhoneAuthCredential.prototype, {\n     toPlainObject: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.AuthError.prototype, {\n      toJSON: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.AuthErrorWithCredential.prototype, {\n      toJSON: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.InvalidOriginError.prototype, {\n      toJSON: {\n        name: 'toJSON',\n        // This shouldn't take an argument but a blank string is being passed\n        // on JSON.stringify and causing this to fail with an argument error.\n        // So allow an optional string.\n        args: [fireauth.args.string(null, true)]\n      }\n    });\n\nfireauth.exportlib.exportPrototypeMethods(\n    fireauth.RecaptchaVerifier.prototype, {\n      clear: {\n        name: 'clear',\n        args: []\n      },\n      render: {\n        name: 'render',\n        args: []\n      },\n      verify: {\n        name: 'verify',\n        args: []\n      }\n    });\n\nfireauth.exportlib.exportFunction(\n    fireauth.ActionCodeURL, 'parseLink',\n    fireauth.ActionCodeURL.parseLink, [fireauth.args.string('link')]);\n\n\n(function() {\n  if (typeof firebase === 'undefined' || !firebase.INTERNAL ||\n      !firebase.INTERNAL.registerService) {\n    throw new Error('Cannot find the firebase namespace; be sure to include ' +\n        'firebase-app.js before this library.');\n  } else {\n    /** @type {!firebase.ServiceFactory} */\n    var factory = function(app, extendApp) {\n      var auth = new fireauth.Auth(app);\n      extendApp({\n        'INTERNAL': {\n          // Extend app.INTERNAL.getUid.\n          'getUid': goog.bind(auth.getUid, auth),\n          'getToken': goog.bind(auth.getIdTokenInternal, auth),\n          'addAuthTokenListener':\n              goog.bind(auth.addAuthTokenListenerInternal, auth),\n          'removeAuthTokenListener':\n              goog.bind(auth.removeAuthTokenListenerInternal, auth)\n        }\n      });\n      return auth;\n    };\n\n    var namespace = {\n      // Exports firebase.auth.ActionCodeInfo.Operation.\n      'ActionCodeInfo': {\n        'Operation': {\n          'EMAIL_SIGNIN': fireauth.ActionCodeInfo.Operation.EMAIL_SIGNIN,\n          'PASSWORD_RESET': fireauth.ActionCodeInfo.Operation.PASSWORD_RESET,\n          'RECOVER_EMAIL': fireauth.ActionCodeInfo.Operation.RECOVER_EMAIL,\n          'VERIFY_EMAIL': fireauth.ActionCodeInfo.Operation.VERIFY_EMAIL\n        }\n      },\n      'Auth': fireauth.Auth,\n      'AuthCredential': fireauth.AuthCredential,\n      'Error': fireauth.AuthError\n    };\n    fireauth.exportlib.exportFunction(namespace,\n        'EmailAuthProvider', fireauth.EmailAuthProvider, []);\n    fireauth.exportlib.exportFunction(namespace,\n        'FacebookAuthProvider', fireauth.FacebookAuthProvider, []);\n    fireauth.exportlib.exportFunction(namespace,\n        'GithubAuthProvider', fireauth.GithubAuthProvider, []);\n    fireauth.exportlib.exportFunction(namespace,\n        'GoogleAuthProvider', fireauth.GoogleAuthProvider, []);\n    fireauth.exportlib.exportFunction(namespace,\n        'TwitterAuthProvider', fireauth.TwitterAuthProvider, []);\n    fireauth.exportlib.exportFunction(namespace,\n        'OAuthProvider', fireauth.OAuthProvider, [\n          fireauth.args.string('providerId')\n        ]);\n    fireauth.exportlib.exportFunction(namespace,\n        'SAMLAuthProvider', fireauth.SAMLAuthProvider, [\n          fireauth.args.string('providerId')\n        ]);\n    fireauth.exportlib.exportFunction(namespace,\n        'PhoneAuthProvider', fireauth.PhoneAuthProvider, [\n          fireauth.args.firebaseAuth(true)\n        ]);\n    fireauth.exportlib.exportFunction(namespace,\n        'RecaptchaVerifier', fireauth.RecaptchaVerifier, [\n          fireauth.args.or(\n              fireauth.args.string(),\n              fireauth.args.element(),\n              'recaptchaContainer'),\n          fireauth.args.object('recaptchaParameters', true),\n          fireauth.args.firebaseApp(true)\n        ]);\n    fireauth.exportlib.exportFunction(namespace,\n        'ActionCodeURL', fireauth.ActionCodeURL, []);\n\n    // Register Auth service with firebase.App.\n    firebase.INTERNAL.registerService(\n        fireauth.exportlib.AUTH_TYPE,\n        factory,\n        namespace,\n        // Initialize Auth when an App is created, so that tokens and Auth state\n        // listeners are available.\n        function (event, app) {\n          if (event === 'create') {\n            try {\n              app[fireauth.exportlib.AUTH_TYPE]();\n            } catch (e) {\n              // This is a silent operation in the background. If the auth\n              // initialization fails, it should not cause a fatal error.\n              // Instead when the developer tries to initialize again manually,\n              // the error will be thrown.\n              // One specific use case here is the initialization for the nodejs\n              // client when no API key is provided. This is commonly used\n              // for unauthenticated database access.\n            }\n          }\n        }\n        );\n\n\n    // Expose User as firebase.User.\n    firebase.INTERNAL.extendNamespace({\n      'User': fireauth.AuthUser\n    });\n  }\n})();\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { jsonEval, stringify } from '@firebase/util';\n\n/**\n * Wraps a DOM Storage object and:\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\n *\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\n * and one for localStorage.\n *\n * @constructor\n */\nexport class DOMStorageWrapper {\n  // Use a prefix to avoid collisions with other stuff saved by the app.\n  private prefix_ = 'firebase:';\n\n  /**\n   * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)\n   */\n  constructor(private domStorage_: Storage) {}\n\n  /**\n   * @param {string} key The key to save the value under\n   * @param {?Object} value The value being stored, or null to remove the key.\n   */\n  set(key: string, value: any | null) {\n    if (value == null) {\n      this.domStorage_.removeItem(this.prefixedName_(key));\n    } else {\n      this.domStorage_.setItem(this.prefixedName_(key), stringify(value));\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @return {*} The value that was stored under this key, or null\n   */\n  get(key: string): any {\n    const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\n    if (storedVal == null) {\n      return null;\n    } else {\n      return jsonEval(storedVal);\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  remove(key: string) {\n    this.domStorage_.removeItem(this.prefixedName_(key));\n  }\n\n  isInMemoryStorage: boolean;\n\n  /**\n   * @param {string} name\n   * @return {string}\n   */\n  prefixedName_(name: string): string {\n    return this.prefix_ + name;\n  }\n\n  toString(): string {\n    return this.domStorage_.toString();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { contains } from '@firebase/util';\n\n/**\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\n * (TODO: create interface for both to implement).\n *\n * @constructor\n */\nexport class MemoryStorage {\n  private cache_: { [k: string]: any } = {};\n\n  set(key: string, value: any | null) {\n    if (value == null) {\n      delete this.cache_[key];\n    } else {\n      this.cache_[key] = value;\n    }\n  }\n\n  get(key: string): any {\n    if (contains(this.cache_, key)) {\n      return this.cache_[key];\n    }\n    return null;\n  }\n\n  remove(key: string) {\n    delete this.cache_[key];\n  }\n\n  isInMemoryStorage = true;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DOMStorageWrapper } from './DOMStorageWrapper';\nimport { MemoryStorage } from './MemoryStorage';\n\ndeclare const window: any;\n\n/**\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\n * to reflect this type\n *\n * @param {string} domStorageName Name of the underlying storage object\n *   (e.g. 'localStorage' or 'sessionStorage').\n * @return {?} Turning off type information until a common interface is defined.\n */\nconst createStoragefor = function(\n  domStorageName: string\n): DOMStorageWrapper | MemoryStorage {\n  try {\n    // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\n    // so it must be inside the try/catch.\n    if (\n      typeof window !== 'undefined' &&\n      typeof window[domStorageName] !== 'undefined'\n    ) {\n      // Need to test cache. Just because it's here doesn't mean it works\n      const domStorage = window[domStorageName];\n      domStorage.setItem('firebase:sentinel', 'cache');\n      domStorage.removeItem('firebase:sentinel');\n      return new DOMStorageWrapper(domStorage);\n    }\n  } catch (e) {}\n\n  // Failed to create wrapper.  Just return in-memory storage.\n  // TODO: log?\n  return new MemoryStorage();\n};\n\n/** A storage object that lasts across sessions */\nexport const PersistentStorage = createStoragefor('localStorage');\n\n/** A storage object that only lasts one session */\nexport const SessionStorage = createStoragefor('sessionStorage');\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../../api/Query';\n\ndeclare const window: any;\ndeclare const Windows: any;\n\nimport { assert } from '@firebase/util';\nimport { base64 } from '@firebase/util';\nimport { Sha1 } from '@firebase/util';\nimport { stringToByteArray } from '@firebase/util';\nimport { stringify } from '@firebase/util';\nimport { SessionStorage } from '../storage/storage';\nimport { isNodeSdk } from '@firebase/util';\nimport { Logger, LogLevel } from '@firebase/logger';\n\nconst logClient = new Logger('@firebase/database');\n\n/**\n * Environment variable for enabling interaction with the Firebase Realtime Database\n * emulator. If set, the module will present the endpoint with a fake \"owner\" credential\n * (see EmulatorAuthTokenProvider) instead of one belonging to a real account.\n *\n * The expected format for this variable is '<HOST>:<PORT>'. The transfer protocol must be\n * omitted and will default to 'http'.\n */\nexport const FIREBASE_DATABASE_EMULATOR_HOST_VAR =\n  'FIREBASE_DATABASE_EMULATOR_HOST';\n\n/**\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\n * @type {function(): number} Generated ID.\n */\nexport const LUIDGenerator: () => number = (function() {\n  let id = 1;\n  return function() {\n    return id++;\n  };\n})();\n\n/**\n * Sha1 hash of the input string\n * @param {!string} str The string to hash\n * @return {!string} The resulting hash\n */\nexport const sha1 = function(str: string): string {\n  const utf8Bytes = stringToByteArray(str);\n  const sha1 = new Sha1();\n  sha1.update(utf8Bytes);\n  const sha1Bytes = sha1.digest();\n  return base64.encodeByteArray(sha1Bytes);\n};\n\n/**\n * @param {...*} var_args\n * @return {string}\n * @private\n */\nconst buildLogMessage_ = function(...var_args: any[]): string {\n  let message = '';\n  for (let i = 0; i < var_args.length; i++) {\n    if (\n      Array.isArray(var_args[i]) ||\n      (var_args[i] &&\n        typeof var_args[i] === 'object' &&\n        typeof var_args[i].length === 'number')\n    ) {\n      message += buildLogMessage_.apply(null, var_args[i]);\n    } else if (typeof var_args[i] === 'object') {\n      message += stringify(var_args[i]);\n    } else {\n      message += var_args[i];\n    }\n    message += ' ';\n  }\n\n  return message;\n};\n\n/**\n * Use this for all debug messages in Firebase.\n * @type {?function(string)}\n */\nexport let logger: ((a: string) => void) | null = null;\n\n/**\n * Flag to check for log availability on first log message\n * @type {boolean}\n * @private\n */\nlet firstLog_ = true;\n\n/**\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\n * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger\n * @param {boolean=} persistent Whether or not to persist logging settings across refreshes\n */\nexport const enableLogging = function(\n  logger_?: boolean | ((a: string) => void) | null,\n  persistent?: boolean\n) {\n  assert(\n    !persistent || (logger_ === true || logger_ === false),\n    \"Can't turn on custom loggers persistently.\"\n  );\n  if (logger_ === true) {\n    logClient.logLevel = LogLevel.VERBOSE;\n    logger = logClient.log.bind(logClient);\n    if (persistent) SessionStorage.set('logging_enabled', true);\n  } else if (typeof logger_ === 'function') {\n    logger = logger_;\n  } else {\n    logger = null;\n    SessionStorage.remove('logging_enabled');\n  }\n};\n\n/**\n *\n * @param {...(string|Arguments)} var_args\n */\nexport const log = function(...var_args: string[]) {\n  if (firstLog_ === true) {\n    firstLog_ = false;\n    if (logger === null && SessionStorage.get('logging_enabled') === true)\n      enableLogging(true);\n  }\n\n  if (logger) {\n    const message = buildLogMessage_.apply(null, var_args);\n    logger(message);\n  }\n};\n\n/**\n * @param {!string} prefix\n * @return {function(...[*])}\n */\nexport const logWrapper = function(\n  prefix: string\n): (...var_args: any[]) => void {\n  return function(...var_args: any[]) {\n    log(prefix, ...var_args);\n  };\n};\n\n/**\n * @param {...string} var_args\n */\nexport const error = function(...var_args: string[]) {\n  const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...var_args);\n  logClient.error(message);\n};\n\n/**\n * @param {...string} var_args\n */\nexport const fatal = function(...var_args: string[]) {\n  const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...var_args)}`;\n  logClient.error(message);\n  throw new Error(message);\n};\n\n/**\n * @param {...*} var_args\n */\nexport const warn = function(...var_args: any[]) {\n  const message = 'FIREBASE WARNING: ' + buildLogMessage_(...var_args);\n  logClient.warn(message);\n};\n\n/**\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\n * does not use https.\n */\nexport const warnIfPageIsSecure = function() {\n  // Be very careful accessing browser globals. Who knows what may or may not exist.\n  if (\n    typeof window !== 'undefined' &&\n    window.location &&\n    window.location.protocol &&\n    window.location.protocol.indexOf('https:') !== -1\n  ) {\n    warn(\n      'Insecure Firebase access from a secure page. ' +\n        'Please use https in calls to new Firebase().'\n    );\n  }\n};\n\n/**\n * @param {!String} methodName\n */\nexport const warnAboutUnsupportedMethod = function(methodName: string) {\n  warn(\n    methodName +\n      ' is unsupported and will likely change soon.  ' +\n      'Please do not use.'\n  );\n};\n\n/**\n * Returns true if data is NaN, or +/- Infinity.\n * @param {*} data\n * @return {boolean}\n */\nexport const isInvalidJSONNumber = function(data: any): boolean {\n  return (\n    typeof data === 'number' &&\n    (data != data || // NaN\n      data == Number.POSITIVE_INFINITY ||\n      data == Number.NEGATIVE_INFINITY)\n  );\n};\n\n/**\n * @param {function()} fn\n */\nexport const executeWhenDOMReady = function(fn: () => void) {\n  if (isNodeSdk() || document.readyState === 'complete') {\n    fn();\n  } else {\n    // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\n    // fire before onload), but fall back to onload.\n\n    let called = false;\n    let wrappedFn = function() {\n      if (!document.body) {\n        setTimeout(wrappedFn, Math.floor(10));\n        return;\n      }\n\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n\n    if (document.addEventListener) {\n      document.addEventListener('DOMContentLoaded', wrappedFn, false);\n      // fallback to onload.\n      window.addEventListener('load', wrappedFn, false);\n    } else if ((document as any).attachEvent) {\n      // IE.\n      (document as any).attachEvent('onreadystatechange', function() {\n        if (document.readyState === 'complete') wrappedFn();\n      });\n      // fallback to onload.\n      (window as any).attachEvent('onload', wrappedFn);\n\n      // jQuery has an extra hack for IE that we could employ (based on\n      // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\n      // I'm hoping we don't need it.\n    }\n  }\n};\n\n/**\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\n * @type {!string}\n */\nexport const MIN_NAME = '[MIN_NAME]';\n\n/**\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\n * @type {!string}\n */\nexport const MAX_NAME = '[MAX_NAME]';\n\n/**\n * Compares valid Firebase key names, plus min and max name\n * @param {!string} a\n * @param {!string} b\n * @return {!number}\n */\nexport const nameCompare = function(a: string, b: string): number {\n  if (a === b) {\n    return 0;\n  } else if (a === MIN_NAME || b === MAX_NAME) {\n    return -1;\n  } else if (b === MIN_NAME || a === MAX_NAME) {\n    return 1;\n  } else {\n    const aAsInt = tryParseInt(a),\n      bAsInt = tryParseInt(b);\n\n    if (aAsInt !== null) {\n      if (bAsInt !== null) {\n        return aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt;\n      } else {\n        return -1;\n      }\n    } else if (bAsInt !== null) {\n      return 1;\n    } else {\n      return a < b ? -1 : 1;\n    }\n  }\n};\n\n/**\n * @param {!string} a\n * @param {!string} b\n * @return {!number} comparison result.\n */\nexport const stringCompare = function(a: string, b: string): number {\n  if (a === b) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n/**\n * @param {string} key\n * @param {Object} obj\n * @return {*}\n */\nexport const requireKey = function(\n  key: string,\n  obj: { [k: string]: any }\n): any {\n  if (obj && key in obj) {\n    return obj[key];\n  } else {\n    throw new Error(\n      'Missing required key (' + key + ') in object: ' + stringify(obj)\n    );\n  }\n};\n\n/**\n * @param {*} obj\n * @return {string}\n */\nexport const ObjectToUniqueKey = function(obj: any): string {\n  if (typeof obj !== 'object' || obj === null) return stringify(obj);\n\n  const keys = [];\n  for (let k in obj) {\n    keys.push(k);\n  }\n\n  // Export as json, but with the keys sorted.\n  keys.sort();\n  let key = '{';\n  for (let i = 0; i < keys.length; i++) {\n    if (i !== 0) key += ',';\n    key += stringify(keys[i]);\n    key += ':';\n    key += ObjectToUniqueKey(obj[keys[i]]);\n  }\n\n  key += '}';\n  return key;\n};\n\n/**\n * Splits a string into a number of smaller segments of maximum size\n * @param {!string} str The string\n * @param {!number} segsize The maximum number of chars in the string.\n * @return {Array.<string>} The string, split into appropriately-sized chunks\n */\nexport const splitStringBySize = function(\n  str: string,\n  segsize: number\n): string[] {\n  const len = str.length;\n\n  if (len <= segsize) {\n    return [str];\n  }\n\n  const dataSegs = [];\n  for (let c = 0; c < len; c += segsize) {\n    if (c + segsize > len) {\n      dataSegs.push(str.substring(c, len));\n    } else {\n      dataSegs.push(str.substring(c, c + segsize));\n    }\n  }\n  return dataSegs;\n};\n\n/**\n * Apply a function to each (key, value) pair in an object or\n * apply a function to each (index, value) pair in an array\n * @param obj The object or array to iterate over\n * @param fn The function to apply\n */\nexport function each(obj: object, fn: (k: string, v: any) => void) {\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn(key, obj[key]);\n    }\n  }\n}\n\n/**\n * Like goog.bind, but doesn't bother to create a closure if opt_context is null/undefined.\n * @param {function(*)} callback Callback function.\n * @param {?Object=} context Optional context to bind to.\n * @return {function(*)}\n */\nexport const bindCallback = function(\n  callback: (a: any) => void,\n  context?: object | null\n): Function {\n  return context ? callback.bind(context) : callback;\n};\n\n/**\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\n * I made one modification at the end and removed the NaN / Infinity\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\n * @param {!number} v A double\n * @return {string}\n */\nexport const doubleToIEEE754String = function(v: number): string {\n  assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL\n\n  const ebits = 11,\n    fbits = 52;\n  let bias = (1 << (ebits - 1)) - 1,\n    s,\n    e,\n    f,\n    ln,\n    i,\n    bits,\n    str;\n\n  // Compute sign, exponent, fraction\n  // Skip NaN / Infinity handling --MJL.\n  if (v === 0) {\n    e = 0;\n    f = 0;\n    s = 1 / v === -Infinity ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = Math.abs(v);\n\n    if (v >= Math.pow(2, 1 - bias)) {\n      // Normalized\n      ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\n      e = ln + bias;\n      f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\n    } else {\n      // Denormalized\n      e = 0;\n      f = Math.round(v / Math.pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) {\n    bits.push(f % 2 ? 1 : 0);\n    f = Math.floor(f / 2);\n  }\n  for (i = ebits; i; i -= 1) {\n    bits.push(e % 2 ? 1 : 0);\n    e = Math.floor(e / 2);\n  }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Return the data as a hex string. --MJL\n  let hexByteString = '';\n  for (i = 0; i < 64; i += 8) {\n    let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\n    if (hexByte.length === 1) hexByte = '0' + hexByte;\n    hexByteString = hexByteString + hexByte;\n  }\n  return hexByteString.toLowerCase();\n};\n\n/**\n * Used to detect if we're in a Chrome content script (which executes in an\n * isolated environment where long-polling doesn't work).\n * @return {boolean}\n */\nexport const isChromeExtensionContentScript = function(): boolean {\n  return !!(\n    typeof window === 'object' &&\n    window['chrome'] &&\n    window['chrome']['extension'] &&\n    !/^chrome/.test(window.location.href)\n  );\n};\n\n/**\n * Used to detect if we're in a Windows 8 Store app.\n * @return {boolean}\n */\nexport const isWindowsStoreApp = function(): boolean {\n  // Check for the presence of a couple WinRT globals\n  return typeof Windows === 'object' && typeof Windows.UI === 'object';\n};\n\n/**\n * Converts a server error code to a Javascript Error\n * @param {!string} code\n * @param {!Query} query\n * @return {Error}\n */\nexport const errorForServerCode = function(code: string, query: Query): Error {\n  let reason = 'Unknown Error';\n  if (code === 'too_big') {\n    reason =\n      'The data requested exceeds the maximum size ' +\n      'that can be accessed with a single request.';\n  } else if (code == 'permission_denied') {\n    reason = \"Client doesn't have permission to access the desired data.\";\n  } else if (code == 'unavailable') {\n    reason = 'The service is unavailable';\n  }\n\n  const error = new Error(\n    code + ' at ' + query.path.toString() + ': ' + reason\n  );\n  (error as any).code = code.toUpperCase();\n  return error;\n};\n\n/**\n * Used to test for integer-looking strings\n * @type {RegExp}\n * @private\n */\nexport const INTEGER_REGEXP_ = new RegExp('^-?(0*)\\\\d{1,10}$');\n\n/**\n * If the string contains a 32-bit integer, return it.  Else return null.\n * @param {!string} str\n * @return {?number}\n */\nexport const tryParseInt = function(str: string): number | null {\n  if (INTEGER_REGEXP_.test(str)) {\n    const intVal = Number(str);\n    if (intVal >= -2147483648 && intVal <= 2147483647) {\n      return intVal;\n    }\n  }\n  return null;\n};\n\n/**\n * Helper to run some code but catch any exceptions and re-throw them later.\n * Useful for preventing user callbacks from breaking internal code.\n *\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\n * convenient (we don't have to try to figure out when is a safe point to\n * re-throw it), and the behavior seems reasonable:\n *\n * * If you aren't pausing on exceptions, you get an error in the console with\n *   the correct stack trace.\n * * If you're pausing on all exceptions, the debugger will pause on your\n *   exception and then again when we rethrow it.\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\n *   on us re-throwing it.\n *\n * @param {!function()} fn The code to guard.\n */\nexport const exceptionGuard = function(fn: () => void) {\n  try {\n    fn();\n  } catch (e) {\n    // Re-throw exception when it's safe.\n    setTimeout(function() {\n      // It used to be that \"throw e\" would result in a good console error with\n      // relevant context, but as of Chrome 39, you just get the firebase.js\n      // file/line number where we re-throw it, which is useless. So we log\n      // e.stack explicitly.\n      const stack = e.stack || '';\n      warn('Exception was thrown by user callback.', stack);\n      throw e;\n    }, Math.floor(0));\n  }\n};\n\n/**\n * Helper function to safely call opt_callback with the specified arguments.  It:\n * 1. Turns into a no-op if opt_callback is null or undefined.\n * 2. Wraps the call inside exceptionGuard to prevent exceptions from breaking our state.\n *\n * @param {?Function=} callback Optional onComplete callback.\n * @param {...*} var_args Arbitrary args to be passed to opt_onComplete\n */\nexport const callUserCallback = function(\n  callback?: Function | null,\n  ...var_args: any[]\n) {\n  if (typeof callback === 'function') {\n    exceptionGuard(function() {\n      callback(...var_args);\n    });\n  }\n};\n\n/**\n * @return {boolean} true if we think we're currently being crawled.\n */\nexport const beingCrawled = function(): boolean {\n  const userAgent =\n    (typeof window === 'object' &&\n      window['navigator'] &&\n      window['navigator']['userAgent']) ||\n    '';\n\n  // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\n  // believe to support JavaScript/AJAX rendering.\n  // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\n  // would have seen the page\" is flaky if we don't treat it as a crawler.\n  return (\n    userAgent.search(\n      /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i\n    ) >= 0\n  );\n};\n\n/**\n * Export a property of an object using a getter function.\n *\n * @param {!Object} object\n * @param {string} name\n * @param {!function(): *} fnGet\n */\nexport const exportPropGetter = function(\n  object: Object,\n  name: string,\n  fnGet: () => any\n) {\n  Object.defineProperty(object, name, { get: fnGet });\n};\n\n/**\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\n *\n * It is removed with clearTimeout() as normal.\n *\n * @param {Function} fn Function to run.\n * @param {number} time Milliseconds to wait before running.\n * @return {number|Object} The setTimeout() return value.\n */\nexport const setTimeoutNonBlocking = function(\n  fn: Function,\n  time: number\n): number | Object {\n  const timeout: number | Object = setTimeout(fn, time);\n  if (typeof timeout === 'object' && (timeout as any)['unref']) {\n    (timeout as any)['unref']();\n  }\n  return timeout;\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { nameCompare } from './util';\nimport { stringLength } from '@firebase/util';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\nexport class Path {\n  private pieces_: string[];\n  private pieceNum_: number;\n\n  /**\n   * Singleton to represent an empty path\n   *\n   * @const\n   */\n  static get Empty() {\n    return new Path('');\n  }\n\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  constructor(pathOrString: string | string[], pieceNum?: number) {\n    if (pieceNum === void 0) {\n      this.pieces_ = (pathOrString as string).split('/');\n\n      // Remove empty pieces.\n      let copyTo = 0;\n      for (let i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString as string[];\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  getFront(): string | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    return this.pieces_[this.pieceNum_];\n  }\n\n  /**\n   * @return {number} The number of segments in this path\n   */\n  getLength(): number {\n    return this.pieces_.length - this.pieceNum_;\n  }\n\n  /**\n   * @return {!Path}\n   */\n  popFront(): Path {\n    let pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  }\n\n  /**\n   * @return {?string}\n   */\n  getBack(): string | null {\n    if (this.pieceNum_ < this.pieces_.length)\n      return this.pieces_[this.pieces_.length - 1];\n\n    return null;\n  }\n\n  toString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  }\n\n  toUrlEncodedString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '')\n        pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  }\n\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  slice(begin: number = 0): string[] {\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  }\n\n  /**\n   * @return {?Path}\n   */\n  parent(): Path | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n      pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  child(childPathObj: string | Path): Path {\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++)\n      pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (\n        let i = childPathObj.pieceNum_;\n        i < childPathObj.pieces_.length;\n        i++\n      ) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      const childPieces = childPathObj.split('/');\n      for (let i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  isEmpty(): boolean {\n    return this.pieceNum_ >= this.pieces_.length;\n  }\n\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  static relativePath(outerPath: Path, innerPath: Path): Path {\n    const outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error(\n        'INTERNAL ERROR: innerPath (' +\n          innerPath +\n          ') is not within ' +\n          'outerPath (' +\n          outerPath +\n          ')'\n      );\n    }\n  }\n\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  static comparePaths(left: Path, right: Path): number {\n    const leftKeys = left.slice();\n    const rightKeys = right.slice();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  }\n\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  equals(other: Path): boolean {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (\n      let i = this.pieceNum_, j = other.pieceNum_;\n      i <= this.pieces_.length;\n      i++, j++\n    ) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  contains(other: Path): boolean {\n    let i = this.pieceNum_;\n    let j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  }\n} // end Path\n\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nexport class ValidationPath {\n  /** @type {!Array<string>} */\n  private parts_: string[];\n  /** @type {number} Initialize to number of '/' chars needed in path. */\n  private byteLength_: number;\n\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  constructor(path: Path, private errorPrefix_: string) {\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (let i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n\n  /** @const {number} Maximum key depth. */\n  static get MAX_PATH_DEPTH() {\n    return 32;\n  }\n\n  /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n  static get MAX_PATH_LENGTH_BYTES() {\n    return 768;\n  }\n\n  /** @param {string} child */\n  push(child: string) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += stringLength(child);\n    this.checkValid_();\n  }\n\n  pop() {\n    const last = this.parts_.pop();\n    this.byteLength_ -= stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  }\n\n  private checkValid_() {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(\n        this.errorPrefix_ +\n          'has a key path longer than ' +\n          ValidationPath.MAX_PATH_LENGTH_BYTES +\n          ' bytes (' +\n          this.byteLength_ +\n          ').'\n      );\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(\n        this.errorPrefix_ +\n          'path specified exceeds the maximum depth that can be written (' +\n          ValidationPath.MAX_PATH_DEPTH +\n          ') or object contains a cycle ' +\n          this.toErrorString()\n      );\n    }\n  }\n\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  toErrorString(): string {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const PROTOCOL_VERSION = '5';\n\nexport const VERSION_PARAM = 'v';\n\nexport const TRANSPORT_SESSION_PARAM = 's';\n\nexport const REFERER_PARAM = 'r';\n\nexport const FORGE_REF = 'f';\n\nexport const FORGE_DOMAIN = 'firebaseio.com';\n\nexport const LAST_SESSION_PARAM = 'ls';\n\nexport const WEBSOCKET = 'websocket';\n\nexport const LONG_POLLING = 'long_polling';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { PersistentStorage } from './storage/storage';\nimport { LONG_POLLING, WEBSOCKET } from '../realtime/Constants';\nimport { each } from './util/util';\n\n/**\n * A class that holds metadata about a Repo object\n *\n * @constructor\n */\nexport class RepoInfo {\n  host: string;\n  domain: string;\n  internalHost: string;\n\n  /**\n   * @param {string} host Hostname portion of the url for the repo\n   * @param {boolean} secure Whether or not this repo is accessed over ssl\n   * @param {string} namespace The namespace represented by the repo\n   * @param {boolean} webSocketOnly Whether to prefer websockets over all other transports (used by Nest).\n   * @param {string=} persistenceKey Override the default session persistence storage key\n   */\n  constructor(\n    host: string,\n    public secure: boolean,\n    public namespace: string,\n    public webSocketOnly: boolean,\n    public persistenceKey: string = '',\n    public includeNamespaceInQueryParams: boolean = false\n  ) {\n    this.host = host.toLowerCase();\n    this.domain = this.host.substr(this.host.indexOf('.') + 1);\n    this.internalHost = PersistentStorage.get('host:' + host) || this.host;\n  }\n\n  needsQueryParam(): boolean {\n    return (\n      this.host !== this.internalHost ||\n      this.isCustomHost() ||\n      this.includeNamespaceInQueryParams\n    );\n  }\n\n  isCacheableHost(): boolean {\n    return this.internalHost.substr(0, 2) === 's-';\n  }\n\n  isDemoHost() {\n    return this.domain === 'firebaseio-demo.com';\n  }\n\n  isCustomHost() {\n    return (\n      this.domain !== 'firebaseio.com' && this.domain !== 'firebaseio-demo.com'\n    );\n  }\n\n  updateHost(newHost: string) {\n    if (newHost !== this.internalHost) {\n      this.internalHost = newHost;\n      if (this.isCacheableHost()) {\n        PersistentStorage.set('host:' + this.host, this.internalHost);\n      }\n    }\n  }\n\n  /**\n   * Returns the websocket URL for this repo\n   * @param {string} type of connection\n   * @param {Object} params list\n   * @return {string} The URL for this repo\n   */\n  connectionURL(type: string, params: { [k: string]: string }): string {\n    assert(typeof type === 'string', 'typeof type must == string');\n    assert(typeof params === 'object', 'typeof params must == object');\n\n    let connURL: string;\n    if (type === WEBSOCKET) {\n      connURL =\n        (this.secure ? 'wss://' : 'ws://') + this.internalHost + '/.ws?';\n    } else if (type === LONG_POLLING) {\n      connURL =\n        (this.secure ? 'https://' : 'http://') + this.internalHost + '/.lp?';\n    } else {\n      throw new Error('Unknown connection type: ' + type);\n    }\n    if (this.needsQueryParam()) {\n      params['ns'] = this.namespace;\n    }\n\n    const pairs: string[] = [];\n\n    each(params, (key: string, value: string) => {\n      pairs.push(key + '=' + value);\n    });\n\n    return connURL + pairs.join('&');\n  }\n\n  /** @return {string} */\n  toString(): string {\n    let str = this.toURLString();\n    if (this.persistenceKey) {\n      str += '<' + this.persistenceKey + '>';\n    }\n    return str;\n  }\n\n  /** @return {string} */\n  toURLString(): string {\n    return (this.secure ? 'https://' : 'http://') + this.host;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../Path';\nimport { RepoInfo } from '../../RepoInfo';\nimport { warnIfPageIsSecure, warn, fatal } from '../util';\n\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString: string): string {\n  let pathStringDecoded = '';\n  const pieces = pathString.split('/');\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      let piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n\n/**\n * @param {!string} queryString\n * @return {!{[key:string]:string}} key value hash\n */\nfunction decodeQuery(queryString: string): { [key: string]: string } {\n  let results = {};\n  if (queryString.charAt(0) === '?') {\n    queryString = queryString.substring(1);\n  }\n  for (const segment of queryString.split('&')) {\n    if (segment.length === 0) {\n      continue;\n    }\n    const kv = segment.split('=');\n    if (kv.length === 2) {\n      results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n    } else {\n      warn(`Invalid query segment '${segment}' in query '${queryString}'`);\n    }\n  }\n  return results;\n}\n\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexport const parseRepoInfo = function(\n  dataURL: string\n): { repoInfo: RepoInfo; path: Path } {\n  const parsedUrl = parseDatabaseURL(dataURL),\n    namespace = parsedUrl.namespace;\n\n  if (parsedUrl.domain === 'firebase') {\n    fatal(\n      parsedUrl.host +\n        ' is no longer supported. ' +\n        'Please use <YOUR FIREBASE>.firebaseio.com instead'\n    );\n  }\n\n  // Catch common error of uninitialized namespace value.\n  if (\n    (!namespace || namespace == 'undefined') &&\n    parsedUrl.domain !== 'localhost'\n  ) {\n    fatal(\n      'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'\n    );\n  }\n\n  if (!parsedUrl.secure) {\n    warnIfPageIsSecure();\n  }\n\n  const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n\n  return {\n    repoInfo: new RepoInfo(\n      parsedUrl.host,\n      parsedUrl.secure,\n      namespace,\n      webSocketOnly,\n      /*persistenceKey=*/ '',\n      /*includeNamespaceInQueryParams=*/ namespace != parsedUrl.subdomain\n    ),\n    path: new Path(parsedUrl.pathString)\n  };\n};\n\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string, namespace: string}}\n */\nexport const parseDatabaseURL = function(\n  dataURL: string\n): {\n  host: string;\n  port: number;\n  domain: string;\n  subdomain: string;\n  secure: boolean;\n  scheme: string;\n  pathString: string;\n  namespace: string;\n} {\n  // Default to empty strings in the event of a malformed string.\n  let host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '',\n    namespace = '';\n\n  // Always default to SSL, unless otherwise specified.\n  let secure = true,\n    scheme = 'https',\n    port = 443;\n\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    let colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n\n    // Parse host, path, and query string.\n    let slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    let questionMarkInd = dataURL.indexOf('?');\n    if (questionMarkInd === -1) {\n      questionMarkInd = dataURL.length;\n    }\n    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n    if (slashInd < questionMarkInd) {\n      // For pathString, questionMarkInd will always come after slashInd\n      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n    }\n    let queryParams = decodeQuery(\n      dataURL.substring(Math.min(dataURL.length, questionMarkInd))\n    );\n\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    } else {\n      colonInd = dataURL.length;\n    }\n\n    const parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n      // We interpret the subdomain of a 3 component URL as the namespace name.\n      namespace = subdomain;\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    } else if (parts[0].slice(0, colonInd).toLowerCase() === 'localhost') {\n      domain = 'localhost';\n    }\n    // Always treat the value of the `ns` as the namespace name if it is present.\n    if ('ns' in queryParams) {\n      namespace = queryParams['ns'];\n    }\n  }\n\n  return {\n    host,\n    port,\n    domain,\n    subdomain,\n    secure,\n    scheme,\n    pathString,\n    namespace\n  };\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path, ValidationPath } from './Path';\nimport { contains, safeGet } from '@firebase/util';\nimport { isInvalidJSONNumber, each } from './util';\nimport { errorPrefix as errorPrefixFxn } from '@firebase/util';\nimport { stringLength } from '@firebase/util';\nimport { RepoInfo } from '../RepoInfo';\n\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexport const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexport const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexport const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n\n/**\n * @param {*} key\n * @return {boolean}\n */\nexport const isValidKey = function(key: any): boolean {\n  return (\n    typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidPathString = function(pathString: string): boolean {\n  return (\n    typeof pathString === 'string' &&\n    pathString.length !== 0 &&\n    !INVALID_PATH_REGEX_.test(pathString)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidRootPathString = function(pathString: string): boolean {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return isValidPathString(pathString);\n};\n\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexport const isValidPriority = function(priority: any): boolean {\n  return (\n    priority === null ||\n    typeof priority === 'string' ||\n    (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\n    (priority && typeof priority === 'object' && contains(priority, '.sv'))\n  );\n};\n\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  validateFirebaseData(\n    errorPrefixFxn(fnName, argumentNumber, optional),\n    data,\n    path\n  );\n};\n\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexport const validateFirebaseData = function(\n  errorPrefix: string,\n  data: any,\n  path_: Path | ValidationPath\n) {\n  const path =\n    path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(\n      errorPrefix +\n        'contains a function ' +\n        path.toErrorString() +\n        ' with contents = ' +\n        data.toString()\n    );\n  }\n  if (isInvalidJSONNumber(data)) {\n    throw new Error(\n      errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString()\n    );\n  }\n\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (\n    typeof data === 'string' &&\n    data.length > MAX_LEAF_SIZE_ / 3 &&\n    stringLength(data) > MAX_LEAF_SIZE_\n  ) {\n    throw new Error(\n      errorPrefix +\n        'contains a string greater than ' +\n        MAX_LEAF_SIZE_ +\n        ' utf8 bytes ' +\n        path.toErrorString() +\n        \" ('\" +\n        data.substring(0, 50) +\n        \"...')\"\n    );\n  }\n\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    let hasDotValue = false;\n    let hasActualChild = false;\n    each(data, function(key: string, value: any) {\n      if (key === '.value') {\n        hasDotValue = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild = true;\n        if (!isValidKey(key)) {\n          throw new Error(\n            errorPrefix +\n              ' contains an invalid key (' +\n              key +\n              ') ' +\n              path.toErrorString() +\n              '.  Keys must be non-empty strings ' +\n              'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n          );\n        }\n      }\n\n      path.push(key);\n      validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue && hasActualChild) {\n      throw new Error(\n        errorPrefix +\n          ' contains \".value\" child ' +\n          path.toErrorString() +\n          ' in addition to actual children.'\n      );\n    }\n  }\n};\n\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexport const validateFirebaseMergePaths = function(\n  errorPrefix: string,\n  mergePaths: Path[]\n) {\n  let i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    const keys = curPath.slice();\n    for (let j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!isValidKey(keys[j])) {\n        throw new Error(\n          errorPrefix +\n            'contains an invalid key (' +\n            keys[j] +\n            ') in path ' +\n            curPath.toString() +\n            '. Keys must be non-empty strings ' +\n            'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n        );\n      }\n    }\n  }\n\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path.comparePaths);\n  let prevPath: Path | null = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(\n        errorPrefix +\n          'contains a path ' +\n          prevPath.toString() +\n          ' that is ancestor of another path ' +\n          curPath.toString()\n      );\n    }\n    prevPath = curPath;\n  }\n};\n\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseMergeDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  const errorPrefix = errorPrefixFxn(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(\n      errorPrefix + ' must be an object containing the children to replace.'\n    );\n  }\n\n  const mergePaths: Path[] = [];\n  each(data, function(key: string, value: any) {\n    const curPath = new Path(key);\n    validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!isValidPriority(value)) {\n        throw new Error(\n          errorPrefix +\n            \"contains an invalid value for '\" +\n            curPath.toString() +\n            \"', which must be a valid \" +\n            'Firebase priority (a string, finite number, server value, or null).'\n        );\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexport const validatePriority = function(\n  fnName: string,\n  argumentNumber: number,\n  priority: any,\n  optional: boolean\n) {\n  if (optional && priority === undefined) return;\n  if (isInvalidJSONNumber(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'is ' +\n        priority.toString() +\n        ', but must be a valid Firebase priority (a string, finite number, ' +\n        'server value, or null).'\n    );\n  // Special case to allow importing data with a .sv.\n  if (!isValidPriority(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid Firebase priority ' +\n        '(a string, finite number, server value, or null).'\n    );\n};\n\nexport const validateEventType = function(\n  fnName: string,\n  argumentNumber: number,\n  eventType: string,\n  optional: boolean\n) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\n          '\"child_changed\", or \"child_moved\".'\n      );\n  }\n};\n\nexport const validateKey = function(\n  fnName: string,\n  argumentNumber: number,\n  key: string,\n  optional: boolean\n) {\n  if (optional && key === undefined) return;\n  if (!isValidKey(key))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid key = \"' +\n        key +\n        '\".  Firebase keys must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").'\n    );\n};\n\nexport const validatePathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (optional && pathString === undefined) return;\n\n  if (!isValidPathString(pathString))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid path = \"' +\n        pathString +\n        '\". Paths must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"'\n    );\n};\n\nexport const validateRootPathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexport const validateWritablePath = function(fnName: string, path: Path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexport const validateUrl = function(\n  fnName: string,\n  argumentNumber: number,\n  parsedUrl: { repoInfo: RepoInfo; path: Path }\n) {\n  // TODO = Validate server better.\n  const pathString = parsedUrl.path.toString();\n  if (\n    !(typeof parsedUrl.repoInfo.host === 'string') ||\n    parsedUrl.repoInfo.host.length === 0 ||\n    (!isValidKey(parsedUrl.repoInfo.namespace) &&\n      parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||\n    (pathString.length !== 0 && !isValidRootPathString(pathString))\n  ) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, false) +\n        'must be a valid firebase URL and ' +\n        'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".'\n    );\n  }\n};\n\nexport const validateCredential = function(\n  fnName: string,\n  argumentNumber: number,\n  cred: any,\n  optional: boolean\n) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string'))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid credential (a string).'\n    );\n};\n\nexport const validateBoolean = function(\n  fnName: string,\n  argumentNumber: number,\n  bool: any,\n  optional: boolean\n) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean')\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) + 'must be a boolean.'\n    );\n};\n\nexport const validateString = function(\n  fnName: string,\n  argumentNumber: number,\n  string: any,\n  optional: boolean\n) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid string.'\n    );\n  }\n};\n\nexport const validateObject = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  optional: boolean\n) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid object.'\n    );\n  }\n};\n\nexport const validateObjectContainsKey = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  key: string,\n  optional: boolean,\n  opt_type?: string\n) {\n  const objectContainsKey =\n    obj && typeof obj === 'object' && contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must contain the key \"' +\n          key +\n          '\"'\n      );\n    }\n  }\n\n  if (opt_type) {\n    const val = safeGet(obj, key);\n    if (\n      (opt_type === 'number' && !(typeof val === 'number')) ||\n      (opt_type === 'string' && !(typeof val === 'string')) ||\n      (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\n      (opt_type === 'function' && !(typeof val === 'function')) ||\n      (opt_type === 'object' && !(typeof val === 'object') && val)\n    ) {\n      if (optional) {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'contains invalid value for key \"' +\n            key +\n            '\" (must be of type \"' +\n            opt_type +\n            '\")'\n        );\n      } else {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'must contain the key \"' +\n            key +\n            '\" with type \"' +\n            opt_type +\n            '\"'\n        );\n      }\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport {\n  validateWritablePath,\n  validateFirebaseDataArg,\n  validatePriority,\n  validateFirebaseMergeDataArg\n} from '../core/util/validation';\nimport { warn } from '../core/util/util';\nimport { Deferred } from '@firebase/util';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\n\n/**\n * @constructor\n */\nexport class OnDisconnect {\n  /**\n   * @param {!Repo} repo_\n   * @param {!Path} path_\n   */\n  constructor(private repo_: Repo, private path_: Path) {}\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!firebase.Promise}\n   */\n  cancel(onComplete?: (a: Error | null) => void): Promise<void> {\n    validateArgCount('OnDisconnect.cancel', 0, 1, arguments.length);\n    validateCallback('OnDisconnect.cancel', 1, onComplete, true);\n    const deferred = new Deferred<void>();\n    this.repo_.onDisconnectCancel(\n      this.path_,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!firebase.Promise}\n   */\n  remove(onComplete?: (a: Error | null) => void): Promise<void> {\n    validateArgCount('OnDisconnect.remove', 0, 1, arguments.length);\n    validateWritablePath('OnDisconnect.remove', this.path_);\n    validateCallback('OnDisconnect.remove', 1, onComplete, true);\n    const deferred = new Deferred<void>();\n    this.repo_.onDisconnectSet(\n      this.path_,\n      null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} value\n   * @param {function(?Error)=} onComplete\n   * @return {!firebase.Promise}\n   */\n  set(value: any, onComplete?: (a: Error | null) => void): Promise<void> {\n    validateArgCount('OnDisconnect.set', 1, 2, arguments.length);\n    validateWritablePath('OnDisconnect.set', this.path_);\n    validateFirebaseDataArg('OnDisconnect.set', 1, value, this.path_, false);\n    validateCallback('OnDisconnect.set', 2, onComplete, true);\n    const deferred = new Deferred<void>();\n    this.repo_.onDisconnectSet(\n      this.path_,\n      value,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} value\n   * @param {number|string|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!firebase.Promise}\n   */\n  setWithPriority(\n    value: any,\n    priority: number | string | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<void> {\n    validateArgCount('OnDisconnect.setWithPriority', 2, 3, arguments.length);\n    validateWritablePath('OnDisconnect.setWithPriority', this.path_);\n    validateFirebaseDataArg(\n      'OnDisconnect.setWithPriority',\n      1,\n      value,\n      this.path_,\n      false\n    );\n    validatePriority('OnDisconnect.setWithPriority', 2, priority, false);\n    validateCallback('OnDisconnect.setWithPriority', 3, onComplete, true);\n\n    const deferred = new Deferred<void>();\n    this.repo_.onDisconnectSetWithPriority(\n      this.path_,\n      value,\n      priority,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!firebase.Promise}\n   */\n  update(\n    objectToMerge: object,\n    onComplete?: (a: Error | null) => void\n  ): Promise<void> {\n    validateArgCount('OnDisconnect.update', 1, 2, arguments.length);\n    validateWritablePath('OnDisconnect.update', this.path_);\n    if (Array.isArray(objectToMerge)) {\n      const newObjectToMerge: { [k: string]: any } = {};\n      for (let i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      warn(\n        'Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the ' +\n          'existing data, or an Object with integer keys if you really do want to only update some of the children.'\n      );\n    }\n    validateFirebaseMergeDataArg(\n      'OnDisconnect.update',\n      1,\n      objectToMerge,\n      this.path_,\n      false\n    );\n    validateCallback('OnDisconnect.update', 2, onComplete, true);\n    const deferred = new Deferred<void>();\n    this.repo_.onDisconnectUpdate(\n      this.path_,\n      objectToMerge,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataSnapshot } from './DataSnapshot';\nimport { validateArgCount } from '@firebase/util';\n\nexport class TransactionResult {\n  /**\n   * A type for the resolve value of Firebase.transaction.\n   * @constructor\n   * @dict\n   * @param {boolean} committed\n   * @param {DataSnapshot} snapshot\n   */\n  constructor(public committed: boolean, public snapshot: DataSnapshot) {}\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  toJSON(): object {\n    validateArgCount('TransactionResult.toJSON', 0, 1, arguments.length);\n    return { committed: this.committed, snapshot: this.snapshot.toJSON() };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\nexport const nextPushId = (function() {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  const PUSH_CHARS =\n    '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n  // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n  let lastPushTime = 0;\n\n  // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n  const lastRandChars: number[] = [];\n\n  return function(now: number) {\n    const duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n\n    let i;\n    const timeStampChars = new Array(8);\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n      // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n      now = Math.floor(now / 64);\n    }\n    assert(now === 0, 'Cannot push at time == 0');\n\n    let id = timeStampChars.join('');\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n      lastRandChars[i]++;\n    }\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n    assert(id.length === 20, 'nextPushId: Length should be 20.');\n\n    return id;\n  };\n})();\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\n\n/**\n * Node is an interface defining the common functionality for nodes in\n * a DataSnapshot.\n *\n * @interface\n */\nexport interface Node {\n  /**\n   * Whether this node is a leaf node.\n   * @return {boolean} Whether this is a leaf node.\n   */\n  isLeafNode(): boolean;\n\n  /**\n   * Gets the priority of the node.\n   * @return {!Node} The priority of the node.\n   */\n  getPriority(): Node;\n\n  /**\n   * Returns a duplicate node with the new priority.\n   * @param {!Node} newPriorityNode New priority to set for the node.\n   * @return {!Node} Node with new priority.\n   */\n  updatePriority(newPriorityNode: Node): Node;\n\n  /**\n   * Returns the specified immediate child, or null if it doesn't exist.\n   * @param {string} childName The name of the child to retrieve.\n   * @return {!Node} The retrieved child, or an empty node.\n   */\n  getImmediateChild(childName: string): Node;\n\n  /**\n   * Returns a child by path, or null if it doesn't exist.\n   * @param {!Path} path The path of the child to retrieve.\n   * @return {!Node} The retrieved child or an empty node.\n   */\n  getChild(path: Path): Node;\n\n  /**\n   * Returns the name of the child immediately prior to the specified childNode, or null.\n   * @param {!string} childName The name of the child to find the predecessor of.\n   * @param {!Node} childNode The node to find the predecessor of.\n   * @param {!Index} index The index to use to determine the predecessor\n   * @return {?string} The name of the predecessor child, or null if childNode is the first child.\n   */\n  getPredecessorChildName(\n    childName: String,\n    childNode: Node,\n    index: Index\n  ): string | null;\n\n  /**\n   * Returns a duplicate node, with the specified immediate child updated.\n   * Any value in the node will be removed.\n   * @param {string} childName The name of the child to update.\n   * @param {!Node} newChildNode The new child node\n   * @return {!Node} The updated node.\n   */\n  updateImmediateChild(childName: string, newChildNode: Node): Node;\n\n  /**\n   * Returns a duplicate node, with the specified child updated.  Any value will\n   * be removed.\n   * @param {!Path} path The path of the child to update.\n   * @param {!Node} newChildNode The new child node, which may be an empty node\n   * @return {!Node} The updated node.\n   */\n  updateChild(path: Path, newChildNode: Node): Node;\n\n  /**\n   * True if the immediate child specified exists\n   * @param {!string} childName\n   * @return {boolean}\n   */\n  hasChild(childName: string): boolean;\n\n  /**\n   * @return {boolean} True if this node has no value or children.\n   */\n  isEmpty(): boolean;\n\n  /**\n   * @return {number} The number of children of this node.\n   */\n  numChildren(): number;\n\n  /**\n   * Calls action for each child.\n   * @param {!Index} index\n   * @param {function(string, !Node)} action Action to be called for\n   * each child.  It's passed the child name and the child node.\n   * @return {*} The first truthy value return by action, or the last falsey one\n   */\n  forEachChild(index: Index, action: (a: string, b: Node) => void): any;\n\n  /**\n   * @param exportFormat True for export format (also wire protocol format).\n   * @return Value of this node as JSON.\n   */\n  val(exportFormat?: boolean): unknown;\n\n  /**\n   * @return {string} hash representing the node contents.\n   */\n  hash(): string;\n\n  /**\n   * @param {!Node} other Another node\n   * @return {!number} -1 for less than, 0 for equal, 1 for greater than other\n   */\n  compareTo(other: Node): number;\n\n  /**\n   * @param {!Node} other\n   * @return {boolean} Whether or not this snapshot equals other\n   */\n  equals(other: Node): boolean;\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!Node} This node, with the specified index now available\n   */\n  withIndex(indexDefinition: Index): Node;\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  isIndexed(indexDefinition: Index): boolean;\n}\n\n/**\n *\n * @param {!string} name\n * @param {!Node} node\n * @constructor\n * @struct\n */\nexport class NamedNode {\n  constructor(public name: string, public node: Node) {}\n\n  /**\n   *\n   * @param {!string} name\n   * @param {!Node} node\n   * @return {NamedNode}\n   */\n  static Wrap(name: string, node: Node) {\n    return new NamedNode(name, node);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Node, NamedNode } from '../Node';\nimport { MIN_NAME, MAX_NAME } from '../../util/util';\nimport { Comparator } from '../../util/SortedMap';\n\n/**\n *\n * @constructor\n */\nexport abstract class Index {\n  /**\n   * @param {!NamedNode} a\n   * @param {!NamedNode} b\n   * @return {number}\n   */\n  abstract compare(a: NamedNode, b: NamedNode): number;\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   */\n  abstract isDefinedOn(node: Node): boolean;\n\n  /**\n   * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for\n   * this index\n   */\n  getCompare(): Comparator<NamedNode> {\n    return this.compare.bind(this);\n  }\n\n  /**\n   * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\n   * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\n   *\n   * @param {!Node} oldNode\n   * @param {!Node} newNode\n   * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode\n   */\n  indexedValueChanged(oldNode: Node, newNode: Node): boolean {\n    const oldWrapped = new NamedNode(MIN_NAME, oldNode);\n    const newWrapped = new NamedNode(MIN_NAME, newNode);\n    return this.compare(oldWrapped, newWrapped) !== 0;\n  }\n\n  /**\n   * @return {!NamedNode} a node wrapper that will sort equal to or less than\n   * any other node wrapper, using this index\n   */\n  minPost(): NamedNode {\n    return (NamedNode as any).MIN;\n  }\n\n  /**\n   * @return {!NamedNode} a node wrapper that will sort greater than or equal to\n   * any other node wrapper, using this index\n   */\n  abstract maxPost(): NamedNode;\n\n  /**\n   * @param {*} indexValue\n   * @param {string} name\n   * @return {!NamedNode}\n   */\n  abstract makePost(indexValue: any, name: string): NamedNode;\n\n  /**\n   * @return {!string} String representation for inclusion in a query spec\n   */\n  abstract toString(): string;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Index } from './Index';\nimport { Node, NamedNode } from '../Node';\nimport { nameCompare, MAX_NAME } from '../../util/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { ChildrenNode } from '../ChildrenNode';\n\nlet __EMPTY_NODE: ChildrenNode;\n\nexport class KeyIndex extends Index {\n  static get __EMPTY_NODE() {\n    return __EMPTY_NODE;\n  }\n\n  static set __EMPTY_NODE(val) {\n    __EMPTY_NODE = val;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compare(a: NamedNode, b: NamedNode): number {\n    return nameCompare(a.name, b.name);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isDefinedOn(node: Node): boolean {\n    // We could probably return true here (since every node has a key), but it's never called\n    // so just leaving unimplemented for now.\n    throw assertionError('KeyIndex.isDefinedOn not expected to be called.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  indexedValueChanged(oldNode: Node, newNode: Node): boolean {\n    return false; // The key for a node never changes.\n  }\n\n  /**\n   * @inheritDoc\n   */\n  minPost() {\n    return (NamedNode as any).MIN;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  maxPost(): NamedNode {\n    // TODO: This should really be created once and cached in a static property, but\n    // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n    return new NamedNode(MAX_NAME, __EMPTY_NODE);\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {string} name\n   * @return {!NamedNode}\n   */\n  makePost(indexValue: string, name: string): NamedNode {\n    assert(\n      typeof indexValue === 'string',\n      'KeyIndex indexValue must always be a string.'\n    );\n    // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n    return new NamedNode(indexValue, __EMPTY_NODE);\n  }\n\n  /**\n   * @return {!string} String representation for inclusion in a query spec\n   */\n  toString(): string {\n    return '.key';\n  }\n}\n\nexport const KEY_INDEX = new KeyIndex();\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { doubleToIEEE754String } from '../util/util';\nimport { contains } from '@firebase/util';\nimport { Node } from './Node';\n\nlet MAX_NODE: Node;\n\nexport function setMaxNode(val: Node) {\n  MAX_NODE = val;\n}\n\n/**\n * @param {(!string|!number)} priority\n * @return {!string}\n */\nexport const priorityHashText = function(priority: string | number): string {\n  if (typeof priority === 'number')\n    return 'number:' + doubleToIEEE754String(priority);\n  else return 'string:' + priority;\n};\n\n/**\n * Validates that a priority snapshot Node is valid.\n *\n * @param {!Node} priorityNode\n */\nexport const validatePriorityNode = function(priorityNode: Node) {\n  if (priorityNode.isLeafNode()) {\n    const val = priorityNode.val();\n    assert(\n      typeof val === 'string' ||\n        typeof val === 'number' ||\n        (typeof val === 'object' &&\n          contains(val as { [key: string]: unknown }, '.sv')),\n      'Priority must be a string or number.'\n    );\n  } else {\n    assert(\n      priorityNode === MAX_NODE || priorityNode.isEmpty(),\n      'priority of unexpected type.'\n    );\n  }\n  // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\n  assert(\n    priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(),\n    \"Priority nodes can't have a priority of their own.\"\n  );\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nimport { Node } from './Node';\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\nimport { ChildrenNodeConstructor } from './ChildrenNode';\n\nlet __childrenNodeConstructor: ChildrenNodeConstructor;\n\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nexport class LeafNode implements Node {\n  static set __childrenNodeConstructor(val: ChildrenNodeConstructor) {\n    __childrenNodeConstructor = val;\n  }\n\n  static get __childrenNodeConstructor() {\n    return __childrenNodeConstructor;\n  }\n\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  static VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n  private lazyHash_: string | null = null;\n\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  constructor(\n    private readonly value_: string | number | boolean | object,\n    private priorityNode_: Node = LeafNode.__childrenNodeConstructor.EMPTY_NODE\n  ) {\n    assert(\n      this.value_ !== undefined && this.value_ !== null,\n      \"LeafNode shouldn't be created with null/undefined value.\"\n    );\n\n    validatePriorityNode(this.priorityNode_);\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return true;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    return new LeafNode(this.value_, newPriorityNode);\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasChild(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(childName: String, childNode: Node): null {\n    return null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(\n        childName,\n        newChildNode\n      ).updatePriority(this.priorityNode_);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      assert(\n        front !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n\n      return this.updateImmediateChild(\n        front,\n        LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(\n          path.popFront(),\n          newChildNode\n        )\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return 0;\n  }\n\n  /** @inheritDoc */\n  forEachChild(index: Index, action: (s: string, n: Node) => void): any {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  val(exportFormat?: boolean): Object {\n    if (exportFormat && !this.getPriority().isEmpty())\n      return {\n        '.value': this.getValue(),\n        '.priority': this.getPriority().val()\n      };\n    else return this.getValue();\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.priorityNode_.isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.priorityNode_.val() as number | string) +\n          ':';\n\n      const type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += doubleToIEEE754String(this.value_ as number);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  getValue(): object | string | number | boolean {\n    return this.value_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: Node): number {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other as LeafNode);\n    }\n  }\n\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  private compareToLeafNode_(otherLeaf: LeafNode): number {\n    const otherLeafType = typeof otherLeaf.value_;\n    const thisLeafType = typeof this.value_;\n    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(): Node {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      const otherLeaf = other as LeafNode;\n      return (\n        this.value_ === otherLeaf.value_ &&\n        this.priorityNode_.equals(otherLeaf.priorityNode_)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Index } from './Index';\nimport { nameCompare, MAX_NAME } from '../../util/util';\nimport { NamedNode, Node } from '../Node';\nimport { LeafNode } from '../LeafNode';\n\nlet nodeFromJSON: (a: any) => Node;\nlet MAX_NODE: Node;\n\nexport function setNodeFromJSON(val: (a: any) => Node) {\n  nodeFromJSON = val;\n}\n\nexport function setMaxNode(val: Node) {\n  MAX_NODE = val;\n}\n\n/**\n * @constructor\n * @extends {Index}\n * @private\n */\nexport class PriorityIndex extends Index {\n  /**\n   * @inheritDoc\n   */\n  compare(a: NamedNode, b: NamedNode): number {\n    const aPriority = a.node.getPriority();\n    const bPriority = b.node.getPriority();\n    const indexCmp = aPriority.compareTo(bPriority);\n    if (indexCmp === 0) {\n      return nameCompare(a.name, b.name);\n    } else {\n      return indexCmp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isDefinedOn(node: Node): boolean {\n    return !node.getPriority().isEmpty();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  indexedValueChanged(oldNode: Node, newNode: Node): boolean {\n    return !oldNode.getPriority().equals(newNode.getPriority());\n  }\n\n  /**\n   * @inheritDoc\n   */\n  minPost(): NamedNode {\n    return (NamedNode as any).MIN;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  maxPost(): NamedNode {\n    return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE));\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {string} name\n   * @return {!NamedNode}\n   */\n  makePost(indexValue: any, name: string): NamedNode {\n    const priorityNode = nodeFromJSON(indexValue);\n    return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));\n  }\n\n  /**\n   * @return {!string} String representation for inclusion in a query spec\n   */\n  toString(): string {\n    return '.priority';\n  }\n}\n\nexport const PRIORITY_INDEX = new PriorityIndex();\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\n// TODO: There are some improvements I'd like to make to improve memory / perf:\n//  * Create two prototypes, LLRedNode and LLBlackNode, instead of storing a\n//    color property in every node.\n// TODO: It would also be good (and possibly necessary) to create a base\n// interface for LLRBNode and LLRBEmptyNode.\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\n/**\n * An iterator over an LLRBNode.\n */\nexport class SortedMapIterator<K, V, T> {\n  /** @private\n   * @type {Array.<!LLRBNode>}\n   */\n  private nodeStack_: (LLRBNode<K, V> | LLRBEmptyNode<K, V>)[] = [];\n\n  /**\n   * @template K, V, T\n   * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n   * @param {?K} startKey\n   * @param {function(K, K): number} comparator\n   * @param {boolean} isReverse_ Whether or not to iterate in reverse\n   * @param {(function(K, V):T)=} resultGenerator_\n   */\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    private isReverse_: boolean,\n    private resultGenerator_: ((k: K, v: V) => T) | null = null\n  ) {\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      node = node as LLRBNode<K, V>;\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse_) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse_) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n        this.nodeStack_.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move to the next one\n        this.nodeStack_.push(node);\n        if (this.isReverse_) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    let node = this.nodeStack_.pop();\n    let result: T;\n    if (this.resultGenerator_)\n      result = this.resultGenerator_(node.key, node.value);\n    else result = { key: node.key, value: node.value } as any;\n\n    if (this.isReverse_) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack_.length > 0;\n  }\n\n  peek(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    const node = this.nodeStack_[this.nodeStack_.length - 1];\n    if (this.resultGenerator_) {\n      return this.resultGenerator_(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value } as any;\n    }\n  }\n}\n\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nexport class LLRBNode<K, V> {\n  color: boolean;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  /**\n   * @template K, V\n   * @param {!K} key Key associated with this node.\n   * @param {!V} value Value associated with this node.\n   * @param {?boolean} color Whether this node is red.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n   */\n  constructor(\n    public key: K,\n    public value: V,\n    color: boolean | null,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left =\n      left != null ? left : (SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>);\n    this.right =\n      right != null ? right : (SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>);\n  }\n\n  static RED = true;\n  static BLACK = false;\n\n  /**\n   * Returns a copy of the current node, optionally replacing pieces of it.\n   *\n   * @param {?K} key New key for the node, or null.\n   * @param {?V} value New value for the node, or null.\n   * @param {?boolean} color New color for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n   * @return {!LLRBNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return this.left.count() + 1 + this.right.count();\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   *   node.  If it returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return (\n      this.left.inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      this.right.inorderTraversal(action)\n    );\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {*} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return (\n      this.right.reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      this.left.reverseTraversal(action)\n    );\n  }\n\n  /**\n   * @return {!Object} The minimum node in the tree.\n   * @private\n   */\n  private min_(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min_();\n    }\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  minKey(): K {\n    return this.min_().key;\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  maxKey(): K {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  /**\n   *\n   * @param {!Object} key Key to insert.\n   * @param {!Object} value Value to insert.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with the key/value added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let cmp, n;\n    n = this;\n    cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n   */\n  private removeMin_(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed_() && !n.left.left.isRed_()) n = n.moveRedLeft_();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin_(), null);\n    return n.fixUp_();\n  }\n\n  /**\n   * @param {!Object} key The key of the item to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n   */\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let n, smallest;\n    n = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n        n = n.moveRedLeft_();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed_()) n = n.rotateRight_();\n      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n        n = n.moveRedRight_();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min_();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin_()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this is a RED node.\n   */\n  isRed_(): boolean {\n    return this.color;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree after performing any needed rotations.\n   */\n  private fixUp_(): LLRBNode<K, V> {\n    let n = this as any;\n    if (n.right.isRed_() && !n.left.isRed_()) n = n.rotateLeft_();\n    if (n.left.isRed_() && n.left.left.isRed_()) n = n.rotateRight_();\n    if (n.left.isRed_() && n.right.isRed_()) n = n.colorFlip_();\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedLeft.\n   */\n  private moveRedLeft_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.right.left.isRed_()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight_()\n      );\n      n = n.rotateLeft_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedRight.\n   */\n  private moveRedRight_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.left.left.isRed_()) {\n      n = n.rotateRight_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateLeft.\n   */\n  private rotateLeft_(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateRight.\n   */\n  private rotateRight_(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after colorFlip.\n   */\n  private colorFlip_(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  /**\n   * For testing.\n   *\n   * @private\n   * @return {boolean} True if all is well.\n   */\n  private checkMaxDepth_(): boolean {\n    const blackDepth = this.check_();\n    return Math.pow(2.0, blackDepth) <= this.count() + 1;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    let blackDepth;\n    if (this.isRed_() && this.left.isRed_()) {\n      throw new Error(\n        'Red node has red child(' + this.key + ',' + this.value + ')'\n      );\n    }\n    if (this.right.isRed_()) {\n      throw new Error(\n        'Right child of (' + this.key + ',' + this.value + ') is red'\n      );\n    }\n    blackDepth = this.left.check_();\n    if (blackDepth !== this.right.check_()) {\n      throw new Error('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed_() ? 0 : 1);\n    }\n  }\n}\n\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  color: boolean;\n\n  /**\n   * Returns a copy of the current node.\n   *\n   * @return {!LLRBEmptyNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key/value added.\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with item added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode(key, value, null);\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBEmptyNode} New tree, with item removed.\n   */\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return true;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return false;\n  }\n\n  /**\n   * @return {null}\n   */\n  minKey(): null {\n    return null;\n  }\n\n  /**\n   * @return {null}\n   */\n  maxKey(): null {\n    return null;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    return 0;\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this node is red.\n   */\n  isRed_() {\n    return false;\n  }\n}\n\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nexport class SortedMap<K, V> {\n  /**\n   * Always use the same empty node, to reduce memory.\n   * @const\n   */\n  static EMPTY_NODE = new LLRBEmptyNode();\n\n  /**\n   * @template K, V\n   * @param {function(K, K):number} comparator_ Key comparator.\n   * @param {LLRBNode=} root_ (Optional) Root node for the map.\n   */\n  constructor(\n    private comparator_: Comparator<K>,\n    private root_:\n      | LLRBNode<K, V>\n      | LLRBEmptyNode<K, V> = SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>\n  ) {}\n\n  /**\n   * Returns a copy of the map, with the specified key/value added or replaced.\n   * (TODO: We should perhaps rename this method to 'put')\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @return {!SortedMap.<K, V>} New map, with item added.\n   */\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .insert(key, value, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns a copy of the map, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @return {!SortedMap.<K, V>} New map, with item removed.\n   */\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .remove(key, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns the value of the node with the given key, or null.\n   *\n   * @param {!K} key The key to look up.\n   * @return {?V} The value of the node with the given key, or null if the\n   * key doesn't exist.\n   */\n  get(key: K): V | null {\n    let cmp;\n    let node = this.root_;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the key of the item *before* the specified key, or null if key is the first item.\n   * @param {K} key The key to find the predecessor of\n   * @return {?K} The predecessor key.\n   */\n  getPredecessorKey(key: K): K | null {\n    let cmp,\n      node = this.root_,\n      rightParent = null;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw new Error(\n      'Attempted to find predecessor key for a nonexistent key.  What gives?'\n    );\n  }\n\n  /**\n   * @return {boolean} True if the map is empty.\n   */\n  isEmpty(): boolean {\n    return this.root_.isEmpty();\n  }\n\n  /**\n   * @return {number} The total number of nodes in the map.\n   */\n  count(): number {\n    return this.root_.count();\n  }\n\n  /**\n   * @return {?K} The minimum key in the map.\n   */\n  minKey(): K | null {\n    return this.root_.minKey();\n  }\n\n  /**\n   * @return {?K} The maximum key in the map.\n   */\n  maxKey(): K | null {\n    return this.root_.maxKey();\n  }\n\n  /**\n   * Traverses the map in key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return this.root_.inorderTraversal(action);\n  }\n\n  /**\n   * Traverses the map in reverse key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} True if the traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return this.root_.reverseTraversal(action);\n  }\n\n  /**\n   * Returns an iterator over the SortedMap.\n   * @template T\n   * @param {(function(K, V):T)=} resultGenerator\n   * @return {SortedMapIterator.<K, V, T>} The iterator.\n   */\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LLRBNode } from '../util/SortedMap';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\n\nconst LOG_2 = Math.log(2);\n\n/**\n * @constructor\n */\nclass Base12Num {\n  count: number;\n  private current_: number;\n  private bits_: number;\n\n  /**\n   * @param {number} length\n   */\n  constructor(length: number) {\n    const logBase2 = (num: number) =>\n      parseInt((Math.log(num) / LOG_2) as any, 10);\n    const bitMask = (bits: number) => parseInt(Array(bits + 1).join('1'), 2);\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    const mask = bitMask(this.count);\n    this.bits_ = (length + 1) & mask;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  nextBitIsOne(): boolean {\n    //noinspection JSBitwiseOperatorUsage\n    const result = !(this.bits_ & (0x1 << this.current_));\n    this.current_--;\n    return result;\n  }\n}\n\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexport const buildChildSet = function<K, V>(\n  childList: NamedNode[],\n  cmp: (a: NamedNode, b: NamedNode) => number,\n  keyFn?: (a: NamedNode) => K,\n  mapSortFn?: (a: K, b: K) => number\n): SortedMap<K, V> {\n  childList.sort(cmp);\n\n  const buildBalancedTree = function(\n    low: number,\n    high: number\n  ): LLRBNode<K, V> | null {\n    const length = high - low;\n    let namedNode: NamedNode;\n    let key: K;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        null,\n        null\n      );\n    } else {\n      const middle = parseInt((length / 2) as any, 10) + low;\n      const left = buildBalancedTree(low, middle);\n      const right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        left,\n        right\n      );\n    }\n  };\n\n  const buildFrom12Array = function(base12: Base12Num): LLRBNode<K, V> {\n    let node: LLRBNode<K, V> = null;\n    let root = null;\n    let index = childList.length;\n\n    const buildPennant = function(chunkSize: number, color: boolean) {\n      const low = index - chunkSize;\n      const high = index;\n      index -= chunkSize;\n      const childTree = buildBalancedTree(low + 1, high);\n      const namedNode = childList[low];\n      const key: K = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      attachPennant(\n        new LLRBNode(key, (namedNode.node as any) as V, color, null, childTree)\n      );\n    };\n\n    const attachPennant = function(pennant: LLRBNode<K, V>) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (let i = 0; i < base12.count; ++i) {\n      const isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      const chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, LLRBNode.BLACK);\n        buildPennant(chunkSize, LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n\n  const base12 = new Base12Num(childList.length);\n  const root = buildFrom12Array(base12);\n\n  return new SortedMap<K, V>(mapSortFn || (cmp as any), root);\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { buildChildSet } from './childSet';\nimport { contains, map, safeGet } from '@firebase/util';\nimport { NamedNode, Node } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { Index } from './indexes/Index';\n\nlet _defaultIndexMap: IndexMap;\n\nconst fallbackObject = {};\n\nexport class IndexMap {\n  /**\n   * The default IndexMap for nodes without a priority\n   */\n  static get Default(): IndexMap {\n    assert(\n      fallbackObject && PRIORITY_INDEX,\n      'ChildrenNode.ts has not been loaded'\n    );\n    _defaultIndexMap =\n      _defaultIndexMap ||\n      new IndexMap(\n        { '.priority': fallbackObject },\n        { '.priority': PRIORITY_INDEX }\n      );\n    return _defaultIndexMap;\n  }\n\n  constructor(\n    private indexes_: {\n      [k: string]: SortedMap<NamedNode, Node> | /*FallbackType*/ object;\n    },\n    private indexSet_: { [k: string]: Index }\n  ) {}\n\n  get(indexKey: string): SortedMap<NamedNode, Node> | null {\n    const sortedMap = safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap instanceof SortedMap) {\n      return sortedMap;\n    } else {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    }\n  }\n\n  hasIndex(indexDefinition: Index): boolean {\n    return contains(this.indexSet_, indexDefinition.toString());\n  }\n\n  addIndex(\n    indexDefinition: Index,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    assert(\n      indexDefinition !== KEY_INDEX,\n      \"KeyIndex always exists and isn't meant to be added to the IndexMap.\"\n    );\n    const childList = [];\n    let sawIndexedValue = false;\n    const iter = existingChildren.getIterator(NamedNode.Wrap);\n    let next = iter.getNext();\n    while (next) {\n      sawIndexedValue =\n        sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    let newIndex;\n    if (sawIndexedValue) {\n      newIndex = buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    const indexName = indexDefinition.toString();\n    const newIndexSet = { ...this.indexSet_ };\n    newIndexSet[indexName] = indexDefinition;\n    const newIndexes = { ...this.indexes_ };\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  }\n\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   */\n  addToIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(\n      this.indexes_,\n      (indexedChildren: SortedMap<NamedNode, Node>, indexName: string) => {\n        const index = safeGet(this.indexSet_, indexName);\n        assert(index, 'Missing index implementation for ' + indexName);\n        if (indexedChildren === fallbackObject) {\n          // Check to see if we need to index everything\n          if (index.isDefinedOn(namedNode.node)) {\n            // We need to build this index\n            const childList = [];\n            const iter = existingChildren.getIterator(NamedNode.Wrap);\n            let next = iter.getNext();\n            while (next) {\n              if (next.name != namedNode.name) {\n                childList.push(next);\n              }\n              next = iter.getNext();\n            }\n            childList.push(namedNode);\n            return buildChildSet(childList, index.getCompare());\n          } else {\n            // No change, this remains a fallback\n            return fallbackObject;\n          }\n        } else {\n          const existingSnap = existingChildren.get(namedNode.name);\n          let newChildren = indexedChildren;\n          if (existingSnap) {\n            newChildren = newChildren.remove(\n              new NamedNode(namedNode.name, existingSnap)\n            );\n          }\n          return newChildren.insert(namedNode, namedNode.node);\n        }\n      }\n    );\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n\n  /**\n   * Create a new IndexMap instance with the given value removed\n   */\n  removeFromIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(this.indexes_, function(\n      indexedChildren: SortedMap<NamedNode, Node>\n    ) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        const existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(\n            new NamedNode(namedNode.name, existingSnap)\n          );\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap, SortedMapIterator } from '../util/SortedMap';\nimport { Node, NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport {\n  PRIORITY_INDEX,\n  setMaxNode as setPriorityMaxNode\n} from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\nimport { Index } from './indexes/Index';\nimport { Path } from '../util/Path';\n\nexport interface ChildrenNodeConstructor {\n  new (\n    children_: SortedMap<string, Node>,\n    priorityNode_: Node | null,\n    indexMap_: IndexMap\n  ): ChildrenNode;\n  EMPTY_NODE: ChildrenNode;\n}\n\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\n\nlet EMPTY_NODE: ChildrenNode;\n\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nexport class ChildrenNode implements Node {\n  private lazyHash_: string | null = null;\n\n  static get EMPTY_NODE(): ChildrenNode {\n    return (\n      EMPTY_NODE ||\n      (EMPTY_NODE = new ChildrenNode(\n        new SortedMap<string, Node>(NAME_COMPARATOR),\n        null,\n        IndexMap.Default\n      ))\n    );\n  }\n\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  constructor(\n    private readonly children_: SortedMap<string, Node>,\n    private readonly priorityNode_: Node | null,\n    private indexMap_: IndexMap\n  ) {\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      assert(\n        !this.priorityNode_ || this.priorityNode_.isEmpty(),\n        'An empty node cannot have a priority'\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_ || EMPTY_NODE;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      const child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    const front = path.getFront();\n    if (front === null) return this;\n\n    return this.getImmediateChild(front).getChild(path.popFront());\n  }\n\n  /** @inheritDoc */\n  hasChild(childName: string): boolean {\n    return this.children_.get(childName) !== null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      const namedNode = new NamedNode(childName, newChildNode);\n      let newChildren, newIndexMap, newPriority;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(\n          namedNode,\n          this.children_\n        );\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      assert(\n        path.getFront() !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n      const newImmediateChild = this.getImmediateChild(front).updateChild(\n        path.popFront(),\n        newChildNode\n      );\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return this.children_.isEmpty();\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return this.children_.count();\n  }\n\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  private static INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n\n  /** @inheritDoc */\n  val(exportFormat?: boolean): object {\n    if (this.isEmpty()) return null;\n\n    const obj: { [k: string]: unknown } = {};\n    let numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PRIORITY_INDEX, function(key: string, childNode: Node) {\n      obj[key] = childNode.val(exportFormat);\n\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      const array: unknown[] = [];\n      for (let key in obj) array[(key as any) as number] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.getPriority().isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.getPriority().val() as string | number) +\n          ':';\n\n      this.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        const childHash = childNode.hash();\n        if (childHash !== '') toHash += ':' + key + ':' + childHash;\n      });\n\n      this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(\n    childName: string,\n    childNode: Node,\n    index: Index\n  ): string {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      const predecessor = idx.getPredecessorKey(\n        new NamedNode(childName, childNode)\n      );\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getFirstChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getFirstChild(indexDefinition: Index): NamedNode | null {\n    const minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getLastChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getLastChild(indexDefinition: Index): NamedNode | null {\n    const maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachChild(\n    index: Index,\n    action: (key: string, node: Node) => boolean | void\n  ): boolean {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function(wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  getIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  }\n\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getIteratorFrom(\n    startPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, key => key);\n    } else {\n      const iterator = this.children_.getIteratorFrom(\n        startPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getReverseIteratorFrom(\n      indexDefinition.maxPost(),\n      indexDefinition\n    );\n  }\n\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIteratorFrom(\n    endPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function(key) {\n        return key;\n      });\n    } else {\n      const iterator = this.children_.getReverseIteratorFrom(\n        endPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: ChildrenNode): number {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(indexDefinition: Index): Node {\n    if (\n      indexDefinition === KEY_INDEX ||\n      this.indexMap_.hasIndex(indexDefinition)\n    ) {\n      return this;\n    } else {\n      const newIndexMap = this.indexMap_.addIndex(\n        indexDefinition,\n        this.children_\n      );\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(index: Index): boolean {\n    return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      const otherChildrenNode = other as ChildrenNode;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (\n        this.children_.count() === otherChildrenNode.children_.count()\n      ) {\n        const thisIter = this.getIterator(PRIORITY_INDEX);\n        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n        let thisCurrent = thisIter.getNext();\n        let otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (\n            thisCurrent.name !== otherCurrent.name ||\n            !thisCurrent.node.equals(otherCurrent.node)\n          ) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  private resolveIndex_(\n    indexDefinition: Index\n  ): SortedMap<NamedNode, Node> | null {\n    if (indexDefinition === KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  }\n}\n\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nexport class MaxNode extends ChildrenNode {\n  constructor() {\n    super(\n      new SortedMap<string, Node>(NAME_COMPARATOR),\n      ChildrenNode.EMPTY_NODE,\n      IndexMap.Default\n    );\n  }\n\n  compareTo(other: Node): number {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n\n  equals(other: Node): boolean {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  }\n\n  getPriority(): MaxNode {\n    return this;\n  }\n\n  getImmediateChild(childName: string): ChildrenNode {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n}\n\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport const MAX_NODE = new MaxNode();\n\n/**\n * Document NamedNode extensions\n */\ndeclare module './Node' {\n  interface NamedNode {\n    MIN: NamedNode;\n    MAX: NamedNode;\n  }\n}\n\nObject.defineProperties(NamedNode, {\n  MIN: {\n    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new NamedNode(MAX_NAME, MAX_NODE)\n  }\n});\n\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { nameCompare } from '../util/util';\nimport { NamedNode } from './Node';\n\nexport function NAME_ONLY_COMPARATOR(left: NamedNode, right: NamedNode) {\n  return nameCompare(left.name, right.name);\n}\n\nexport function NAME_COMPARATOR(left: string, right: string) {\n  return nameCompare(left, right);\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChildrenNode } from './ChildrenNode';\nimport { LeafNode } from './LeafNode';\nimport { NamedNode, Node } from './Node';\nimport { contains } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { buildChildSet } from './childSet';\nimport { NAME_COMPARATOR, NAME_ONLY_COMPARATOR } from './comparators';\nimport { IndexMap } from './IndexMap';\nimport { PRIORITY_INDEX, setNodeFromJSON } from './indexes/PriorityIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { each } from '../util/util';\n\nconst USE_HINZE = true;\n\n/**\n * Constructs a snapshot node representing the passed JSON and returns it.\n * @param {*} json JSON to create a node for.\n * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the\n * passed JSON contains a .priority property.\n * @return {!Node}\n */\nexport function nodeFromJSON(\n  json: any | null,\n  priority: string | number | null = null\n): Node {\n  if (json === null) {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  if (typeof json === 'object' && '.priority' in json) {\n    priority = json['.priority'];\n  }\n\n  assert(\n    priority === null ||\n      typeof priority === 'string' ||\n      typeof priority === 'number' ||\n      (typeof priority === 'object' && '.sv' in (priority as object)),\n    'Invalid priority type found: ' + typeof priority\n  );\n\n  if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\n    json = json['.value'];\n  }\n\n  // Valid leaf nodes include non-objects or server-value wrapper objects\n  if (typeof json !== 'object' || '.sv' in json) {\n    const jsonLeaf = json as string | number | boolean | object;\n    return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n  }\n\n  if (!(json instanceof Array) && USE_HINZE) {\n    const children: NamedNode[] = [];\n    let childrenHavePriority = false;\n    const hinzeJsonObj: { [k: string]: any } = json;\n    each(hinzeJsonObj, (key, child) => {\n      if (key.substring(0, 1) !== '.') {\n        // Ignore metadata nodes\n        const childNode = nodeFromJSON(child);\n        if (!childNode.isEmpty()) {\n          childrenHavePriority =\n            childrenHavePriority || !childNode.getPriority().isEmpty();\n          children.push(new NamedNode(key, childNode));\n        }\n      }\n    });\n\n    if (children.length == 0) {\n      return ChildrenNode.EMPTY_NODE;\n    }\n\n    const childSet = buildChildSet(\n      children,\n      NAME_ONLY_COMPARATOR,\n      namedNode => namedNode.name,\n      NAME_COMPARATOR\n    ) as SortedMap<string, Node>;\n    if (childrenHavePriority) {\n      const sortedChildSet = buildChildSet(\n        children,\n        PRIORITY_INDEX.getCompare()\n      );\n      return new ChildrenNode(\n        childSet,\n        nodeFromJSON(priority),\n        new IndexMap(\n          { '.priority': sortedChildSet },\n          { '.priority': PRIORITY_INDEX }\n        )\n      );\n    } else {\n      return new ChildrenNode(\n        childSet,\n        nodeFromJSON(priority),\n        IndexMap.Default\n      );\n    }\n  } else {\n    let node: Node = ChildrenNode.EMPTY_NODE;\n    each(json, (key: string, childData: any) => {\n      if (contains(json, key)) {\n        if (key.substring(0, 1) !== '.') {\n          // ignore metadata nodes.\n          const childNode = nodeFromJSON(childData);\n          if (childNode.isLeafNode() || !childNode.isEmpty())\n            node = node.updateImmediateChild(key, childNode);\n        }\n      }\n    });\n\n    return node.updatePriority(nodeFromJSON(priority));\n  }\n}\n\nsetNodeFromJSON(nodeFromJSON);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Index } from './Index';\nimport { NamedNode, Node } from '../Node';\nimport { nameCompare } from '../../util/util';\nimport { nodeFromJSON } from '../nodeFromJSON';\n\n/**\n * @constructor\n * @extends {Index}\n * @private\n */\nexport class ValueIndex extends Index {\n  /**\n   * @inheritDoc\n   */\n  compare(a: NamedNode, b: NamedNode): number {\n    const indexCmp = a.node.compareTo(b.node);\n    if (indexCmp === 0) {\n      return nameCompare(a.name, b.name);\n    } else {\n      return indexCmp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isDefinedOn(node: Node): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  indexedValueChanged(oldNode: Node, newNode: Node): boolean {\n    return !oldNode.equals(newNode);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  minPost(): NamedNode {\n    return (NamedNode as any).MIN;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  maxPost(): NamedNode {\n    return (NamedNode as any).MAX;\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {string} name\n   * @return {!NamedNode}\n   */\n  makePost(indexValue: object, name: string): NamedNode {\n    const valueNode = nodeFromJSON(indexValue);\n    return new NamedNode(name, valueNode);\n  }\n\n  /**\n   * @return {!string} String representation for inclusion in a query spec\n   */\n  toString(): string {\n    return '.value';\n  }\n}\n\nexport const VALUE_INDEX = new ValueIndex();\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { nameCompare, MAX_NAME } from '../../util/util';\nimport { Index } from './Index';\nimport { ChildrenNode, MAX_NODE } from '../ChildrenNode';\nimport { NamedNode, Node } from '../Node';\nimport { nodeFromJSON } from '../nodeFromJSON';\nimport { Path } from '../../util/Path';\n\n/**\n * @param {!Path} indexPath\n * @constructor\n * @extends {Index}\n */\nexport class PathIndex extends Index {\n  constructor(private indexPath_: Path) {\n    super();\n\n    assert(\n      !indexPath_.isEmpty() && indexPath_.getFront() !== '.priority',\n      \"Can't create PathIndex with empty path or .priority key\"\n    );\n  }\n\n  /**\n   * @param {!Node} snap\n   * @return {!Node}\n   * @protected\n   */\n  protected extractChild(snap: Node): Node {\n    return snap.getChild(this.indexPath_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isDefinedOn(node: Node): boolean {\n    return !node.getChild(this.indexPath_).isEmpty();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compare(a: NamedNode, b: NamedNode): number {\n    const aChild = this.extractChild(a.node);\n    const bChild = this.extractChild(b.node);\n    const indexCmp = aChild.compareTo(bChild);\n    if (indexCmp === 0) {\n      return nameCompare(a.name, b.name);\n    } else {\n      return indexCmp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  makePost(indexValue: object, name: string): NamedNode {\n    const valueNode = nodeFromJSON(indexValue);\n    const node = ChildrenNode.EMPTY_NODE.updateChild(\n      this.indexPath_,\n      valueNode\n    );\n    return new NamedNode(name, node);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  maxPost(): NamedNode {\n    const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\n    return new NamedNode(MAX_NAME, node);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toString(): string {\n    return this.indexPath_.slice().join('/');\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { validatePathString } from '../core/util/validation';\nimport { Path } from '../core/util/Path';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { Node } from '../core/snap/Node';\nimport { Reference } from './Reference';\nimport { Index } from '../core/snap/indexes/Index';\nimport { ChildrenNode } from '../core/snap/ChildrenNode';\n\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\nexport class DataSnapshot {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  constructor(\n    private readonly node_: Node,\n    private readonly ref_: Reference,\n    private readonly index_: Index\n  ) {}\n\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  val(): any {\n    validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  }\n\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  exportVal(): any {\n    validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  toJSON(): any {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  }\n\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n  exists(): boolean {\n    validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  }\n\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n  child(childPathString: string): DataSnapshot {\n    validateArgCount('DataSnapshot.child', 0, 1, arguments.length);\n    // Ensure the childPath is a string (can be a number)\n    childPathString = String(childPathString);\n    validatePathString('DataSnapshot.child', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    const childRef = this.ref_.child(childPath);\n    return new DataSnapshot(\n      this.node_.getChild(childPath),\n      childRef,\n      PRIORITY_INDEX\n    );\n  }\n\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n  hasChild(childPathString: string): boolean {\n    validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  }\n\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n  getPriority(): string | number | null {\n    validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);\n\n    // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n    return this.node_.getPriority().val() as string | number | null;\n  }\n\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n  forEach(action: (d: DataSnapshot) => boolean | void): boolean {\n    validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    validateCallback('DataSnapshot.forEach', 1, action, false);\n\n    if (this.node_.isLeafNode()) return false;\n\n    const childrenNode = this.node_ as ChildrenNode;\n    // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n    return !!childrenNode.forEachChild(this.index_, (key, node) => {\n      return action(\n        new DataSnapshot(node, this.ref_.child(key), PRIORITY_INDEX)\n      );\n    });\n  }\n\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n  hasChildren(): boolean {\n    validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n\n    if (this.node_.isLeafNode()) return false;\n    else return !this.node_.isEmpty();\n  }\n\n  get key() {\n    return this.ref_.getKey();\n  }\n\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n  numChildren(): number {\n    validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n\n    return this.node_.numChildren();\n  }\n\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n  getRef(): Reference {\n    validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n\n    return this.ref_;\n  }\n\n  get ref() {\n    return this.getRef();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stringify } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { EventRegistration } from './EventRegistration';\nimport { DataSnapshot } from '../../api/DataSnapshot';\n\n/**\n * Encapsulates the data needed to raise an event\n * @interface\n */\nexport interface Event {\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path;\n\n  /**\n   * @return {!string}\n   */\n  getEventType(): string;\n\n  /**\n   * @return {!function()}\n   */\n  getEventRunner(): () => void;\n\n  /**\n   * @return {!string}\n   */\n  toString(): string;\n}\n\n/**\n * Encapsulates the data needed to raise an event\n * @implements {Event}\n */\nexport class DataEvent implements Event {\n  /**\n   * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed\n   * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided\n   * @param {!DataSnapshot} snapshot The data backing the event\n   * @param {?string=} prevName Optional, the name of the previous child for child_* events.\n   */\n  constructor(\n    public eventType:\n      | 'value'\n      | ' child_added'\n      | ' child_changed'\n      | ' child_moved'\n      | ' child_removed',\n    public eventRegistration: EventRegistration,\n    public snapshot: DataSnapshot,\n    public prevName?: string | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  getPath(): Path {\n    const ref = this.snapshot.getRef();\n    if (this.eventType === 'value') {\n      return ref.path;\n    } else {\n      return ref.getParent().path;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventType(): string {\n    return this.eventType;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(): () => void {\n    return this.eventRegistration.getEventRunner(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toString(): string {\n    return (\n      this.getPath().toString() +\n      ':' +\n      this.eventType +\n      ':' +\n      stringify(this.snapshot.exportVal())\n    );\n  }\n}\n\nexport class CancelEvent implements Event {\n  /**\n   * @param {EventRegistration} eventRegistration\n   * @param {Error} error\n   * @param {!Path} path\n   */\n  constructor(\n    public eventRegistration: EventRegistration,\n    public error: Error,\n    public path: Path\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  getPath(): Path {\n    return this.path;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventType(): string {\n    return 'cancel';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(): () => void {\n    return this.eventRegistration.getEventRunner(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toString(): string {\n    return this.path.toString() + ':cancel';\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent, Event } from './Event';\nimport { contains } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Change } from './Change';\nimport { Query } from '../../api/Query';\n\n/**\n * An EventRegistration is basically an event type ('value', 'child_added', etc.) and a callback\n * to be notified of that type of event.\n *\n * That said, it can also contain a cancel callback to be notified if the event is canceled.  And\n * currently, this code is organized around the idea that you would register multiple child_ callbacks\n * together, as a single EventRegistration.  Though currently we don't do that.\n */\nexport interface EventRegistration {\n  /**\n   * True if this container has a callback to trigger for this event type\n   * @param {!string} eventType\n   * @return {boolean}\n   */\n  respondsTo(eventType: string): boolean;\n\n  /**\n   * @param {!Change} change\n   * @param {!Query} query\n   * @return {!Event}\n   */\n  createEvent(change: Change, query: Query): Event;\n\n  /**\n   * Given event data, return a function to trigger the user's callback\n   * @param {!Event} eventData\n   * @return {function()}\n   */\n  getEventRunner(eventData: Event): () => void;\n\n  /**\n   * @param {!Error} error\n   * @param {!Path} path\n   * @return {?CancelEvent}\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null;\n\n  /**\n   * @param {!EventRegistration} other\n   * @return {boolean}\n   */\n  matches(other: EventRegistration): boolean;\n\n  /**\n   * False basically means this is a \"dummy\" callback container being used as a sentinel\n   * to remove all callback containers of a particular type.  (e.g. if the user does\n   * ref.off('value') without specifying a specific callback).\n   *\n   * (TODO: Rework this, since it's hacky)\n   *\n   * @return {boolean}\n   */\n  hasAnyCallback(): boolean;\n}\n\n/**\n * Represents registration for 'value' events.\n */\nexport class ValueEventRegistration implements EventRegistration {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  constructor(\n    private callback_: ((d: DataSnapshot) => void) | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_: Object | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    return eventType === 'value';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      'value',\n      this,\n      new DataSnapshot(change.snapshotNode, query.getRef(), index)\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callback_;\n      return function() {\n        cb.call(ctx, (eventData as DataEvent).snapshot);\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return (\n        other.callback_ === this.callback_ && other.context_ === this.context_\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callback_ !== null;\n  }\n}\n\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nexport class ChildEventRegistration implements EventRegistration {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  constructor(\n    private callbacks_:\n      | ({ [k: string]: (d: DataSnapshot, s?: string | null) => void })\n      | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_?: Object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    let eventToCheck =\n      eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck =\n      eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return contains(this.callbacks_, eventToCheck);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    assert(change.childName != null, 'Child events should have a childName.');\n    const ref = query.getRef().child(/** @type {!string} */ change.childName);\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      change.type as any,\n      this,\n      new DataSnapshot(change.snapshotNode, ref, index as any),\n      change.prevName\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callbacks_[(eventData as DataEvent).eventType];\n      return function() {\n        cb.call(\n          ctx,\n          (eventData as DataEvent).snapshot,\n          (eventData as DataEvent).prevName\n        );\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        const otherKeys = Object.keys(other.callbacks_);\n        const thisKeys = Object.keys(this.callbacks_);\n        const otherCount = otherKeys.length;\n        const thisCount = thisKeys.length;\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          // If event types don't match, not a match\n          // If count is not 1, exact match across all\n\n          if (otherCount === 1) {\n            const otherKey = otherKeys[0];\n            const thisKey = thisKeys[0];\n            return (\n              thisKey === otherKey &&\n              (!other.callbacks_[otherKey] ||\n                !this.callbacks_[thisKey] ||\n                other.callbacks_[otherKey] === this.callbacks_[thisKey])\n            );\n          } else {\n            // Exact match on each key.\n            return thisKeys.every(\n              eventType =>\n                other.callbacks_[eventType] === this.callbacks_[eventType]\n            );\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callbacks_ !== null;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey\n} from '../core/util/validation';\nimport {\n  errorPrefix,\n  validateArgCount,\n  validateCallback,\n  validateContextObject\n} from '@firebase/util';\nimport {\n  ValueEventRegistration,\n  ChildEventRegistration,\n  EventRegistration\n} from '../core/view/EventRegistration';\nimport { Deferred } from '@firebase/util';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new (repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string | null): any;\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(\n    public repo: Repo,\n    public path: Path,\n    private queryParams_: QueryParams,\n    private orderByCalled_: boolean\n  ) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError =\n        'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError =\n        'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n      if (\n        (startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))\n      ) {\n        throw new Error(\n          'Query: When ordering by priority, the first argument passed to startAt(), ' +\n            'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).'\n        );\n      }\n    } else {\n      assert(\n        params.getIndex() instanceof PathIndex ||\n          params.getIndex() === VALUE_INDEX,\n        'unknown index type.'\n      );\n      if (\n        (startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')\n      ) {\n        throw new Error(\n          'Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n            'an object.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (\n      params.hasStart() &&\n      params.hasEnd() &&\n      params.hasLimit() &&\n      !params.hasAnchoredLimit()\n    ) {\n      throw new Error(\n        \"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\"\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path) as Reference;\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(\n    eventType: string,\n    callback: SnapshotCallback,\n    cancelCallbackOrContext?: ((a: Error) => any) | Object | null,\n    context?: Object | null\n  ): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.on',\n      cancelCallbackOrContext,\n      context\n    );\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(\n    callback: (a: DataSnapshot) => void,\n    cancelCallback: ((a: Error) => void) | null,\n    context: Object | null\n  ) {\n    const container = new ValueEventRegistration(\n      callback,\n      cancelCallback || null,\n      context || null\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(\n    callbacks: { [k: string]: SnapshotCallback },\n    cancelCallback: ((a: Error) => any) | null,\n    context: Object | null\n  ) {\n    const container = new ChildEventRegistration(\n      callbacks,\n      cancelCallback,\n      context\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(\n    eventType?: string,\n    callback?: SnapshotCallback,\n    context?: Object | null\n  ): void {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(\n        valueCallback,\n        null,\n        context || null\n      );\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param failureCallbackOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(\n    eventType: string,\n    userCallback?: SnapshotCallback,\n    failureCallbackOrContext?: ((a: Error) => void) | Object | null,\n    context?: Object | null\n  ): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.once',\n      failureCallbackOrContext,\n      context\n    );\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred<DataSnapshot>();\n\n    // A dummy error handler in case a user wasn't expecting promises\n    deferred.promise.catch(() => {});\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(\n      eventType,\n      onceCallback,\n      /*cancel=*/ err => {\n        this.off(eventType, onceCallback);\n\n        if (ret.cancel) ret.cancel.bind(ret.context)(err);\n        deferred.reject(err);\n      }\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToFirst: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToFirst: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToFirst(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToLast: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToLast: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToLast(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error(\n        'Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.'\n      );\n    } else if (path === '$priority') {\n      throw new Error(\n        'Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.'\n      );\n    } else if (path === '$value') {\n      throw new Error(\n        'Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.'\n      );\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error(\n        'Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.'\n      );\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.startAt: Starting point was already set (by another call to startAt ' +\n          'or equalTo).'\n      );\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.endAt: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.equalTo: Starting point was already set (by another call to startAt or ' +\n          'equalTo).'\n      );\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.equalTo: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error =\n        'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = this.repo === other.repo;\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier =\n      this.queryIdentifier() === other.queryIdentifier();\n\n    return sameRepo && samePath && sameQueryIdentifier;\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(\n    fnName: string,\n    cancelOrContext?: ((a: Error) => void) | Object | null,\n    context?: Object | null\n  ): { cancel: ((a: Error) => void) | null; context: Object | null } {\n    const ret: {\n      cancel: ((a: Error) => void) | null;\n      context: Object | null;\n    } = { cancel: null, context: null };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext as (a: Error) => void;\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext as (a: Error) => void;\n      } else {\n        throw new Error(\n          errorPrefix(fnName, 3, true) +\n            ' must either be a cancel callback or a context object.'\n        );\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n */\nexport class SparseSnapshotTree {\n  private value: Node | null = null;\n\n  private readonly children: Map<string, SparseSnapshotTree> = new Map();\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param path Path to look up snapshot for.\n   * @return The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value != null) {\n      return this.value.getChild(path);\n    } else if (!path.isEmpty() && this.children.size > 0) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children.has(childKey)) {\n        const childTree = this.children.get(childKey);\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param path Path to look up snapshot for.\n   * @param data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value = data;\n      this.children.clear();\n    } else if (this.value !== null) {\n      this.value = this.value.updateChild(path, data);\n    } else {\n      const childKey = path.getFront();\n      if (!this.children.has(childKey)) {\n        this.children.set(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children.get(childKey);\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param path Path to look up snapshot for.\n   * @return True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value = null;\n      this.children.clear();\n      return true;\n    } else {\n      if (this.value !== null) {\n        if (this.value.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value;\n          this.value = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children.size > 0) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children.has(childKey)) {\n          const safeToRemove = this.children.get(childKey).forget(path);\n          if (safeToRemove) {\n            this.children.delete(childKey);\n          }\n        }\n\n        return this.children.size === 0;\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param prefixPath Path to look up node for.\n   * @param func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value !== null) {\n      func(prefixPath, this.value);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    this.children.forEach((tree, key) => {\n      func(key, tree);\n    });\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { SparseSnapshotTree } from '../SparseSnapshotTree';\nimport { LeafNode } from '../snap/LeafNode';\nimport { nodeFromJSON } from '../snap/nodeFromJSON';\nimport { PRIORITY_INDEX } from '../snap/indexes/PriorityIndex';\nimport { Node } from '../snap/Node';\nimport { ChildrenNode } from '../snap/ChildrenNode';\n\n/**\n * Generate placeholders for deferred values.\n * @param {?Object} values\n * @return {!Object}\n */\nexport const generateWithValues = function(\n  values: {\n    [k: string]: any;\n  } | null\n): { [k: string]: any } {\n  values = values || {};\n  values['timestamp'] = values['timestamp'] || new Date().getTime();\n  return values;\n};\n\n/**\n * Value to use when firing local events. When writing server values, fire\n * local events with an approximate value, otherwise return value as-is.\n * @param {(Object|string|number|boolean)} value\n * @param {!Object} serverValues\n * @return {!(string|number|boolean)}\n */\nexport const resolveDeferredValue = function(\n  value: { [k: string]: any } | string | number | boolean,\n  serverValues: { [k: string]: any }\n): string | number | boolean {\n  if (!value || typeof value !== 'object') {\n    return value as string | number | boolean;\n  } else {\n    assert('.sv' in value, 'Unexpected leaf node or priority contents');\n    return serverValues[value['.sv']];\n  }\n};\n\n/**\n * Recursively replace all deferred values and priorities in the tree with the\n * specified generated replacement values.\n * @param {!SparseSnapshotTree} tree\n * @param {!Object} serverValues\n * @return {!SparseSnapshotTree}\n */\nexport const resolveDeferredValueTree = function(\n  tree: SparseSnapshotTree,\n  serverValues: Object\n): SparseSnapshotTree {\n  const resolvedTree = new SparseSnapshotTree();\n  tree.forEachTree(new Path(''), function(path, node) {\n    resolvedTree.remember(\n      path,\n      resolveDeferredValueSnapshot(node, serverValues)\n    );\n  });\n  return resolvedTree;\n};\n\n/**\n * Recursively replace all deferred values and priorities in the node with the\n * specified generated replacement values.  If there are no server values in the node,\n * it'll be returned as-is.\n * @param {!Node} node\n * @param {!Object} serverValues\n * @return {!Node}\n */\nexport const resolveDeferredValueSnapshot = function(\n  node: Node,\n  serverValues: Object\n): Node {\n  const rawPri = node.getPriority().val() as\n    | object\n    | boolean\n    | null\n    | number\n    | string;\n  const priority = resolveDeferredValue(rawPri, serverValues);\n  let newNode: Node;\n\n  if (node.isLeafNode()) {\n    const leafNode = node as LeafNode;\n    const value = resolveDeferredValue(leafNode.getValue(), serverValues);\n    if (\n      value !== leafNode.getValue() ||\n      priority !== leafNode.getPriority().val()\n    ) {\n      return new LeafNode(value, nodeFromJSON(priority));\n    } else {\n      return node;\n    }\n  } else {\n    const childrenNode = node as ChildrenNode;\n    newNode = childrenNode;\n    if (priority !== childrenNode.getPriority().val()) {\n      newNode = newNode.updatePriority(new LeafNode(priority));\n    }\n    childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {\n      const newChildNode = resolveDeferredValueSnapshot(\n        childNode,\n        serverValues\n      );\n      if (newChildNode !== childNode) {\n        newNode = newNode.updateImmediateChild(childName, newChildNode);\n      }\n    });\n    return newNode;\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\n\n/**\n *\n * @enum\n */\nexport enum OperationType {\n  OVERWRITE,\n  MERGE,\n  ACK_USER_WRITE,\n  LISTEN_COMPLETE\n}\n\n/**\n * @interface\n */\nexport interface Operation {\n  /**\n   * @type {!OperationSource}\n   */\n  source: OperationSource;\n\n  /**\n   * @type {!OperationType}\n   */\n  type: OperationType;\n\n  /**\n   * @type {!Path}\n   */\n  path: Path;\n\n  /**\n   * @param {string} childName\n   * @return {?Operation}\n   */\n  operationForChild(childName: string): Operation | null;\n}\n\n/**\n * @param {boolean} fromUser\n * @param {boolean} fromServer\n * @param {?string} queryId\n * @param {boolean} tagged\n * @constructor\n */\nexport class OperationSource {\n  constructor(\n    public fromUser: boolean,\n    public fromServer: boolean,\n    public queryId: string | null,\n    public tagged: boolean\n  ) {\n    assert(!tagged || fromServer, 'Tagged queries must be from server.');\n  }\n  /**\n   * @const\n   * @type {!OperationSource}\n   */\n  static User = new OperationSource(\n    /*fromUser=*/ true,\n    false,\n    null,\n    /*tagged=*/ false\n  );\n\n  /**\n   * @const\n   * @type {!OperationSource}\n   */\n  static Server = new OperationSource(\n    false,\n    /*fromServer=*/ true,\n    null,\n    /*tagged=*/ false\n  );\n\n  /**\n   * @param {string} queryId\n   * @return {!OperationSource}\n   */\n  static forServerTaggedQuery = function(queryId: string): OperationSource {\n    return new OperationSource(\n      false,\n      /*fromServer=*/ true,\n      queryId,\n      /*tagged=*/ true\n    );\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Operation, OperationSource, OperationType } from './Operation';\nimport { ImmutableTree } from '../util/ImmutableTree';\n\nexport class AckUserWrite implements Operation {\n  /** @inheritDoc */\n  type = OperationType.ACK_USER_WRITE;\n\n  /** @inheritDoc */\n  source = OperationSource.User;\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.\n   * @param {!boolean} revert\n   */\n  constructor(\n    /**@inheritDoc */ public path: Path,\n    /**@inheritDoc */ public affectedTree: ImmutableTree<boolean>,\n    /**@inheritDoc */ public revert: boolean\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  operationForChild(childName: string): AckUserWrite {\n    if (!this.path.isEmpty()) {\n      assert(\n        this.path.getFront() === childName,\n        'operationForChild called for unrelated child.'\n      );\n      return new AckUserWrite(\n        this.path.popFront(),\n        this.affectedTree,\n        this.revert\n      );\n    } else if (this.affectedTree.value != null) {\n      assert(\n        this.affectedTree.children.isEmpty(),\n        'affectedTree should not have overlapping affected paths.'\n      );\n      // All child locations are affected as well; just return same operation.\n      return this;\n    } else {\n      const childTree = this.affectedTree.subtree(new Path(childName));\n      return new AckUserWrite(Path.Empty, childTree, this.revert);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare, each } from './util';\n\nlet emptyChildrenSingleton: SortedMap<string, ImmutableTree<null>>;\n\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nconst EmptyChildren = (): SortedMap<string, ImmutableTree<null>> => {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap<string, ImmutableTree<null>>(\n      stringCompare\n    );\n  }\n  return emptyChildrenSingleton;\n};\n\n/**\n * A tree with immutable elements.\n */\nexport class ImmutableTree<T> {\n  static Empty = new ImmutableTree<any>(null);\n\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  static fromObject<T>(obj: { [k: string]: T }): ImmutableTree<T> {\n    let tree: ImmutableTree<T> = ImmutableTree.Empty;\n    each(obj, (childPath: string, childSnap: T) => {\n      tree = tree.set(new Path(childPath), childSnap);\n    });\n    return tree;\n  }\n\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  constructor(\n    public readonly value: T | null,\n    public readonly children: SortedMap<\n      string,\n      ImmutableTree<T>\n    > = EmptyChildren()\n  ) {}\n\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.value === null && this.children.isEmpty();\n  }\n\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  findRootMostMatchingPathAndValue(\n    relativePath: Path,\n    predicate: (a: T) => boolean\n  ): { path: Path; value: T } | null {\n    if (this.value != null && predicate(this.value)) {\n      return { path: Path.Empty, value: this.value };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        const front = relativePath.getFront();\n        const child = this.children.get(front);\n        if (child !== null) {\n          const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(\n            relativePath.popFront(),\n            predicate\n          );\n          if (childExistingPathAndValue != null) {\n            const fullPath = new Path(front).child(\n              childExistingPathAndValue.path\n            );\n            return { path: fullPath, value: childExistingPathAndValue.value };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  findRootMostValueAndPath(\n    relativePath: Path\n  ): { path: Path; value: T } | null {\n    return this.findRootMostMatchingPathAndValue(relativePath, () => true);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  subtree(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      const front = relativePath.getFront();\n      const childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  set(relativePath: Path, toSet: T | null): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.set(relativePath.popFront(), toSet);\n      const newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  remove(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        const newChild = child.remove(relativePath.popFront());\n        let newChildren;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  get(relativePath: Path): T | null {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.setTree(relativePath.popFront(), newTree);\n      let newChildren;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  fold<V>(fn: (path: Path, value: T, children: { [k: string]: V }) => V): V {\n    return this.fold_(Path.Empty, fn);\n  }\n\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  private fold_<V>(\n    pathSoFar: Path,\n    fn: (path: Path, value: T | null, children: { [k: string]: V }) => V\n  ): V {\n    const accum: { [k: string]: V } = {};\n    this.children.inorderTraversal(function(\n      childKey: string,\n      childTree: ImmutableTree<T>\n    ) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  }\n\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null {\n    return this.findOnPath_(path, Path.Empty, f);\n  }\n\n  private findOnPath_<V>(\n    pathToFollow: Path,\n    pathSoFar: Path,\n    f: (path: Path, value: T) => V | null\n  ): V | null {\n    const result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        const front = pathToFollow.getFront()!;\n        const nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(\n            pathToFollow.popFront(),\n            pathSoFar.child(front),\n            f\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  foreachOnPath(\n    path: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    return this.foreachOnPath_(path, Path.Empty, f);\n  }\n\n  private foreachOnPath_(\n    pathToFollow: Path,\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      const front = pathToFollow.getFront();\n      const nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(\n          pathToFollow.popFront(),\n          currentRelativePath.child(front),\n          f\n        );\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  foreach(f: (path: Path, value: T) => void) {\n    this.foreach_(Path.Empty, f);\n  }\n\n  private foreach_(\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ) {\n    this.children.inorderTraversal(function(childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  }\n\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  foreachChild(f: (name: string, value: T) => void) {\n    this.children.inorderTraversal(\n      (childName: string, childTree: ImmutableTree<T>) => {\n        if (childTree.value) {\n          f(childName, childTree.value);\n        }\n      }\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { Operation, OperationSource, OperationType } from './Operation';\n\n/**\n * @param {!OperationSource} source\n * @param {!Path} path\n * @constructor\n * @implements {Operation}\n */\nexport class ListenComplete implements Operation {\n  /** @inheritDoc */\n  type = OperationType.LISTEN_COMPLETE;\n\n  constructor(public source: OperationSource, public path: Path) {}\n\n  operationForChild(childName: string): ListenComplete {\n    if (this.path.isEmpty()) {\n      return new ListenComplete(this.source, Path.Empty);\n    } else {\n      return new ListenComplete(this.source, this.path.popFront());\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationSource, OperationType } from './Operation';\nimport { Path } from '../util/Path';\nimport { Node } from '../snap/Node';\n\n/**\n * @param {!OperationSource} source\n * @param {!Path} path\n * @param {!Node} snap\n * @constructor\n * @implements {Operation}\n */\nexport class Overwrite implements Operation {\n  /** @inheritDoc */\n  type = OperationType.OVERWRITE;\n\n  constructor(\n    public source: OperationSource,\n    public path: Path,\n    public snap: Node\n  ) {}\n\n  operationForChild(childName: string): Overwrite {\n    if (this.path.isEmpty()) {\n      return new Overwrite(\n        this.source,\n        Path.Empty,\n        this.snap.getImmediateChild(childName)\n      );\n    } else {\n      return new Overwrite(this.source, this.path.popFront(), this.snap);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationSource, OperationType } from './Operation';\nimport { Overwrite } from './Overwrite';\nimport { Path } from '../util/Path';\nimport { assert } from '@firebase/util';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Node } from '../snap/Node';\n\n/**\n * @param {!OperationSource} source\n * @param {!Path} path\n * @param {!ImmutableTree.<!Node>} children\n * @constructor\n * @implements {Operation}\n */\nexport class Merge implements Operation {\n  /** @inheritDoc */\n  type = OperationType.MERGE;\n\n  constructor(\n    /**@inheritDoc */ public source: OperationSource,\n    /**@inheritDoc */ public path: Path,\n    /**@inheritDoc */ public children: ImmutableTree<Node>\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  operationForChild(childName: string): Operation {\n    if (this.path.isEmpty()) {\n      const childTree = this.children.subtree(new Path(childName));\n      if (childTree.isEmpty()) {\n        // This child is unaffected\n        return null;\n      } else if (childTree.value) {\n        // We have a snapshot for the child in question.  This becomes an overwrite of the child.\n        return new Overwrite(this.source, Path.Empty, childTree.value);\n      } else {\n        // This is a merge at a deeper level\n        return new Merge(this.source, Path.Empty, childTree);\n      }\n    } else {\n      assert(\n        this.path.getFront() === childName,\n        \"Can't get a merge for a child not on the path of the operation\"\n      );\n      return new Merge(this.source, this.path.popFront(), this.children);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toString(): string {\n    return (\n      'Operation(' +\n      this.path +\n      ': ' +\n      this.source.toString() +\n      ' merge: ' +\n      this.children.toString() +\n      ')'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Node } from '../snap/Node';\nimport { Path } from '../util/Path';\n\n/**\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\n * whether a node potentially had children removed due to a filter.\n */\nexport class CacheNode {\n  /**\n   * @param {!Node} node_\n   * @param {boolean} fullyInitialized_\n   * @param {boolean} filtered_\n   */\n  constructor(\n    private node_: Node,\n    private fullyInitialized_: boolean,\n    private filtered_: boolean\n  ) {}\n\n  /**\n   * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\n   * @return {boolean}\n   */\n  isFullyInitialized(): boolean {\n    return this.fullyInitialized_;\n  }\n\n  /**\n   * Returns whether this node is potentially missing children due to a filter applied to the node\n   * @return {boolean}\n   */\n  isFiltered(): boolean {\n    return this.filtered_;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {boolean}\n   */\n  isCompleteForPath(path: Path): boolean {\n    if (path.isEmpty()) {\n      return this.isFullyInitialized() && !this.filtered_;\n    }\n\n    const childKey = path.getFront();\n    return this.isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!string} key\n   * @return {boolean}\n   */\n  isCompleteForChild(key: string): boolean {\n    return (\n      (this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key)\n    );\n  }\n\n  /**\n   * @return {!Node}\n   */\n  getNode(): Node {\n    return this.node_;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { CacheNode } from './CacheNode';\nimport { Node } from '../snap/Node';\n\n/**\n * Stores the data we have cached for a view.\n *\n * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).\n *\n * @constructor\n */\nexport class ViewCache {\n  /**\n   *\n   * @param {!CacheNode} eventCache_\n   * @param {!CacheNode} serverCache_\n   */\n  constructor(\n    private readonly eventCache_: CacheNode,\n    private readonly serverCache_: CacheNode\n  ) {}\n\n  /**\n   * @const\n   * @type {ViewCache}\n   */\n  static Empty = new ViewCache(\n    new CacheNode(\n      ChildrenNode.EMPTY_NODE,\n      /*fullyInitialized=*/ false,\n      /*filtered=*/ false\n    ),\n    new CacheNode(\n      ChildrenNode.EMPTY_NODE,\n      /*fullyInitialized=*/ false,\n      /*filtered=*/ false\n    )\n  );\n\n  /**\n   * @param {!Node} eventSnap\n   * @param {boolean} complete\n   * @param {boolean} filtered\n   * @return {!ViewCache}\n   */\n  updateEventSnap(\n    eventSnap: Node,\n    complete: boolean,\n    filtered: boolean\n  ): ViewCache {\n    return new ViewCache(\n      new CacheNode(eventSnap, complete, filtered),\n      this.serverCache_\n    );\n  }\n\n  /**\n   * @param {!Node} serverSnap\n   * @param {boolean} complete\n   * @param {boolean} filtered\n   * @return {!ViewCache}\n   */\n  updateServerSnap(\n    serverSnap: Node,\n    complete: boolean,\n    filtered: boolean\n  ): ViewCache {\n    return new ViewCache(\n      this.eventCache_,\n      new CacheNode(serverSnap, complete, filtered)\n    );\n  }\n\n  /**\n   * @return {!CacheNode}\n   */\n  getEventCache(): CacheNode {\n    return this.eventCache_;\n  }\n\n  /**\n   * @return {?Node}\n   */\n  getCompleteEventSnap(): Node | null {\n    return this.eventCache_.isFullyInitialized()\n      ? this.eventCache_.getNode()\n      : null;\n  }\n\n  /**\n   * @return {!CacheNode}\n   */\n  getServerCache(): CacheNode {\n    return this.serverCache_;\n  }\n\n  /**\n   * @return {?Node}\n   */\n  getCompleteServerSnap(): Node | null {\n    return this.serverCache_.isFullyInitialized()\n      ? this.serverCache_.getNode()\n      : null;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n * @param {!string} type The event type\n * @param {!Node} snapshotNode The data\n * @param {string=} childName The name for this child, if it's a child event\n * @param {Node=} oldSnap Used for intermediate processing of child changed events\n * @param {string=} prevName The name for the previous child, if applicable\n */\nexport class Change {\n  constructor(\n    public type: string,\n    public snapshotNode: Node,\n    public childName?: string,\n    public oldSnap?: Node,\n    public prevName?: string | null\n  ) {}\n\n  /**\n   * @param {!Node} snapshot\n   * @return {!Change}\n   */\n  static valueChange(snapshot: Node): Change {\n    return new Change(Change.VALUE, snapshot);\n  }\n\n  /**\n   * @param {string} childKey\n   * @param {!Node} snapshot\n   * @return {!Change}\n   */\n  static childAddedChange(childKey: string, snapshot: Node): Change {\n    return new Change(Change.CHILD_ADDED, snapshot, childKey);\n  }\n\n  /**\n   * @param {string} childKey\n   * @param {!Node} snapshot\n   * @return {!Change}\n   */\n  static childRemovedChange(childKey: string, snapshot: Node): Change {\n    return new Change(Change.CHILD_REMOVED, snapshot, childKey);\n  }\n\n  /**\n   * @param {string} childKey\n   * @param {!Node} newSnapshot\n   * @param {!Node} oldSnapshot\n   * @return {!Change}\n   */\n  static childChangedChange(\n    childKey: string,\n    newSnapshot: Node,\n    oldSnapshot: Node\n  ): Change {\n    return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);\n  }\n\n  /**\n   * @param {string} childKey\n   * @param {!Node} snapshot\n   * @return {!Change}\n   */\n  static childMovedChange(childKey: string, snapshot: Node): Change {\n    return new Change(Change.CHILD_MOVED, snapshot, childKey);\n  }\n\n  //event types\n  /** Event type for a child added */\n  static CHILD_ADDED = 'child_added';\n\n  /** Event type for a child removed */\n  static CHILD_REMOVED = 'child_removed';\n\n  /** Event type for a child changed */\n  static CHILD_CHANGED = 'child_changed';\n\n  /** Event type for a child moved */\n  static CHILD_MOVED = 'child_moved';\n\n  /** Event type for a value change */\n  static VALUE = 'value';\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Change } from './Change';\nimport { assert, assertionError } from '@firebase/util';\n\nexport class ChildChangeAccumulator {\n  private readonly changeMap: Map<string, Change> = new Map();\n\n  trackChildChange(change: Change) {\n    const type = change.type;\n    const childKey = change.childName!;\n    assert(\n      type == Change.CHILD_ADDED ||\n        type == Change.CHILD_CHANGED ||\n        type == Change.CHILD_REMOVED,\n      'Only child changes supported for tracking'\n    );\n    assert(\n      childKey !== '.priority',\n      'Only non-priority child changes can be tracked.'\n    );\n    const oldChange = this.changeMap.get(childKey);\n    if (oldChange) {\n      const oldType = oldChange.type;\n      if (type == Change.CHILD_ADDED && oldType == Change.CHILD_REMOVED) {\n        this.changeMap.set(\n          childKey,\n          Change.childChangedChange(\n            childKey,\n            change.snapshotNode,\n            oldChange.snapshotNode\n          )\n        );\n      } else if (\n        type == Change.CHILD_REMOVED &&\n        oldType == Change.CHILD_ADDED\n      ) {\n        this.changeMap.delete(childKey);\n      } else if (\n        type == Change.CHILD_REMOVED &&\n        oldType == Change.CHILD_CHANGED\n      ) {\n        this.changeMap.set(\n          childKey,\n          Change.childRemovedChange(childKey, oldChange.oldSnap)\n        );\n      } else if (\n        type == Change.CHILD_CHANGED &&\n        oldType == Change.CHILD_ADDED\n      ) {\n        this.changeMap.set(\n          childKey,\n          Change.childAddedChange(childKey, change.snapshotNode)\n        );\n      } else if (\n        type == Change.CHILD_CHANGED &&\n        oldType == Change.CHILD_CHANGED\n      ) {\n        this.changeMap.set(\n          childKey,\n          Change.childChangedChange(\n            childKey,\n            change.snapshotNode,\n            oldChange.oldSnap\n          )\n        );\n      } else {\n        throw assertionError(\n          'Illegal combination of changes: ' +\n            change +\n            ' occurred after ' +\n            oldChange\n        );\n      }\n    } else {\n      this.changeMap.set(childKey, change);\n    }\n  }\n\n  getChanges(): Change[] {\n    return Array.from(this.changeMap.values());\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CacheNode } from './CacheNode';\nimport { NamedNode, Node } from '../snap/Node';\nimport { Index } from '../snap/indexes/Index';\nimport { WriteTreeRef } from '../WriteTree';\nimport { ViewCache } from './ViewCache';\n\n/**\n * Since updates to filtered nodes might require nodes to be pulled in from \"outside\" the node, this interface\n * can help to get complete children that can be pulled in.\n * A class implementing this interface takes potentially multiple sources (e.g. user writes, server data from\n * other views etc.) to try it's best to get a complete child that might be useful in pulling into the view.\n *\n * @interface\n */\nexport interface CompleteChildSource {\n  /**\n   * @param {!string} childKey\n   * @return {?Node}\n   */\n  getCompleteChild(childKey: string): Node | null;\n\n  /**\n   * @param {!Index} index\n   * @param {!NamedNode} child\n   * @param {boolean} reverse\n   * @return {?NamedNode}\n   */\n  getChildAfterChild(\n    index: Index,\n    child: NamedNode,\n    reverse: boolean\n  ): NamedNode | null;\n}\n\n/**\n * An implementation of CompleteChildSource that never returns any additional children\n *\n * @private\n * @constructor\n * @implements CompleteChildSource\n */\nexport class NoCompleteChildSource_ implements CompleteChildSource {\n  /**\n   * @inheritDoc\n   */\n  getCompleteChild(childKey?: string): Node | null {\n    return null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getChildAfterChild(\n    index?: Index,\n    child?: NamedNode,\n    reverse?: boolean\n  ): NamedNode | null {\n    return null;\n  }\n}\n\n/**\n * Singleton instance.\n * @const\n * @type {!CompleteChildSource}\n */\nexport const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\n\n/**\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\n * old event caches available to calculate complete children.\n *\n *\n * @implements CompleteChildSource\n */\nexport class WriteTreeCompleteChildSource implements CompleteChildSource {\n  /**\n   * @param {!WriteTreeRef} writes_\n   * @param {!ViewCache} viewCache_\n   * @param {?Node} optCompleteServerCache_\n   */\n  constructor(\n    private writes_: WriteTreeRef,\n    private viewCache_: ViewCache,\n    private optCompleteServerCache_: Node | null = null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  getCompleteChild(childKey: string): Node | null {\n    const node = this.viewCache_.getEventCache();\n    if (node.isCompleteForChild(childKey)) {\n      return node.getNode().getImmediateChild(childKey);\n    } else {\n      const serverNode =\n        this.optCompleteServerCache_ != null\n          ? new CacheNode(this.optCompleteServerCache_, true, false)\n          : this.viewCache_.getServerCache();\n      return this.writes_.calcCompleteChild(childKey, serverNode);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getChildAfterChild(\n    index: Index,\n    child: NamedNode,\n    reverse: boolean\n  ): NamedNode | null {\n    const completeServerData =\n      this.optCompleteServerCache_ != null\n        ? this.optCompleteServerCache_\n        : this.viewCache_.getCompleteServerSnap();\n    const nodes = this.writes_.calcIndexedSlice(\n      completeServerData,\n      child,\n      1,\n      reverse,\n      index\n    );\n    if (nodes.length === 0) {\n      return null;\n    } else {\n      return nodes[0];\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '@firebase/util';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport {\n  WriteTreeCompleteChildSource,\n  NO_COMPLETE_CHILD_SOURCE,\n  CompleteChildSource\n} from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(\n    public readonly viewCache: ViewCache,\n    public readonly changes: Change[]\n  ) {}\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {}\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(\n      viewCache\n        .getEventCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Event snap not indexed'\n    );\n    assert(\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed'\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(\n    oldViewCache: ViewCache,\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null\n  ): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode =\n          overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() &&\n            !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode =\n          merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          ackUserWrite.affectedTree,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        newViewCache = this.revertUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(\n        oldViewCache,\n        operation.path,\n        writesCache,\n        accumulator\n      );\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(\n    oldViewCache: ViewCache,\n    newViewCache: ViewCache,\n    accumulator: Change[]\n  ) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty =\n        eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (\n        accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty &&\n          !eventSnap.getNode().equals(/** @type {!Node} */ oldCompleteSnap)) ||\n        !eventSnap\n          .getNode()\n          .getPriority()\n          .equals(oldCompleteSnap.getPriority())\n      ) {\n        accumulator.push(\n          Change.valueChange(\n            /** @type {!Node} */ newViewCache.getCompleteEventSnap()\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(\n    viewCache: ViewCache,\n    changePath: Path,\n    writesCache: WriteTreeRef,\n    source: CompleteChildSource,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(\n          viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data'\n        );\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren =\n            serverCache instanceof ChildrenNode\n              ? serverCache\n              : ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(\n            completeChildren\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeEventChildren,\n            accumulator\n          );\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeNode,\n            accumulator\n          );\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(\n            changePath.getLength() == 1,\n            \"Can't have a priority with additional path components\"\n          );\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(\n            changePath,\n            oldEventNode,\n            serverNode\n          );\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(\n              oldEventNode,\n              updatedPriority\n            );\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(\n              changePath,\n              oldEventSnap.getNode(),\n              serverNode\n            );\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey)\n                .updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(\n              childKey,\n              viewCache.getServerCache()\n            );\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(\n              oldEventSnap.getNode(),\n              childKey,\n              newEventChild,\n              childChangePath,\n              source,\n              accumulator\n            );\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(\n        newEventCache,\n        oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode\n      ? this.filter_\n      : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        changedSnap,\n        null\n      );\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap\n        .getNode()\n        .updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        newServerNode,\n        null\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (\n        !oldServerSnap.isCompleteForPath(changePath) &&\n        changePath.getLength() > 1\n      ) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(\n          oldServerSnap.getNode(),\n          newChildNode\n        );\n      } else {\n        newServerCache = serverFilter.updateChild(\n          oldServerSnap.getNode(),\n          childKey,\n          newChildNode,\n          childChangePath,\n          NO_COMPLETE_CHILD_SOURCE,\n          null\n        );\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(\n      newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(),\n      serverFilter.filtersNodes()\n    );\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      newViewCache,\n      completeCache\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      changePath,\n      writesCache,\n      source,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      oldViewCache,\n      completeCache\n    );\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(\n        oldViewCache.getEventCache().getNode(),\n        changedSnap,\n        accumulator\n      );\n      newViewCache = oldViewCache.updateEventSnap(\n        newEventCache,\n        true,\n        this.filter_.filtersNodes()\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(\n          oldViewCache.getEventCache().getNode(),\n          changedSnap\n        );\n        newViewCache = oldViewCache.updateEventSnap(\n          newEventCache,\n          oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered()\n        );\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (\n              childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()\n            ) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(\n            oldEventSnap.getNode(),\n            childKey,\n            newChild,\n            childChangePath,\n            source,\n            accumulator\n          );\n          newViewCache = oldViewCache.updateEventSnap(\n            newEventSnap,\n            oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes()\n          );\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(\n    viewCache: ViewCache,\n    childKey: string\n  ): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function(relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isEmpty() &&\n      !viewCache.getServerCache().isFullyInitialized()\n    ) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge =\n        !viewCache.getServerCache().isCompleteForChild(childKey) &&\n        childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(\n    viewCache: ViewCache,\n    ackPath: Path,\n    affectedTree: ImmutableTree<boolean>,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (\n        (ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n        serverCache.isCompleteForPath(ackPath)\n      ) {\n        return this.applyServerOverwrite_(\n          viewCache,\n          ackPath,\n          serverCache.getNode().getChild(ackPath),\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(\n          viewCache,\n          ackPath,\n          changedChildren,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function(mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(\n            mergePath,\n            serverCache.getNode().getChild(serverCachePath)\n          );\n        }\n      });\n      return this.applyServerMerge_(\n        viewCache,\n        ackPath,\n        changedChildren,\n        writesCache,\n        completeCache,\n        filterServerNode,\n        accumulator\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(\n      oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(),\n      oldServerNode.isFiltered()\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      path,\n      writesCache,\n      NO_COMPLETE_CHILD_SOURCE,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(\n        writesCache,\n        viewCache,\n        completeServerCache\n      );\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(\n            serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node'\n          );\n          newNode = writesCache.calcCompleteEventChildren(\n            serverChildren as ChildrenNode\n          );\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(\n          oldEventCache,\n          newNode,\n          accumulator\n        );\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(\n          childKey,\n          viewCache.getServerCache()\n        );\n        if (\n          newChild == null &&\n          viewCache.getServerCache().isCompleteForChild(childKey)\n        ) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            newChild,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else if (\n          viewCache\n            .getEventCache()\n            .getNode()\n            .hasChild(childKey)\n        ) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            ChildrenNode.EMPTY_NODE,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (\n          newEventCache.isEmpty() &&\n          viewCache.getServerCache().isFullyInitialized()\n        ) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(\n              newEventCache,\n              complete,\n              accumulator\n            );\n          }\n        }\n      }\n      complete =\n        viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(\n        newEventCache,\n        complete,\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NamedNode, Node } from '../snap/Node';\nimport { Change } from './Change';\nimport { assertionError } from '@firebase/util';\nimport { Query } from '../../api/Query';\nimport { Index } from '../snap/indexes/Index';\nimport { EventRegistration } from './EventRegistration';\nimport { Event } from './Event';\n\n/**\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\n * for details.\n *\n * @constructor\n */\nexport class EventGenerator {\n  private index_: Index;\n\n  /**\n   *\n   * @param {!Query} query_\n   */\n  constructor(private query_: Query) {\n    /**\n     * @private\n     * @type {!Index}\n     */\n    this.index_ = this.query_.getQueryParams().getIndex();\n  }\n\n  /**\n   * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\n   * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\n   *\n   * Notes:\n   *  - child_moved events will be synthesized at this time for any child_changed events that affect\n   *    our index.\n   *  - prevName will be calculated based on the index ordering.\n   *\n   * @param {!Array.<!Change>} changes\n   * @param {!Node} eventCache\n   * @param {!Array.<!EventRegistration>} eventRegistrations\n   * @return {!Array.<!Event>}\n   */\n  generateEventsForChanges(\n    changes: Change[],\n    eventCache: Node,\n    eventRegistrations: EventRegistration[]\n  ): Event[] {\n    const events: Event[] = [];\n    const moves: Change[] = [];\n\n    changes.forEach(change => {\n      if (\n        change.type === Change.CHILD_CHANGED &&\n        this.index_.indexedValueChanged(\n          change.oldSnap as Node,\n          change.snapshotNode\n        )\n      ) {\n        moves.push(\n          Change.childMovedChange(\n            change.childName as string,\n            change.snapshotNode\n          )\n        );\n      }\n    });\n\n    this.generateEventsForType_(\n      events,\n      Change.CHILD_REMOVED,\n      changes,\n      eventRegistrations,\n      eventCache\n    );\n    this.generateEventsForType_(\n      events,\n      Change.CHILD_ADDED,\n      changes,\n      eventRegistrations,\n      eventCache\n    );\n    this.generateEventsForType_(\n      events,\n      Change.CHILD_MOVED,\n      moves,\n      eventRegistrations,\n      eventCache\n    );\n    this.generateEventsForType_(\n      events,\n      Change.CHILD_CHANGED,\n      changes,\n      eventRegistrations,\n      eventCache\n    );\n    this.generateEventsForType_(\n      events,\n      Change.VALUE,\n      changes,\n      eventRegistrations,\n      eventCache\n    );\n\n    return events;\n  }\n\n  /**\n   * Given changes of a single change type, generate the corresponding events.\n   *\n   * @param {!Array.<!Event>} events\n   * @param {!string} eventType\n   * @param {!Array.<!Change>} changes\n   * @param {!Array.<!EventRegistration>} registrations\n   * @param {!Node} eventCache\n   * @private\n   */\n  private generateEventsForType_(\n    events: Event[],\n    eventType: string,\n    changes: Change[],\n    registrations: EventRegistration[],\n    eventCache: Node\n  ) {\n    const filteredChanges = changes.filter(change => change.type === eventType);\n\n    filteredChanges.sort(this.compareChanges_.bind(this));\n    filteredChanges.forEach(change => {\n      const materializedChange = this.materializeSingleChange_(\n        change,\n        eventCache\n      );\n      registrations.forEach(registration => {\n        if (registration.respondsTo(change.type)) {\n          events.push(\n            registration.createEvent(materializedChange, this.query_)\n          );\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {!Change} change\n   * @param {!Node} eventCache\n   * @return {!Change}\n   * @private\n   */\n  private materializeSingleChange_(change: Change, eventCache: Node): Change {\n    if (change.type === 'value' || change.type === 'child_removed') {\n      return change;\n    } else {\n      change.prevName = eventCache.getPredecessorChildName(\n        /** @type {!string} */\n        change.childName,\n        change.snapshotNode,\n        this.index_\n      );\n      return change;\n    }\n  }\n\n  /**\n   * @param {!Change} a\n   * @param {!Change} b\n   * @return {number}\n   * @private\n   */\n  private compareChanges_(a: Change, b: Change) {\n    if (a.childName == null || b.childName == null) {\n      throw assertionError('Should only compare child_ events.');\n    }\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\n    return this.index_.compare(aWrapped, bWrapped);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexedFilter } from './filter/IndexedFilter';\nimport { ViewProcessor } from './ViewProcessor';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { CacheNode } from './CacheNode';\nimport { ViewCache } from './ViewCache';\nimport { EventGenerator } from './EventGenerator';\nimport { assert } from '@firebase/util';\nimport { Operation, OperationType } from '../operation/Operation';\nimport { Change } from './Change';\nimport { PRIORITY_INDEX } from '../snap/indexes/PriorityIndex';\nimport { Query } from '../../api/Query';\nimport { EventRegistration } from './EventRegistration';\nimport { Node } from '../snap/Node';\nimport { Path } from '../util/Path';\nimport { WriteTreeRef } from '../WriteTree';\nimport { CancelEvent, Event } from './Event';\n\n/**\n * A view represents a specific location and query that has 1 or more event registrations.\n *\n * It does several things:\n *  - Maintains the list of event registrations for this location/query.\n *  - Maintains a cache of the data visible for this location/query.\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\n *    registrations returns the set of events to be raised.\n * @constructor\n */\nexport class View {\n  private processor_: ViewProcessor;\n  private viewCache_: ViewCache;\n  private eventRegistrations_: EventRegistration[] = [];\n  private eventGenerator_: EventGenerator;\n\n  /**\n   *\n   * @param {!Query} query_\n   * @param {!ViewCache} initialViewCache\n   */\n  constructor(private query_: Query, initialViewCache: ViewCache) {\n    const params = this.query_.getQueryParams();\n\n    const indexFilter = new IndexedFilter(params.getIndex());\n    const filter = params.getNodeFilter();\n\n    /**\n     * @type {ViewProcessor}\n     * @private\n     */\n    this.processor_ = new ViewProcessor(filter);\n\n    const initialServerCache = initialViewCache.getServerCache();\n    const initialEventCache = initialViewCache.getEventCache();\n\n    // Don't filter server node with other filter than index, wait for tagged listen\n    const serverSnap = indexFilter.updateFullNode(\n      ChildrenNode.EMPTY_NODE,\n      initialServerCache.getNode(),\n      null\n    );\n    const eventSnap = filter.updateFullNode(\n      ChildrenNode.EMPTY_NODE,\n      initialEventCache.getNode(),\n      null\n    );\n    const newServerCache = new CacheNode(\n      serverSnap,\n      initialServerCache.isFullyInitialized(),\n      indexFilter.filtersNodes()\n    );\n    const newEventCache = new CacheNode(\n      eventSnap,\n      initialEventCache.isFullyInitialized(),\n      filter.filtersNodes()\n    );\n\n    /**\n     * @type {!ViewCache}\n     * @private\n     */\n    this.viewCache_ = new ViewCache(newEventCache, newServerCache);\n\n    /**\n     * @type {!EventGenerator}\n     * @private\n     */\n    this.eventGenerator_ = new EventGenerator(this.query_);\n  }\n\n  /**\n   * @return {!Query}\n   */\n  getQuery(): Query {\n    return this.query_;\n  }\n\n  /**\n   * @return {?Node}\n   */\n  getServerCache(): Node | null {\n    return this.viewCache_.getServerCache().getNode();\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    const cache = this.viewCache_.getCompleteServerSnap();\n    if (cache) {\n      // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\n      // we need to see if it contains the child we're interested in.\n      if (\n        this.query_.getQueryParams().loadsAllData() ||\n        (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())\n      ) {\n        return cache.getChild(path);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.eventRegistrations_.length === 0;\n  }\n\n  /**\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventRegistration(eventRegistration: EventRegistration) {\n    this.eventRegistrations_.push(eventRegistration);\n  }\n\n  /**\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n   */\n  removeEventRegistration(\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): Event[] {\n    const cancelEvents: CancelEvent[] = [];\n    if (cancelError) {\n      assert(\n        eventRegistration == null,\n        'A cancel should cancel all event registrations.'\n      );\n      const path = this.query_.path;\n      this.eventRegistrations_.forEach(function(registration) {\n        cancelError /** @type {!Error} */ = cancelError;\n        const maybeEvent = registration.createCancelEvent(cancelError, path);\n        if (maybeEvent) {\n          cancelEvents.push(maybeEvent);\n        }\n      });\n    }\n\n    if (eventRegistration) {\n      let remaining = [];\n      for (let i = 0; i < this.eventRegistrations_.length; ++i) {\n        const existing = this.eventRegistrations_[i];\n        if (!existing.matches(eventRegistration)) {\n          remaining.push(existing);\n        } else if (eventRegistration.hasAnyCallback()) {\n          // We're removing just this one\n          remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));\n          break;\n        }\n      }\n      this.eventRegistrations_ = remaining;\n    } else {\n      this.eventRegistrations_ = [];\n    }\n    return cancelEvents;\n  }\n\n  /**\n   * Applies the given Operation, updates our cache, and returns the appropriate events.\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @return {!Array.<!Event>}\n   */\n  applyOperation(\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null\n  ): Event[] {\n    if (\n      operation.type === OperationType.MERGE &&\n      operation.source.queryId !== null\n    ) {\n      assert(\n        this.viewCache_.getCompleteServerSnap(),\n        'We should always have a full cache before handling merges'\n      );\n      assert(\n        this.viewCache_.getCompleteEventSnap(),\n        'Missing event cache, even though we have a server cache'\n      );\n    }\n\n    const oldViewCache = this.viewCache_;\n    const result = this.processor_.applyOperation(\n      oldViewCache,\n      operation,\n      writesCache,\n      completeServerCache\n    );\n    this.processor_.assertIndexed(result.viewCache);\n\n    assert(\n      result.viewCache.getServerCache().isFullyInitialized() ||\n        !oldViewCache.getServerCache().isFullyInitialized(),\n      'Once a server snap is complete, it should never go back'\n    );\n\n    this.viewCache_ = result.viewCache;\n\n    return this.generateEventsForChanges_(\n      result.changes,\n      result.viewCache.getEventCache().getNode(),\n      null\n    );\n  }\n\n  /**\n   * @param {!EventRegistration} registration\n   * @return {!Array.<!Event>}\n   */\n  getInitialEvents(registration: EventRegistration): Event[] {\n    const eventSnap = this.viewCache_.getEventCache();\n    const initialChanges: Change[] = [];\n    if (!eventSnap.getNode().isLeafNode()) {\n      const eventNode = eventSnap.getNode() as ChildrenNode;\n      eventNode.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        initialChanges.push(Change.childAddedChange(key, childNode));\n      });\n    }\n    if (eventSnap.isFullyInitialized()) {\n      initialChanges.push(Change.valueChange(eventSnap.getNode()));\n    }\n    return this.generateEventsForChanges_(\n      initialChanges,\n      eventSnap.getNode(),\n      registration\n    );\n  }\n\n  /**\n   * @private\n   * @param {!Array.<!Change>} changes\n   * @param {!Node} eventCache\n   * @param {EventRegistration=} eventRegistration\n   * @return {!Array.<!Event>}\n   */\n  generateEventsForChanges_(\n    changes: Change[],\n    eventCache: Node,\n    eventRegistration?: EventRegistration\n  ): Event[] {\n    const registrations = eventRegistration\n      ? [eventRegistration]\n      : this.eventRegistrations_;\n    return this.eventGenerator_.generateEventsForChanges(\n      changes,\n      eventCache,\n      registrations\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '@firebase/util';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nimport { Operation } from './operation/Operation';\nimport { WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { Node } from './snap/Node';\nimport { Path } from './util/Path';\nimport { Event } from './view/Event';\nimport { Reference, ReferenceConstructor } from '../api/Reference';\n\nlet __referenceConstructor: ReferenceConstructor;\n\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nexport class SyncPoint {\n  static set __referenceConstructor(val: ReferenceConstructor) {\n    assert(\n      !__referenceConstructor,\n      '__referenceConstructor has already been defined'\n    );\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  /**\n   * The Views being tracked at this location in the tree, stored as a map where the key is a\n   * queryId and the value is the View for that query.\n   *\n   * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n   */\n  private readonly views: Map<string, View> = new Map();\n\n  isEmpty(): boolean {\n    return this.views.size === 0;\n  }\n\n  applyOperation(\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    optCompleteServerCache: Node | null\n  ): Event[] {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n      const view = this.views.get(queryId);\n      assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(\n        operation,\n        writesCache,\n        optCompleteServerCache\n      );\n    } else {\n      let events: Event[] = [];\n\n      for (const view of this.views.values()) {\n        events = events.concat(\n          view.applyOperation(operation, writesCache, optCompleteServerCache)\n        );\n      }\n\n      return events;\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    serverCacheComplete: boolean\n  ): Event[] {\n    const queryId = query.queryIdentifier();\n    let view = this.views.get(queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      let eventCache = writesCache.calcCompleteEventCache(\n        serverCacheComplete ? serverCache : null\n      );\n      let eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      const viewCache = new ViewCache(\n        new CacheNode(\n          /** @type {!Node} */ eventCache,\n          eventCacheComplete,\n          false\n        ),\n        new CacheNode(\n          /** @type {!Node} */ serverCache,\n          serverCacheComplete,\n          false\n        )\n      );\n      view = new View(query, viewCache);\n      this.views.set(queryId, view);\n    }\n\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  }\n\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): { removed: Query[]; events: Event[] } {\n    const queryId = query.queryIdentifier();\n    const removed: Query[] = [];\n    let cancelEvents: Event[] = [];\n    const hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      for (const [viewQueryId, view] of this.views.entries()) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          this.views.delete(viewQueryId);\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    } else {\n      // remove the callback from the specific view.\n      const view = this.views.get(queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          this.views.delete(queryId);\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(\n        new SyncPoint.__referenceConstructor(query.repo, query.path)\n      );\n    }\n\n    return { removed: removed, events: cancelEvents };\n  }\n\n  getQueryViews(): View[] {\n    const result = [];\n    for (const view of this.views.values()) {\n      if (\n        !view\n          .getQuery()\n          .getQueryParams()\n          .loadsAllData()\n      ) {\n        result.push(view);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @param path The path to the desired complete snapshot\n   * @return A complete cache, if it exists\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    let serverCache: Node | null = null;\n    for (const view of this.views.values()) {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    }\n    return serverCache;\n  }\n\n  viewForQuery(query: Query): View | null {\n    const params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      const queryId = query.queryIdentifier();\n      return this.views.get(queryId);\n    }\n  }\n\n  viewExistsForQuery(query: Query): boolean {\n    return this.viewForQuery(query) != null;\n  }\n\n  hasCompleteView(): boolean {\n    return this.getCompleteView() != null;\n  }\n\n  getCompleteView(): View | null {\n    for (const view of this.views.values()) {\n      if (\n        view\n          .getQuery()\n          .getQueryParams()\n          .loadsAllData()\n      ) {\n        return view;\n      }\n    }\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { Path } from './util/Path';\nimport { Node, NamedNode } from './snap/Node';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { assert } from '@firebase/util';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { each } from './util/util';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {}\n\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    each(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param path The path to check for\n   * @return Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param path The path to get a complete write\n   * @return The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_\n        .get(rootmost.path)\n        .getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return A list of all complete children.\n   */\n  getCompleteChildren(): NamedNode[] {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childNode\n        ) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param node The node to apply this CompoundWrite to\n   * @return The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return applySubtreeWrite(Path.Empty, this.writeTree_, node);\n  }\n}\n\nfunction applySubtreeWrite(\n  relativePath: Path,\n  writeTree: ImmutableTree<Node>,\n  node: Node\n): Node {\n  if (writeTree.value != null) {\n    // Since there a write is always a leaf, we're done here\n    return node.updateChild(relativePath, writeTree.value);\n  } else {\n    let priorityWrite = null;\n    writeTree.children.inorderTraversal(function(childKey, childTree) {\n      if (childKey === '.priority') {\n        // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n        // to apply priorities to empty nodes that are later filled\n        assert(\n          childTree.value !== null,\n          'Priority writes must always be leaf nodes'\n        );\n        priorityWrite = childTree.value;\n      } else {\n        node = applySubtreeWrite(relativePath.child(childKey), childTree, node);\n      }\n    });\n    // If there was a priority write, we only apply it if the node is not empty\n    if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n      node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n    }\n    return node;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { safeGet } from '@firebase/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\nimport { each } from './util/util';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        each(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      for (const childName in writeRecord.children) {\n        if (\n          writeRecord.children.hasOwnProperty(childName) &&\n          writeRecord.path.child(childName).contains(path)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    completeServerChildren: ChildrenNode | null\n  ): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { errorForServerCode, each } from './util/util';\nimport { AckUserWrite } from './operation/AckUserWrite';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { ListenComplete } from './operation/ListenComplete';\nimport { Merge } from './operation/Merge';\nimport { Operation, OperationSource } from './operation/Operation';\nimport { Overwrite } from './operation/Overwrite';\nimport { Path } from './util/Path';\nimport { SyncPoint } from './SyncPoint';\nimport { WriteTree, WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { Node } from './snap/Node';\nimport { Event } from './view/Event';\nimport { EventRegistration } from './view/EventRegistration';\nimport { View } from './view/View';\n\n/**\n * @typedef {{\n *   startListening: function(\n *     !Query,\n *     ?number,\n *     function():string,\n *     function(!string, *):!Array.<!Event>\n *   ):!Array.<!Event>,\n *\n *   stopListening: function(!Query, ?number)\n * }}\n */\nexport interface ListenProvider {\n  startListening(\n    query: Query,\n    tag: number | null,\n    hashFn: () => string,\n    onComplete: (a: string, b?: any) => Event[]\n  ): Event[];\n\n  stopListening(a: Query, b: number | null): void;\n}\n\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nexport class SyncTree {\n  /**\n   * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n   */\n  private syncPointTree_: ImmutableTree<SyncPoint> = ImmutableTree.Empty;\n\n  /**\n   * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n   */\n  private pendingWriteTree_ = new WriteTree();\n\n  private readonly tagToQueryMap: Map<number, string> = new Map();\n  private readonly queryToTagMap: Map<string, number> = new Map();\n\n  /**\n   * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n   *   to server data.\n   */\n  constructor(private listenProvider_: ListenProvider) {}\n\n  /**\n   * Apply the data changes for a user-generated set() or transaction() call.\n   *\n   * @return Events to raise.\n   */\n  applyUserOverwrite(\n    path: Path,\n    newData: Node,\n    writeId: number,\n    visible?: boolean\n  ): Event[] {\n    // Record pending write.\n    this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n\n    if (!visible) {\n      return [];\n    } else {\n      return this.applyOperationToSyncPoints_(\n        new Overwrite(OperationSource.User, path, newData)\n      );\n    }\n  }\n\n  /**\n   * Apply the data from a user-generated update() call\n   *\n   * @return Events to raise.\n   */\n  applyUserMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ): Event[] {\n    // Record pending merge.\n    this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.User, path, changeTree)\n    );\n  }\n\n  /**\n   * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n   *\n   * @param revert True if the given write failed and needs to be reverted\n   * @return Events to raise.\n   */\n  ackUserWrite(writeId: number, revert: boolean = false) {\n    const write = this.pendingWriteTree_.getWrite(writeId);\n    const needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n    if (!needToReevaluate) {\n      return [];\n    } else {\n      let affectedTree = ImmutableTree.Empty;\n      if (write.snap != null) {\n        // overwrite\n        affectedTree = affectedTree.set(Path.Empty, true);\n      } else {\n        each(write.children, function(pathString: string, node: Node) {\n          affectedTree = affectedTree.set(new Path(pathString), node);\n        });\n      }\n      return this.applyOperationToSyncPoints_(\n        new AckUserWrite(write.path, affectedTree, revert)\n      );\n    }\n  }\n\n  /**\n   * Apply new server data for the specified path..\n   *\n   * @return Events to raise.\n   */\n  applyServerOverwrite(path: Path, newData: Node): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new Overwrite(OperationSource.Server, path, newData)\n    );\n  }\n\n  /**\n   * Apply new server data to be merged in at the specified path.\n   *\n   * @return Events to raise.\n   */\n  applyServerMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node }\n  ): Event[] {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.Server, path, changeTree)\n    );\n  }\n\n  /**\n   * Apply a listen complete for a query\n   *\n   * @return Events to raise.\n   */\n  applyListenComplete(path: Path): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new ListenComplete(OperationSource.Server, path)\n    );\n  }\n\n  /**\n   * Apply new server data for the specified tagged query.\n   *\n   * @return Events to raise.\n   */\n  applyTaggedQueryOverwrite(path: Path, snap: Node, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey != null) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new Overwrite(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        snap\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // Query must have been removed already\n      return [];\n    }\n  }\n\n  /**\n   * Apply server data to be merged in for the specified tagged query.\n   *\n   * @return Events to raise.\n   */\n  applyTaggedQueryMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    tag: number\n  ): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const changeTree = ImmutableTree.fromObject(changedChildren);\n      const op = new Merge(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        changeTree\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Apply a listen complete for a tagged query\n   *\n   * @return Events to raise.\n   */\n  applyTaggedListenComplete(path: Path, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new ListenComplete(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @return Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration\n  ): Event[] {\n    const path = query.path;\n\n    let serverCache: Node | null = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    this.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {\n      const relativePath = Path.relativePath(pathToSyncPoint, path);\n      serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || sp.hasCompleteView();\n    });\n    let syncPoint = this.syncPointTree_.get(path);\n    if (!syncPoint) {\n      syncPoint = new SyncPoint();\n      this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n    } else {\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || syncPoint.hasCompleteView();\n      serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let serverCacheComplete;\n    if (serverCache != null) {\n      serverCacheComplete = true;\n    } else {\n      serverCacheComplete = false;\n      serverCache = ChildrenNode.EMPTY_NODE;\n      const subtree = this.syncPointTree_.subtree(path);\n      subtree.foreachChild(function(childName, childSyncPoint) {\n        const completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\n        if (completeCache) {\n          serverCache = serverCache.updateImmediateChild(\n            childName,\n            completeCache\n          );\n        }\n      });\n    }\n\n    const viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n    if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n      // We need to track a tag for this query\n      const queryKey = SyncTree.makeQueryKey_(query);\n      assert(\n        !this.queryToTagMap.has(queryKey),\n        'View does not exist, but we have a tag'\n      );\n      const tag = SyncTree.getNextQueryTag_();\n      this.queryToTagMap.set(queryKey, tag);\n      this.tagToQueryMap.set(tag, queryKey);\n    }\n    const writesCache = this.pendingWriteTree_.childWrites(path);\n    let events = syncPoint.addEventRegistration(\n      query,\n      eventRegistration,\n      writesCache,\n      serverCache,\n      serverCacheComplete\n    );\n    if (!viewAlreadyExists && !foundAncestorDefaultView) {\n      const view /** @type !View */ = syncPoint.viewForQuery(query);\n      events = events.concat(this.setupListener_(query, view));\n    }\n    return events;\n  }\n\n  /**\n   * Remove event callback(s).\n   *\n   * If query is the default query, we'll check all queries for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n   *\n   * @param eventRegistration If null, all callbacks are removed.\n   * @param cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return Cancel events, if cancelError was provided.\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): Event[] {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query.path;\n    const maybeSyncPoint = this.syncPointTree_.get(path);\n    let cancelEvents: Event[] = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (\n      maybeSyncPoint &&\n      (query.queryIdentifier() === 'default' ||\n        maybeSyncPoint.viewExistsForQuery(query))\n    ) {\n      /**\n       * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n       */\n      const removedAndEvents = maybeSyncPoint.removeEventRegistration(\n        query,\n        eventRegistration,\n        cancelError\n      );\n      if (maybeSyncPoint.isEmpty()) {\n        this.syncPointTree_ = this.syncPointTree_.remove(path);\n      }\n      const removed = removedAndEvents.removed;\n      cancelEvents = removedAndEvents.events;\n      // We may have just removed one of many listeners and can short-circuit this whole process\n      // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n      // properly set up.\n      //\n      // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n      // queryId === 'default'\n      const removingDefault =\n        -1 !==\n        removed.findIndex(function(query) {\n          return query.getQueryParams().loadsAllData();\n        });\n      const covered = this.syncPointTree_.findOnPath(path, function(\n        relativePath,\n        parentSyncPoint\n      ) {\n        return parentSyncPoint.hasCompleteView();\n      });\n\n      if (removingDefault && !covered) {\n        const subtree = this.syncPointTree_.subtree(path);\n        // There are potentially child listeners. Determine what if any listens we need to send before executing the\n        // removal\n        if (!subtree.isEmpty()) {\n          // We need to fold over our subtree and collect the listeners to send\n          const newViews = this.collectDistinctViewsForSubTree_(subtree);\n\n          // Ok, we've collected all the listens we need. Set them up.\n          for (let i = 0; i < newViews.length; ++i) {\n            const view = newViews[i],\n              newQuery = view.getQuery();\n            const listener = this.createListenerForView_(view);\n            this.listenProvider_.startListening(\n              SyncTree.queryForListening_(newQuery),\n              this.tagForQuery_(newQuery),\n              listener.hashFn,\n              listener.onComplete\n            );\n          }\n        } else {\n          // There's nothing below us, so nothing we need to start listening on\n        }\n      }\n      // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n      // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n      // Also, note that if we have a cancelError, it's already been removed at the provider level.\n      if (!covered && removed.length > 0 && !cancelError) {\n        // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n        // default. Otherwise, we need to iterate through and cancel each individual query\n        if (removingDefault) {\n          // We don't tag default listeners\n          const defaultTag: number | null = null;\n          this.listenProvider_.stopListening(\n            SyncTree.queryForListening_(query),\n            defaultTag\n          );\n        } else {\n          removed.forEach((queryToRemove: Query) => {\n            const tagToRemove = this.queryToTagMap.get(\n              SyncTree.makeQueryKey_(queryToRemove)\n            );\n            this.listenProvider_.stopListening(\n              SyncTree.queryForListening_(queryToRemove),\n              tagToRemove\n            );\n          });\n        }\n      }\n      // Now, clear all of the tags we're tracking for the removed listens\n      this.removeTags_(removed);\n    } else {\n      // No-op, this listener must've been already removed\n    }\n    return cancelEvents;\n  }\n\n  /**\n   * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n   * it, but as this is only used by transaction code, that should always be the case anyways.\n   *\n   * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n   *\n   * @param path The path to the data we want\n   * @param writeIdsToExclude A specific set to be excluded\n   */\n  calcCompleteEventCache(\n    path: Path,\n    writeIdsToExclude?: number[]\n  ): Node | null {\n    const includeHiddenSets = true;\n    const writeTree = this.pendingWriteTree_;\n    const serverCache = this.syncPointTree_.findOnPath(path, function(\n      pathSoFar,\n      syncPoint\n    ) {\n      const relativePath = Path.relativePath(pathSoFar, path);\n      const serverCache = syncPoint.getCompleteServerCache(relativePath);\n      if (serverCache) {\n        return serverCache;\n      }\n    });\n    return writeTree.calcCompleteEventCache(\n      path,\n      serverCache,\n      writeIdsToExclude,\n      includeHiddenSets\n    );\n  }\n\n  /**\n   * This collapses multiple unfiltered views into a single view, since we only need a single\n   * listener for them.\n   */\n  private collectDistinctViewsForSubTree_(\n    subtree: ImmutableTree<SyncPoint>\n  ): View[] {\n    return subtree.fold<View[]>(\n      (relativePath, maybeChildSyncPoint, childMap) => {\n        if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n          const completeView = maybeChildSyncPoint.getCompleteView();\n          return [completeView];\n        } else {\n          // No complete view here, flatten any deeper listens into an array\n          let views: View[] = [];\n          if (maybeChildSyncPoint) {\n            views = maybeChildSyncPoint.getQueryViews();\n          }\n          each(childMap, function(_key: string, childViews: View[]) {\n            views = views.concat(childViews);\n          });\n          return views;\n        }\n      }\n    );\n  }\n\n  private removeTags_(queries: Query[]) {\n    for (let j = 0; j < queries.length; ++j) {\n      const removedQuery = queries[j];\n      if (!removedQuery.getQueryParams().loadsAllData()) {\n        // We should have a tag for this\n        const removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n        const removedQueryTag = this.queryToTagMap.get(removedQueryKey);\n        this.queryToTagMap.delete(removedQueryKey);\n        this.tagToQueryMap.delete(removedQueryTag);\n      }\n    }\n  }\n\n  /**\n   * Normalizes a query to a query we send the server for listening\n   *\n   * @return The normalized query\n   */\n  private static queryForListening_(query: Query): Query {\n    if (\n      query.getQueryParams().loadsAllData() &&\n      !query.getQueryParams().isDefault()\n    ) {\n      // We treat queries that load all data as default queries\n      // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n      // from Query\n      return query.getRef()!;\n    } else {\n      return query;\n    }\n  }\n\n  /**\n   * For a given new listen, manage the de-duplication of outstanding subscriptions.\n   *\n   * @return This method can return events to support synchronous data sources\n   */\n  private setupListener_(query: Query, view: View): Event[] {\n    const path = query.path;\n    const tag = this.tagForQuery_(query);\n    const listener = this.createListenerForView_(view);\n\n    const events = this.listenProvider_.startListening(\n      SyncTree.queryForListening_(query),\n      tag,\n      listener.hashFn,\n      listener.onComplete\n    );\n\n    const subtree = this.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n      assert(\n        !subtree.value.hasCompleteView(),\n        \"If we're adding a query, it shouldn't be shadowed\"\n      );\n    } else {\n      // Shadow everything at or below this location, this is a default listener.\n      const queriesToStop = subtree.fold<Query[]>(function(\n        relativePath,\n        maybeChildSyncPoint,\n        childMap\n      ) {\n        if (\n          !relativePath.isEmpty() &&\n          maybeChildSyncPoint &&\n          maybeChildSyncPoint.hasCompleteView()\n        ) {\n          return [maybeChildSyncPoint.getCompleteView().getQuery()];\n        } else {\n          // No default listener here, flatten any deeper queries into an array\n          let queries: Query[] = [];\n          if (maybeChildSyncPoint) {\n            queries = queries.concat(\n              maybeChildSyncPoint.getQueryViews().map(view => view.getQuery())\n            );\n          }\n          each(childMap, function(_key: string, childQueries: Query[]) {\n            queries = queries.concat(childQueries);\n          });\n          return queries;\n        }\n      });\n      for (let i = 0; i < queriesToStop.length; ++i) {\n        const queryToStop = queriesToStop[i];\n        this.listenProvider_.stopListening(\n          SyncTree.queryForListening_(queryToStop),\n          this.tagForQuery_(queryToStop)\n        );\n      }\n    }\n    return events;\n  }\n\n  private createListenerForView_(\n    view: View\n  ): { hashFn(): string; onComplete(a: string, b?: any): Event[] } {\n    const query = view.getQuery();\n    const tag = this.tagForQuery_(query);\n\n    return {\n      hashFn: () => {\n        const cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\n        return cache.hash();\n      },\n      onComplete: (status: string): Event[] => {\n        if (status === 'ok') {\n          if (tag) {\n            return this.applyTaggedListenComplete(query.path, tag);\n          } else {\n            return this.applyListenComplete(query.path);\n          }\n        } else {\n          // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n          // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n          const error = errorForServerCode(status, query);\n          return this.removeEventRegistration(\n            query,\n            /*eventRegistration*/ null,\n            error\n          );\n        }\n      }\n    };\n  }\n\n  /**\n   * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n   */\n  private static makeQueryKey_(query: Query): string {\n    return query.path.toString() + '$' + query.queryIdentifier();\n  }\n\n  /**\n   * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n   */\n  private static parseQueryKey_(\n    queryKey: string\n  ): { queryId: string; path: Path } {\n    const splitIndex = queryKey.indexOf('$');\n    assert(\n      splitIndex !== -1 && splitIndex < queryKey.length - 1,\n      'Bad queryKey.'\n    );\n    return {\n      queryId: queryKey.substr(splitIndex + 1),\n      path: new Path(queryKey.substr(0, splitIndex))\n    };\n  }\n\n  /**\n   * Return the query associated with the given tag, if we have one\n   */\n  private queryKeyForTag_(tag: number): string | null {\n    return this.tagToQueryMap.get(tag);\n  }\n\n  /**\n   * Return the tag associated with the given query.\n   */\n  private tagForQuery_(query: Query): number | null {\n    const queryKey = SyncTree.makeQueryKey_(query);\n    return this.queryToTagMap.get(queryKey);\n  }\n\n  /**\n   * Static tracker for next query tag.\n   */\n  private static nextQueryTag_ = 1;\n\n  /**\n   * Static accessor for query tags.\n   */\n  private static getNextQueryTag_(): number {\n    return SyncTree.nextQueryTag_++;\n  }\n\n  /**\n   * A helper method to apply tagged operations\n   */\n  private applyTaggedOperation_(\n    queryPath: Path,\n    operation: Operation\n  ): Event[] {\n    const syncPoint = this.syncPointTree_.get(queryPath);\n    assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = this.pendingWriteTree_.childWrites(queryPath);\n    return syncPoint.applyOperation(\n      operation,\n      writesCache,\n      /*serverCache=*/ null\n    );\n  }\n\n  /**\n   * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n   *\n   * NOTES:\n   * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n\n   * - We call applyOperation() on each SyncPoint passing three things:\n   *   1. A version of the Operation that has been made relative to the SyncPoint location.\n   *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n   *   3. A snapshot Node with cached server data, if we have it.\n\n   * - We concatenate all of the events returned by each SyncPoint and return the result.\n   */\n  private applyOperationToSyncPoints_(operation: Operation): Event[] {\n    return this.applyOperationHelper_(\n      operation,\n      this.syncPointTree_,\n      /*serverCache=*/ null,\n      this.pendingWriteTree_.childWrites(Path.Empty)\n    );\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   */\n  private applyOperationHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    if (operation.path.isEmpty()) {\n      return this.applyOperationDescendantsHelper_(\n        operation,\n        syncPointTree,\n        serverCache,\n        writesCache\n      );\n    } else {\n      const syncPoint = syncPointTree.get(Path.Empty);\n\n      // If we don't have cached server data, see if we can get it from this SyncPoint.\n      if (serverCache == null && syncPoint != null) {\n        serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n      }\n\n      let events: Event[] = [];\n      const childName = operation.path.getFront();\n      const childOperation = operation.operationForChild(childName);\n      const childTree = syncPointTree.children.get(childName);\n      if (childTree && childOperation) {\n        const childServerCache = serverCache\n          ? serverCache.getImmediateChild(childName)\n          : null;\n        const childWritesCache = writesCache.child(childName);\n        events = events.concat(\n          this.applyOperationHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n\n      if (syncPoint) {\n        events = events.concat(\n          syncPoint.applyOperation(operation, writesCache, serverCache)\n        );\n      }\n\n      return events;\n    }\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   */\n  private applyOperationDescendantsHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    const syncPoint = syncPointTree.get(Path.Empty);\n\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n      serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let events: Event[] = [];\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\n      const childServerCache = serverCache\n        ? serverCache.getImmediateChild(childName)\n        : null;\n      const childWritesCache = writesCache.child(childName);\n      const childOperation = operation.operationForChild(childName);\n      if (childOperation) {\n        events = events.concat(\n          this.applyOperationDescendantsHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n    });\n\n    if (syncPoint) {\n      events = events.concat(\n        syncPoint.applyOperation(operation, writesCache, serverCache)\n      );\n    }\n\n    return events;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Path } from './util/Path';\nimport { Node } from './snap/Node';\n\n/**\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\n *\n * @constructor\n */\nexport class SnapshotHolder {\n  private rootNode_: Node = ChildrenNode.EMPTY_NODE;\n\n  getNode(path: Path): Node {\n    return this.rootNode_.getChild(path);\n  }\n\n  updateSnapshot(path: Path, newSnapshotNode: Node) {\n    this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseAuthTokenData } from '@firebase/app-types/private';\nimport { log, warn } from './util/util';\n\n/**\n * An interface for token fetchers.\n */\nexport interface AuthTokenProvider {\n  /**\n   * @param {boolean} forceRefresh\n   * @return {!Promise<FirebaseAuthTokenData>}\n   */\n  getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData>;\n\n  addTokenChangeListener(listener: (token: string | null) => void);\n\n  removeTokenChangeListener(listener: (token: string | null) => void);\n\n  notifyForInvalidToken();\n}\n\n/**\n * Abstraction around FirebaseApp's token fetching capabilities.\n */\nexport class FirebaseAuthTokenProvider implements AuthTokenProvider {\n  constructor(private app_: FirebaseApp) {}\n\n  getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData> {\n    return this.app_['INTERNAL']['getToken'](forceRefresh).then(\n      null,\n      // .catch\n      function(error) {\n        // TODO: Need to figure out all the cases this is raised and whether\n        // this makes sense.\n        if (error && error.code === 'auth/token-not-initialized') {\n          log('Got auth/token-not-initialized error.  Treating as null token.');\n          return null;\n        } else {\n          return Promise.reject(error);\n        }\n      }\n    );\n  }\n\n  addTokenChangeListener(listener: (token: string | null) => void) {\n    // TODO: We might want to wrap the listener and call it with no args to\n    // avoid a leaky abstraction, but that makes removing the listener harder.\n    this.app_['INTERNAL']['addAuthTokenListener'](listener);\n  }\n\n  removeTokenChangeListener(listener: (token: string | null) => void) {\n    this.app_['INTERNAL']['removeAuthTokenListener'](listener);\n  }\n\n  notifyForInvalidToken() {\n    let errorMessage =\n      'Provided authentication credentials for the app named \"' +\n      this.app_.name +\n      '\" are invalid. This usually indicates your app was not ' +\n      'initialized correctly. ';\n    if ('credential' in this.app_.options) {\n      errorMessage +=\n        'Make sure the \"credential\" property provided to initializeApp() ' +\n        'is authorized to access the specified \"databaseURL\" and is from the correct ' +\n        'project.';\n    } else if ('serviceAccount' in this.app_.options) {\n      errorMessage +=\n        'Make sure the \"serviceAccount\" property provided to initializeApp() ' +\n        'is authorized to access the specified \"databaseURL\" and is from the correct ' +\n        'project.';\n    } else {\n      errorMessage +=\n        'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' +\n        'initializeApp() match the values provided for your app at ' +\n        'https://console.firebase.google.com/.';\n    }\n    warn(errorMessage);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseAuthTokenData } from '@firebase/app-types/private';\n\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { log, warn } from './util/util';\n\nclass EmulatorAuthToken implements FirebaseAuthTokenData {\n  constructor(public accessToken: string) {}\n}\n\nexport class EmulatorAuthTokenProvider implements AuthTokenProvider {\n  constructor(private app_: FirebaseApp) {}\n\n  getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData> {\n    return Promise.resolve(new EmulatorAuthToken('owner'));\n  }\n\n  addTokenChangeListener(listener: (token: string | null) => void) {}\n\n  removeTokenChangeListener(listener: (token: string | null) => void) {}\n\n  notifyForInvalidToken() {\n    let errorMessage =\n      'Database emulator unexpectedly rejected fake \"owner\" credentials.';\n    warn(errorMessage);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deepCopy } from '@firebase/util';\nimport { contains } from '@firebase/util';\n\n/**\n * Tracks a collection of stats.\n *\n * @constructor\n */\nexport class StatsCollection {\n  private counters_: { [k: string]: number } = {};\n\n  incrementCounter(name: string, amount: number = 1) {\n    if (!contains(this.counters_, name)) this.counters_[name] = 0;\n\n    this.counters_[name] += amount;\n  }\n\n  get() {\n    return deepCopy(this.counters_);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { StatsCollection } from './StatsCollection';\nimport { RepoInfo } from '../RepoInfo';\n\nexport class StatsManager {\n  private static collections_: { [k: string]: StatsCollection } = {};\n  private static reporters_: { [k: string]: any } = {};\n\n  static getCollection(repoInfo: RepoInfo): StatsCollection {\n    const hashString = repoInfo.toString();\n\n    if (!this.collections_[hashString]) {\n      this.collections_[hashString] = new StatsCollection();\n    }\n\n    return this.collections_[hashString];\n  }\n\n  static getOrCreateReporter<T>(\n    repoInfo: RepoInfo,\n    creatorFunction: () => T\n  ): T {\n    const hashString = repoInfo.toString();\n\n    if (!this.reporters_[hashString]) {\n      this.reporters_[hashString] = creatorFunction();\n    }\n\n    return this.reporters_[hashString];\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { StatsCollection } from './StatsCollection';\nimport { each } from '../util/util';\n\n/**\n * Returns the delta from the previous call to get stats.\n *\n * @param collection_ The collection to \"listen\" to.\n * @constructor\n */\nexport class StatsListener {\n  private last_: { [k: string]: number } | null = null;\n\n  constructor(private collection_: StatsCollection) {}\n\n  get(): { [k: string]: number } {\n    const newStats = this.collection_.get();\n\n    const delta = { ...newStats };\n    if (this.last_) {\n      each(this.last_, (stat: string, value: number) => {\n        delta[stat] = delta[stat] - value;\n      });\n    }\n    this.last_ = newStats;\n\n    return delta;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { contains } from '@firebase/util';\nimport { setTimeoutNonBlocking, each } from '../util/util';\nimport { StatsListener } from './StatsListener';\nimport { StatsCollection } from './StatsCollection';\nimport { ServerActions } from '../ServerActions';\n\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n\n/**\n * @constructor\n */\nexport class StatsReporter {\n  private statsListener_: StatsListener;\n  private statsToReport_: { [k: string]: boolean } = {};\n\n  /**\n   * @param collection\n   * @param server_\n   */\n  constructor(collection: StatsCollection, private server_: ServerActions) {\n    this.statsListener_ = new StatsListener(collection);\n\n    const timeout =\n      FIRST_STATS_MIN_TIME +\n      (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n\n  includeStat(stat: string) {\n    this.statsToReport_[stat] = true;\n  }\n\n  private reportStats_() {\n    const stats = this.statsListener_.get();\n    const reportedStats: typeof stats = {};\n    let haveStatsToReport = false;\n\n    each(stats, (stat: string, value: number) => {\n      if (value > 0 && contains(this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    }\n\n    // queue our next run.\n    setTimeoutNonBlocking(\n      this.reportStats_.bind(this),\n      Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { log, logger, exceptionGuard } from '../util/util';\nimport { Event } from './Event';\n\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nexport class EventQueue {\n  /**\n   * @private\n   * @type {!Array.<EventList>}\n   */\n  private eventLists_: EventList[] = [];\n\n  /**\n   * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n   * @private\n   * @type {!number}\n   */\n  private recursionDepth_ = 0;\n\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  queueEvents(eventDataList: Event[]) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for (let i = 0; i < eventDataList.length; i++) {\n      const eventData = eventDataList[i];\n      const eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  raiseEventsAtPath(path: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) =>\n      eventPath.equals(path)\n    );\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  raiseEventsForChangedPath(changedPath: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) => {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  }\n\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  private raiseQueuedEventsMatchingPredicate_(\n    predicate: (path: Path) => boolean\n  ) {\n    this.recursionDepth_++;\n\n    let sentAll = true;\n    for (let i = 0; i < this.eventLists_.length; i++) {\n      const eventList = this.eventLists_[i];\n      if (eventList) {\n        const eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  }\n}\n\n/**\n * @param {!Path} path\n * @constructor\n */\nexport class EventList {\n  /**\n   * @type {!Array.<Event>}\n   * @private\n   */\n  private events_: Event[] = [];\n\n  constructor(private readonly path_: Path) {}\n\n  /**\n   * @param {!Event} eventData\n   */\n  add(eventData: Event) {\n    this.events_.push(eventData);\n  }\n\n  /**\n   * Iterates through the list and raises each event\n   */\n  raise() {\n    for (let i = 0; i < this.events_.length; i++) {\n      const eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        const eventFn = eventData.getEventRunner();\n        if (logger) {\n          log('event: ' + eventData.toString());\n        }\n        exceptionGuard(eventFn);\n      }\n    }\n  }\n\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path {\n    return this.path_;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\n\n/**\n * Base class to be used if you want to emit events. Call the constructor with\n * the set of allowed event names.\n */\nexport abstract class EventEmitter {\n  private listeners_: {\n    [eventType: string]: Array<{\n      callback(...args: any[]): void;\n      context: any;\n    }>;\n  } = {};\n\n  /**\n   * @param {!Array.<string>} allowedEvents_\n   */\n  constructor(private allowedEvents_: Array<string>) {\n    assert(\n      Array.isArray(allowedEvents_) && allowedEvents_.length > 0,\n      'Requires a non-empty array'\n    );\n  }\n\n  /**\n   * To be overridden by derived classes in order to fire an initial event when\n   * somebody subscribes for data.\n   *\n   * @param {!string} eventType\n   * @return {Array.<*>} Array of parameters to trigger initial event with.\n   */\n  abstract getInitialEvent(eventType: string): any[];\n\n  /**\n   * To be called by derived classes to trigger events.\n   * @param {!string} eventType\n   * @param {...*} var_args\n   */\n  protected trigger(eventType: string, ...var_args: any[]) {\n    if (Array.isArray(this.listeners_[eventType])) {\n      // Clone the list, since callbacks could add/remove listeners.\n      const listeners = [...this.listeners_[eventType]];\n\n      for (let i = 0; i < listeners.length; i++) {\n        listeners[i].callback.apply(listeners[i].context, var_args);\n      }\n    }\n  }\n\n  on(eventType: string, callback: (a: any) => void, context: any) {\n    this.validateEventType_(eventType);\n    this.listeners_[eventType] = this.listeners_[eventType] || [];\n    this.listeners_[eventType].push({ callback, context });\n\n    const eventData = this.getInitialEvent(eventType);\n    if (eventData) {\n      callback.apply(context, eventData);\n    }\n  }\n\n  off(eventType: string, callback: (a: any) => void, context: any) {\n    this.validateEventType_(eventType);\n    const listeners = this.listeners_[eventType] || [];\n    for (let i = 0; i < listeners.length; i++) {\n      if (\n        listeners[i].callback === callback &&\n        (!context || context === listeners[i].context)\n      ) {\n        listeners.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  private validateEventType_(eventType: string) {\n    assert(\n      this.allowedEvents_.find(function(et) {\n        return et === eventType;\n      }),\n      'Unknown event: ' + eventType\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from './EventEmitter';\nimport { assert } from '@firebase/util';\n\ndeclare const document: any;\n\n/**\n * @extends {EventEmitter}\n */\nexport class VisibilityMonitor extends EventEmitter {\n  private visible_: boolean;\n\n  static getInstance() {\n    return new VisibilityMonitor();\n  }\n\n  constructor() {\n    super(['visible']);\n    let hidden: string;\n    let visibilityChange: string;\n    if (\n      typeof document !== 'undefined' &&\n      typeof document.addEventListener !== 'undefined'\n    ) {\n      if (typeof document['hidden'] !== 'undefined') {\n        // Opera 12.10 and Firefox 18 and later support\n        visibilityChange = 'visibilitychange';\n        hidden = 'hidden';\n      } else if (typeof document['mozHidden'] !== 'undefined') {\n        visibilityChange = 'mozvisibilitychange';\n        hidden = 'mozHidden';\n      } else if (typeof document['msHidden'] !== 'undefined') {\n        visibilityChange = 'msvisibilitychange';\n        hidden = 'msHidden';\n      } else if (typeof document['webkitHidden'] !== 'undefined') {\n        visibilityChange = 'webkitvisibilitychange';\n        hidden = 'webkitHidden';\n      }\n    }\n\n    // Initially, we always assume we are visible. This ensures that in browsers\n    // without page visibility support or in cases where we are never visible\n    // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\n    // reconnects\n    this.visible_ = true;\n\n    if (visibilityChange) {\n      document.addEventListener(\n        visibilityChange,\n        () => {\n          const visible = !document[hidden];\n          if (visible !== this.visible_) {\n            this.visible_ = visible;\n            this.trigger('visible', visible);\n          }\n        },\n        false\n      );\n    }\n  }\n\n  /**\n   * @param {!string} eventType\n   * @return {Array.<boolean>}\n   */\n  getInitialEvent(eventType: string): boolean[] {\n    assert(eventType === 'visible', 'Unknown event type: ' + eventType);\n    return [this.visible_];\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { EventEmitter } from './EventEmitter';\nimport { isMobileCordova } from '@firebase/util';\n\n/**\n * Monitors online state (as reported by window.online/offline events).\n *\n * The expectation is that this could have many false positives (thinks we are online\n * when we're not), but no false negatives.  So we can safely use it to determine when\n * we definitely cannot reach the internet.\n *\n * @extends {EventEmitter}\n */\nexport class OnlineMonitor extends EventEmitter {\n  private online_ = true;\n\n  static getInstance() {\n    return new OnlineMonitor();\n  }\n\n  constructor() {\n    super(['online']);\n\n    // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\n    // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\n    // It would seem that the 'online' event does not always fire consistently. So we disable it\n    // for Cordova.\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.addEventListener !== 'undefined' &&\n      !isMobileCordova()\n    ) {\n      window.addEventListener(\n        'online',\n        () => {\n          if (!this.online_) {\n            this.online_ = true;\n            this.trigger('online', true);\n          }\n        },\n        false\n      );\n\n      window.addEventListener(\n        'offline',\n        () => {\n          if (this.online_) {\n            this.online_ = false;\n            this.trigger('online', false);\n          }\n        },\n        false\n      );\n    }\n  }\n\n  /**\n   * @param {!string} eventType\n   * @return {Array.<boolean>}\n   */\n  getInitialEvent(eventType: string): boolean[] {\n    assert(eventType === 'online', 'Unknown event type: ' + eventType);\n    return [this.online_];\n  }\n\n  /**\n   * @return {boolean}\n   */\n  currentlyOnline(): boolean {\n    return this.online_;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { exceptionGuard } from '../../core/util/util';\n\n/**\n * This class ensures the packets from the server arrive in order\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\n * @constructor\n */\nexport class PacketReceiver {\n  pendingResponses: any[] = [];\n  currentResponseNum = 0;\n  closeAfterResponse = -1;\n  onClose: (() => void) | null = null;\n\n  /**\n   * @param onMessage_\n   */\n  constructor(private onMessage_: (a: Object) => void) {}\n\n  closeAfter(responseNum: number, callback: () => void) {\n    this.closeAfterResponse = responseNum;\n    this.onClose = callback;\n    if (this.closeAfterResponse < this.currentResponseNum) {\n      this.onClose();\n      this.onClose = null;\n    }\n  }\n\n  /**\n   * Each message from the server comes with a response number, and an array of data. The responseNumber\n   * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\n   * browsers will respond in the same order as the requests we sent\n   * @param {number} requestNum\n   * @param {Array} data\n   */\n  handleResponse(requestNum: number, data: any[]) {\n    this.pendingResponses[requestNum] = data;\n    while (this.pendingResponses[this.currentResponseNum]) {\n      const toProcess = this.pendingResponses[this.currentResponseNum];\n      delete this.pendingResponses[this.currentResponseNum];\n      for (let i = 0; i < toProcess.length; ++i) {\n        if (toProcess[i]) {\n          exceptionGuard(() => {\n            this.onMessage_(toProcess[i]);\n          });\n        }\n      }\n      if (this.currentResponseNum === this.closeAfterResponse) {\n        if (this.onClose) {\n          this.onClose();\n          this.onClose = null;\n        }\n        break;\n      }\n      this.currentResponseNum++;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  executeWhenDOMReady,\n  isChromeExtensionContentScript,\n  isWindowsStoreApp,\n  log,\n  logWrapper,\n  LUIDGenerator,\n  splitStringBySize\n} from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { PacketReceiver } from './polling/PacketReceiver';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  LONG_POLLING,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM\n} from './Constants';\nimport { base64Encode, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\n// URL query parameters associated with longpolling\nexport const FIREBASE_LONGPOLL_START_PARAM = 'start';\nexport const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexport const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexport const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexport const FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexport const FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexport const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexport const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexport const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexport const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexport const FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\n\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nconst LP_CONNECT_TIMEOUT = 30000;\n\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nexport class BrowserPollConnection implements Transport {\n  bytesSent = 0;\n  bytesReceived = 0;\n  urlFn: (params: object) => string;\n  scriptTagHolder: FirebaseIFrameScriptHolder;\n  myDisconnFrame: HTMLIFrameElement;\n  curSegmentNum: number;\n  myPacketOrderer: PacketReceiver;\n  id: string;\n  password: string;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_ = false;\n  private isClosed_: boolean;\n  private connectTimeoutTimer_: number | null;\n  private onDisconnect_: ((a?: boolean) => void) | null;\n\n  /**\n   * @param {string} connId An identifier for this connection, used for logging\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n   *                                         transport session\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n   *                                     connection previously\n   */\n  constructor(\n    public connId: string,\n    public repoInfo: RepoInfo,\n    public transportSessionId?: string,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.urlFn = (params: { [k: string]: string }) =>\n      repoInfo.connectionURL(LONG_POLLING, params);\n  }\n\n  /**\n   *\n   * @param {function(Object)} onMessage Callback when messages arrive\n   * @param {function()} onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver(onMessage);\n    this.isClosed_ = false;\n\n    this.connectTimeoutTimer_ = setTimeout(() => {\n      this.log_('Timed out trying to connect.');\n      // Make sure we clear the host cache\n      this.onClosed_();\n      this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT)) as any;\n\n    // Ensure we delay the creation of the iframe until the DOM is loaded.\n    executeWhenDOMReady(() => {\n      if (this.isClosed_) return;\n\n      //Set up a callback that gets triggered once a connection is set up.\n      this.scriptTagHolder = new FirebaseIFrameScriptHolder(\n        (...args) => {\n          const [command, arg1, arg2, arg3, arg4] = args;\n          this.incrementIncomingBytes_(args);\n          if (!this.scriptTagHolder) return; // we closed the connection.\n\n          if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n          }\n          this.everConnected_ = true;\n          if (command == FIREBASE_LONGPOLL_START_PARAM) {\n            this.id = arg1;\n            this.password = arg2;\n          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n            // Don't clear the host cache. We got a response from the server, so we know it's reachable\n            if (arg1) {\n              // We aren't expecting any more data (other than what the server's already in the process of sending us\n              // through our already open polls), so don't send any more.\n              this.scriptTagHolder.sendNewPolls = false;\n\n              // arg1 in this case is the last response number sent by the server. We should try to receive\n              // all of the responses up to this one before closing\n              this.myPacketOrderer.closeAfter(arg1, () => {\n                this.onClosed_();\n              });\n            } else {\n              this.onClosed_();\n            }\n          } else {\n            throw new Error('Unrecognized command received: ' + command);\n          }\n        },\n        (...args) => {\n          const [pN, data] = args;\n          this.incrementIncomingBytes_(args);\n          this.myPacketOrderer.handleResponse(pN, data);\n        },\n        () => {\n          this.onClosed_();\n        },\n        this.urlFn\n      );\n\n      //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(\n        Math.random() * 100000000\n      );\n      if (this.scriptTagHolder.uniqueCallbackIdentifier)\n        urlParams[\n          FIREBASE_LONGPOLL_CALLBACK_ID_PARAM\n        ] = this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n      if (this.transportSessionId) {\n        urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n      }\n      if (this.lastSessionId) {\n        urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n      }\n      if (\n        typeof location !== 'undefined' &&\n        location.href &&\n        location.href.indexOf(FORGE_DOMAIN) !== -1\n      ) {\n        urlParams[REFERER_PARAM] = FORGE_REF;\n      }\n      const connectURL = this.urlFn(urlParams);\n      this.log_('Connecting via long-poll to ' + connectURL);\n      this.scriptTagHolder.addTag(connectURL, () => {\n        /* do nothing */\n      });\n    });\n  }\n\n  /**\n   * Call this when a handshake has completed successfully and we want to consider the connection established\n   */\n  start() {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  }\n\n  private static forceAllow_: boolean;\n\n  /**\n   * Forces long polling to be considered as a potential transport\n   */\n  static forceAllow() {\n    BrowserPollConnection.forceAllow_ = true;\n  }\n\n  private static forceDisallow_: boolean;\n\n  /**\n   * Forces longpolling to not be considered as a potential transport\n   */\n  static forceDisallow() {\n    BrowserPollConnection.forceDisallow_ = true;\n  }\n\n  // Static method, use string literal so it can be accessed in a generic way\n  static isAvailable() {\n    if (isNodeSdk()) {\n      return false;\n    } else if (BrowserPollConnection.forceAllow_) {\n      return true;\n    } else {\n      // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n      // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n      return (\n        !BrowserPollConnection.forceDisallow_ &&\n        typeof document !== 'undefined' &&\n        document.createElement != null &&\n        !isChromeExtensionContentScript() &&\n        !isWindowsStoreApp()\n      );\n    }\n  }\n\n  /**\n   * No-op for polling\n   */\n  markConnectionHealthy() {}\n\n  /**\n   * Stops polling and cleans up the iframe\n   * @private\n   */\n  private shutdown_() {\n    this.isClosed_ = true;\n\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    }\n\n    //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  }\n\n  /**\n   * Triggered when this transport is closed\n   * @private\n   */\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n   * that we've left.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n   * broken into chunks (since URLs have a small maximum length).\n   * @param {!Object} data The JSON data to transmit.\n   */\n  send(data: Object) {\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //first, lets get the base64-encoded data\n    const base64data = base64Encode(dataStr);\n\n    //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n\n    //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(\n        this.curSegmentNum,\n        dataSegs.length,\n        dataSegs[i]\n      );\n      this.curSegmentNum++;\n    }\n  }\n\n  /**\n   * This is how we notify the server that we're leaving.\n   * We aren't able to send requests with DHTML on a window close event, but we can\n   * trigger XHR requests in some browsers (everything but Opera basically).\n   * @param {!string} id\n   * @param {!string} pw\n   */\n  addDisconnectPingFrame(id: string, pw: string) {\n    if (isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    const urlParams: { [k: string]: string } = {};\n    urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n\n    document.body.appendChild(this.myDisconnFrame);\n  }\n\n  /**\n   * Used to track the bytes received by this client\n   * @param {*} args\n   * @private\n   */\n  private incrementIncomingBytes_(args: any) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    const bytesReceived = stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  }\n}\n\nexport interface IFrameElement extends HTMLIFrameElement {\n  doc: Document;\n}\n\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nexport class FirebaseIFrameScriptHolder {\n  //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n  //problems in some browsers.\n  outstandingRequests = new Set<number>();\n\n  //A queue of the pending segments waiting for transmission to the server.\n  pendingSegs: { seg: number; ts: number; d: any }[] = [];\n\n  //A serial number. We use this for two things:\n  // 1) A way to ensure the browser doesn't cache responses to polls\n  // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n  //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n  //    JSONP code in the order it was added to the iframe.\n  currentSerial = Math.floor(Math.random() * 100000000);\n\n  // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n  // incoming data from the server that we're waiting for).\n  sendNewPolls = true;\n\n  uniqueCallbackIdentifier: number;\n  myIFrame: IFrameElement;\n  alive: boolean;\n  myID: string;\n  myPW: string;\n  commandCB: (command: string, ...args: any[]) => void;\n  onMessageCB: (...args: any[]) => void;\n\n  /**\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\n   */\n  constructor(\n    commandCB: (command: string, ...args: any[]) => void,\n    onMessageCB: (...args: any[]) => void,\n    public onDisconnect: () => void,\n    public urlFn: (a: object) => string\n  ) {\n    if (!isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = LUIDGenerator();\n      (window as any)[\n        FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier\n      ] = commandCB;\n      (window as any)[\n        FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier\n      ] = onMessageCB;\n\n      //Create an iframe for us to add script tags to.\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n\n      // Set the iframe's contents.\n      let script = '';\n      // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n      if (\n        this.myIFrame.src &&\n        this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:'\n      ) {\n        const currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n      const iframeContents = '<html><body>' + script + '</body></html>';\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        log('frame writing exception');\n        if (e.stack) {\n          log(e.stack);\n        }\n        log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n\n  /**\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n   * actually use.\n   * @private\n   * @return {Element}\n   */\n  private static createIFrame_(): IFrameElement {\n    const iframe = document.createElement('iframe') as IFrameElement;\n    iframe.style.display = 'none';\n\n    // This is necessary in order to initialize the document inside the iframe\n    if (document.body) {\n      document.body.appendChild(iframe);\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        const a = iframe.contentWindow.document;\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          log('No IE domain setting required');\n        }\n      } catch (e) {\n        const domain = document.domain;\n        iframe.src =\n          \"javascript:void((function(){document.open();document.domain='\" +\n          domain +\n          \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    }\n\n    // Get the document of the iframe in a browser-specific way.\n    if (iframe.contentDocument) {\n      (iframe as any).doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      (iframe as any).doc = iframe.contentWindow.document; // Internet Explorer\n    } else if ((iframe as any).document) {\n      (iframe as any).doc = (iframe as any).document; //others?\n    }\n\n    return iframe;\n  }\n\n  /**\n   * Cancel all outstanding queries and remove the frame.\n   */\n  close() {\n    //Mark this iframe as dead, so no new requests are sent.\n    this.alive = false;\n\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(() => {\n        if (this.myIFrame !== null) {\n          document.body.removeChild(this.myIFrame);\n          this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n\n    // Protect from being called recursively.\n    const onDisconnect = this.onDisconnect;\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  }\n\n  /**\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n   * @param {!string} id - The ID of this connection\n   * @param {!string} pw - The password for this connection\n   */\n  startLongPoll(id: string, pw: string) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true;\n\n    //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n    while (this.newRequest_()) {}\n  }\n\n  /**\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n   * too many outstanding requests and we are still alive.\n   *\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n   * needed.\n   */\n  private newRequest_() {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (\n      this.alive &&\n      this.sendNewPolls &&\n      this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)\n    ) {\n      //construct our url\n      this.currentSerial++;\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      let theURL = this.urlFn(urlParams);\n      //Now add as much data as we can.\n      let curDataString = '';\n      let i = 0;\n\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        const nextSeg = this.pendingSegs[0];\n        if (\n          nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=\n          MAX_URL_DATA_SIZE\n        ) {\n          //great, the segment will fit. Lets append it.\n          const theSeg = this.pendingSegs.shift();\n          curDataString =\n            curDataString +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\n            i +\n            '=' +\n            theSeg.seg +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\n            i +\n            '=' +\n            theSeg.ts +\n            '&' +\n            FIREBASE_LONGPOLL_DATA_PARAM +\n            i +\n            '=' +\n            theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Queue a packet for transmission to the server.\n   * @param segnum - A sequential id for this packet segment used for reassembly\n   * @param totalsegs - The total number of segments in this packet\n   * @param data - The data for this segment.\n   */\n  enqueueSegment(segnum: number, totalsegs: number, data: any) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\n\n    //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n    if (this.alive) {\n      this.newRequest_();\n    }\n  }\n\n  /**\n   * Add a script tag for a regular long-poll request.\n   * @param {!string} url - The URL of the script tag.\n   * @param {!number} serial - The serial number of the request.\n   * @private\n   */\n  private addLongPollTag_(url: string, serial: number) {\n    //remember that we sent this request.\n    this.outstandingRequests.add(serial);\n\n    const doNewRequest = () => {\n      this.outstandingRequests.delete(serial);\n      this.newRequest_();\n    };\n\n    // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n    const keepaliveTimeout = setTimeout(\n      doNewRequest,\n      Math.floor(KEEPALIVE_REQUEST_INTERVAL)\n    );\n\n    const readyStateCB = () => {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout);\n\n      // Trigger a new request so we can continue receiving data.\n      doNewRequest();\n    };\n\n    this.addTag(url, readyStateCB);\n  }\n\n  /**\n   * Add an arbitrary script tag to the iframe.\n   * @param {!string} url - The URL for the script tag source.\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n   */\n  addTag(url: string, loadCB: () => void) {\n    if (isNodeSdk()) {\n      (this as any).doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(() => {\n        try {\n          // if we're already closed, don't add this poll\n          if (!this.sendNewPolls) return;\n          const newScript = this.myIFrame.doc.createElement('script');\n          newScript.type = 'text/javascript';\n          newScript.async = true;\n          newScript.src = url;\n          newScript.onload = (newScript as any).onreadystatechange = function() {\n            const rstate = (newScript as any).readyState;\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript.onload = (newScript as any).onreadystatechange = null;\n              if (newScript.parentNode) {\n                newScript.parentNode.removeChild(newScript);\n              }\n              loadCB();\n            }\n          };\n          newScript.onerror = () => {\n            log('Long-poll script failed to load: ' + url);\n            this.sendNewPolls = false;\n            this.close();\n          };\n          this.myIFrame.doc.body.appendChild(newScript);\n        } catch (e) {\n          // TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** The semver (www.semver.org) version of the SDK. */\nexport let SDK_VERSION = '';\n\n// SDK_VERSION should be set before any database instance is created\nexport function setSDKVersion(version: string): void {\n  SDK_VERSION = version;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\n\ndeclare const MozWebSocket: any;\n\nimport { assert, CONSTANTS as ENV_CONSTANTS } from '@firebase/util';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM,\n  WEBSOCKET\n} from './Constants';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { StatsCollection } from '../core/stats/StatsCollection';\nimport { SDK_VERSION } from '../core/version';\n\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\n\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nexport function setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nexport class WebSocketConnection implements Transport {\n  keepaliveTimer: number | null = null;\n  frames: string[] | null = null;\n  totalFrames = 0;\n  bytesSent = 0;\n  bytesReceived = 0;\n  connURL: string;\n  onDisconnect: (a?: boolean) => void;\n  onMessage: (msg: Object) => void;\n  mySock: any | null;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_: boolean;\n  private isClosed_: boolean;\n\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  constructor(\n    public connId: string,\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(this.connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(\n      repoInfo,\n      transportSessionId,\n      lastSessionId\n    );\n  }\n\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  private static connectionURL_(\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ): string {\n    const urlParams: { [k: string]: string } = {};\n    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n\n    if (\n      !isNodeSdk() &&\n      typeof location !== 'undefined' &&\n      location.href &&\n      location.href.indexOf(FORGE_DOMAIN) !== -1\n    ) {\n      urlParams[REFERER_PARAM] = FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(WEBSOCKET, urlParams);\n  }\n\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n\n    this.log_('Websocket connecting to ' + this.connURL);\n\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (isNodeSdk()) {\n        const device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        const options: { [k: string]: object } = {\n          headers: {\n            'User-Agent': `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`\n          }\n        };\n\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        const env = process['env'];\n        const proxy =\n          this.connURL.indexOf('wss://') == 0\n            ? env['HTTPS_PROXY'] || env['https_proxy']\n            : env['HTTP_PROXY'] || env['http_proxy'];\n\n        if (proxy) {\n          options['proxy'] = { origin: proxy };\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = () => {\n      this.log_('Websocket connected.');\n      this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = () => {\n      this.log_('Websocket connection was disconnected.');\n      this.mySock = null;\n      this.onClosed_();\n    };\n\n    this.mySock.onmessage = (m: object) => {\n      this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = (e: any) => {\n      this.log_('WebSocket error.  Closing connection.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n    };\n  }\n\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  start() {}\n\n  static forceDisallow_: Boolean;\n\n  static forceDisallow() {\n    WebSocketConnection.forceDisallow_ = true;\n  }\n\n  static isAvailable(): boolean {\n    let isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return (\n      !isOldAndroid &&\n      WebSocketImpl !== null &&\n      !WebSocketConnection.forceDisallow_\n    );\n  }\n\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  static responsesRequiredToBeHealthy = 2;\n\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  static healthyTimeout = 30000;\n\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  static previouslyFailed(): boolean {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return (\n      PersistentStorage.isInMemoryStorage ||\n      PersistentStorage.get('previous_websocket_failure') === true\n    );\n  }\n\n  markConnectionHealthy() {\n    PersistentStorage.remove('previous_websocket_failure');\n  }\n\n  private appendFrame_(data: string) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      const fullMess = this.frames.join('');\n      this.frames = null;\n      const jsonMess = jsonEval(fullMess) as object;\n\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  }\n\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  private handleNewFrameCount_(frameCount: number) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  }\n\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  private extractFrameCount_(data: string): string | null {\n    assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      const frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  }\n\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  handleIncomingFrame(mess: { [k: string]: any }) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    const data = mess['data'] as string;\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      const remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  send(data: Object) {\n    this.resetKeepAlive();\n\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n\n    //Send the actual data in segments.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  }\n\n  private shutdown_() {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  }\n\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  resetKeepAlive() {\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(() => {\n      //If there has been no websocket activity for a while, send a no-op\n      if (this.mySock) {\n        this.sendString_('0');\n      }\n      this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)) as any;\n  }\n\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  private sendString_(str: string) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_(\n        'Exception thrown from WebSocket.send():',\n        e.message || e.data,\n        'Closing connection.'\n      );\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BrowserPollConnection } from './BrowserPollConnection';\nimport { WebSocketConnection } from './WebSocketConnection';\nimport { warn, each } from '../core/util/util';\nimport { TransportConstructor } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\n\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\nexport class TransportManager {\n  private transports_: TransportConstructor[];\n\n  /**\n   * @const\n   * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n   */\n  static get ALL_TRANSPORTS() {\n    return [BrowserPollConnection, WebSocketConnection];\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  constructor(repoInfo: RepoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n  private initTransports_(repoInfo: RepoInfo) {\n    const isWebSocketsAvailable: boolean =\n      WebSocketConnection && WebSocketConnection['isAvailable']();\n    let isSkipPollConnection =\n      isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable)\n        warn(\n          \"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\"\n        );\n\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection];\n    } else {\n      const transports = (this.transports_ = [] as TransportConstructor[]);\n      for (const transport of TransportManager.ALL_TRANSPORTS) {\n        if (transport && transport['isAvailable']()) {\n          transports.push(transport);\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n  initialTransport(): TransportConstructor {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  }\n\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n  upgradeTransport(): TransportConstructor | null {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  error,\n  logWrapper,\n  requireKey,\n  setTimeoutNonBlocking,\n  warn\n} from '../core/util/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { PROTOCOL_VERSION } from './Constants';\nimport { TransportManager } from './TransportManager';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { Transport, TransportConstructor } from './Transport';\n\n// Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\n\nconst enum RealtimeState {\n  CONNECTING,\n  CONNECTED,\n  DISCONNECTED\n}\n\nconst MESSAGE_TYPE = 't';\nconst MESSAGE_DATA = 'd';\nconst CONTROL_SHUTDOWN = 's';\nconst CONTROL_RESET = 'r';\nconst CONTROL_ERROR = 'e';\nconst CONTROL_PONG = 'o';\nconst SWITCH_ACK = 'a';\nconst END_TRANSMISSION = 'n';\nconst PING = 'p';\n\nconst SERVER_HELLO = 'h';\n\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nexport class Connection {\n  connectionCount = 0;\n  pendingDataMessages: any[] = [];\n  sessionId: string;\n\n  private conn_: Transport;\n  private healthyTimeout_: number;\n  private isHealthy_: boolean;\n  private log_: (...args: any[]) => void;\n  private primaryResponsesRequired_: number;\n  private rx_: Transport;\n  private secondaryConn_: Transport;\n  private secondaryResponsesRequired_: number;\n  private state_ = RealtimeState.CONNECTING;\n  private transportManager_: TransportManager;\n  private tx_: Transport;\n\n  /**\n   * @param {!string} id - an id for this connection\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n   */\n  constructor(\n    public id: string,\n    private repoInfo_: RepoInfo,\n    private onMessage_: (a: Object) => void,\n    private onReady_: (a: number, b: string) => void,\n    private onDisconnect_: () => void,\n    private onKill_: (a: string) => void,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n\n  /**\n   * Starts a connection attempt\n   * @private\n   */\n  private start_() {\n    const conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      undefined,\n      this.lastSessionId\n    );\n\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessageReceived = this.connReceiver_(this.conn_);\n    const onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n\n    /*\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n     * still have the context of your originating frame.\n     */\n    setTimeout(() => {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n\n    const healthyTimeout_ms = conn['healthyTimeout'] || 0;\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = setTimeoutNonBlocking(() => {\n        this.healthyTimeout_ = null;\n        if (!this.isHealthy_) {\n          if (\n            this.conn_ &&\n            this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has received ' +\n                this.conn_.bytesReceived +\n                ' bytes.  Marking connection healthy.'\n            );\n            this.isHealthy_ = true;\n            this.conn_.markConnectionHealthy();\n          } else if (\n            this.conn_ &&\n            this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has sent ' +\n                this.conn_.bytesSent +\n                ' bytes.  Leaving connection alive.'\n            );\n            // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n          } else {\n            this.log_('Closing unhealthy connection after timeout.');\n            this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms)) as any;\n    }\n  }\n\n  /**\n   * @return {!string}\n   * @private\n   */\n  private nextTransportId_(): string {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  }\n\n  private disconnReceiver_(conn) {\n    return everConnected => {\n      if (conn === this.conn_) {\n        this.onConnectionLost_(everConnected);\n      } else if (conn === this.secondaryConn_) {\n        this.log_('Secondary connection lost.');\n        this.onSecondaryConnectionLost_();\n      } else {\n        this.log_('closing an old connection');\n      }\n    };\n  }\n\n  private connReceiver_(conn: Transport) {\n    return (message: object) => {\n      if (this.state_ != RealtimeState.DISCONNECTED) {\n        if (conn === this.rx_) {\n          this.onPrimaryMessageReceived_(message);\n        } else if (conn === this.secondaryConn_) {\n          this.onSecondaryMessageReceived_(message);\n        } else {\n          this.log_('message on old connection');\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\n   */\n  sendRequest(dataMsg: object) {\n    // wrap in a data message envelope and send it on\n    const msg = { t: 'd', d: dataMsg };\n    this.sendData_(msg);\n  }\n\n  tryCleanupConnection() {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_(\n        'cleaning up and promoting a connection: ' + this.secondaryConn_.connId\n      );\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null;\n      // the server will shutdown the old connection\n    }\n  }\n\n  private onSecondaryControl_(controlData: { [k: string]: any }) {\n    if (MESSAGE_TYPE in controlData) {\n      const cmd = controlData[MESSAGE_TYPE] as string;\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close();\n        // If we were already using this connection for something, than we need to fully close\n        if (\n          this.tx_ === this.secondaryConn_ ||\n          this.rx_ === this.secondaryConn_\n        ) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  }\n\n  private onSecondaryMessageReceived_(parsedData: object) {\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  }\n\n  private upgradeIfSecondaryHealthy_() {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private proceedWithUpgrade_() {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start();\n    // send ack\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n\n    // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n    this.log_('Ending transmission on primary');\n    this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n    this.tx_ = this.secondaryConn_;\n\n    this.tryCleanupConnection();\n  }\n\n  private onPrimaryMessageReceived_(parsedData: { [k: string]: any }) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  }\n\n  private onDataMessage_(message: any) {\n    this.onPrimaryResponse_();\n\n    // We don't do anything with data messages, just kick them up a level\n    this.onMessage_(message);\n  }\n\n  private onPrimaryResponse_() {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  }\n\n  private onControl_(controlData: { [k: string]: any }) {\n    const cmd: string = requireKey(MESSAGE_TYPE, controlData);\n    if (MESSAGE_DATA in controlData) {\n      const payload = controlData[MESSAGE_DATA];\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n        for (let i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        error('Unknown control packet command: ' + cmd);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Object} handshake The handshake data returned from the server\n   * @private\n   */\n  private onHandshake_(handshake: {\n    ts: number;\n    v: string;\n    h: string;\n    s: string;\n  }) {\n    const timestamp = handshake.ts;\n    const version = handshake.v;\n    const host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host);\n    // if we've already closed the connection, then don't bother trying to progress further\n    if (this.state_ == RealtimeState.CONNECTING) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n      if (PROTOCOL_VERSION !== version) {\n        warn('Protocol version mismatch detected');\n      }\n      // TODO: do we want to upgrade? when? maybe a delay?\n      this.tryStartUpgrade_();\n    }\n  }\n\n  private tryStartUpgrade_() {\n    const conn = this.transportManager_.upgradeTransport();\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  }\n\n  private startUpgrade_(conn: TransportConstructor) {\n    this.secondaryConn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      this.sessionId\n    );\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.secondaryResponsesRequired_ =\n      conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessage = this.connReceiver_(this.secondaryConn_);\n    const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect);\n\n    // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n    setTimeoutNonBlocking(() => {\n      if (this.secondaryConn_) {\n        this.log_('Timed out trying to upgrade.');\n        this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  }\n\n  private onReset_(host: string) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host);\n    // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n    if (this.state_ === RealtimeState.CONNECTED) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  }\n\n  private onConnectionEstablished_(conn: Transport, timestamp: number) {\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = RealtimeState.CONNECTED;\n\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    }\n\n    // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      setTimeoutNonBlocking(() => {\n        this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  }\n\n  private sendPingOnPrimaryIfNecessary_() {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === RealtimeState.CONNECTED) {\n      this.log_('sending ping on primary.');\n      this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private onSecondaryConnectionLost_() {\n    const conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  }\n\n  /**\n   *\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n   * we should flush the host cache\n   * @private\n   */\n  private onConnectionLost_(everConnected: boolean) {\n    this.conn_ = null;\n\n    // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n    if (!everConnected && this.state_ === RealtimeState.CONNECTING) {\n      this.log_('Realtime connection failed.');\n      // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n      if (this.repoInfo_.isCacheableHost()) {\n        PersistentStorage.remove('host:' + this.repoInfo_.host);\n        // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === RealtimeState.CONNECTED) {\n      this.log_('Realtime connection lost.');\n    }\n\n    this.close();\n  }\n\n  /**\n   *\n   * @param {string} reason\n   * @private\n   */\n  private onConnectionShutdown_(reason: string) {\n    this.log_('Connection shutdown command received. Shutting down...');\n\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    }\n\n    // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n    this.onDisconnect_ = null;\n\n    this.close();\n  }\n\n  private sendData_(data: object) {\n    if (this.state_ !== RealtimeState.CONNECTED) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  }\n\n  /**\n   * Cleans up this connection, calling the appropriate callbacks\n   */\n  close() {\n    if (this.state_ !== RealtimeState.DISCONNECTED) {\n      this.log_('Closing realtime connection.');\n      this.state_ = RealtimeState.DISCONNECTED;\n\n      this.closeConnections_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   *\n   * @private\n   */\n  private closeConnections_() {\n    this.log_('Shutting down all connections');\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../api/Query';\n\n/**\n * Interface defining the set of actions that can be performed against the Firebase server\n * (basically corresponds to our wire protocol).\n *\n * @interface\n */\nexport abstract class ServerActions {\n  /**\n   * @param {!Query} query\n   * @param {function():string} currentHashFn\n   * @param {?number} tag\n   * @param {function(string, *)} onComplete\n   */\n  abstract listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ): void;\n\n  /**\n   * Remove a listen.\n   *\n   * @param {!Query} query\n   * @param {?number} tag\n   */\n  abstract unlisten(query: Query, tag: number | null): void;\n\n  /**\n   * @param {string} pathString\n   * @param {*} data\n   * @param {function(string, string)=} onComplete\n   * @param {string=} hash\n   */\n  put(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void,\n    hash?: string\n  ) {}\n\n  /**\n   * @param {string} pathString\n   * @param {*} data\n   * @param {function(string, ?string)} onComplete\n   * @param {string=} hash\n   */\n  merge(\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {}\n\n  /**\n   * Refreshes the auth token for the current connection.\n   * @param {string} token The authentication token\n   */\n  refreshAuthToken(token: string) {}\n\n  /**\n   * @param {string} pathString\n   * @param {*} data\n   * @param {function(string, string)=} onComplete\n   */\n  onDisconnectPut(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {}\n\n  /**\n   * @param {string} pathString\n   * @param {*} data\n   * @param {function(string, string)=} onComplete\n   */\n  onDisconnectMerge(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {}\n\n  /**\n   * @param {string} pathString\n   * @param {function(string, string)=} onComplete\n   */\n  onDisconnectCancel(\n    pathString: string,\n    onComplete?: (a: string, b: string) => void\n  ) {}\n\n  /**\n   * @param {Object.<string, *>} stats\n   */\n  reportStats(stats: { [k: string]: any }) {}\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { contains, isEmpty, safeGet, CONSTANTS } from '@firebase/util';\nimport { stringify } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '@firebase/util';\nimport { Connection } from '../realtime/Connection';\nimport { isMobileCordova, isReactNative, isNodeSdk } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { RepoInfo } from './RepoInfo';\nimport { Query } from '../api/Query';\nimport { SDK_VERSION } from './version';\n\nconst RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_AUTH_TOKEN_THRESHOLD = 3;\n\ninterface ListenSpec {\n  onComplete(s: string, p?: any): void;\n\n  hashFn(): string;\n\n  query: Query;\n  tag: number | null;\n}\n\ninterface OnDisconnectRequest {\n  pathString: string;\n  action: string;\n  data: any;\n  onComplete?: (a: string, b: string) => void;\n}\n\ninterface OutstandingPut {\n  action: string;\n  request: Object;\n  queued?: boolean;\n  onComplete: (a: string, b?: string) => void;\n}\n\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nexport class PersistentConnection extends ServerActions {\n  // Used for diagnostic logging.\n  id = PersistentConnection.nextPersistentConnectionId_++;\n  private log_ = logWrapper('p:' + this.id + ':');\n\n  private interruptReasons_: { [reason: string]: boolean } = {};\n  /** Map<path, Map<queryId, ListenSpec>> */\n  private readonly listens: Map<\n    /* path */ string,\n    Map</* queryId */ string, ListenSpec>\n  > = new Map();\n  private outstandingPuts_: OutstandingPut[] = [];\n  private outstandingPutCount_ = 0;\n  private onDisconnectRequestQueue_: OnDisconnectRequest[] = [];\n  private connected_ = false;\n  private reconnectDelay_ = RECONNECT_MIN_DELAY;\n  private maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n  private securityDebugCallback_: ((a: Object) => void) | null = null;\n  lastSessionId: string | null = null;\n\n  private establishConnectionTimer_: number | null = null;\n\n  private visible_: boolean = false;\n\n  // Before we get connected, we keep a queue of pending messages to send.\n  private requestCBHash_: { [k: number]: (a: any) => void } = {};\n  private requestNumber_ = 0;\n\n  private realtime_: {\n    sendRequest(a: Object): void;\n    close(): void;\n  } | null = null;\n\n  private authToken_: string | null = null;\n  private forceTokenRefresh_ = false;\n  private invalidAuthTokenCount_ = 0;\n\n  private firstConnection_ = true;\n  private lastConnectionAttemptTime_: number | null = null;\n  private lastConnectionEstablishedTime_: number | null = null;\n\n  private static nextPersistentConnectionId_ = 0;\n\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   */\n  private static nextConnectionId_ = 0;\n\n  /**\n   * @implements {ServerActions}\n   * @param repoInfo_ Data about the namespace we are connecting to\n   * @param onDataUpdate_ A callback for new data from the server\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private onConnectStatus_: (a: boolean) => void,\n    private onServerInfoUpdate_: (a: any) => void,\n    private authTokenProvider_: AuthTokenProvider,\n    private authOverride_?: Object | null\n  ) {\n    super();\n\n    if (authOverride_ && !isNodeSdk()) {\n      throw new Error(\n        'Auth override specified in options, but not supported on non Node.js platforms'\n      );\n    }\n    this.scheduleConnect_(0);\n\n    VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor.getInstance().on('online', this.onOnline_, this);\n    }\n  }\n\n  protected sendRequest(\n    action: string,\n    body: any,\n    onResponse?: (a: any) => void\n  ) {\n    const curReqNum = ++this.requestNumber_;\n\n    const msg = { r: curReqNum, a: action, b: body };\n    this.log_(stringify(msg));\n    assert(\n      this.connected_,\n      \"sendRequest call when we're not connected not allowed.\"\n    );\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const queryId = query.queryIdentifier();\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    if (!this.listens.has(pathString)) {\n      this.listens.set(pathString, new Map());\n    }\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'listen() called for non-default but complete query'\n    );\n    assert(\n      !this.listens.get(pathString)!.has(queryId),\n      'listen() called twice for same path/queryId.'\n    );\n    const listenSpec: ListenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens.get(pathString)!.set(queryId, listenSpec);\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  }\n\n  private sendListen_(listenSpec: ListenSpec) {\n    const query = listenSpec.query;\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n\n    const action = 'q';\n\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req[/*hash*/ 'h'] = listenSpec.hashFn();\n\n    this.sendRequest(action, req, (message: { [k: string]: any }) => {\n      const payload: any = message[/*data*/ 'd'];\n      const status: string = message[/*status*/ 's'];\n\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n\n      const currentListenSpec =\n        this.listens.get(pathString) &&\n        this.listens.get(pathString)!.get(queryId);\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  }\n\n  private static warnOnListenWarnings_(payload: any, query: Query) {\n    if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n      const warnings = safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        const indexSpec =\n          '\".indexOn\": \"' +\n          query\n            .getQueryParams()\n            .getIndex()\n            .toString() +\n          '\"';\n        const indexPath = query.path.toString();\n        warn(\n          `Using an unspecified index. Your data will be downloaded and ` +\n            `filtered on the client. Consider adding ${indexSpec} at ` +\n            `${indexPath} to your security rules for better performance.`\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refreshAuthToken(token: string) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, () => {});\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  }\n\n  private reduceReconnectDelayIfAdminCredential_(credential: string) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    const isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || isAdmin(credential)) {\n      this.log_(\n        'Admin auth credential detected.  Reducing max reconnect time.'\n      );\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  }\n\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  tryAuth() {\n    if (this.connected_ && this.authToken_) {\n      const token = this.authToken_;\n      const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\n      const requestData: { [k: string]: any } = { cred: token };\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, (res: { [k: string]: any }) => {\n        const status: string = res[/*status*/ 's'];\n        const data: string = res[/*data*/ 'd'] || 'error';\n\n        if (this.authToken_ === token) {\n          if (status === 'ok') {\n            this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  unlisten(query: Query, tag: number | null) {\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'unlisten() called for non-default but complete query'\n    );\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  }\n\n  private sendUnlisten_(\n    pathString: string,\n    queryId: string,\n    queryObj: Object,\n    tag: number | null\n  ) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n    const action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectPut(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'o',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectMerge(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'om',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectCancel(\n    pathString: string,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'oc',\n        data: null,\n        onComplete\n      });\n    }\n  }\n\n  private sendOnDisconnect_(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string) => void\n  ) {\n    const request = { /*path*/ p: pathString, /*data*/ d: data };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, (response: { [k: string]: any }) => {\n      if (onComplete) {\n        setTimeout(function() {\n          onComplete(response[/*status*/ 's'], response[/* data */ 'd']);\n        }, Math.floor(0));\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  put(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void,\n    hash?: string\n  ) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  merge(\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  }\n\n  putInternal(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    const request: { [k: string]: any } = {\n      /*path*/ p: pathString,\n      /*data*/ d: data\n    };\n\n    if (hash !== undefined) request[/*hash*/ 'h'] = hash;\n\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action,\n      request,\n      onComplete\n    });\n\n    this.outstandingPutCount_++;\n    const index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  }\n\n  private sendPut_(index: number) {\n    const action = this.outstandingPuts_[index].action;\n    const request = this.outstandingPuts_[index].request;\n    const onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n\n    this.sendRequest(action, request, (message: { [k: string]: any }) => {\n      this.log_(action + ' response', message);\n\n      delete this.outstandingPuts_[index];\n      this.outstandingPutCount_--;\n\n      // Clean up array occasionally.\n      if (this.outstandingPutCount_ === 0) {\n        this.outstandingPuts_ = [];\n      }\n\n      if (onComplete)\n        onComplete(message[/*status*/ 's'], message[/* data */ 'd']);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  reportStats(stats: { [k: string]: any }) {\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      const request = { /*counters*/ c: stats };\n      this.log_('reportStats', request);\n\n      this.sendRequest(/*stats*/ 's', request, result => {\n        const status = result[/*status*/ 's'];\n        if (status !== 'ok') {\n          const errorReason = result[/* data */ 'd'];\n          this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  }\n\n  private onDataMessage_(message: { [k: string]: any }) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + stringify(message));\n      const reqNum = message['r'];\n      const onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message[/*body*/ 'b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  }\n\n  private onDataPush_(action: string, body: { [k: string]: any }) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge*/ false,\n        body['t']\n      );\n    else if (action === 'm')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge=*/ true,\n        body['t']\n      );\n    else if (action === 'c')\n      this.onListenRevoked_(body[/*path*/ 'p'], body[/*query*/ 'q']);\n    else if (action === 'ac')\n      this.onAuthRevoked_(\n        body[/*status code*/ 's'],\n        body[/* explanation */ 'd']\n      );\n    else if (action === 'sd') this.onSecurityDebugPacket_(body);\n    else\n      error(\n        'Unrecognized action received from server: ' +\n          stringify(action) +\n          '\\nAre you using the latest client?'\n      );\n  }\n\n  private onReady_(timestamp: number, sessionId: string) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  }\n\n  private scheduleConnect_(timeout: number) {\n    assert(\n      !this.realtime_,\n      \"Scheduling a connect when we're already connected/ing?\"\n    );\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n    this.establishConnectionTimer_ = setTimeout(() => {\n      this.establishConnectionTimer_ = null;\n      this.establishConnection_();\n    }, Math.floor(timeout)) as any;\n  }\n\n  private onVisible_(visible: boolean) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (\n      visible &&\n      !this.visible_ &&\n      this.reconnectDelay_ === this.maxReconnectDelay_\n    ) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  }\n\n  private onOnline_(online: boolean) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  }\n\n  private onRealtimeDisconnect_() {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        const timeSinceLastConnectSucceeded =\n          new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n          this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      const timeSinceLastConnectAttempt =\n        new Date().getTime() - this.lastConnectionAttemptTime_;\n      let reconnectDelay = Math.max(\n        0,\n        this.reconnectDelay_ - timeSinceLastConnectAttempt\n      );\n      reconnectDelay = Math.random() * reconnectDelay;\n\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(\n        this.maxReconnectDelay_,\n        this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER\n      );\n    }\n    this.onConnectStatus_(false);\n  }\n\n  private establishConnection_() {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      const onDataMessage = this.onDataMessage_.bind(this);\n      const onReady = this.onReady_.bind(this);\n      const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n      const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      const self = this;\n      const lastSessionId = this.lastSessionId;\n      let canceled = false;\n      let connection: Connection | null = null;\n      const closeFn = function() {\n        if (connection) {\n          connection.close();\n        } else {\n          canceled = true;\n          onDisconnect();\n        }\n      };\n      const sendRequestFn = function(msg: Object) {\n        assert(\n          connection,\n          \"sendRequest call when we're not connected not allowed.\"\n        );\n        connection.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn,\n        sendRequest: sendRequestFn\n      };\n\n      const forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_\n        .getToken(forceRefresh)\n        .then(function(result) {\n          if (!canceled) {\n            log('getToken() completed. Creating connection.');\n            self.authToken_ = result && result.accessToken;\n            connection = new Connection(\n              connId,\n              self.repoInfo_,\n              onDataMessage,\n              onReady,\n              onDisconnect,\n              /* onKill= */ function(reason) {\n                warn(reason + ' (' + self.repoInfo_.toString() + ')');\n                self.interrupt(SERVER_KILL_INTERRUPT_REASON);\n              },\n              lastSessionId\n            );\n          } else {\n            log('getToken() completed but was canceled');\n          }\n        })\n        .then(null, function(error) {\n          self.log_('Failed to get token: ' + error);\n          if (!canceled) {\n            if (CONSTANTS.NODE_ADMIN) {\n              // This may be a critical error for the Admin Node.js SDK, so log a warning.\n              // But getToken() may also just have temporarily failed, so we still want to\n              // continue retrying.\n              warn(error);\n            }\n            closeFn();\n          }\n        });\n    }\n  }\n\n  interrupt(reason: string) {\n    log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  }\n\n  resume(reason: string) {\n    log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  }\n\n  private handleTimestamp_(timestamp: number) {\n    const delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({ serverTimeOffset: delta });\n  }\n\n  private cancelSentTransactions_() {\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      const put = this.outstandingPuts_[i];\n      if (put && /*hash*/ 'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  }\n\n  private onListenRevoked_(pathString: string, query?: any[]) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    let queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\n    }\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  }\n\n  private removeListen_(pathString: string, queryId: string): ListenSpec {\n    const normalizedPathString = new Path(pathString).toString(); // normalize path.\n    let listen;\n    if (this.listens.has(normalizedPathString)) {\n      const map = this.listens.get(normalizedPathString)!;\n      listen = map.get(queryId);\n      map.delete(queryId);\n      if (map.size === 0) {\n        this.listens.delete(normalizedPathString);\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  }\n\n  private onAuthRevoked_(statusCode: string, explanation: string) {\n    log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  }\n\n  private onSecurityDebugPacket_(body: { [k: string]: any }) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body) {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  }\n\n  private restoreState_() {\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    for (const queries of this.listens.values()) {\n      for (const listenSpec of queries.values()) {\n        this.sendListen_(listenSpec);\n      }\n    }\n\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      const request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(\n        request.action,\n        request.pathString,\n        request.data,\n        request.onComplete\n      );\n    }\n  }\n\n  /**\n   * Sends client stats for first connection\n   */\n  private sendConnectStats_() {\n    const stats: { [k: string]: number } = {};\n\n    let clientName = 'js';\n    if (CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\\./g, '-')] = 1;\n\n    if (isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  }\n\n  private shouldReconnect_(): boolean {\n    const online = OnlineMonitor.getInstance().currentlyOnline();\n    return isEmpty(this.interruptReasons_) && online;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '@firebase/util';\nimport { safeGet } from '@firebase/util';\nimport { querystring } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport {\n  FirebaseAuthTokenProvider,\n  AuthTokenProvider\n} from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: { [k: string]: any }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(\n        query.getQueryParams().isDefault(),\n        \"should have a tag if it's not a default query.\"\n      );\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private authTokenProvider_: AuthTokenProvider\n  ) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const pathString = query.path.toString();\n    this.log_(\n      'Listen called for ' + pathString + ' ' + query.queryIdentifier()\n    );\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParameters = query\n      .getQueryParams()\n      .toRestQueryStringParameters();\n\n    this.restRequest_(\n      pathString + '.json',\n      queryStringParameters,\n      (error, result) => {\n        let data = result;\n\n        if (error === 404) {\n          data = null;\n          error = null;\n        }\n\n        if (error === null) {\n          this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n        }\n\n        if (safeGet(this.listens_, listenId) === thisListen) {\n          let status;\n          if (!error) {\n            status = 'ok';\n          } else if (error == 401) {\n            status = 'permission_denied';\n          } else {\n            status = 'rest_error:' + error;\n          }\n\n          onComplete(status, null);\n        }\n      }\n    );\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(\n    pathString: string,\n    queryStringParameters: { [k: string]: any } = {},\n    callback: ((a: number | null, b?: any) => void) | null\n  ) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_\n      .getToken(/*forceRefresh=*/ false)\n      .then(authTokenData => {\n        const authToken = authTokenData && authTokenData.accessToken;\n        if (authToken) {\n          queryStringParameters['auth'] = authToken;\n        }\n\n        const url =\n          (this.repoInfo_.secure ? 'https://' : 'http://') +\n          this.repoInfo_.host +\n          pathString +\n          '?' +\n          'ns=' +\n          this.repoInfo_.namespace +\n          querystring(queryStringParameters);\n\n        this.log_('Sending REST request for ' + url);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (callback && xhr.readyState === 4) {\n            this.log_(\n              'REST Response for ' + url + ' received. status:',\n              xhr.status,\n              'response:',\n              xhr.responseText\n            );\n            let res = null;\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                res = jsonEval(xhr.responseText);\n              } catch (e) {\n                warn(\n                  'Failed to parse JSON response for ' +\n                    url +\n                    ': ' +\n                    xhr.responseText\n                );\n              }\n              callback(null, res);\n            } else {\n              // 401 and 404 are expected.\n              if (xhr.status !== 401 && xhr.status !== 404) {\n                warn(\n                  'Got unsuccessful REST response for ' +\n                    url +\n                    ' Status: ' +\n                    xhr.status\n                );\n              }\n              callback(xhr.status);\n            }\n            callback = null;\n          }\n        };\n\n        xhr.open('GET', url, /*asynchronous=*/ true);\n        xhr.send();\n      });\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nexport function querystring(querystringParams: {\n  [key: string]: string;\n}): string {\n  const params = [];\n  for (const [key, value] of Object.entries(querystringParams)) {\n    if (Array.isArray(value)) {\n      value.forEach(arrayVal => {\n        params.push(\n          encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal)\n        );\n      });\n    } else {\n      params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n    }\n  }\n  return params.length ? '&' + params.join('&') : '';\n}\n\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nexport function querystringDecode(querystring: string): object {\n  const obj: { [key: string]: unknown } = {};\n  const tokens = querystring.replace(/^\\?/, '').split('&');\n\n  tokens.forEach(token => {\n    if (token) {\n      const key = token.split('=');\n      obj[key[0]] = key[1];\n    }\n  });\n  return obj;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '@firebase/util';\nimport {\n  beingCrawled,\n  each,\n  exceptionGuard,\n  warn,\n  log,\n  FIREBASE_DATABASE_EMULATOR_HOST_VAR\n} from './util/util';\nimport { map, isEmpty } from '@firebase/util';\nimport {\n  FirebaseAuthTokenProvider,\n  AuthTokenProvider\n} from './AuthTokenProvider';\nimport { EmulatorAuthTokenProvider } from './EmulatorAuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_:\n    | ((a: string, b: any) => void)\n    | null = null;\n  private __database: Database;\n\n  /** A list of data pieces and paths to be set when this client disconnects. */\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  // TODO: This should be @private but it's used by test_access.js and internal.js\n  persistentConnection_: PersistentConnection | null = null;\n\n  constructor(\n    public repoInfo_: RepoInfo,\n    forceRestClient: boolean,\n    public app: FirebaseApp\n  ) {\n    let authTokenProvider: AuthTokenProvider;\n    if (\n      typeof process !== 'undefined' &&\n      process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR]\n    ) {\n      authTokenProvider = new EmulatorAuthTokenProvider(app);\n    } else {\n      authTokenProvider = new FirebaseAuthTokenProvider(app);\n    }\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider\n      );\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error(\n            'Only objects are supported for option databaseAuthVariableOverride'\n          );\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride\n      );\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(token => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(\n      repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_)\n    );\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(\n            query.path,\n            node\n          );\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (\n      (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host\n    );\n  }\n\n  /**\n   * @return The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(\n      new Path('.info/serverTimeOffset')\n    );\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      timestamp: this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   */\n  private onDataUpdate_(\n    pathString: string,\n    data: any,\n    isMerge: boolean,\n    tag: number | null\n  ) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_\n      ? this.interceptServerDataCallback_(pathString, data)\n      : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) =>\n          nodeFromJSON(raw)\n        );\n        events = this.serverSyncTree_.applyTaggedQueryMerge(\n          path,\n          taggedChildren,\n          tag\n        );\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(\n          path,\n          taggedSnap,\n          tag\n        );\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) =>\n        nodeFromJSON(raw)\n      );\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  // TODO: This should be @private but it's used by test_access.js and internal.js\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (key: string, value: any) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  setWithPriority(\n    path: Path,\n    newVal: any,\n    newPriority: number | string | null,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      writeId,\n      true\n    );\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(\n      path.toString(),\n      newNodeUnresolved.val(/*export=*/ true),\n      (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('set at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(\n          writeId,\n          !success\n        );\n        this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  update(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('update', { path: path.toString(), value: childrenToMerge });\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    each(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(\n        newNodeUnresolved,\n        serverValues\n      );\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(\n        path,\n        changedChildren,\n        writeId\n      );\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(\n        path.toString(),\n        childrenToMerge,\n        (status, errorReason) => {\n          const success = status === 'ok';\n          if (!success) {\n            warn('update at ' + path + ' failed: ' + status);\n          }\n\n          const clearEvents = this.serverSyncTree_.ackUserWrite(\n            writeId,\n            !success\n          );\n          const affectedPath =\n            clearEvents.length > 0 ? this.rerunTransactions_(path) : path;\n          this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n          this.callOnCompleteCallback(onComplete, status, errorReason);\n        }\n      );\n\n      each(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(\n      this.onDisconnect_,\n      serverValues\n    );\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(\n        this.serverSyncTree_.applyServerOverwrite(path, snap)\n      );\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  onDisconnectCancel(\n    path: Path,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  onDisconnectSet(\n    path: Path,\n    value: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  onDisconnectSetWithPriority(\n    path: Path,\n    value: any,\n    priority: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  onDisconnectUpdate(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    if (isEmpty(childrenToMerge)) {\n      log(\n        \"onDisconnect().update() called with empty data.  Don't do anything.\"\n      );\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(\n      path.toString(),\n      childrenToMerge,\n      (status, errorReason) => {\n        if (status === 'ok') {\n          each(childrenToMerge, (childName: string, childNode: any) => {\n            const newChildNode = nodeFromJSON(childNode);\n            this.onDisconnect_.remember(path.child(childName), newChildNode);\n          });\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  removeEventCallbackForQuery(\n    query: Query,\n    eventRegistration: EventRegistration\n  ) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined') return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) =>\n        Math.max(currentValue.length, previousValue),\n      0\n    );\n\n    each(stats, (stat: string, value: any) => {\n      let paddedStat = stat;\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++) {\n        paddedStat += ' ';\n      }\n      console.log(paddedStat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  callOnCompleteCallback(\n    callback: ((status: Error | null, errorReason?: string) => void) | null,\n    status: string,\n    errorReason?: string | null\n  ) {\n    if (callback) {\n      exceptionGuard(function() {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason) message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexedFilter } from './IndexedFilter';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NamedNode, Node } from '../../../core/snap/Node';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { NodeFilter } from './NodeFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class RangedFilter implements NodeFilter {\n  /**\n   * @type {!IndexedFilter}\n   * @const\n   * @private\n   */\n  private indexedFilter_: IndexedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private index_: Index;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private startPost_: NamedNode;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private endPost_: NamedNode;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.indexedFilter_ = new IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getStartPost(): NamedNode {\n    return this.startPost_;\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getEndPost(): NamedNode {\n    return this.endPost_;\n  }\n\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n  matches(node: NamedNode): boolean {\n    return (\n      this.index_.compare(this.getStartPost(), node) <= 0 &&\n      this.index_.compare(node, this.getEndPost()) <= 0\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    return this.indexedFilter_.updateChild(\n      snap,\n      key,\n      newChild,\n      affectedPath,\n      source,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode.EMPTY_NODE;\n    }\n    let filtered = newSnap.withIndex(this.index_);\n    // Don't support priorities on queries\n    filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n    const self = this;\n    newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n      if (!self.matches(new NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(\n      oldSnap,\n      filtered,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.indexedFilter_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getStartPost_(params: QueryParams): NamedNode {\n    if (params.hasStart()) {\n      const startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getEndPost_(params: QueryParams): NamedNode {\n    if (params.hasEnd()) {\n      const endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { Node, NamedNode } from '../../snap/Node';\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { IndexedFilter } from './IndexedFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class LimitedFilter implements NodeFilter {\n  /**\n   * @const\n   * @type {RangedFilter}\n   * @private\n   */\n  private readonly rangedFilter_: RangedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private readonly index_: Index;\n\n  /**\n   * @const\n   * @type {number}\n   * @private\n   */\n  private readonly limit_: number;\n\n  /**\n   * @const\n   * @type {boolean}\n   * @private\n   */\n  private readonly reverse_: boolean;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.rangedFilter_ = new RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_\n        .getIndexedFilter()\n        .updateChild(\n          snap,\n          key,\n          newChild,\n          affectedPath,\n          source,\n          optChangeAccumulator\n        );\n    } else {\n      return this.fullLimitUpdateChild_(\n        snap,\n        key,\n        newChild,\n        source,\n        optChangeAccumulator\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    let filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (\n        this.limit_ * 2 < newSnap.numChildren() &&\n        newSnap.isIndexed(this.index_)\n      ) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        let iterator;\n        if (this.reverse_) {\n          iterator = (newSnap as ChildrenNode).getReverseIteratorFrom(\n            this.rangedFilter_.getEndPost(),\n            this.index_\n          );\n        } else {\n          iterator = (newSnap as ChildrenNode).getIteratorFrom(\n            this.rangedFilter_.getStartPost(),\n            this.index_\n          );\n        }\n        let count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          const next = iterator.getNext();\n          let inRange;\n          if (this.reverse_) {\n            inRange =\n              this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange =\n              this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(\n          ChildrenNode.EMPTY_NODE\n        ) as ChildrenNode;\n        let startPost;\n        let endPost;\n        let cmp;\n        let iterator;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          const indexCompare = this.index_.getCompare();\n          cmp = (a: NamedNode, b: NamedNode) => indexCompare(b, a);\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        let count = 0;\n        let foundStartPost = false;\n        while (iterator.hasNext()) {\n          let next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          let inRange =\n            foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(\n              next.name,\n              ChildrenNode.EMPTY_NODE\n            );\n          }\n        }\n      }\n    }\n    return this.rangedFilter_\n      .getIndexedFilter()\n      .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.rangedFilter_.getIndexedFilter();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  private fullLimitUpdateChild_(\n    snap: Node,\n    childKey: string,\n    childSnap: Node,\n    source: CompleteChildSource,\n    changeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    // TODO: rename all cache stuff etc to general snap terminology\n    let cmp;\n    if (this.reverse_) {\n      const indexCmp = this.index_.getCompare();\n      cmp = (a: NamedNode, b: NamedNode) => indexCmp(b, a);\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    const oldEventCache = snap as ChildrenNode;\n    assert(oldEventCache.numChildren() == this.limit_, '');\n    const newChildNamedNode = new NamedNode(childKey, childSnap);\n    const windowBoundary = this.reverse_\n      ? oldEventCache.getFirstChild(this.index_)\n      : (oldEventCache.getLastChild(this.index_) as NamedNode);\n    const inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      let nextChild = source.getChildAfterChild(\n        this.index_,\n        windowBoundary,\n        this.reverse_\n      );\n      while (\n        nextChild != null &&\n        (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))\n      ) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(\n          this.index_,\n          nextChild,\n          this.reverse_\n        );\n      }\n      const compareNext =\n        nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      const remainsInWindow =\n        inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childChangedChange(childKey, childSnap, oldChildSnap)\n          );\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(childKey, oldChildSnap)\n          );\n        }\n        const newEventCache = oldEventCache.updateImmediateChild(\n          childKey,\n          ChildrenNode.EMPTY_NODE\n        );\n        const nextChildInRange =\n          nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(\n              Change.childAddedChange(nextChild.name, nextChild.node)\n            );\n          }\n          return newEventCache.updateImmediateChild(\n            nextChild.name,\n            nextChild.node\n          );\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(windowBoundary.name, windowBoundary.node)\n          );\n          changeAccumulator.trackChildChange(\n            Change.childAddedChange(childKey, childSnap)\n          );\n        }\n        return oldEventCache\n          .updateImmediateChild(childKey, childSnap)\n          .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { MIN_NAME, MAX_NAME } from '../util/util';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../snap/indexes/ValueIndex';\nimport { PathIndex } from '../snap/indexes/PathIndex';\nimport { IndexedFilter } from './filter/IndexedFilter';\nimport { LimitedFilter } from './filter/LimitedFilter';\nimport { RangedFilter } from './filter/RangedFilter';\nimport { stringify } from '@firebase/util';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { Index } from '../snap/indexes/Index';\n\n/**\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\n * user-facing API level, so it is not done here.\n * @constructor\n */\nexport class QueryParams {\n  private limitSet_ = false;\n  private startSet_ = false;\n  private startNameSet_ = false;\n  private endSet_ = false;\n  private endNameSet_ = false;\n\n  private limit_ = 0;\n  private viewFrom_ = '';\n  private indexStartValue_: any | null = null;\n  private indexStartName_ = '';\n  private indexEndValue_: any | null = null;\n  private indexEndName_ = '';\n\n  private index_ = PRIORITY_INDEX;\n\n  /**\n   * Wire Protocol Constants\n   * @const\n   * @enum {string}\n   * @private\n   */\n  private static readonly WIRE_PROTOCOL_CONSTANTS_ = {\n    INDEX_START_VALUE: 'sp',\n    INDEX_START_NAME: 'sn',\n    INDEX_END_VALUE: 'ep',\n    INDEX_END_NAME: 'en',\n    LIMIT: 'l',\n    VIEW_FROM: 'vf',\n    VIEW_FROM_LEFT: 'l',\n    VIEW_FROM_RIGHT: 'r',\n    INDEX: 'i'\n  };\n\n  /**\n   * REST Query Constants\n   * @const\n   * @enum {string}\n   * @private\n   */\n  private static readonly REST_QUERY_CONSTANTS_ = {\n    ORDER_BY: 'orderBy',\n    PRIORITY_INDEX: '$priority',\n    VALUE_INDEX: '$value',\n    KEY_INDEX: '$key',\n    START_AT: 'startAt',\n    END_AT: 'endAt',\n    LIMIT_TO_FIRST: 'limitToFirst',\n    LIMIT_TO_LAST: 'limitToLast'\n  };\n\n  /**\n   * Default, empty query parameters\n   * @type {!QueryParams}\n   * @const\n   */\n  static readonly DEFAULT = new QueryParams();\n\n  /**\n   * @return {boolean}\n   */\n  hasStart(): boolean {\n    return this.startSet_;\n  }\n\n  /**\n   * @return {boolean} True if it would return from left.\n   */\n  isViewFromLeft(): boolean {\n    if (this.viewFrom_ === '') {\n      // limit(), rather than limitToFirst or limitToLast was called.\n      // This means that only one of startSet_ and endSet_ is true. Use them\n      // to calculate which side of the view to anchor to. If neither is set,\n      // anchor to the end.\n      return this.startSet_;\n    } else {\n      return (\n        this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT\n      );\n    }\n  }\n\n  /**\n   * Only valid to call if hasStart() returns true\n   * @return {*}\n   */\n  getIndexStartValue(): any {\n    assert(this.startSet_, 'Only valid if start has been set');\n    return this.indexStartValue_;\n  }\n\n  /**\n   * Only valid to call if hasStart() returns true.\n   * Returns the starting key name for the range defined by these query parameters\n   * @return {!string}\n   */\n  getIndexStartName(): string {\n    assert(this.startSet_, 'Only valid if start has been set');\n    if (this.startNameSet_) {\n      return this.indexStartName_;\n    } else {\n      return MIN_NAME;\n    }\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasEnd(): boolean {\n    return this.endSet_;\n  }\n\n  /**\n   * Only valid to call if hasEnd() returns true.\n   * @return {*}\n   */\n  getIndexEndValue(): any {\n    assert(this.endSet_, 'Only valid if end has been set');\n    return this.indexEndValue_;\n  }\n\n  /**\n   * Only valid to call if hasEnd() returns true.\n   * Returns the end key name for the range defined by these query parameters\n   * @return {!string}\n   */\n  getIndexEndName(): string {\n    assert(this.endSet_, 'Only valid if end has been set');\n    if (this.endNameSet_) {\n      return this.indexEndName_;\n    } else {\n      return MAX_NAME;\n    }\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasLimit(): boolean {\n    return this.limitSet_;\n  }\n\n  /**\n   * @return {boolean} True if a limit has been set and it has been explicitly anchored\n   */\n  hasAnchoredLimit(): boolean {\n    return this.limitSet_ && this.viewFrom_ !== '';\n  }\n\n  /**\n   * Only valid to call if hasLimit() returns true\n   * @return {!number}\n   */\n  getLimit(): number {\n    assert(this.limitSet_, 'Only valid if limit has been set');\n    return this.limit_;\n  }\n\n  /**\n   * @return {!Index}\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @return {!QueryParams}\n   * @private\n   */\n  private copy_(): QueryParams {\n    const copy = new QueryParams();\n    copy.limitSet_ = this.limitSet_;\n    copy.limit_ = this.limit_;\n    copy.startSet_ = this.startSet_;\n    copy.indexStartValue_ = this.indexStartValue_;\n    copy.startNameSet_ = this.startNameSet_;\n    copy.indexStartName_ = this.indexStartName_;\n    copy.endSet_ = this.endSet_;\n    copy.indexEndValue_ = this.indexEndValue_;\n    copy.endNameSet_ = this.endNameSet_;\n    copy.indexEndName_ = this.indexEndName_;\n    copy.index_ = this.index_;\n    copy.viewFrom_ = this.viewFrom_;\n    return copy;\n  }\n\n  /**\n   * @param {!number} newLimit\n   * @return {!QueryParams}\n   */\n  limit(newLimit: number): QueryParams {\n    const newParams = this.copy_();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = '';\n    return newParams;\n  }\n\n  /**\n   * @param {!number} newLimit\n   * @return {!QueryParams}\n   */\n  limitToFirst(newLimit: number): QueryParams {\n    const newParams = this.copy_();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;\n    return newParams;\n  }\n\n  /**\n   * @param {!number} newLimit\n   * @return {!QueryParams}\n   */\n  limitToLast(newLimit: number): QueryParams {\n    const newParams = this.copy_();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;\n    return newParams;\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {?string=} key\n   * @return {!QueryParams}\n   */\n  startAt(indexValue: any, key?: string | null): QueryParams {\n    const newParams = this.copy_();\n    newParams.startSet_ = true;\n    if (indexValue === undefined) {\n      indexValue = null;\n    }\n    newParams.indexStartValue_ = indexValue;\n    if (key != null) {\n      newParams.startNameSet_ = true;\n      newParams.indexStartName_ = key;\n    } else {\n      newParams.startNameSet_ = false;\n      newParams.indexStartName_ = '';\n    }\n    return newParams;\n  }\n\n  /**\n   * @param {*} indexValue\n   * @param {?string=} key\n   * @return {!QueryParams}\n   */\n  endAt(indexValue: any, key?: string | null): QueryParams {\n    const newParams = this.copy_();\n    newParams.endSet_ = true;\n    if (indexValue === undefined) {\n      indexValue = null;\n    }\n    newParams.indexEndValue_ = indexValue;\n    if (key !== undefined) {\n      newParams.endNameSet_ = true;\n      newParams.indexEndName_ = key;\n    } else {\n      newParams.endNameSet_ = false;\n      newParams.indexEndName_ = '';\n    }\n    return newParams;\n  }\n\n  /**\n   * @param {!Index} index\n   * @return {!QueryParams}\n   */\n  orderBy(index: Index): QueryParams {\n    const newParams = this.copy_();\n    newParams.index_ = index;\n    return newParams;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  getQueryObject(): Object {\n    const WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;\n    const obj: { [k: string]: any } = {};\n    if (this.startSet_) {\n      obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;\n      if (this.startNameSet_) {\n        obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_;\n      }\n    }\n    if (this.endSet_) {\n      obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;\n      if (this.endNameSet_) {\n        obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_;\n      }\n    }\n    if (this.limitSet_) {\n      obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;\n      let viewFrom = this.viewFrom_;\n      if (viewFrom === '') {\n        if (this.isViewFromLeft()) {\n          viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;\n        } else {\n          viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;\n        }\n      }\n      obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;\n    }\n    // For now, priority index is the default, so we only specify if it's some other index\n    if (this.index_ !== PRIORITY_INDEX) {\n      obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString();\n    }\n    return obj;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  loadsAllData(): boolean {\n    return !(this.startSet_ || this.endSet_ || this.limitSet_);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isDefault(): boolean {\n    return this.loadsAllData() && this.index_ == PRIORITY_INDEX;\n  }\n\n  /**\n   * @return {!NodeFilter}\n   */\n  getNodeFilter(): NodeFilter {\n    if (this.loadsAllData()) {\n      return new IndexedFilter(this.getIndex());\n    } else if (this.hasLimit()) {\n      return new LimitedFilter(this);\n    } else {\n      return new RangedFilter(this);\n    }\n  }\n\n  /**\n   * Returns a set of REST query string parameters representing this query.\n   *\n   * @return {!Object.<string,*>} query string parameters\n   */\n  toRestQueryStringParameters(): { [k: string]: any } {\n    const REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;\n    const qs: { [k: string]: string | number } = {};\n\n    if (this.isDefault()) {\n      return qs;\n    }\n\n    let orderBy;\n    if (this.index_ === PRIORITY_INDEX) {\n      orderBy = REST_CONSTANTS.PRIORITY_INDEX;\n    } else if (this.index_ === VALUE_INDEX) {\n      orderBy = REST_CONSTANTS.VALUE_INDEX;\n    } else if (this.index_ === KEY_INDEX) {\n      orderBy = REST_CONSTANTS.KEY_INDEX;\n    } else {\n      assert(this.index_ instanceof PathIndex, 'Unrecognized index type!');\n      orderBy = this.index_.toString();\n    }\n    qs[REST_CONSTANTS.ORDER_BY] = stringify(orderBy);\n\n    if (this.startSet_) {\n      qs[REST_CONSTANTS.START_AT] = stringify(this.indexStartValue_);\n      if (this.startNameSet_) {\n        qs[REST_CONSTANTS.START_AT] += ',' + stringify(this.indexStartName_);\n      }\n    }\n\n    if (this.endSet_) {\n      qs[REST_CONSTANTS.END_AT] = stringify(this.indexEndValue_);\n      if (this.endNameSet_) {\n        qs[REST_CONSTANTS.END_AT] += ',' + stringify(this.indexEndName_);\n      }\n    }\n\n    if (this.limitSet_) {\n      if (this.isViewFromLeft()) {\n        qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_;\n      } else {\n        qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_;\n      }\n    }\n\n    return qs;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnDisconnect } from './onDisconnect';\nimport { TransactionResult } from './TransactionResult';\nimport { warn } from '../core/util/util';\nimport { nextPushId } from '../core/util/NextPushId';\nimport { Query } from './Query';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\nimport { QueryParams } from '../core/view/QueryParams';\nimport {\n  validateRootPathString,\n  validatePathString,\n  validateFirebaseMergeDataArg,\n  validateBoolean,\n  validatePriority,\n  validateFirebaseDataArg,\n  validateWritablePath\n} from '../core/util/validation';\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { Deferred } from '@firebase/util';\nimport { SyncPoint } from '../core/SyncPoint';\nimport { Database } from './Database';\nimport { DataSnapshot } from './DataSnapshot';\n\nexport interface ReferenceConstructor {\n  new (repo: Repo, path: Path): Reference;\n}\n\nexport class Reference extends Query {\n  public then: (a?: any) => Promise<any>;\n  public catch: (a?: Error) => Promise<any>;\n\n  /**\n   * Call options:\n   *   new Reference(Repo, Path) or\n   *   new Reference(url: string, string|RepoManager)\n   *\n   * Externally - this is the firebase.database.Reference type.\n   *\n   * @param {!Repo} repo\n   * @param {(!Path)} path\n   * @extends {Query}\n   */\n  constructor(repo: Repo, path: Path) {\n    if (!(repo instanceof Repo)) {\n      throw new Error(\n        'new Reference() no longer supported - use app.database().'\n      );\n    }\n\n    // call Query's constructor, passing in the repo and path.\n    super(repo, path, QueryParams.DEFAULT, false);\n  }\n\n  /** @return {?string} */\n  getKey(): string | null {\n    validateArgCount('Reference.key', 0, 0, arguments.length);\n\n    if (this.path.isEmpty()) return null;\n    else return this.path.getBack();\n  }\n\n  /**\n   * @param {!(string|Path)} pathString\n   * @return {!Reference}\n   */\n  child(pathString: string | Path): Reference {\n    validateArgCount('Reference.child', 1, 1, arguments.length);\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path)) {\n      if (this.path.getFront() === null)\n        validateRootPathString('Reference.child', 1, pathString, false);\n      else validatePathString('Reference.child', 1, pathString, false);\n    }\n\n    return new Reference(this.repo, this.path.child(pathString));\n  }\n\n  /** @return {?Reference} */\n  getParent(): Reference | null {\n    validateArgCount('Reference.parent', 0, 0, arguments.length);\n\n    const parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  }\n\n  /** @return {!Reference} */\n  getRoot(): Reference {\n    validateArgCount('Reference.root', 0, 0, arguments.length);\n\n    let ref = this as any;\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n    return ref;\n  }\n\n  /** @return {!Database} */\n  databaseProp(): Database {\n    return this.repo.database;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  set(newVal: any, onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.set', 1, 2, arguments.length);\n    validateWritablePath('Reference.set', this.path);\n    validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    validateCallback('Reference.set', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      /*priority=*/ null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  update(\n    objectToMerge: Object,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.update', 1, 2, arguments.length);\n    validateWritablePath('Reference.update', this.path);\n\n    if (Array.isArray(objectToMerge)) {\n      const newObjectToMerge: { [k: string]: any } = {};\n      for (let i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      warn(\n        'Passing an Array to Firebase.update() is deprecated. ' +\n          'Use set() if you want to overwrite the existing data, or ' +\n          'an Object with integer keys if you really do want to ' +\n          'only update some of the children.'\n      );\n    }\n    validateFirebaseMergeDataArg(\n      'Reference.update',\n      1,\n      objectToMerge,\n      this.path,\n      false\n    );\n    validateCallback('Reference.update', 2, onComplete, true);\n    const deferred = new Deferred();\n    this.repo.update(\n      this.path,\n      objectToMerge,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {string|number|null} newPriority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setWithPriority(\n    newVal: any,\n    newPriority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validateWritablePath('Reference.setWithPriority', this.path);\n    validateFirebaseDataArg(\n      'Reference.setWithPriority',\n      1,\n      newVal,\n      this.path,\n      false\n    );\n    validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    validateCallback('Reference.setWithPriority', 3, onComplete, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.setWithPriority failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      newPriority,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  remove(onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validateWritablePath('Reference.remove', this.path);\n    validateCallback('Reference.remove', 1, onComplete, true);\n\n    return this.set(null, onComplete);\n  }\n\n  /**\n   * @param {function(*):*} transactionUpdate\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n   * @param {boolean=} applyLocally\n   * @return {!Promise}\n   */\n  transaction(\n    transactionUpdate: (a: any) => any,\n    onComplete?: (a: Error | null, b: boolean, c: DataSnapshot | null) => void,\n    applyLocally?: boolean\n  ): Promise<TransactionResult> {\n    validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validateWritablePath('Reference.transaction', this.path);\n    validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    validateCallback('Reference.transaction', 2, onComplete, true);\n    // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n    validateBoolean('Reference.transaction', 3, applyLocally, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.transaction failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    if (applyLocally === undefined) applyLocally = true;\n\n    const deferred = new Deferred<TransactionResult>();\n    if (typeof onComplete === 'function') {\n      deferred.promise.catch(() => {});\n    }\n\n    const promiseComplete = function(\n      error: Error,\n      committed: boolean,\n      snapshot: DataSnapshot\n    ) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult(committed, snapshot));\n      }\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n    this.repo.startTransaction(\n      this.path,\n      transactionUpdate,\n      promiseComplete,\n      applyLocally\n    );\n\n    return deferred.promise;\n  }\n\n  /**\n   * @param {string|number|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setPriority(\n    priority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validateWritablePath('Reference.setPriority', this.path);\n    validatePriority('Reference.setPriority', 1, priority, false);\n    validateCallback('Reference.setPriority', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path.child('.priority'),\n      priority,\n      null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*=} value\n   * @param {function(?Error)=} onComplete\n   * @return {!Reference}\n   */\n  push(value?: any, onComplete?: (a: Error | null) => void): Reference {\n    validateArgCount('Reference.push', 0, 2, arguments.length);\n    validateWritablePath('Reference.push', this.path);\n    validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    validateCallback('Reference.push', 2, onComplete, true);\n\n    const now = this.repo.serverTime();\n    const name = nextPushId(now);\n\n    // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n    const thennablePushRef = this.child(name);\n    const pushRef = this.child(name);\n\n    let promise;\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(() => pushRef);\n    } else {\n      promise = Promise.resolve(pushRef);\n    }\n\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n\n    if (typeof onComplete === 'function') {\n      promise.catch(() => {});\n    }\n\n    return thennablePushRef;\n  }\n\n  /**\n   * @return {!OnDisconnect}\n   */\n  onDisconnect(): OnDisconnect {\n    validateWritablePath('Reference.onDisconnect', this.path);\n    return new OnDisconnect(this.repo, this.path);\n  }\n\n  get database(): Database {\n    return this.databaseProp();\n  }\n\n  get key(): string | null {\n    return this.getKey();\n  }\n\n  get parent(): Reference | null {\n    return this.getParent();\n  }\n\n  get root(): Reference {\n    return this.getRoot();\n  }\n}\n\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery.__referenceConstructor = Reference;\nSyncPoint.__referenceConstructor = Reference;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { contains, safeGet } from '@firebase/util';\nimport { each } from './util';\n\n/**\n * Node in a Tree.\n */\nexport class TreeNode<T> {\n  // TODO: Consider making accessors that create children and value lazily or\n  // separate Internal / Leaf 'types'.\n  children: { [name: string]: TreeNode<T> } = {};\n  childCount = 0;\n  value: T | null = null;\n}\n\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nexport class Tree<T> {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  constructor(\n    private name_: string = '',\n    private parent_: Tree<T> | null = null,\n    private node_: TreeNode<T> = new TreeNode<T>()\n  ) {}\n\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  subTree(pathObj: string | Path): Tree<T> {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = this as Tree<T>,\n      next;\n    while ((next = path.getFront()) !== null) {\n      const childNode = safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  }\n\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  getValue(): T | null {\n    return this.node_.value;\n  }\n\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  setValue(value: T) {\n    assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  }\n\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  clear() {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  }\n\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  hasChildren(): boolean {\n    return this.node_.childCount > 0;\n  }\n\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  isEmpty(): boolean {\n    return this.getValue() === null && !this.hasChildren();\n  }\n\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachChild(action: (tree: Tree<T>) => void) {\n    each(this.node_.children, (child: string, childTree: TreeNode<T>) => {\n      action(new Tree<T>(child, this, childTree));\n    });\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  forEachDescendant(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean,\n    childrenFirst?: boolean\n  ) {\n    if (includeSelf && !childrenFirst) action(this);\n\n    this.forEachChild(function(child) {\n      child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n    });\n\n    if (includeSelf && childrenFirst) action(this);\n  }\n\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  forEachAncestor(\n    action: (tree: Tree<T>) => unknown,\n    includeSelf?: boolean\n  ): boolean {\n    let node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachImmediateDescendantWithValue(action: (tree: Tree<T>) => void) {\n    this.forEachChild(function(child) {\n      if (child.getValue() !== null) action(child);\n      else child.forEachImmediateDescendantWithValue(action);\n    });\n  }\n\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  path(): Path {\n    return new Path(\n      this.parent_ === null\n        ? this.name_\n        : this.parent_.path() + '/' + this.name_\n    );\n  }\n\n  /**\n   * @return {string} The name of the tree node.\n   */\n  name(): string {\n    return this.name_;\n  }\n\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  parent(): Tree<T> | null {\n    return this.parent_;\n  }\n\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  private updateParents_() {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  }\n\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  private updateChild_(childName: string, child: Tree<T>) {\n    const childEmpty = child.isEmpty();\n    const childExists = contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '@firebase/util';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { safeGet } from '@firebase/util';\nimport { Repo } from './Repo';\nimport { fatal, FIREBASE_DATABASE_EMULATOR_HOST_VAR } from './util/util';\nimport { parseRepoInfo, parseDatabaseURL } from './util/libs/parser';\nimport { validateUrl } from './util/validation';\nimport './Repo_transaction';\nimport { Database } from '../api/Database';\nimport { RepoInfo } from './RepoInfo';\n\n/** @const {string} */\nconst DATABASE_URL_OPTION = 'databaseURL';\n\nlet _staticInstance: RepoManager;\n\n/**\n * Creates and caches Repo instances.\n */\nexport class RepoManager {\n  /**\n   * @private {!Object.<string, Object<string, !fb.core.Repo>>}\n   */\n  private repos_: {\n    [appName: string]: {\n      [dbUrl: string]: Repo;\n    };\n  } = {};\n\n  /**\n   * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).\n   * @private {boolean}\n   */\n  private useRestClient_: boolean = false;\n\n  static getInstance(): RepoManager {\n    if (!_staticInstance) {\n      _staticInstance = new RepoManager();\n    }\n    return _staticInstance;\n  }\n\n  // TODO(koss): Remove these functions unless used in tests?\n  interrupt() {\n    for (const appName in this.repos_) {\n      for (const dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].interrupt();\n      }\n    }\n  }\n\n  resume() {\n    for (const appName in this.repos_) {\n      for (const dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].resume();\n      }\n    }\n  }\n\n  /**\n   * This function should only ever be called to CREATE a new database instance.\n   *\n   * @param {!FirebaseApp} app\n   * @return {!Database}\n   */\n  databaseFromApp(app: FirebaseApp, url?: string): Database {\n    let dbUrl: string | undefined = url || app.options[DATABASE_URL_OPTION];\n    if (dbUrl === undefined) {\n      fatal(\n        \"Can't determine Firebase Database URL.  Be sure to include \" +\n          DATABASE_URL_OPTION +\n          ' option when calling firebase.initializeApp().'\n      );\n    }\n\n    let parsedUrl = parseRepoInfo(dbUrl);\n    let repoInfo = parsedUrl.repoInfo;\n\n    let dbEmulatorHost: string | undefined = undefined;\n    if (typeof process !== 'undefined') {\n      dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\n    }\n    if (dbEmulatorHost) {\n      dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\n      parsedUrl = parseRepoInfo(dbUrl);\n      repoInfo = parsedUrl.repoInfo;\n    }\n\n    validateUrl('Invalid Firebase Database URL', 1, parsedUrl);\n    if (!parsedUrl.path.isEmpty()) {\n      fatal(\n        'Database URL must point to the root of a Firebase Database ' +\n          '(not including a child path).'\n      );\n    }\n\n    const repo = this.createRepo(repoInfo, app);\n\n    return repo.database;\n  }\n\n  /**\n   * Remove the repo and make sure it is disconnected.\n   *\n   * @param {!Repo} repo\n   */\n  deleteRepo(repo: Repo) {\n    const appRepos = safeGet(this.repos_, repo.app.name);\n    // This should never happen...\n    if (!appRepos || safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {\n      fatal(\n        `Database ${repo.app.name}(${repo.repoInfo_}) has already been deleted.`\n      );\n    }\n    repo.interrupt();\n    delete appRepos[repo.repoInfo_.toURLString()];\n  }\n\n  /**\n   * Ensures a repo doesn't already exist and then creates one using the\n   * provided app.\n   *\n   * @param {!RepoInfo} repoInfo The metadata about the Repo\n   * @param {!FirebaseApp} app\n   * @return {!Repo} The Repo object for the specified server / repoName.\n   */\n  createRepo(repoInfo: RepoInfo, app: FirebaseApp): Repo {\n    let appRepos = safeGet(this.repos_, app.name);\n\n    if (!appRepos) {\n      appRepos = {};\n      this.repos_[app.name] = appRepos;\n    }\n\n    let repo = safeGet(appRepos, repoInfo.toURLString());\n    if (repo) {\n      fatal(\n        'Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.'\n      );\n    }\n    repo = new Repo(repoInfo, this.useRestClient_, app);\n    appRepos[repoInfo.toURLString()] = repo;\n\n    return repo;\n  }\n\n  /**\n   * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\n   * @param {boolean} forceRestClient\n   */\n  forceRestClient(forceRestClient: boolean) {\n    this.useRestClient_ = forceRestClient;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fatal } from '../core/util/util';\nimport { parseRepoInfo } from '../core/util/libs/parser';\nimport { Path } from '../core/util/Path';\nimport { Reference } from './Reference';\nimport { Repo } from '../core/Repo';\nimport { RepoManager } from '../core/RepoManager';\nimport { validateArgCount } from '@firebase/util';\nimport { validateUrl } from '../core/util/validation';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { FirebaseService } from '@firebase/app-types/private';\nimport { RepoInfo } from '../core/RepoInfo';\n\n/**\n * Class representing a firebase database.\n * @implements {FirebaseService}\n */\nexport class Database implements FirebaseService {\n  INTERNAL: DatabaseInternals;\n  private root_: Reference;\n\n  static readonly ServerValue = {\n    TIMESTAMP: {\n      '.sv': 'timestamp'\n    }\n  };\n\n  /**\n   * The constructor should not be called by users of our public API.\n   * @param {!Repo} repo_\n   */\n  constructor(private repo_: Repo) {\n    if (!(repo_ instanceof Repo)) {\n      fatal(\n        \"Don't call new Database() directly - please use firebase.database().\"\n      );\n    }\n\n    /** @type {Reference} */\n    this.root_ = new Reference(repo_, Path.Empty);\n\n    this.INTERNAL = new DatabaseInternals(this);\n  }\n\n  get app(): FirebaseApp {\n    return this.repo_.app;\n  }\n\n  /**\n   * Returns a reference to the root or to the path specified in the provided\n   * argument.\n\n   * @param {string|Reference=} path The relative string path or an existing\n   * Reference to a database location.\n   * @throws If a Reference is provided, throws if it does not belong to the\n   * same project.\n   * @return {!Reference} Firebase reference.\n   **/\n  ref(path?: string): Reference;\n  ref(path?: Reference): Reference;\n  ref(path?: string | Reference): Reference {\n    this.checkDeleted_('ref');\n    validateArgCount('database.ref', 0, 1, arguments.length);\n\n    if (path instanceof Reference) {\n      return this.refFromURL(path.toString());\n    }\n\n    return path !== undefined ? this.root_.child(path) : this.root_;\n  }\n\n  /**\n   * Returns a reference to the root or the path specified in url.\n   * We throw a exception if the url is not in the same domain as the\n   * current repo.\n   * @param {string} url\n   * @return {!Reference} Firebase reference.\n   */\n  refFromURL(url: string): Reference {\n    /** @const {string} */\n    const apiName = 'database.refFromURL';\n    this.checkDeleted_(apiName);\n    validateArgCount(apiName, 1, 1, arguments.length);\n    const parsedURL = parseRepoInfo(url);\n    validateUrl(apiName, 1, parsedURL);\n\n    const repoInfo = parsedURL.repoInfo;\n    if (repoInfo.host !== ((this.repo_ as any).repoInfo_ as RepoInfo).host) {\n      fatal(\n        apiName +\n          ': Host name does not match the current database: ' +\n          '(found ' +\n          repoInfo.host +\n          ' but expected ' +\n          ((this.repo_ as any).repoInfo_ as RepoInfo).host +\n          ')'\n      );\n    }\n\n    return this.ref(parsedURL.path.toString());\n  }\n\n  /**\n   * @param {string} apiName\n   */\n  private checkDeleted_(apiName: string) {\n    if (this.repo_ === null) {\n      fatal('Cannot call ' + apiName + ' on a deleted database.');\n    }\n  }\n\n  // Make individual repo go offline.\n  goOffline() {\n    validateArgCount('database.goOffline', 0, 0, arguments.length);\n    this.checkDeleted_('goOffline');\n    this.repo_.interrupt();\n  }\n\n  goOnline() {\n    validateArgCount('database.goOnline', 0, 0, arguments.length);\n    this.checkDeleted_('goOnline');\n    this.repo_.resume();\n  }\n}\n\nexport class DatabaseInternals {\n  /** @param {!Database} database */\n  constructor(public database: Database) {}\n\n  /** @return {Promise<void>} */\n  async delete(): Promise<void> {\n    (this.database as any).checkDeleted_('delete');\n    RepoManager.getInstance().deleteRepo((this.database as any).repo_ as Repo);\n\n    (this.database as any).repo_ = null;\n    (this.database as any).root_ = null;\n    this.database.INTERNAL = null;\n    this.database = null;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WebSocketConnection } from '../realtime/WebSocketConnection';\nimport { BrowserPollConnection } from '../realtime/BrowserPollConnection';\nimport { Reference } from './Reference';\n\n/**\n * INTERNAL methods for internal-use only (tests, etc.).\n *\n * Customers shouldn't use these or else should be aware that they could break at any time.\n *\n * @const\n */\n\nexport const forceLongPolling = function() {\n  WebSocketConnection.forceDisallow();\n  BrowserPollConnection.forceAllow();\n};\n\nexport const forceWebSockets = function() {\n  BrowserPollConnection.forceDisallow();\n};\n\n/* Used by App Manager */\nexport const isWebSocketsAvailable = function(): boolean {\n  return WebSocketConnection['isAvailable']();\n};\n\nexport const setSecurityDebugCallback = function(\n  ref: Reference,\n  callback: (a: Object) => void\n) {\n  (ref.repo.persistentConnection_ as any).securityDebugCallback_ = callback;\n};\n\nexport const stats = function(ref: Reference, showDelta?: boolean) {\n  ref.repo.stats(showDelta);\n};\n\nexport const statsIncrementCounter = function(ref: Reference, metric: string) {\n  ref.repo.statsIncrementCounter(metric);\n};\n\nexport const dataUpdateCount = function(ref: Reference): number {\n  return ref.repo.dataUpdateCount;\n};\n\nexport const interceptServerData = function(\n  ref: Reference,\n  callback: ((a: string, b: any) => void) | null\n) {\n  return ref.repo.interceptServerData_(callback);\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\nimport { PersistentConnection } from '../core/PersistentConnection';\nimport { RepoManager } from '../core/RepoManager';\nimport { Connection } from '../realtime/Connection';\nimport { Query } from './Query';\n\nexport const DataConnection = PersistentConnection;\n\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n(PersistentConnection.prototype as any).simpleListen = function(\n  pathString: string,\n  onComplete: (a: any) => void\n) {\n  this.sendRequest('q', { p: pathString }, onComplete);\n};\n\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n(PersistentConnection.prototype as any).echo = function(\n  data: any,\n  onEcho: (a: any) => void\n) {\n  this.sendRequest('echo', { d: data }, onEcho);\n};\n\n// RealTimeConnection properties that we use in tests.\nexport const RealTimeConnection = Connection;\n\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\nexport const hijackHash = function(newHash: () => string) {\n  const oldPut = PersistentConnection.prototype.put;\n  PersistentConnection.prototype.put = function(\n    pathString,\n    data,\n    opt_onComplete,\n    opt_hash\n  ) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n  return function() {\n    PersistentConnection.prototype.put = oldPut;\n  };\n};\n\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\nexport const ConnectionTarget = RepoInfo;\n\n/**\n * @param {!Query} query\n * @return {!string}\n */\nexport const queryIdentifier = function(query: Query) {\n  return query.queryIdentifier();\n};\n\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\nexport const forceRestClient = function(forceRestClient: boolean) {\n  RepoManager.getInstance().forceRestClient(forceRestClient);\n};\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport { FirebaseNamespace } from '@firebase/app-types';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport { Database } from './src/api/Database';\nimport { DataSnapshot } from './src/api/DataSnapshot';\nimport { Query } from './src/api/Query';\nimport { Reference } from './src/api/Reference';\nimport { enableLogging } from './src/core/util/util';\nimport { RepoManager } from './src/core/RepoManager';\nimport * as INTERNAL from './src/api/internal';\nimport * as TEST_ACCESS from './src/api/test_access';\nimport { isNodeSdk } from '@firebase/util';\nimport * as types from '@firebase/database-types';\nimport { setSDKVersion } from './src/core/version';\n\nconst ServerValue = Database.ServerValue;\n\nexport function registerDatabase(instance: FirebaseNamespace) {\n  // set SDK_VERSION\n  setSDKVersion(instance.SDK_VERSION);\n\n  // Register the Database Service with the 'firebase' namespace.\n  const namespace = (instance as _FirebaseNamespace).INTERNAL.registerService(\n    'database',\n    (app, unused, url) => RepoManager.getInstance().databaseFromApp(app, url),\n    // firebase.database namespace properties\n    {\n      Reference,\n      Query,\n      Database,\n      DataSnapshot,\n      enableLogging,\n      INTERNAL,\n      ServerValue,\n      TEST_ACCESS\n    },\n    null,\n    true\n  );\n\n  if (isNodeSdk()) {\n    module.exports = namespace;\n  }\n}\n\nregisterDatabase(firebase);\n\n// Types to export for the admin SDK\nexport { Database, Query, Reference, enableLogging, ServerValue };\n\nexport { DataSnapshot } from './src/api/DataSnapshot';\nexport { OnDisconnect } from './src/api/onDisconnect';\n\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    database?: {\n      (app?: FirebaseApp): types.FirebaseDatabase;\n      enableLogging: typeof types.enableLogging;\n      ServerValue: types.ServerValue;\n      Database: typeof types.FirebaseDatabase;\n    };\n  }\n  interface FirebaseApp {\n    database?(databaseURL?: string): types.FirebaseDatabase;\n  }\n}\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Bootstrap for the Google JS Library (Closure).\r\n *\r\n * In uncompiled mode base.js will attempt to load Closure's deps file, unless\r\n * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects\r\n * to include their own deps file(s) from different locations.\r\n *\r\n * Avoid including base.js more than once. This is strictly discouraged and not\r\n * supported. goog.require(...) won't work properly in that case.\r\n *\r\n * @provideGoog\r\n */\r\n\r\n\r\n/**\r\n * @define {boolean} Overridden to true by the compiler.\r\n */\r\nvar COMPILED = false;\r\n\r\n\r\n/**\r\n * Base namespace for the Closure library.  Checks to see goog is already\r\n * defined in the current scope before assigning to prevent clobbering if\r\n * base.js is loaded more than once.\r\n *\r\n * @const\r\n */\r\nvar goog = goog || {};\r\n\r\n/**\r\n * Reference to the global context.  In most cases this will be 'window'.\r\n * @const\r\n * @suppress {newCheckTypes}\r\n */\r\ngoog.global = this;\r\n\r\n\r\n/**\r\n * A hook for overriding the define values in uncompiled mode.\r\n *\r\n * In uncompiled mode, `CLOSURE_UNCOMPILED_DEFINES` may be defined before\r\n * loading base.js.  If a key is defined in `CLOSURE_UNCOMPILED_DEFINES`,\r\n * `goog.define` will use the value instead of the default value.  This\r\n * allows flags to be overwritten without compilation (this is normally\r\n * accomplished with the compiler's \"define\" flag).\r\n *\r\n * Example:\r\n * <pre>\r\n *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};\r\n * </pre>\r\n *\r\n * @type {Object<string, (string|number|boolean)>|undefined}\r\n */\r\ngoog.global.CLOSURE_UNCOMPILED_DEFINES;\r\n\r\n\r\n/**\r\n * A hook for overriding the define values in uncompiled or compiled mode,\r\n * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In\r\n * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.\r\n *\r\n * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or\r\n * string literals or the compiler will emit an error.\r\n *\r\n * While any @define value may be set, only those set with goog.define will be\r\n * effective for uncompiled code.\r\n *\r\n * Example:\r\n * <pre>\r\n *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;\r\n * </pre>\r\n *\r\n * @type {Object<string, (string|number|boolean)>|undefined}\r\n */\r\ngoog.global.CLOSURE_DEFINES;\r\n\r\n\r\n/**\r\n * Returns true if the specified value is not undefined.\r\n *\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is defined.\r\n */\r\ngoog.isDef = function(val) {\r\n  // void 0 always evaluates to undefined and hence we do not need to depend on\r\n  // the definition of the global variable named 'undefined'.\r\n  return val !== void 0;\r\n};\r\n\r\n/**\r\n * Returns true if the specified value is a string.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a string.\r\n */\r\ngoog.isString = function(val) {\r\n  return typeof val == 'string';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a boolean.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is boolean.\r\n */\r\ngoog.isBoolean = function(val) {\r\n  return typeof val == 'boolean';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a number.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a number.\r\n */\r\ngoog.isNumber = function(val) {\r\n  return typeof val == 'number';\r\n};\r\n\r\n\r\n/**\r\n * Builds an object structure for the provided namespace path, ensuring that\r\n * names that already exist are not overwritten. For example:\r\n * \"a.b.c\" -> a = {};a.b={};a.b.c={};\r\n * Used by goog.provide and goog.exportSymbol.\r\n * @param {string} name name of the object that this file defines.\r\n * @param {*=} opt_object the object to expose at the end of the path.\r\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\r\n *     is `goog.global`.\r\n * @private\r\n */\r\ngoog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {\r\n  var parts = name.split('.');\r\n  var cur = opt_objectToExportTo || goog.global;\r\n\r\n  // Internet Explorer exhibits strange behavior when throwing errors from\r\n  // methods externed in this manner.  See the testExportSymbolExceptions in\r\n  // base_test.html for an example.\r\n  if (!(parts[0] in cur) && typeof cur.execScript != 'undefined') {\r\n    cur.execScript('var ' + parts[0]);\r\n  }\r\n\r\n  for (var part; parts.length && (part = parts.shift());) {\r\n    if (!parts.length && goog.isDef(opt_object)) {\r\n      // last part and we have an object; use it\r\n      cur[part] = opt_object;\r\n    } else if (cur[part] && cur[part] !== Object.prototype[part]) {\r\n      cur = cur[part];\r\n    } else {\r\n      cur = cur[part] = {};\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Defines a named value. In uncompiled mode, the value is retrieved from\r\n * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and\r\n * has the property specified, and otherwise used the defined defaultValue.\r\n * When compiled the default can be overridden using the compiler options or the\r\n * value set in the CLOSURE_DEFINES object. Returns the defined value so that it\r\n * can be used safely in modules. Note that the value type MUST be either\r\n * boolean, number, or string.\r\n *\r\n * @param {string} name The distinguished name to provide.\r\n * @param {T} defaultValue\r\n * @return {T} The defined value.\r\n * @template T\r\n */\r\ngoog.define = function(name, defaultValue) {\r\n  var value = defaultValue;\r\n  if (!COMPILED) {\r\n    var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;\r\n    var defines = goog.global.CLOSURE_DEFINES;\r\n    if (uncompiledDefines &&\r\n        // Anti DOM-clobbering runtime check (b/37736576).\r\n        /** @type {?} */ (uncompiledDefines).nodeType === undefined &&\r\n        Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {\r\n      value = uncompiledDefines[name];\r\n    } else if (\r\n        defines &&\r\n        // Anti DOM-clobbering runtime check (b/37736576).\r\n        /** @type {?} */ (defines).nodeType === undefined &&\r\n        Object.prototype.hasOwnProperty.call(defines, name)) {\r\n      value = defines[name];\r\n    }\r\n  }\r\n  goog.exportPath_(name, value);\r\n  return value;\r\n};\r\n\r\n\r\n/**\r\n * @define {number} Integer year indicating the set of browser features that are\r\n * guaranteed to be present.  This is defined to include exactly features that\r\n * work correctly on all \"modern\" browsers that are stable on January 1 of the\r\n * specified year.  For example,\r\n * ```js\r\n * if (goog.FEATURESET_YEAR >= 2019) {\r\n *   // use APIs known to be available on all major stable browsers Jan 1, 2019\r\n * } else {\r\n *   // polyfill for older browsers\r\n * }\r\n * ```\r\n * This is intended to be the primary define for removing\r\n * unnecessary browser compatibility code (such as ponyfills and workarounds),\r\n * and should inform the default value for most other defines:\r\n * ```js\r\n * const ASSUME_NATIVE_PROMISE =\r\n *     goog.define('ASSUME_NATIVE_PROMISE', goog.FEATURESET_YEAR >= 2016);\r\n * ```\r\n *\r\n * The default assumption is that IE9 is the lowest supported browser, which was\r\n * first available Jan 1, 2012.\r\n *\r\n * TODO(user): Reference more thorough documentation when it's available.\r\n */\r\ngoog.FEATURESET_YEAR = goog.define('goog.FEATURESET_YEAR', 2012);\r\n\r\n\r\n/**\r\n * @define {boolean} DEBUG is provided as a convenience so that debugging code\r\n * that should not be included in a production. It can be easily stripped\r\n * by specifying --define goog.DEBUG=false to the Closure Compiler aka\r\n * JSCompiler. For example, most toString() methods should be declared inside an\r\n * \"if (goog.DEBUG)\" conditional because they are generally used for debugging\r\n * purposes and it is difficult for the JSCompiler to statically determine\r\n * whether they are used.\r\n */\r\ngoog.DEBUG = goog.define('goog.DEBUG', true);\r\n\r\n\r\n/**\r\n * @define {string} LOCALE defines the locale being used for compilation. It is\r\n * used to select locale specific data to be compiled in js binary. BUILD rule\r\n * can specify this value by \"--define goog.LOCALE=<locale_name>\" as a compiler\r\n * option.\r\n *\r\n * Take into account that the locale code format is important. You should use\r\n * the canonical Unicode format with hyphen as a delimiter. Language must be\r\n * lowercase, Language Script - Capitalized, Region - UPPERCASE.\r\n * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.\r\n *\r\n * See more info about locale codes here:\r\n * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers\r\n *\r\n * For language codes you should use values defined by ISO 693-1. See it here\r\n * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from\r\n * this rule: the Hebrew language. For legacy reasons the old code (iw) should\r\n * be used instead of the new code (he).\r\n *\r\n */\r\ngoog.LOCALE = goog.define('goog.LOCALE', 'en');  // default to en\r\n\r\n\r\n/**\r\n * @define {boolean} Whether this code is running on trusted sites.\r\n *\r\n * On untrusted sites, several native functions can be defined or overridden by\r\n * external libraries like Prototype, Datejs, and JQuery and setting this flag\r\n * to false forces closure to use its own implementations when possible.\r\n *\r\n * If your JavaScript can be loaded by a third party site and you are wary about\r\n * relying on non-standard implementations, specify\r\n * \"--define goog.TRUSTED_SITE=false\" to the compiler.\r\n */\r\ngoog.TRUSTED_SITE = goog.define('goog.TRUSTED_SITE', true);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether a project is expected to be running in strict mode.\r\n *\r\n * This define can be used to trigger alternate implementations compatible with\r\n * running in EcmaScript Strict mode or warn about unavailable functionality.\r\n * @see https://goo.gl/PudQ4y\r\n *\r\n */\r\ngoog.STRICT_MODE_COMPATIBLE = goog.define('goog.STRICT_MODE_COMPATIBLE', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether code that calls {@link goog.setTestOnly} should\r\n *     be disallowed in the compilation unit.\r\n */\r\ngoog.DISALLOW_TEST_ONLY_CODE =\r\n    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to use a Chrome app CSP-compliant method for\r\n *     loading scripts via goog.require. @see appendScriptSrcNode_.\r\n */\r\ngoog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING =\r\n    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);\r\n\r\n\r\n/**\r\n * Defines a namespace in Closure.\r\n *\r\n * A namespace may only be defined once in a codebase. It may be defined using\r\n * goog.provide() or goog.module().\r\n *\r\n * The presence of one or more goog.provide() calls in a file indicates\r\n * that the file defines the given objects/namespaces.\r\n * Provided symbols must not be null or undefined.\r\n *\r\n * In addition, goog.provide() creates the object stubs for a namespace\r\n * (for example, goog.provide(\"goog.foo.bar\") will create the object\r\n * goog.foo.bar if it does not already exist).\r\n *\r\n * Build tools also scan for provide/require/module statements\r\n * to discern dependencies, build dependency files (see deps.js), etc.\r\n *\r\n * @see goog.require\r\n * @see goog.module\r\n * @param {string} name Namespace provided by this file in the form\r\n *     \"goog.package.part\".\r\n */\r\ngoog.provide = function(name) {\r\n  if (goog.isInModuleLoader_()) {\r\n    throw new Error('goog.provide cannot be used within a module.');\r\n  }\r\n  if (!COMPILED) {\r\n    // Ensure that the same namespace isn't provided twice.\r\n    // A goog.module/goog.provide maps a goog.require to a specific file\r\n    if (goog.isProvided_(name)) {\r\n      throw new Error('Namespace \"' + name + '\" already declared.');\r\n    }\r\n  }\r\n\r\n  goog.constructNamespace_(name);\r\n};\r\n\r\n\r\n/**\r\n * @param {string} name Namespace provided by this file in the form\r\n *     \"goog.package.part\".\r\n * @param {Object=} opt_obj The object to embed in the namespace.\r\n * @private\r\n */\r\ngoog.constructNamespace_ = function(name, opt_obj) {\r\n  if (!COMPILED) {\r\n    delete goog.implicitNamespaces_[name];\r\n\r\n    var namespace = name;\r\n    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {\r\n      if (goog.getObjectByName(namespace)) {\r\n        break;\r\n      }\r\n      goog.implicitNamespaces_[namespace] = true;\r\n    }\r\n  }\r\n\r\n  goog.exportPath_(name, opt_obj);\r\n};\r\n\r\n\r\n/**\r\n * Returns CSP nonce, if set for any script tag.\r\n * @param {?Window=} opt_window The window context used to retrieve the nonce.\r\n *     Defaults to global context.\r\n * @return {string} CSP nonce or empty string if no nonce is present.\r\n */\r\ngoog.getScriptNonce = function(opt_window) {\r\n  if (opt_window && opt_window != goog.global) {\r\n    return goog.getScriptNonce_(opt_window.document);\r\n  }\r\n  if (goog.cspNonce_ === null) {\r\n    goog.cspNonce_ = goog.getScriptNonce_(goog.global.document);\r\n  }\r\n  return goog.cspNonce_;\r\n};\r\n\r\n\r\n/**\r\n * According to the CSP3 spec a nonce must be a valid base64 string.\r\n * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value\r\n * @private @const\r\n */\r\ngoog.NONCE_PATTERN_ = /^[\\w+/_-]+[=]{0,2}$/;\r\n\r\n\r\n/**\r\n * @private {?string}\r\n */\r\ngoog.cspNonce_ = null;\r\n\r\n\r\n/**\r\n * Returns CSP nonce, if set for any script tag.\r\n * @param {!Document} doc\r\n * @return {string} CSP nonce or empty string if no nonce is present.\r\n * @private\r\n */\r\ngoog.getScriptNonce_ = function(doc) {\r\n  var script = doc.querySelector && doc.querySelector('script[nonce]');\r\n  if (script) {\r\n    // Try to get the nonce from the IDL property first, because browsers that\r\n    // implement additional nonce protection features (currently only Chrome) to\r\n    // prevent nonce stealing via CSS do not expose the nonce via attributes.\r\n    // See https://github.com/whatwg/html/issues/2369\r\n    var nonce = script['nonce'] || script.getAttribute('nonce');\r\n    if (nonce && goog.NONCE_PATTERN_.test(nonce)) {\r\n      return nonce;\r\n    }\r\n  }\r\n  return '';\r\n};\r\n\r\n\r\n/**\r\n * Module identifier validation regexp.\r\n * Note: This is a conservative check, it is very possible to be more lenient,\r\n *   the primary exclusion here is \"/\" and \"\\\" and a leading \".\", these\r\n *   restrictions are intended to leave the door open for using goog.require\r\n *   with relative file paths rather than module identifiers.\r\n * @private\r\n */\r\ngoog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;\r\n\r\n\r\n/**\r\n * Defines a module in Closure.\r\n *\r\n * Marks that this file must be loaded as a module and claims the namespace.\r\n *\r\n * A namespace may only be defined once in a codebase. It may be defined using\r\n * goog.provide() or goog.module().\r\n *\r\n * goog.module() has three requirements:\r\n * - goog.module may not be used in the same file as goog.provide.\r\n * - goog.module must be the first statement in the file.\r\n * - only one goog.module is allowed per file.\r\n *\r\n * When a goog.module annotated file is loaded, it is enclosed in\r\n * a strict function closure. This means that:\r\n * - any variables declared in a goog.module file are private to the file\r\n * (not global), though the compiler is expected to inline the module.\r\n * - The code must obey all the rules of \"strict\" JavaScript.\r\n * - the file will be marked as \"use strict\"\r\n *\r\n * NOTE: unlike goog.provide, goog.module does not declare any symbols by\r\n * itself. If declared symbols are desired, use\r\n * goog.module.declareLegacyNamespace().\r\n *\r\n *\r\n * See the public goog.module proposal: http://goo.gl/Va1hin\r\n *\r\n * @param {string} name Namespace provided by this file in the form\r\n *     \"goog.package.part\", is expected but not required.\r\n * @return {void}\r\n */\r\ngoog.module = function(name) {\r\n  if (!goog.isString(name) || !name ||\r\n      name.search(goog.VALID_MODULE_RE_) == -1) {\r\n    throw new Error('Invalid module identifier');\r\n  }\r\n  if (!goog.isInGoogModuleLoader_()) {\r\n    throw new Error(\r\n        'Module ' + name + ' has been loaded incorrectly. Note, ' +\r\n        'modules cannot be loaded as normal scripts. They require some kind of ' +\r\n        'pre-processing step. You\\'re likely trying to load a module via a ' +\r\n        'script tag or as a part of a concatenated bundle without rewriting the ' +\r\n        'module. For more info see: ' +\r\n        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');\r\n  }\r\n  if (goog.moduleLoaderState_.moduleName) {\r\n    throw new Error('goog.module may only be called once per module.');\r\n  }\r\n\r\n  // Store the module name for the loader.\r\n  goog.moduleLoaderState_.moduleName = name;\r\n  if (!COMPILED) {\r\n    // Ensure that the same namespace isn't provided twice.\r\n    // A goog.module/goog.provide maps a goog.require to a specific file\r\n    if (goog.isProvided_(name)) {\r\n      throw new Error('Namespace \"' + name + '\" already declared.');\r\n    }\r\n    delete goog.implicitNamespaces_[name];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @param {string} name The module identifier.\r\n * @return {?} The module exports for an already loaded module or null.\r\n *\r\n * Note: This is not an alternative to goog.require, it does not\r\n * indicate a hard dependency, instead it is used to indicate\r\n * an optional dependency or to access the exports of a module\r\n * that has already been loaded.\r\n * @suppress {missingProvide}\r\n */\r\ngoog.module.get = function(name) {\r\n\r\n  return goog.module.getInternal_(name);\r\n};\r\n\r\n\r\n/**\r\n * @param {string} name The module identifier.\r\n * @return {?} The module exports for an already loaded module or null.\r\n * @private\r\n */\r\ngoog.module.getInternal_ = function(name) {\r\n  if (!COMPILED) {\r\n    if (name in goog.loadedModules_) {\r\n      return goog.loadedModules_[name].exports;\r\n    } else if (!goog.implicitNamespaces_[name]) {\r\n      var ns = goog.getObjectByName(name);\r\n      return ns != null ? ns : null;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\n\r\n/**\r\n * Types of modules the debug loader can load.\r\n * @enum {string}\r\n */\r\ngoog.ModuleType = {\r\n  ES6: 'es6',\r\n  GOOG: 'goog'\r\n};\r\n\r\n\r\n/**\r\n * @private {?{\r\n *   moduleName: (string|undefined),\r\n *   declareLegacyNamespace:boolean,\r\n *   type: ?goog.ModuleType\r\n * }}\r\n */\r\ngoog.moduleLoaderState_ = null;\r\n\r\n\r\n/**\r\n * @private\r\n * @return {boolean} Whether a goog.module or an es6 module is currently being\r\n *     initialized.\r\n */\r\ngoog.isInModuleLoader_ = function() {\r\n  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();\r\n};\r\n\r\n\r\n/**\r\n * @private\r\n * @return {boolean} Whether a goog.module is currently being initialized.\r\n */\r\ngoog.isInGoogModuleLoader_ = function() {\r\n  return !!goog.moduleLoaderState_ &&\r\n      goog.moduleLoaderState_.type == goog.ModuleType.GOOG;\r\n};\r\n\r\n\r\n/**\r\n * @private\r\n * @return {boolean} Whether an es6 module is currently being initialized.\r\n */\r\ngoog.isInEs6ModuleLoader_ = function() {\r\n  var inLoader = !!goog.moduleLoaderState_ &&\r\n      goog.moduleLoaderState_.type == goog.ModuleType.ES6;\r\n\r\n  if (inLoader) {\r\n    return true;\r\n  }\r\n\r\n  var jscomp = goog.global['$jscomp'];\r\n\r\n  if (jscomp) {\r\n    // jscomp may not have getCurrentModulePath if this is a compiled bundle\r\n    // that has some of the runtime, but not all of it. This can happen if\r\n    // optimizations are turned on so the unused runtime is removed but renaming\r\n    // and Closure pass are off (so $jscomp is still named $jscomp and the\r\n    // goog.provide/require calls still exist).\r\n    if (typeof jscomp.getCurrentModulePath != 'function') {\r\n      return false;\r\n    }\r\n\r\n    // Bundled ES6 module.\r\n    return !!jscomp.getCurrentModulePath();\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Provide the module's exports as a globally accessible object under the\r\n * module's declared name.  This is intended to ease migration to goog.module\r\n * for files that have existing usages.\r\n * @suppress {missingProvide}\r\n */\r\ngoog.module.declareLegacyNamespace = function() {\r\n  if (!COMPILED && !goog.isInGoogModuleLoader_()) {\r\n    throw new Error(\r\n        'goog.module.declareLegacyNamespace must be called from ' +\r\n        'within a goog.module');\r\n  }\r\n  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {\r\n    throw new Error(\r\n        'goog.module must be called prior to ' +\r\n        'goog.module.declareLegacyNamespace.');\r\n  }\r\n  goog.moduleLoaderState_.declareLegacyNamespace = true;\r\n};\r\n\r\n\r\n/**\r\n * Associates an ES6 module with a Closure module ID so that is available via\r\n * goog.require. The associated ID  acts like a goog.module ID - it does not\r\n * create any global names, it is merely available via goog.require /\r\n * goog.module.get / goog.forwardDeclare / goog.requireType. goog.require and\r\n * goog.module.get will return the entire module as if it was import *'d. This\r\n * allows Closure files to reference ES6 modules for the sake of migration.\r\n *\r\n * @param {string} namespace\r\n * @suppress {missingProvide}\r\n */\r\ngoog.declareModuleId = function(namespace) {\r\n  if (!COMPILED) {\r\n    if (!goog.isInEs6ModuleLoader_()) {\r\n      throw new Error(\r\n          'goog.declareModuleId may only be called from ' +\r\n          'within an ES6 module');\r\n    }\r\n    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {\r\n      throw new Error(\r\n          'goog.declareModuleId may only be called once per module.');\r\n    }\r\n    if (namespace in goog.loadedModules_) {\r\n      throw new Error(\r\n          'Module with namespace \"' + namespace + '\" already exists.');\r\n    }\r\n  }\r\n  if (goog.moduleLoaderState_) {\r\n    // Not bundled - debug loading.\r\n    goog.moduleLoaderState_.moduleName = namespace;\r\n  } else {\r\n    // Bundled - not debug loading, no module loader state.\r\n    var jscomp = goog.global['$jscomp'];\r\n    if (!jscomp || typeof jscomp.getCurrentModulePath != 'function') {\r\n      throw new Error(\r\n          'Module with namespace \"' + namespace +\r\n          '\" has been loaded incorrectly.');\r\n    }\r\n    var exports = jscomp.require(jscomp.getCurrentModulePath());\r\n    goog.loadedModules_[namespace] = {\r\n      exports: exports,\r\n      type: goog.ModuleType.ES6,\r\n      moduleId: namespace\r\n    };\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Marks that the current file should only be used for testing, and never for\r\n * live code in production.\r\n *\r\n * In the case of unit tests, the message may optionally be an exact namespace\r\n * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra\r\n * provide (if not explicitly defined in the code).\r\n *\r\n * @param {string=} opt_message Optional message to add to the error that's\r\n *     raised when used in production code.\r\n */\r\ngoog.setTestOnly = function(opt_message) {\r\n  if (goog.DISALLOW_TEST_ONLY_CODE) {\r\n    opt_message = opt_message || '';\r\n    throw new Error(\r\n        'Importing test-only code into non-debug environment' +\r\n        (opt_message ? ': ' + opt_message : '.'));\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Forward declares a symbol. This is an indication to the compiler that the\r\n * symbol may be used in the source yet is not required and may not be provided\r\n * in compilation.\r\n *\r\n * The most common usage of forward declaration is code that takes a type as a\r\n * function parameter but does not need to require it. By forward declaring\r\n * instead of requiring, no hard dependency is made, and (if not required\r\n * elsewhere) the namespace may never be required and thus, not be pulled\r\n * into the JavaScript binary. If it is required elsewhere, it will be type\r\n * checked as normal.\r\n *\r\n * Before using goog.forwardDeclare, please read the documentation at\r\n * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to\r\n * understand the options and tradeoffs when working with forward declarations.\r\n *\r\n * @param {string} name The namespace to forward declare in the form of\r\n *     \"goog.package.part\".\r\n */\r\ngoog.forwardDeclare = function(name) {};\r\n\r\n\r\n/**\r\n * Forward declare type information. Used to assign types to goog.global\r\n * referenced object that would otherwise result in unknown type references\r\n * and thus block property disambiguation.\r\n */\r\ngoog.forwardDeclare('Document');\r\ngoog.forwardDeclare('HTMLScriptElement');\r\ngoog.forwardDeclare('XMLHttpRequest');\r\n\r\n\r\nif (!COMPILED) {\r\n  /**\r\n   * Check if the given name has been goog.provided. This will return false for\r\n   * names that are available only as implicit namespaces.\r\n   * @param {string} name name of the object to look for.\r\n   * @return {boolean} Whether the name has been provided.\r\n   * @private\r\n   */\r\n  goog.isProvided_ = function(name) {\r\n    return (name in goog.loadedModules_) ||\r\n        (!goog.implicitNamespaces_[name] &&\r\n         goog.isDefAndNotNull(goog.getObjectByName(name)));\r\n  };\r\n\r\n  /**\r\n   * Namespaces implicitly defined by goog.provide. For example,\r\n   * goog.provide('goog.events.Event') implicitly declares that 'goog' and\r\n   * 'goog.events' must be namespaces.\r\n   *\r\n   * @type {!Object<string, (boolean|undefined)>}\r\n   * @private\r\n   */\r\n  goog.implicitNamespaces_ = {'goog.module': true};\r\n\r\n  // NOTE: We add goog.module as an implicit namespace as goog.module is defined\r\n  // here and because the existing module package has not been moved yet out of\r\n  // the goog.module namespace. This satisifies both the debug loader and\r\n  // ahead-of-time dependency management.\r\n}\r\n\r\n\r\n/**\r\n * Returns an object based on its fully qualified external name.  The object\r\n * is not found if null or undefined.  If you are using a compilation pass that\r\n * renames property names beware that using this function will not find renamed\r\n * properties.\r\n *\r\n * @param {string} name The fully qualified name.\r\n * @param {Object=} opt_obj The object within which to look; default is\r\n *     |goog.global|.\r\n * @return {?} The value (object or primitive) or, if not found, null.\r\n */\r\ngoog.getObjectByName = function(name, opt_obj) {\r\n  var parts = name.split('.');\r\n  var cur = opt_obj || goog.global;\r\n  for (var i = 0; i < parts.length; i++) {\r\n    cur = cur[parts[i]];\r\n    if (!goog.isDefAndNotNull(cur)) {\r\n      return null;\r\n    }\r\n  }\r\n  return cur;\r\n};\r\n\r\n\r\n/**\r\n * Globalizes a whole namespace, such as goog or goog.lang.\r\n *\r\n * @param {!Object} obj The namespace to globalize.\r\n * @param {Object=} opt_global The object to add the properties to.\r\n * @deprecated Properties may be explicitly exported to the global scope, but\r\n *     this should no longer be done in bulk.\r\n */\r\ngoog.globalize = function(obj, opt_global) {\r\n  var global = opt_global || goog.global;\r\n  for (var x in obj) {\r\n    global[x] = obj[x];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds a dependency from a file to the files it requires.\r\n * @param {string} relPath The path to the js file.\r\n * @param {!Array<string>} provides An array of strings with\r\n *     the names of the objects this file provides.\r\n * @param {!Array<string>} requires An array of strings with\r\n *     the names of the objects this file requires.\r\n * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating\r\n *     how the file must be loaded.  The boolean 'true' is equivalent\r\n *     to {'module': 'goog'} for backwards-compatibility.  Valid properties\r\n *     and values include {'module': 'goog'} and {'lang': 'es6'}.\r\n */\r\ngoog.addDependency = function(relPath, provides, requires, opt_loadFlags) {\r\n  if (!COMPILED && goog.DEPENDENCIES_ENABLED) {\r\n    goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags);\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n// NOTE(nnaze): The debug DOM loader was included in base.js as an original way\r\n// to do \"debug-mode\" development.  The dependency system can sometimes be\r\n// confusing, as can the debug DOM loader's asynchronous nature.\r\n//\r\n// With the DOM loader, a call to goog.require() is not blocking -- the script\r\n// will not load until some point after the current script.  If a namespace is\r\n// needed at runtime, it needs to be defined in a previous script, or loaded via\r\n// require() with its registered dependencies.\r\n//\r\n// User-defined namespaces may need their own deps file. For a reference on\r\n// creating a deps file, see:\r\n// Externally: https://developers.google.com/closure/library/docs/depswriter\r\n//\r\n// Because of legacy clients, the DOM loader can't be easily removed from\r\n// base.js.  Work was done to make it disableable or replaceable for\r\n// different environments (DOM-less JavaScript interpreters like Rhino or V8,\r\n// for example). See bootstrap/ for more information.\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to enable the debug loader.\r\n *\r\n * If enabled, a call to goog.require() will attempt to load the namespace by\r\n * appending a script tag to the DOM (if the namespace has been registered).\r\n *\r\n * If disabled, goog.require() will simply assert that the namespace has been\r\n * provided (and depend on the fact that some outside tool correctly ordered\r\n * the script).\r\n */\r\ngoog.ENABLE_DEBUG_LOADER = goog.define('goog.ENABLE_DEBUG_LOADER', true);\r\n\r\n\r\n/**\r\n * @param {string} msg\r\n * @private\r\n */\r\ngoog.logToConsole_ = function(msg) {\r\n  if (goog.global.console) {\r\n    goog.global.console['error'](msg);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Implements a system for the dynamic resolution of dependencies that works in\r\n * parallel with the BUILD system.\r\n *\r\n * Note that all calls to goog.require will be stripped by the compiler.\r\n *\r\n * @see goog.provide\r\n * @param {string} namespace Namespace (as was given in goog.provide,\r\n *     goog.module, or goog.declareModuleId) in the form\r\n *     \"goog.package.part\".\r\n * @return {?} If called within a goog.module or ES6 module file, the associated\r\n *     namespace or module otherwise null.\r\n */\r\ngoog.require = function(namespace) {\r\n  if (!COMPILED) {\r\n    // Might need to lazy load on old IE.\r\n    if (goog.ENABLE_DEBUG_LOADER) {\r\n      goog.debugLoader_.requested(namespace);\r\n    }\r\n\r\n    // If the object already exists we do not need to do anything.\r\n    if (goog.isProvided_(namespace)) {\r\n      if (goog.isInModuleLoader_()) {\r\n        return goog.module.getInternal_(namespace);\r\n      }\r\n    } else if (goog.ENABLE_DEBUG_LOADER) {\r\n      var moduleLoaderState = goog.moduleLoaderState_;\r\n      goog.moduleLoaderState_ = null;\r\n      try {\r\n        goog.debugLoader_.load_(namespace);\r\n      } finally {\r\n        goog.moduleLoaderState_ = moduleLoaderState;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Requires a symbol for its type information. This is an indication to the\r\n * compiler that the symbol may appear in type annotations, yet it is not\r\n * referenced at runtime.\r\n *\r\n * When called within a goog.module or ES6 module file, the return value may be\r\n * assigned to or destructured into a variable, but it may not be otherwise used\r\n * in code outside of a type annotation.\r\n *\r\n * Note that all calls to goog.requireType will be stripped by the compiler.\r\n *\r\n * @param {string} namespace Namespace (as was given in goog.provide,\r\n *     goog.module, or goog.declareModuleId) in the form\r\n *     \"goog.package.part\".\r\n * @return {?}\r\n */\r\ngoog.requireType = function(namespace) {\r\n  // Return an empty object so that single-level destructuring of the return\r\n  // value doesn't crash at runtime when using the debug loader. Multi-level\r\n  // destructuring isn't supported.\r\n  return {};\r\n};\r\n\r\n\r\n/**\r\n * Path for included scripts.\r\n * @type {string}\r\n */\r\ngoog.basePath = '';\r\n\r\n\r\n/**\r\n * A hook for overriding the base path.\r\n * @type {string|undefined}\r\n */\r\ngoog.global.CLOSURE_BASE_PATH;\r\n\r\n\r\n/**\r\n * Whether to attempt to load Closure's deps file. By default, when uncompiled,\r\n * deps files will attempt to be loaded.\r\n * @type {boolean|undefined}\r\n */\r\ngoog.global.CLOSURE_NO_DEPS;\r\n\r\n\r\n/**\r\n * A function to import a single script. This is meant to be overridden when\r\n * Closure is being run in non-HTML contexts, such as web workers. It's defined\r\n * in the global scope so that it can be set before base.js is loaded, which\r\n * allows deps.js to be imported properly.\r\n *\r\n * The first parameter the script source, which is a relative URI. The second,\r\n * optional parameter is the script contents, in the event the script needed\r\n * transformation. It should return true if the script was imported, false\r\n * otherwise.\r\n * @type {(function(string, string=): boolean)|undefined}\r\n */\r\ngoog.global.CLOSURE_IMPORT_SCRIPT;\r\n\r\n\r\n/**\r\n * Null function used for default values of callbacks, etc.\r\n * @return {void} Nothing.\r\n */\r\ngoog.nullFunction = function() {};\r\n\r\n\r\n/**\r\n * When defining a class Foo with an abstract method bar(), you can do:\r\n * Foo.prototype.bar = goog.abstractMethod\r\n *\r\n * Now if a subclass of Foo fails to override bar(), an error will be thrown\r\n * when bar() is invoked.\r\n *\r\n * @type {!Function}\r\n * @throws {Error} when invoked to indicate the method should be overridden.\r\n */\r\ngoog.abstractMethod = function() {\r\n  throw new Error('unimplemented abstract method');\r\n};\r\n\r\n\r\n/**\r\n * Adds a `getInstance` static method that always returns the same\r\n * instance object.\r\n * @param {!Function} ctor The constructor for the class to add the static\r\n *     method to.\r\n * @suppress {missingProperties} 'instance_' isn't a property on 'Function'\r\n *     but we don't have a better type to use here.\r\n */\r\ngoog.addSingletonGetter = function(ctor) {\r\n  // instance_ is immediately set to prevent issues with sealed constructors\r\n  // such as are encountered when a constructor is returned as the export object\r\n  // of a goog.module in unoptimized code.\r\n  // Delcare type to avoid conformance violations that ctor.instance_ is unknown\r\n  /** @type {undefined|!Object} @suppress {underscore} */\r\n  ctor.instance_ = undefined;\r\n  ctor.getInstance = function() {\r\n    if (ctor.instance_) {\r\n      return ctor.instance_;\r\n    }\r\n    if (goog.DEBUG) {\r\n      // NOTE: JSCompiler can't optimize away Array#push.\r\n      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;\r\n    }\r\n    // Cast to avoid conformance violations that ctor.instance_ is unknown\r\n    return /** @type {!Object|undefined} */ (ctor.instance_) = new ctor;\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * All singleton classes that have been instantiated, for testing. Don't read\r\n * it directly, use the `goog.testing.singleton` module. The compiler\r\n * removes this variable if unused.\r\n * @type {!Array<!Function>}\r\n * @private\r\n */\r\ngoog.instantiatedSingletons_ = [];\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to load goog.modules using `eval` when using\r\n * the debug loader.  This provides a better debugging experience as the\r\n * source is unmodified and can be edited using Chrome Workspaces or similar.\r\n * However in some environments the use of `eval` is banned\r\n * so we provide an alternative.\r\n */\r\ngoog.LOAD_MODULE_USING_EVAL = goog.define('goog.LOAD_MODULE_USING_EVAL', true);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the exports of goog.modules should be sealed when\r\n * possible.\r\n */\r\ngoog.SEAL_MODULE_EXPORTS = goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);\r\n\r\n\r\n/**\r\n * The registry of initialized modules:\r\n * The module identifier or path to module exports map.\r\n * @private @const {!Object<string, {exports:?,type:string,moduleId:string}>}\r\n */\r\ngoog.loadedModules_ = {};\r\n\r\n\r\n/**\r\n * True if the debug loader enabled and used.\r\n * @const {boolean}\r\n */\r\ngoog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;\r\n\r\n\r\n/**\r\n * @define {string} How to decide whether to transpile.  Valid values\r\n * are 'always', 'never', and 'detect'.  The default ('detect') is to\r\n * use feature detection to determine which language levels need\r\n * transpilation.\r\n */\r\n// NOTE(sdh): we could expand this to accept a language level to bypass\r\n// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but\r\n// would leave ES3 and ES5 files alone.\r\ngoog.TRANSPILE = goog.define('goog.TRANSPILE', 'detect');\r\n\r\n/**\r\n * @define {boolean} If true assume that ES modules have already been\r\n * transpiled by the jscompiler (in the same way that transpile.js would\r\n * transpile them - to jscomp modules). Useful only for servers that wish to use\r\n * the debug loader and transpile server side. Thus this is only respected if\r\n * goog.TRANSPILE is \"never\".\r\n */\r\ngoog.ASSUME_ES_MODULES_TRANSPILED =\r\n    goog.define('goog.ASSUME_ES_MODULES_TRANSPILED', false);\r\n\r\n\r\n/**\r\n * @define {string} If a file needs to be transpiled what the output language\r\n * should be. By default this is the highest language level this file detects\r\n * the current environment supports. Generally this flag should not be set, but\r\n * it could be useful to override. Example: If the current environment supports\r\n * ES6 then by default ES7+ files will be transpiled to ES6, unless this is\r\n * overridden.\r\n *\r\n * Valid values include: es3, es5, es6, es7, and es8. Anything not recognized\r\n * is treated as es3.\r\n *\r\n * Note that setting this value does not force transpilation. Just if\r\n * transpilation occurs this will be the output. So this is most useful when\r\n * goog.TRANSPILE is set to 'always' and then forcing the language level to be\r\n * something lower than what the environment detects.\r\n */\r\ngoog.TRANSPILE_TO_LANGUAGE = goog.define('goog.TRANSPILE_TO_LANGUAGE', '');\r\n\r\n\r\n/**\r\n * @define {string} Path to the transpiler.  Executing the script at this\r\n * path (relative to base.js) should define a function $jscomp.transpile.\r\n */\r\ngoog.TRANSPILER = goog.define('goog.TRANSPILER', 'transpile.js');\r\n\r\n\r\n/**\r\n * @package {?boolean}\r\n * Visible for testing.\r\n */\r\ngoog.hasBadLetScoping = null;\r\n\r\n\r\n/**\r\n * @return {boolean}\r\n * @package Visible for testing.\r\n */\r\ngoog.useSafari10Workaround = function() {\r\n  if (goog.hasBadLetScoping == null) {\r\n    var hasBadLetScoping;\r\n    try {\r\n      hasBadLetScoping = !eval(\r\n          '\"use strict\";' +\r\n          'let x = 1; function f() { return typeof x; };' +\r\n          'f() == \"number\";');\r\n    } catch (e) {\r\n      // Assume that ES6 syntax isn't supported.\r\n      hasBadLetScoping = false;\r\n    }\r\n    goog.hasBadLetScoping = hasBadLetScoping;\r\n  }\r\n  return goog.hasBadLetScoping;\r\n};\r\n\r\n\r\n/**\r\n * @param {string} moduleDef\r\n * @return {string}\r\n * @package Visible for testing.\r\n */\r\ngoog.workaroundSafari10EvalBug = function(moduleDef) {\r\n  return '(function(){' + moduleDef +\r\n      '\\n' +  // Terminate any trailing single line comment.\r\n      ';' +   // Terminate any trailing expression.\r\n      '})();\\n';\r\n};\r\n\r\n\r\n/**\r\n * @param {function(?):?|string} moduleDef The module definition.\r\n */\r\ngoog.loadModule = function(moduleDef) {\r\n  // NOTE: we allow function definitions to be either in the from\r\n  // of a string to eval (which keeps the original source intact) or\r\n  // in a eval forbidden environment (CSP) we allow a function definition\r\n  // which in its body must call `goog.module`, and return the exports\r\n  // of the module.\r\n  var previousState = goog.moduleLoaderState_;\r\n  try {\r\n    goog.moduleLoaderState_ = {\r\n      moduleName: '',\r\n      declareLegacyNamespace: false,\r\n      type: goog.ModuleType.GOOG\r\n    };\r\n    var exports;\r\n    if (goog.isFunction(moduleDef)) {\r\n      exports = moduleDef.call(undefined, {});\r\n    } else if (goog.isString(moduleDef)) {\r\n      if (goog.useSafari10Workaround()) {\r\n        moduleDef = goog.workaroundSafari10EvalBug(moduleDef);\r\n      }\r\n\r\n      exports = goog.loadModuleFromSource_.call(undefined, moduleDef);\r\n    } else {\r\n      throw new Error('Invalid module definition');\r\n    }\r\n\r\n    var moduleName = goog.moduleLoaderState_.moduleName;\r\n    if (goog.isString(moduleName) && moduleName) {\r\n      // Don't seal legacy namespaces as they may be used as a parent of\r\n      // another namespace\r\n      if (goog.moduleLoaderState_.declareLegacyNamespace) {\r\n        goog.constructNamespace_(moduleName, exports);\r\n      } else if (\r\n          goog.SEAL_MODULE_EXPORTS && Object.seal &&\r\n          typeof exports == 'object' && exports != null) {\r\n        Object.seal(exports);\r\n      }\r\n\r\n      var data = {\r\n        exports: exports,\r\n        type: goog.ModuleType.GOOG,\r\n        moduleId: goog.moduleLoaderState_.moduleName\r\n      };\r\n      goog.loadedModules_[moduleName] = data;\r\n    } else {\r\n      throw new Error('Invalid module name \\\"' + moduleName + '\\\"');\r\n    }\r\n  } finally {\r\n    goog.moduleLoaderState_ = previousState;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @private @const\r\n */\r\ngoog.loadModuleFromSource_ = /** @type {function(string):?} */ (function() {\r\n  // NOTE: we avoid declaring parameters or local variables here to avoid\r\n  // masking globals or leaking values into the module definition.\r\n  'use strict';\r\n  var exports = {};\r\n  eval(arguments[0]);\r\n  return exports;\r\n});\r\n\r\n\r\n/**\r\n * Normalize a file path by removing redundant \"..\" and extraneous \".\" file\r\n * path components.\r\n * @param {string} path\r\n * @return {string}\r\n * @private\r\n */\r\ngoog.normalizePath_ = function(path) {\r\n  var components = path.split('/');\r\n  var i = 0;\r\n  while (i < components.length) {\r\n    if (components[i] == '.') {\r\n      components.splice(i, 1);\r\n    } else if (\r\n        i && components[i] == '..' && components[i - 1] &&\r\n        components[i - 1] != '..') {\r\n      components.splice(--i, 2);\r\n    } else {\r\n      i++;\r\n    }\r\n  }\r\n  return components.join('/');\r\n};\r\n\r\n\r\n/**\r\n * Provides a hook for loading a file when using Closure's goog.require() API\r\n * with goog.modules.  In particular this hook is provided to support Node.js.\r\n *\r\n * @type {(function(string):string)|undefined}\r\n */\r\ngoog.global.CLOSURE_LOAD_FILE_SYNC;\r\n\r\n\r\n/**\r\n * Loads file by synchronous XHR. Should not be used in production environments.\r\n * @param {string} src Source URL.\r\n * @return {?string} File contents, or null if load failed.\r\n * @private\r\n */\r\ngoog.loadFileSync_ = function(src) {\r\n  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {\r\n    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);\r\n  } else {\r\n    try {\r\n      /** @type {XMLHttpRequest} */\r\n      var xhr = new goog.global['XMLHttpRequest']();\r\n      xhr.open('get', src, false);\r\n      xhr.send();\r\n      // NOTE: Successful http: requests have a status of 200, but successful\r\n      // file: requests may have a status of zero.  Any other status, or a\r\n      // thrown exception (particularly in case of file: requests) indicates\r\n      // some sort of error, which we treat as a missing or unavailable file.\r\n      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;\r\n    } catch (err) {\r\n      // No need to rethrow or log, since errors should show up on their own.\r\n      return null;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Lazily retrieves the transpiler and applies it to the source.\r\n * @param {string} code JS code.\r\n * @param {string} path Path to the code.\r\n * @param {string} target Language level output.\r\n * @return {string} The transpiled code.\r\n * @private\r\n */\r\ngoog.transpile_ = function(code, path, target) {\r\n  var jscomp = goog.global['$jscomp'];\r\n  if (!jscomp) {\r\n    goog.global['$jscomp'] = jscomp = {};\r\n  }\r\n  var transpile = jscomp.transpile;\r\n  if (!transpile) {\r\n    var transpilerPath = goog.basePath + goog.TRANSPILER;\r\n    var transpilerCode = goog.loadFileSync_(transpilerPath);\r\n    if (transpilerCode) {\r\n      // This must be executed synchronously, since by the time we know we\r\n      // need it, we're about to load and write the ES6 code synchronously,\r\n      // so a normal script-tag load will be too slow. Wrapped in a function\r\n      // so that code is eval'd in the global scope.\r\n      (function() {\r\n        eval(transpilerCode + '\\n//# sourceURL=' + transpilerPath);\r\n      }).call(goog.global);\r\n      // Even though the transpiler is optional, if $gwtExport is found, it's\r\n      // a sign the transpiler was loaded and the $jscomp.transpile *should*\r\n      // be there.\r\n      if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&\r\n          !goog.global['$gwtExport']['$jscomp']['transpile']) {\r\n        throw new Error(\r\n            'The transpiler did not properly export the \"transpile\" ' +\r\n            'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));\r\n      }\r\n      // transpile.js only exports a single $jscomp function, transpile. We\r\n      // grab just that and add it to the existing definition of $jscomp which\r\n      // contains the polyfills.\r\n      goog.global['$jscomp'].transpile =\r\n          goog.global['$gwtExport']['$jscomp']['transpile'];\r\n      jscomp = goog.global['$jscomp'];\r\n      transpile = jscomp.transpile;\r\n    }\r\n  }\r\n  if (!transpile) {\r\n    // The transpiler is an optional component.  If it's not available then\r\n    // replace it with a pass-through function that simply logs.\r\n    var suffix = ' requires transpilation but no transpiler was found.';\r\n    transpile = jscomp.transpile = function(code, path) {\r\n      // TODO(sdh): figure out some way to get this error to show up\r\n      // in test results, noting that the failure may occur in many\r\n      // different ways, including in loadModule() before the test\r\n      // runner even comes up.\r\n      goog.logToConsole_(path + suffix);\r\n      return code;\r\n    };\r\n  }\r\n  // Note: any transpilation errors/warnings will be logged to the console.\r\n  return transpile(code, path, target);\r\n};\r\n\r\n//==============================================================================\r\n// Language Enhancements\r\n//==============================================================================\r\n\r\n\r\n/**\r\n * This is a \"fixed\" version of the typeof operator.  It differs from the typeof\r\n * operator in such a way that null returns 'null' and arrays return 'array'.\r\n * @param {?} value The value to get the type of.\r\n * @return {string} The name of the type.\r\n */\r\ngoog.typeOf = function(value) {\r\n  var s = typeof value;\r\n  if (s == 'object') {\r\n    if (value) {\r\n      // Check these first, so we can avoid calling Object.prototype.toString if\r\n      // possible.\r\n      //\r\n      // IE improperly marshals typeof across execution contexts, but a\r\n      // cross-context object will still return false for \"instanceof Object\".\r\n      if (value instanceof Array) {\r\n        return 'array';\r\n      } else if (value instanceof Object) {\r\n        return s;\r\n      }\r\n\r\n      // HACK: In order to use an Object prototype method on the arbitrary\r\n      //   value, the compiler requires the value be cast to type Object,\r\n      //   even though the ECMA spec explicitly allows it.\r\n      var className = Object.prototype.toString.call(\r\n          /** @type {!Object} */ (value));\r\n      // In Firefox 3.6, attempting to access iframe window objects' length\r\n      // property throws an NS_ERROR_FAILURE, so we need to special-case it\r\n      // here.\r\n      if (className == '[object Window]') {\r\n        return 'object';\r\n      }\r\n\r\n      // We cannot always use constructor == Array or instanceof Array because\r\n      // different frames have different Array objects. In IE6, if the iframe\r\n      // where the array was created is destroyed, the array loses its\r\n      // prototype. Then dereferencing val.splice here throws an exception, so\r\n      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'\r\n      // so that will work. In this case, this function will return false and\r\n      // most array functions will still work because the array is still\r\n      // array-like (supports length and []) even though it has lost its\r\n      // prototype.\r\n      // Mark Miller noticed that Object.prototype.toString\r\n      // allows access to the unforgeable [[Class]] property.\r\n      //  15.2.4.2 Object.prototype.toString ( )\r\n      //  When the toString method is called, the following steps are taken:\r\n      //      1. Get the [[Class]] property of this object.\r\n      //      2. Compute a string value by concatenating the three strings\r\n      //         \"[object \", Result(1), and \"]\".\r\n      //      3. Return Result(2).\r\n      // and this behavior survives the destruction of the execution context.\r\n      if ((className == '[object Array]' ||\r\n           // In IE all non value types are wrapped as objects across window\r\n           // boundaries (not iframe though) so we have to do object detection\r\n           // for this edge case.\r\n           typeof value.length == 'number' &&\r\n               typeof value.splice != 'undefined' &&\r\n               typeof value.propertyIsEnumerable != 'undefined' &&\r\n               !value.propertyIsEnumerable('splice')\r\n\r\n               )) {\r\n        return 'array';\r\n      }\r\n      // HACK: There is still an array case that fails.\r\n      //     function ArrayImpostor() {}\r\n      //     ArrayImpostor.prototype = [];\r\n      //     var impostor = new ArrayImpostor;\r\n      // this can be fixed by getting rid of the fast path\r\n      // (value instanceof Array) and solely relying on\r\n      // (value && Object.prototype.toString.vall(value) === '[object Array]')\r\n      // but that would require many more function calls and is not warranted\r\n      // unless closure code is receiving objects from untrusted sources.\r\n\r\n      // IE in cross-window calls does not correctly marshal the function type\r\n      // (it appears just as an object) so we cannot use just typeof val ==\r\n      // 'function'. However, if the object has a call property, it is a\r\n      // function.\r\n      if ((className == '[object Function]' ||\r\n           typeof value.call != 'undefined' &&\r\n               typeof value.propertyIsEnumerable != 'undefined' &&\r\n               !value.propertyIsEnumerable('call'))) {\r\n        return 'function';\r\n      }\r\n\r\n    } else {\r\n      return 'null';\r\n    }\r\n\r\n  } else if (s == 'function' && typeof value.call == 'undefined') {\r\n    // In Safari typeof nodeList returns 'function', and on Firefox typeof\r\n    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We\r\n    // would like to return object for those and we can detect an invalid\r\n    // function by making sure that the function object has a call method.\r\n    return 'object';\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is null.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is null.\r\n */\r\ngoog.isNull = function(val) {\r\n  return val === null;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is defined and not null.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is defined and not null.\r\n */\r\ngoog.isDefAndNotNull = function(val) {\r\n  // Note that undefined == null.\r\n  return val != null;\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is an array.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an array.\r\n */\r\ngoog.isArray = function(val) {\r\n  return goog.typeOf(val) == 'array';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the object looks like an array. To qualify as array like\r\n * the value needs to be either a NodeList or an object with a Number length\r\n * property. Note that for this function neither strings nor functions are\r\n * considered \"array-like\".\r\n *\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an array.\r\n */\r\ngoog.isArrayLike = function(val) {\r\n  var type = goog.typeOf(val);\r\n  // We do not use goog.isObject here in order to exclude function values.\r\n  return type == 'array' || type == 'object' && typeof val.length == 'number';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the object looks like a Date. To qualify as Date-like the\r\n * value needs to be an object and have a getFullYear() function.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a like a Date.\r\n */\r\ngoog.isDateLike = function(val) {\r\n  return goog.isObject(val) && typeof val.getFullYear == 'function';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is a function.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is a function.\r\n */\r\ngoog.isFunction = function(val) {\r\n  return goog.typeOf(val) == 'function';\r\n};\r\n\r\n\r\n/**\r\n * Returns true if the specified value is an object.  This includes arrays and\r\n * functions.\r\n * @param {?} val Variable to test.\r\n * @return {boolean} Whether variable is an object.\r\n */\r\ngoog.isObject = function(val) {\r\n  var type = typeof val;\r\n  return type == 'object' && val != null || type == 'function';\r\n  // return Object(val) === val also works, but is slower, especially if val is\r\n  // not an object.\r\n};\r\n\r\n\r\n/**\r\n * Gets a unique ID for an object. This mutates the object so that further calls\r\n * with the same object as a parameter returns the same value. The unique ID is\r\n * guaranteed to be unique across the current session amongst objects that are\r\n * passed into `getUid`. There is no guarantee that the ID is unique or\r\n * consistent across sessions. It is unsafe to generate unique ID for function\r\n * prototypes.\r\n *\r\n * @param {Object} obj The object to get the unique ID for.\r\n * @return {number} The unique ID for the object.\r\n */\r\ngoog.getUid = function(obj) {\r\n  // TODO(arv): Make the type stricter, do not accept null.\r\n\r\n  // In Opera window.hasOwnProperty exists but always returns false so we avoid\r\n  // using it. As a consequence the unique ID generated for BaseClass.prototype\r\n  // and SubClass.prototype will be the same.\r\n  return obj[goog.UID_PROPERTY_] ||\r\n      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);\r\n};\r\n\r\n\r\n/**\r\n * Whether the given object is already assigned a unique ID.\r\n *\r\n * This does not modify the object.\r\n *\r\n * @param {!Object} obj The object to check.\r\n * @return {boolean} Whether there is an assigned unique id for the object.\r\n */\r\ngoog.hasUid = function(obj) {\r\n  return !!obj[goog.UID_PROPERTY_];\r\n};\r\n\r\n\r\n/**\r\n * Removes the unique ID from an object. This is useful if the object was\r\n * previously mutated using `goog.getUid` in which case the mutation is\r\n * undone.\r\n * @param {Object} obj The object to remove the unique ID field from.\r\n */\r\ngoog.removeUid = function(obj) {\r\n  // TODO(arv): Make the type stricter, do not accept null.\r\n\r\n  // In IE, DOM nodes are not instances of Object and throw an exception if we\r\n  // try to delete.  Instead we try to use removeAttribute.\r\n  if (obj !== null && 'removeAttribute' in obj) {\r\n    obj.removeAttribute(goog.UID_PROPERTY_);\r\n  }\r\n\r\n  try {\r\n    delete obj[goog.UID_PROPERTY_];\r\n  } catch (ex) {\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Name for unique ID property. Initialized in a way to help avoid collisions\r\n * with other closure JavaScript on the same page.\r\n * @type {string}\r\n * @private\r\n */\r\ngoog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);\r\n\r\n\r\n/**\r\n * Counter for UID.\r\n * @type {number}\r\n * @private\r\n */\r\ngoog.uidCounter_ = 0;\r\n\r\n\r\n/**\r\n * Adds a hash code field to an object. The hash code is unique for the\r\n * given object.\r\n * @param {Object} obj The object to get the hash code for.\r\n * @return {number} The hash code for the object.\r\n * @deprecated Use goog.getUid instead.\r\n */\r\ngoog.getHashCode = goog.getUid;\r\n\r\n\r\n/**\r\n * Removes the hash code field from an object.\r\n * @param {Object} obj The object to remove the field from.\r\n * @deprecated Use goog.removeUid instead.\r\n */\r\ngoog.removeHashCode = goog.removeUid;\r\n\r\n\r\n/**\r\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\r\n * arrays will be cloned recursively.\r\n *\r\n * WARNINGS:\r\n * <code>goog.cloneObject</code> does not detect reference loops. Objects that\r\n * refer to themselves will cause infinite recursion.\r\n *\r\n * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies\r\n * UIDs created by <code>getUid</code> into cloned results.\r\n *\r\n * @param {*} obj The value to clone.\r\n * @return {*} A clone of the input value.\r\n * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.\r\n */\r\ngoog.cloneObject = function(obj) {\r\n  var type = goog.typeOf(obj);\r\n  if (type == 'object' || type == 'array') {\r\n    if (typeof obj.clone === 'function') {\r\n      return obj.clone();\r\n    }\r\n    var clone = type == 'array' ? [] : {};\r\n    for (var key in obj) {\r\n      clone[key] = goog.cloneObject(obj[key]);\r\n    }\r\n    return clone;\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n\r\n/**\r\n * A native implementation of goog.bind.\r\n * @param {?function(this:T, ...)} fn A function to partially apply.\r\n * @param {T} selfObj Specifies the object which this should point to when the\r\n *     function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function goog.bind() was\r\n *     invoked as a method of.\r\n * @template T\r\n * @private\r\n */\r\ngoog.bindNative_ = function(fn, selfObj, var_args) {\r\n  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));\r\n};\r\n\r\n\r\n/**\r\n * A pure-JS implementation of goog.bind.\r\n * @param {?function(this:T, ...)} fn A function to partially apply.\r\n * @param {T} selfObj Specifies the object which this should point to when the\r\n *     function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function goog.bind() was\r\n *     invoked as a method of.\r\n * @template T\r\n * @private\r\n */\r\ngoog.bindJs_ = function(fn, selfObj, var_args) {\r\n  if (!fn) {\r\n    throw new Error();\r\n  }\r\n\r\n  if (arguments.length > 2) {\r\n    var boundArgs = Array.prototype.slice.call(arguments, 2);\r\n    return function() {\r\n      // Prepend the bound arguments to the current arguments.\r\n      var newArgs = Array.prototype.slice.call(arguments);\r\n      Array.prototype.unshift.apply(newArgs, boundArgs);\r\n      return fn.apply(selfObj, newArgs);\r\n    };\r\n\r\n  } else {\r\n    return function() {\r\n      return fn.apply(selfObj, arguments);\r\n    };\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Partially applies this function to a particular 'this object' and zero or\r\n * more arguments. The result is a new function with some arguments of the first\r\n * function pre-filled and the value of this 'pre-specified'.\r\n *\r\n * Remaining arguments specified at call-time are appended to the pre-specified\r\n * ones.\r\n *\r\n * Also see: {@link #partial}.\r\n *\r\n * Usage:\r\n * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');\r\n * barMethBound('arg3', 'arg4');</pre>\r\n *\r\n * @param {?function(this:T, ...)} fn A function to partially apply.\r\n * @param {T} selfObj Specifies the object which this should point to when the\r\n *     function is run.\r\n * @param {...*} var_args Additional arguments that are partially applied to the\r\n *     function.\r\n * @return {!Function} A partially-applied form of the function goog.bind() was\r\n *     invoked as a method of.\r\n * @template T\r\n * @suppress {deprecated} See above.\r\n */\r\ngoog.bind = function(fn, selfObj, var_args) {\r\n  // TODO(nicksantos): narrow the type signature.\r\n  if (Function.prototype.bind &&\r\n      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome\r\n      // extension environment. This means that for Chrome extensions, they get\r\n      // the implementation of Function.prototype.bind that calls goog.bind\r\n      // instead of the native one. Even worse, we don't want to introduce a\r\n      // circular dependency between goog.bind and Function.prototype.bind, so\r\n      // we have to hack this to make sure it works correctly.\r\n      Function.prototype.bind.toString().indexOf('native code') != -1) {\r\n    goog.bind = goog.bindNative_;\r\n  } else {\r\n    goog.bind = goog.bindJs_;\r\n  }\r\n  return goog.bind.apply(null, arguments);\r\n};\r\n\r\n\r\n/**\r\n * Like goog.bind(), except that a 'this object' is not required. Useful when\r\n * the target function is already bound.\r\n *\r\n * Usage:\r\n * var g = goog.partial(f, arg1, arg2);\r\n * g(arg3, arg4);\r\n *\r\n * @param {Function} fn A function to partially apply.\r\n * @param {...*} var_args Additional arguments that are partially applied to fn.\r\n * @return {!Function} A partially-applied form of the function goog.partial()\r\n *     was invoked as a method of.\r\n */\r\ngoog.partial = function(fn, var_args) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    // Clone the array (with slice()) and append additional arguments\r\n    // to the existing arguments.\r\n    var newArgs = args.slice();\r\n    newArgs.push.apply(newArgs, arguments);\r\n    return fn.apply(/** @type {?} */ (this), newArgs);\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Copies all the members of a source object to a target object. This method\r\n * does not work on all browsers for all objects that contain keys such as\r\n * toString or hasOwnProperty. Use goog.object.extend for this purpose.\r\n * @param {Object} target Target.\r\n * @param {Object} source Source.\r\n */\r\ngoog.mixin = function(target, source) {\r\n  for (var x in source) {\r\n    target[x] = source[x];\r\n  }\r\n\r\n  // For IE7 or lower, the for-in-loop does not contain any properties that are\r\n  // not enumerable on the prototype object (for example, isPrototypeOf from\r\n  // Object.prototype) but also it will not include 'replace' on objects that\r\n  // extend String and change 'replace' (not that it is common for anyone to\r\n  // extend anything except Object).\r\n};\r\n\r\n\r\n/**\r\n * @return {number} An integer value representing the number of milliseconds\r\n *     between midnight, January 1, 1970 and the current time.\r\n */\r\ngoog.now = (goog.TRUSTED_SITE && Date.now) || (function() {\r\n             // Unary plus operator converts its operand to a number which in\r\n             // the case of\r\n             // a date is done by calling getTime().\r\n             return +new Date();\r\n           });\r\n\r\n\r\n/**\r\n * Evals JavaScript in the global scope.  In IE this uses execScript, other\r\n * browsers use goog.global.eval. If goog.global.eval does not evaluate in the\r\n * global scope (for example, in Safari), appends a script tag instead.\r\n * Throws an exception if neither execScript or eval is defined.\r\n * @param {string} script JavaScript string.\r\n */\r\ngoog.globalEval = function(script) {\r\n  if (goog.global.execScript) {\r\n    goog.global.execScript(script, 'JavaScript');\r\n  } else if (goog.global.eval) {\r\n    // Test to see if eval works\r\n    if (goog.evalWorksForGlobals_ == null) {\r\n      try {\r\n        goog.global.eval('var _evalTest_ = 1;');\r\n      } catch (ignore) {\r\n      }\r\n      if (typeof goog.global['_evalTest_'] != 'undefined') {\r\n        try {\r\n          delete goog.global['_evalTest_'];\r\n        } catch (ignore) {\r\n          // Microsoft edge fails the deletion above in strict mode.\r\n        }\r\n        goog.evalWorksForGlobals_ = true;\r\n      } else {\r\n        goog.evalWorksForGlobals_ = false;\r\n      }\r\n    }\r\n\r\n    if (goog.evalWorksForGlobals_) {\r\n      goog.global.eval(script);\r\n    } else {\r\n      /** @type {!Document} */\r\n      var doc = goog.global.document;\r\n      var scriptElt =\r\n          /** @type {!HTMLScriptElement} */ (doc.createElement('SCRIPT'));\r\n      scriptElt.type = 'text/javascript';\r\n      scriptElt.defer = false;\r\n      // Note(user): can't use .innerHTML since \"t('<test>')\" will fail and\r\n      // .text doesn't work in Safari 2.  Therefore we append a text node.\r\n      scriptElt.appendChild(doc.createTextNode(script));\r\n      doc.head.appendChild(scriptElt);\r\n      doc.head.removeChild(scriptElt);\r\n    }\r\n  } else {\r\n    throw new Error('goog.globalEval not available');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Indicates whether or not we can call 'eval' directly to eval code in the\r\n * global scope. Set to a Boolean by the first call to goog.globalEval (which\r\n * empirically tests whether eval works for globals). @see goog.globalEval\r\n * @type {?boolean}\r\n * @private\r\n */\r\ngoog.evalWorksForGlobals_ = null;\r\n\r\n\r\n/**\r\n * Optional map of CSS class names to obfuscated names used with\r\n * goog.getCssName().\r\n * @private {!Object<string, string>|undefined}\r\n * @see goog.setCssNameMapping\r\n */\r\ngoog.cssNameMapping_;\r\n\r\n\r\n/**\r\n * Optional obfuscation style for CSS class names. Should be set to either\r\n * 'BY_WHOLE' or 'BY_PART' if defined.\r\n * @type {string|undefined}\r\n * @private\r\n * @see goog.setCssNameMapping\r\n */\r\ngoog.cssNameMappingStyle_;\r\n\r\n\r\n\r\n/**\r\n * A hook for modifying the default behavior goog.getCssName. The function\r\n * if present, will receive the standard output of the goog.getCssName as\r\n * its input.\r\n *\r\n * @type {(function(string):string)|undefined}\r\n */\r\ngoog.global.CLOSURE_CSS_NAME_MAP_FN;\r\n\r\n\r\n/**\r\n * Handles strings that are intended to be used as CSS class names.\r\n *\r\n * This function works in tandem with @see goog.setCssNameMapping.\r\n *\r\n * Without any mapping set, the arguments are simple joined with a hyphen and\r\n * passed through unaltered.\r\n *\r\n * When there is a mapping, there are two possible styles in which these\r\n * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)\r\n * of the passed in css name is rewritten according to the map. In the BY_WHOLE\r\n * style, the full css name is looked up in the map directly. If a rewrite is\r\n * not specified by the map, the compiler will output a warning.\r\n *\r\n * When the mapping is passed to the compiler, it will replace calls to\r\n * goog.getCssName with the strings from the mapping, e.g.\r\n *     var x = goog.getCssName('foo');\r\n *     var y = goog.getCssName(this.baseClass, 'active');\r\n *  becomes:\r\n *     var x = 'foo';\r\n *     var y = this.baseClass + '-active';\r\n *\r\n * If one argument is passed it will be processed, if two are passed only the\r\n * modifier will be processed, as it is assumed the first argument was generated\r\n * as a result of calling goog.getCssName.\r\n *\r\n * @param {string} className The class name.\r\n * @param {string=} opt_modifier A modifier to be appended to the class name.\r\n * @return {string} The class name or the concatenation of the class name and\r\n *     the modifier.\r\n */\r\ngoog.getCssName = function(className, opt_modifier) {\r\n  // String() is used for compatibility with compiled soy where the passed\r\n  // className can be non-string objects.\r\n  if (String(className).charAt(0) == '.') {\r\n    throw new Error(\r\n        'className passed in goog.getCssName must not start with \".\".' +\r\n        ' You passed: ' + className);\r\n  }\r\n\r\n  var getMapping = function(cssName) {\r\n    return goog.cssNameMapping_[cssName] || cssName;\r\n  };\r\n\r\n  var renameByParts = function(cssName) {\r\n    // Remap all the parts individually.\r\n    var parts = cssName.split('-');\r\n    var mapped = [];\r\n    for (var i = 0; i < parts.length; i++) {\r\n      mapped.push(getMapping(parts[i]));\r\n    }\r\n    return mapped.join('-');\r\n  };\r\n\r\n  var rename;\r\n  if (goog.cssNameMapping_) {\r\n    rename =\r\n        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;\r\n  } else {\r\n    rename = function(a) {\r\n      return a;\r\n    };\r\n  }\r\n\r\n  var result =\r\n      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);\r\n\r\n  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further\r\n  // processing of the class name.\r\n  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {\r\n    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Sets the map to check when returning a value from goog.getCssName(). Example:\r\n * <pre>\r\n * goog.setCssNameMapping({\r\n *   \"goog\": \"a\",\r\n *   \"disabled\": \"b\",\r\n * });\r\n *\r\n * var x = goog.getCssName('goog');\r\n * // The following evaluates to: \"a a-b\".\r\n * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')\r\n * </pre>\r\n * When declared as a map of string literals to string literals, the JSCompiler\r\n * will replace all calls to goog.getCssName() using the supplied map if the\r\n * --process_closure_primitives flag is set.\r\n *\r\n * @param {!Object} mapping A map of strings to strings where keys are possible\r\n *     arguments to goog.getCssName() and values are the corresponding values\r\n *     that should be returned.\r\n * @param {string=} opt_style The style of css name mapping. There are two valid\r\n *     options: 'BY_PART', and 'BY_WHOLE'.\r\n * @see goog.getCssName for a description.\r\n */\r\ngoog.setCssNameMapping = function(mapping, opt_style) {\r\n  goog.cssNameMapping_ = mapping;\r\n  goog.cssNameMappingStyle_ = opt_style;\r\n};\r\n\r\n\r\n/**\r\n * To use CSS renaming in compiled mode, one of the input files should have a\r\n * call to goog.setCssNameMapping() with an object literal that the JSCompiler\r\n * can extract and use to replace all calls to goog.getCssName(). In uncompiled\r\n * mode, JavaScript code should be loaded before this base.js file that declares\r\n * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is\r\n * to ensure that the mapping is loaded before any calls to goog.getCssName()\r\n * are made in uncompiled mode.\r\n *\r\n * A hook for overriding the CSS name mapping.\r\n * @type {!Object<string, string>|undefined}\r\n */\r\ngoog.global.CLOSURE_CSS_NAME_MAPPING;\r\n\r\n\r\nif (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {\r\n  // This does not call goog.setCssNameMapping() because the JSCompiler\r\n  // requires that goog.setCssNameMapping() be called with an object literal.\r\n  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;\r\n}\r\n\r\n\r\n/**\r\n * Gets a localized message.\r\n *\r\n * This function is a compiler primitive. If you give the compiler a localized\r\n * message bundle, it will replace the string at compile-time with a localized\r\n * version, and expand goog.getMsg call to a concatenated string.\r\n *\r\n * Messages must be initialized in the form:\r\n * <code>\r\n * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});\r\n * </code>\r\n *\r\n * This function produces a string which should be treated as plain text. Use\r\n * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to\r\n * produce SafeHtml.\r\n *\r\n * @param {string} str Translatable string, places holders in the form {$foo}.\r\n * @param {Object<string, string>=} opt_values Maps place holder name to value.\r\n * @return {string} message with placeholders filled.\r\n */\r\ngoog.getMsg = function(str, opt_values) {\r\n  if (opt_values) {\r\n    str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {\r\n      return (opt_values != null && key in opt_values) ? opt_values[key] :\r\n                                                         match;\r\n    });\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Gets a localized message. If the message does not have a translation, gives a\r\n * fallback message.\r\n *\r\n * This is useful when introducing a new message that has not yet been\r\n * translated into all languages.\r\n *\r\n * This function is a compiler primitive. Must be used in the form:\r\n * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>\r\n * where MSG_A and MSG_B were initialized with goog.getMsg.\r\n *\r\n * @param {string} a The preferred message.\r\n * @param {string} b The fallback message.\r\n * @return {string} The best translated message.\r\n */\r\ngoog.getMsgWithFallback = function(a, b) {\r\n  return a;\r\n};\r\n\r\n\r\n/**\r\n * Exposes an unobfuscated global namespace path for the given object.\r\n * Note that fields of the exported object *will* be obfuscated, unless they are\r\n * exported in turn via this function or goog.exportProperty.\r\n *\r\n * Also handy for making public items that are defined in anonymous closures.\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo', Foo);\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\r\n *     public.path.Foo.staticFunction();\r\n *\r\n * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\r\n *                       Foo.prototype.myMethod);\r\n *     new public.path.Foo().myMethod();\r\n *\r\n * @param {string} publicPath Unobfuscated name to export.\r\n * @param {*} object Object the name should point to.\r\n * @param {Object=} opt_objectToExportTo The object to add the path to; default\r\n *     is goog.global.\r\n */\r\ngoog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {\r\n  goog.exportPath_(publicPath, object, opt_objectToExportTo);\r\n};\r\n\r\n\r\n/**\r\n * Exports a property unobfuscated into the object's namespace.\r\n * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\r\n * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\r\n * @param {Object} object Object whose static property is being exported.\r\n * @param {string} publicName Unobfuscated name to export.\r\n * @param {*} symbol Object the name should point to.\r\n */\r\ngoog.exportProperty = function(object, publicName, symbol) {\r\n  object[publicName] = symbol;\r\n};\r\n\r\n\r\n/**\r\n * Inherit the prototype methods from one constructor into another.\r\n *\r\n * Usage:\r\n * <pre>\r\n * function ParentClass(a, b) { }\r\n * ParentClass.prototype.foo = function(a) { };\r\n *\r\n * function ChildClass(a, b, c) {\r\n *   ChildClass.base(this, 'constructor', a, b);\r\n * }\r\n * goog.inherits(ChildClass, ParentClass);\r\n *\r\n * var child = new ChildClass('a', 'b', 'see');\r\n * child.foo(); // This works.\r\n * </pre>\r\n *\r\n * @param {!Function} childCtor Child class.\r\n * @param {!Function} parentCtor Parent class.\r\n * @suppress {strictMissingProperties} superClass_ and base is not defined on\r\n *    Function.\r\n */\r\ngoog.inherits = function(childCtor, parentCtor) {\r\n  /** @constructor */\r\n  function tempCtor() {}\r\n  tempCtor.prototype = parentCtor.prototype;\r\n  childCtor.superClass_ = parentCtor.prototype;\r\n  childCtor.prototype = new tempCtor();\r\n  /** @override */\r\n  childCtor.prototype.constructor = childCtor;\r\n\r\n  /**\r\n   * Calls superclass constructor/method.\r\n   *\r\n   * This function is only available if you use goog.inherits to\r\n   * express inheritance relationships between classes.\r\n   *\r\n   * NOTE: This is a replacement for goog.base and for superClass_\r\n   * property defined in childCtor.\r\n   *\r\n   * @param {!Object} me Should always be \"this\".\r\n   * @param {string} methodName The method name to call. Calling\r\n   *     superclass constructor can be done with the special string\r\n   *     'constructor'.\r\n   * @param {...*} var_args The arguments to pass to superclass\r\n   *     method/constructor.\r\n   * @return {*} The return value of the superclass method/constructor.\r\n   */\r\n  childCtor.base = function(me, methodName, var_args) {\r\n    // Copying using loop to avoid deop due to passing arguments object to\r\n    // function. This is faster in many JS engines as of late 2014.\r\n    var args = new Array(arguments.length - 2);\r\n    for (var i = 2; i < arguments.length; i++) {\r\n      args[i - 2] = arguments[i];\r\n    }\r\n    return parentCtor.prototype[methodName].apply(me, args);\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Call up to the superclass.\r\n *\r\n * If this is called from a constructor, then this calls the superclass\r\n * constructor with arguments 1-N.\r\n *\r\n * If this is called from a prototype method, then you must pass the name of the\r\n * method as the second argument to this function. If you do not, you will get a\r\n * runtime error. This calls the superclass' method with arguments 2-N.\r\n *\r\n * This function only works if you use goog.inherits to express inheritance\r\n * relationships between your classes.\r\n *\r\n * This function is a compiler primitive. At compile-time, the compiler will do\r\n * macro expansion to remove a lot of the extra overhead that this function\r\n * introduces. The compiler will also enforce a lot of the assumptions that this\r\n * function makes, and treat it as a compiler error if you break them.\r\n *\r\n * @param {!Object} me Should always be \"this\".\r\n * @param {*=} opt_methodName The method name if calling a super method.\r\n * @param {...*} var_args The rest of the arguments.\r\n * @return {*} The return value of the superclass method.\r\n * @suppress {es5Strict} This method can not be used in strict mode, but\r\n *     all Closure Library consumers must depend on this file.\r\n * @deprecated goog.base is not strict mode compatible.  Prefer the static\r\n *     \"base\" method added to the constructor by goog.inherits\r\n *     or ES6 classes and the \"super\" keyword.\r\n */\r\ngoog.base = function(me, opt_methodName, var_args) {\r\n  var caller = arguments.callee.caller;\r\n\r\n  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {\r\n    throw new Error(\r\n        'arguments.caller not defined.  goog.base() cannot be used ' +\r\n        'with strict mode code. See ' +\r\n        'http://www.ecma-international.org/ecma-262/5.1/#sec-C');\r\n  }\r\n\r\n  if (typeof caller.superClass_ !== 'undefined') {\r\n    // Copying using loop to avoid deop due to passing arguments object to\r\n    // function. This is faster in many JS engines as of late 2014.\r\n    var ctorArgs = new Array(arguments.length - 1);\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      ctorArgs[i - 1] = arguments[i];\r\n    }\r\n    // This is a constructor. Call the superclass constructor.\r\n    return /** @type {!Function} */ (caller.superClass_)\r\n        .constructor.apply(me, ctorArgs);\r\n  }\r\n\r\n  if (typeof opt_methodName != 'string' && typeof opt_methodName != 'symbol') {\r\n    throw new Error(\r\n        'method names provided to goog.base must be a string or a symbol');\r\n  }\r\n\r\n  // Copying using loop to avoid deop due to passing arguments object to\r\n  // function. This is faster in many JS engines as of late 2014.\r\n  var args = new Array(arguments.length - 2);\r\n  for (var i = 2; i < arguments.length; i++) {\r\n    args[i - 2] = arguments[i];\r\n  }\r\n  var foundCaller = false;\r\n  for (var ctor = me.constructor; ctor;\r\n       ctor = ctor.superClass_ && ctor.superClass_.constructor) {\r\n    if (ctor.prototype[opt_methodName] === caller) {\r\n      foundCaller = true;\r\n    } else if (foundCaller) {\r\n      return ctor.prototype[opt_methodName].apply(me, args);\r\n    }\r\n  }\r\n\r\n  // If we did not find the caller in the prototype chain, then one of two\r\n  // things happened:\r\n  // 1) The caller is an instance method.\r\n  // 2) This method was not called by the right caller.\r\n  if (me[opt_methodName] === caller) {\r\n    return me.constructor.prototype[opt_methodName].apply(me, args);\r\n  } else {\r\n    throw new Error(\r\n        'goog.base called from a method of one name ' +\r\n        'to a method of a different name');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Allow for aliasing within scope functions.  This function exists for\r\n * uncompiled code - in compiled code the calls will be inlined and the aliases\r\n * applied.  In uncompiled code the function is simply run since the aliases as\r\n * written are valid JavaScript.\r\n *\r\n *\r\n * @param {function()} fn Function to call.  This function can contain aliases\r\n *     to namespaces (e.g. \"var dom = goog.dom\") or classes\r\n *     (e.g. \"var Timer = goog.Timer\").\r\n */\r\ngoog.scope = function(fn) {\r\n  if (goog.isInModuleLoader_()) {\r\n    throw new Error('goog.scope is not supported within a module.');\r\n  }\r\n  fn.call(goog.global);\r\n};\r\n\r\n\r\n/*\r\n * To support uncompiled, strict mode bundles that use eval to divide source\r\n * like so:\r\n *    eval('someSource;//# sourceUrl sourcefile.js');\r\n * We need to export the globally defined symbols \"goog\" and \"COMPILED\".\r\n * Exporting \"goog\" breaks the compiler optimizations, so we required that\r\n * be defined externally.\r\n * NOTE: We don't use goog.exportSymbol here because we don't want to trigger\r\n * extern generation when that compiler option is enabled.\r\n */\r\nif (!COMPILED) {\r\n  goog.global['COMPILED'] = COMPILED;\r\n}\r\n\r\n\r\n//==============================================================================\r\n// goog.defineClass implementation\r\n//==============================================================================\r\n\r\n\r\n/**\r\n * Creates a restricted form of a Closure \"class\":\r\n *   - from the compiler's perspective, the instance returned from the\r\n *     constructor is sealed (no new properties may be added).  This enables\r\n *     better checks.\r\n *   - the compiler will rewrite this definition to a form that is optimal\r\n *     for type checking and optimization (initially this will be a more\r\n *     traditional form).\r\n *\r\n * @param {Function} superClass The superclass, Object or null.\r\n * @param {goog.defineClass.ClassDescriptor} def\r\n *     An object literal describing\r\n *     the class.  It may have the following properties:\r\n *     \"constructor\": the constructor function\r\n *     \"statics\": an object literal containing methods to add to the constructor\r\n *        as \"static\" methods or a function that will receive the constructor\r\n *        function as its only parameter to which static properties can\r\n *        be added.\r\n *     all other properties are added to the prototype.\r\n * @return {!Function} The class constructor.\r\n */\r\ngoog.defineClass = function(superClass, def) {\r\n  // TODO(johnlenz): consider making the superClass an optional parameter.\r\n  var constructor = def.constructor;\r\n  var statics = def.statics;\r\n  // Wrap the constructor prior to setting up the prototype and static methods.\r\n  if (!constructor || constructor == Object.prototype.constructor) {\r\n    constructor = function() {\r\n      throw new Error(\r\n          'cannot instantiate an interface (no constructor defined).');\r\n    };\r\n  }\r\n\r\n  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);\r\n  if (superClass) {\r\n    goog.inherits(cls, superClass);\r\n  }\r\n\r\n  // Remove all the properties that should not be copied to the prototype.\r\n  delete def.constructor;\r\n  delete def.statics;\r\n\r\n  goog.defineClass.applyProperties_(cls.prototype, def);\r\n  if (statics != null) {\r\n    if (statics instanceof Function) {\r\n      statics(cls);\r\n    } else {\r\n      goog.defineClass.applyProperties_(cls, statics);\r\n    }\r\n  }\r\n\r\n  return cls;\r\n};\r\n\r\n\r\n/**\r\n * @typedef {{\r\n *   constructor: (!Function|undefined),\r\n *   statics: (Object|undefined|function(Function):void)\r\n * }}\r\n */\r\ngoog.defineClass.ClassDescriptor;\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the instances returned by goog.defineClass should\r\n *     be sealed when possible.\r\n *\r\n * When sealing is disabled the constructor function will not be wrapped by\r\n * goog.defineClass, making it incompatible with ES6 class methods.\r\n */\r\ngoog.defineClass.SEAL_CLASS_INSTANCES =\r\n    goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);\r\n\r\n\r\n/**\r\n * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is\r\n * defined, this function will wrap the constructor in a function that seals the\r\n * results of the provided constructor function.\r\n *\r\n * @param {!Function} ctr The constructor whose results maybe be sealed.\r\n * @param {Function} superClass The superclass constructor.\r\n * @return {!Function} The replacement constructor.\r\n * @private\r\n */\r\ngoog.defineClass.createSealingConstructor_ = function(ctr, superClass) {\r\n  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {\r\n    // Do now wrap the constructor when sealing is disabled. Angular code\r\n    // depends on this for injection to work properly.\r\n    return ctr;\r\n  }\r\n\r\n  // Compute whether the constructor is sealable at definition time, rather\r\n  // than when the instance is being constructed.\r\n  var superclassSealable = !goog.defineClass.isUnsealable_(superClass);\r\n\r\n  /**\r\n   * @this {Object}\r\n   * @return {?}\r\n   */\r\n  var wrappedCtr = function() {\r\n    // Don't seal an instance of a subclass when it calls the constructor of\r\n    // its super class as there is most likely still setup to do.\r\n    var instance = ctr.apply(this, arguments) || this;\r\n    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];\r\n\r\n    if (this.constructor === wrappedCtr && superclassSealable &&\r\n        Object.seal instanceof Function) {\r\n      Object.seal(instance);\r\n    }\r\n    return instance;\r\n  };\r\n\r\n  return wrappedCtr;\r\n};\r\n\r\n\r\n/**\r\n * @param {Function} ctr The constructor to test.\r\n * @return {boolean} Whether the constructor has been tagged as unsealable\r\n *     using goog.tagUnsealableClass.\r\n * @private\r\n */\r\ngoog.defineClass.isUnsealable_ = function(ctr) {\r\n  return ctr && ctr.prototype &&\r\n      ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];\r\n};\r\n\r\n\r\n// TODO(johnlenz): share these values with the goog.object\r\n/**\r\n * The names of the fields that are defined on Object.prototype.\r\n * @type {!Array<string>}\r\n * @private\r\n * @const\r\n */\r\ngoog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [\r\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\r\n  'toLocaleString', 'toString', 'valueOf'\r\n];\r\n\r\n\r\n// TODO(johnlenz): share this function with the goog.object\r\n/**\r\n * @param {!Object} target The object to add properties to.\r\n * @param {!Object} source The object to copy properties from.\r\n * @private\r\n */\r\ngoog.defineClass.applyProperties_ = function(target, source) {\r\n  // TODO(johnlenz): update this to support ES5 getters/setters\r\n\r\n  var key;\r\n  for (key in source) {\r\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n      target[key] = source[key];\r\n    }\r\n  }\r\n\r\n  // For IE the for-in-loop does not contain any properties that are not\r\n  // enumerable on the prototype object (for example isPrototypeOf from\r\n  // Object.prototype) and it will also not include 'replace' on objects that\r\n  // extend String and change 'replace' (not that it is common for anyone to\r\n  // extend anything except Object).\r\n  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {\r\n    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];\r\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n      target[key] = source[key];\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Sealing classes breaks the older idiom of assigning properties on the\r\n * prototype rather than in the constructor. As such, goog.defineClass\r\n * must not seal subclasses of these old-style classes until they are fixed.\r\n * Until then, this marks a class as \"broken\", instructing defineClass\r\n * not to seal subclasses.\r\n * @param {!Function} ctr The legacy constructor to tag as unsealable.\r\n */\r\ngoog.tagUnsealableClass = function(ctr) {\r\n  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {\r\n    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Name for unsealable tag property.\r\n * @const @private {string}\r\n */\r\ngoog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';\r\n\r\n\r\n// There's a bug in the compiler where without collapse properties the\r\n// Closure namespace defines do not guard code correctly. To help reduce code\r\n// size also check for !COMPILED even though it redundant until this is fixed.\r\nif (!COMPILED && goog.DEPENDENCIES_ENABLED) {\r\n\r\n  /**\r\n   * Tries to detect whether is in the context of an HTML document.\r\n   * @return {boolean} True if it looks like HTML document.\r\n   * @private\r\n   */\r\n  goog.inHtmlDocument_ = function() {\r\n    /** @type {!Document} */\r\n    var doc = goog.global.document;\r\n    return doc != null && 'write' in doc;  // XULDocument misses write.\r\n  };\r\n\r\n\r\n  /**\r\n   * We'd like to check for if the document readyState is 'loading'; however\r\n   * there are bugs on IE 10 and below where the readyState being anything other\r\n   * than 'complete' is not reliable.\r\n   * @return {boolean}\r\n   * @private\r\n   */\r\n  goog.isDocumentLoading_ = function() {\r\n    // attachEvent is available on IE 6 thru 10 only, and thus can be used to\r\n    // detect those browsers.\r\n    /** @type {!HTMLDocument} */\r\n    var doc = goog.global.document;\r\n    return doc.attachEvent ? doc.readyState != 'complete' :\r\n                             doc.readyState == 'loading';\r\n  };\r\n\r\n\r\n  /**\r\n   * Tries to detect the base path of base.js script that bootstraps Closure.\r\n   * @private\r\n   */\r\n  goog.findBasePath_ = function() {\r\n    if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &&\r\n        // Anti DOM-clobbering runtime check (b/37736576).\r\n        goog.isString(goog.global.CLOSURE_BASE_PATH)) {\r\n      goog.basePath = goog.global.CLOSURE_BASE_PATH;\r\n      return;\r\n    } else if (!goog.inHtmlDocument_()) {\r\n      return;\r\n    }\r\n    /** @type {!Document} */\r\n    var doc = goog.global.document;\r\n    // If we have a currentScript available, use it exclusively.\r\n    var currentScript = doc.currentScript;\r\n    if (currentScript) {\r\n      var scripts = [currentScript];\r\n    } else {\r\n      var scripts = doc.getElementsByTagName('SCRIPT');\r\n    }\r\n    // Search backwards since the current script is in almost all cases the one\r\n    // that has base.js.\r\n    for (var i = scripts.length - 1; i >= 0; --i) {\r\n      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);\r\n      var src = script.src;\r\n      var qmark = src.lastIndexOf('?');\r\n      var l = qmark == -1 ? src.length : qmark;\r\n      if (src.substr(l - 7, 7) == 'base.js') {\r\n        goog.basePath = src.substr(0, l - 7);\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  goog.findBasePath_();\r\n\r\n  /** @struct @constructor @final */\r\n  goog.Transpiler = function() {\r\n    /** @private {?Object<string, boolean>} */\r\n    this.requiresTranspilation_ = null;\r\n    /** @private {string} */\r\n    this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns a newly created map from language mode string to a boolean\r\n   * indicating whether transpilation should be done for that mode as well as\r\n   * the highest level language that this environment supports.\r\n   *\r\n   * Guaranteed invariant:\r\n   * For any two modes, l1 and l2 where l2 is a newer mode than l1,\r\n   * `map[l1] == true` implies that `map[l2] == true`.\r\n   *\r\n   * Note this method is extracted and used elsewhere, so it cannot rely on\r\n   * anything external (it should easily be able to be transformed into a\r\n   * standalone, top level function).\r\n   *\r\n   * @private\r\n   * @return {{\r\n   *   target: string,\r\n   *   map: !Object<string, boolean>\r\n   * }}\r\n   */\r\n  goog.Transpiler.prototype.createRequiresTranspilation_ = function() {\r\n    var transpilationTarget = 'es3';\r\n    var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};\r\n    var transpilationRequiredForAllLaterModes = false;\r\n\r\n    /**\r\n     * Adds an entry to requiresTranspliation for the given language mode.\r\n     *\r\n     * IMPORTANT: Calls must be made in order from oldest to newest language\r\n     * mode.\r\n     * @param {string} modeName\r\n     * @param {function(): boolean} isSupported Returns true if the JS engine\r\n     *     supports the given mode.\r\n     */\r\n    function addNewerLanguageTranspilationCheck(modeName, isSupported) {\r\n      if (transpilationRequiredForAllLaterModes) {\r\n        requiresTranspilation[modeName] = true;\r\n      } else if (isSupported()) {\r\n        transpilationTarget = modeName;\r\n        requiresTranspilation[modeName] = false;\r\n      } else {\r\n        requiresTranspilation[modeName] = true;\r\n        transpilationRequiredForAllLaterModes = true;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Does the given code evaluate without syntax errors and return a truthy\r\n     * result?\r\n     */\r\n    function /** boolean */ evalCheck(/** string */ code) {\r\n      try {\r\n        return !!eval(code);\r\n      } catch (ignored) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?\r\n        goog.global.navigator.userAgent :\r\n        '';\r\n\r\n    // Identify ES3-only browsers by their incorrect treatment of commas.\r\n    addNewerLanguageTranspilationCheck('es5', function() {\r\n      return evalCheck('[1,].length==1');\r\n    });\r\n    addNewerLanguageTranspilationCheck('es6', function() {\r\n      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:\r\n      // https://github.com/Microsoft/ChakraCore/issues/1496.\r\n      var re = /Edge\\/(\\d+)(\\.\\d)*/i;\r\n      var edgeUserAgent = userAgent.match(re);\r\n      if (edgeUserAgent) {\r\n        // The Reflect.construct test below is flaky on Edge. It can sometimes\r\n        // pass or fail on 40 15.15063, so just exit early for Edge and treat\r\n        // it as ES5. Until we're on a more up to date version just always use\r\n        // ES5. See https://github.com/Microsoft/ChakraCore/issues/3217.\r\n        return false;\r\n      }\r\n      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]\r\n      //   (a) default params (specifically shadowing locals),\r\n      //   (b) destructuring, (c) block-scoped functions,\r\n      //   (d) for-of (const), (e) new.target/Reflect.construct\r\n      var es6fullTest =\r\n          'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +\r\n          'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +\r\n          'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +\r\n          'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +\r\n          '==3}';\r\n\r\n      return evalCheck('(()=>{\"use strict\";' + es6fullTest + '})()');\r\n    });\r\n    // ** and **= are the only new features in 'es7'\r\n    addNewerLanguageTranspilationCheck('es7', function() {\r\n      return evalCheck('2 ** 2 == 4');\r\n    });\r\n    // async functions are the only new features in 'es8'\r\n    addNewerLanguageTranspilationCheck('es8', function() {\r\n      return evalCheck('async () => 1, true');\r\n    });\r\n    addNewerLanguageTranspilationCheck('es9', function() {\r\n      return evalCheck('({...rest} = {}), true');\r\n    });\r\n    addNewerLanguageTranspilationCheck('es_next', function() {\r\n      return false;  // assume it always need to transpile\r\n    });\r\n    return {target: transpilationTarget, map: requiresTranspilation};\r\n  };\r\n\r\n\r\n  /**\r\n   * Determines whether the given language needs to be transpiled.\r\n   * @param {string} lang\r\n   * @param {string|undefined} module\r\n   * @return {boolean}\r\n   */\r\n  goog.Transpiler.prototype.needsTranspile = function(lang, module) {\r\n    if (goog.TRANSPILE == 'always') {\r\n      return true;\r\n    } else if (goog.TRANSPILE == 'never') {\r\n      return false;\r\n    } else if (!this.requiresTranspilation_) {\r\n      var obj = this.createRequiresTranspilation_();\r\n      this.requiresTranspilation_ = obj.map;\r\n      this.transpilationTarget_ = this.transpilationTarget_ || obj.target;\r\n    }\r\n    if (lang in this.requiresTranspilation_) {\r\n      if (this.requiresTranspilation_[lang]) {\r\n        return true;\r\n      } else if (\r\n          goog.inHtmlDocument_() && module == 'es6' &&\r\n          !('noModule' in goog.global.document.createElement('script'))) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      throw new Error('Unknown language mode: ' + lang);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Lazily retrieves the transpiler and applies it to the source.\r\n   * @param {string} code JS code.\r\n   * @param {string} path Path to the code.\r\n   * @return {string} The transpiled code.\r\n   */\r\n  goog.Transpiler.prototype.transpile = function(code, path) {\r\n    // TODO(johnplaisted): We should delete goog.transpile_ and just have this\r\n    // function. But there's some compile error atm where goog.global is being\r\n    // stripped incorrectly without this.\r\n    return goog.transpile_(code, path, this.transpilationTarget_);\r\n  };\r\n\r\n\r\n  /** @private @final {!goog.Transpiler} */\r\n  goog.transpiler_ = new goog.Transpiler();\r\n\r\n  /**\r\n   * Rewrites closing script tags in input to avoid ending an enclosing script\r\n   * tag.\r\n   *\r\n   * @param {string} str\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  goog.protectScriptTag_ = function(str) {\r\n    return str.replace(/<\\/(SCRIPT)/ig, '\\\\x3c/$1');\r\n  };\r\n\r\n\r\n  /**\r\n   * A debug loader is responsible for downloading and executing javascript\r\n   * files in an unbundled, uncompiled environment.\r\n   *\r\n   * This can be custimized via the setDependencyFactory method, or by\r\n   * CLOSURE_IMPORT_SCRIPT/CLOSURE_LOAD_FILE_SYNC.\r\n   *\r\n   * @struct @constructor @final @private\r\n   */\r\n  goog.DebugLoader_ = function() {\r\n    /** @private @const {!Object<string, !goog.Dependency>} */\r\n    this.dependencies_ = {};\r\n    /** @private @const {!Object<string, string>} */\r\n    this.idToPath_ = {};\r\n    /** @private @const {!Object<string, boolean>} */\r\n    this.written_ = {};\r\n    /** @private @const {!Array<!goog.Dependency>} */\r\n    this.loadingDeps_ = [];\r\n    /** @private {!Array<!goog.Dependency>} */\r\n    this.depsToLoad_ = [];\r\n    /** @private {boolean} */\r\n    this.paused_ = false;\r\n    /** @private {!goog.DependencyFactory} */\r\n    this.factory_ = new goog.DependencyFactory(goog.transpiler_);\r\n    /** @private @const {!Object<string, !Function>} */\r\n    this.deferredCallbacks_ = {};\r\n    /** @private @const {!Array<string>} */\r\n    this.deferredQueue_ = [];\r\n  };\r\n\r\n  /**\r\n   * @param {!Array<string>} namespaces\r\n   * @param {function(): undefined} callback Function to call once all the\r\n   *     namespaces have loaded.\r\n   */\r\n  goog.DebugLoader_.prototype.bootstrap = function(namespaces, callback) {\r\n    var cb = callback;\r\n    function resolve() {\r\n      if (cb) {\r\n        goog.global.setTimeout(cb, 0);\r\n        cb = null;\r\n      }\r\n    }\r\n\r\n    if (!namespaces.length) {\r\n      resolve();\r\n      return;\r\n    }\r\n\r\n    var deps = [];\r\n    for (var i = 0; i < namespaces.length; i++) {\r\n      var path = this.getPathFromDeps_(namespaces[i]);\r\n      if (!path) {\r\n        throw new Error('Unregonized namespace: ' + namespaces[i]);\r\n      }\r\n      deps.push(this.dependencies_[path]);\r\n    }\r\n\r\n    var require = goog.require;\r\n    var loaded = 0;\r\n    for (var i = 0; i < namespaces.length; i++) {\r\n      require(namespaces[i]);\r\n      deps[i].onLoad(function() {\r\n        if (++loaded == namespaces.length) {\r\n          resolve();\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Loads the Closure Dependency file.\r\n   *\r\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\r\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\r\n   * custom loading of the deps file.\r\n   */\r\n  goog.DebugLoader_.prototype.loadClosureDeps = function() {\r\n    // Circumvent addDependency, which would try to transpile deps.js if\r\n    // transpile is set to always.\r\n    var relPath = 'deps.js';\r\n    this.depsToLoad_.push(this.factory_.createDependency(\r\n        goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {},\r\n        false));\r\n    this.loadDeps_();\r\n  };\r\n\r\n\r\n  /**\r\n   * Notifies the debug loader when a dependency has been requested.\r\n   *\r\n   * @param {string} absPathOrId Path of the dependency or goog id.\r\n   * @param {boolean=} opt_force\r\n   */\r\n  goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {\r\n    var path = this.getPathFromDeps_(absPathOrId);\r\n    if (path &&\r\n        (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {\r\n      var callback = this.deferredCallbacks_[path];\r\n      if (callback) {\r\n        delete this.deferredCallbacks_[path];\r\n        callback();\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the dependency factory, which can be used to create custom\r\n   * goog.Dependency implementations to control how dependencies are loaded.\r\n   *\r\n   * @param {!goog.DependencyFactory} factory\r\n   */\r\n  goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {\r\n    this.factory_ = factory;\r\n  };\r\n\r\n\r\n  /**\r\n   * Travserses the dependency graph and queues the given dependency, and all of\r\n   * its transitive dependencies, for loading and then starts loading if not\r\n   * paused.\r\n   *\r\n   * @param {string} namespace\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.load_ = function(namespace) {\r\n    if (!this.getPathFromDeps_(namespace)) {\r\n      var errorMessage = 'goog.require could not find: ' + namespace;\r\n\r\n      goog.logToConsole_(errorMessage);\r\n      throw Error(errorMessage);\r\n    } else {\r\n      var loader = this;\r\n\r\n      var deps = [];\r\n\r\n      /** @param {string} namespace */\r\n      var visit = function(namespace) {\r\n        var path = loader.getPathFromDeps_(namespace);\r\n\r\n        if (!path) {\r\n          throw new Error('Bad dependency path or symbol: ' + namespace);\r\n        }\r\n\r\n        if (loader.written_[path]) {\r\n          return;\r\n        }\r\n\r\n        loader.written_[path] = true;\r\n\r\n        var dep = loader.dependencies_[path];\r\n        for (var i = 0; i < dep.requires.length; i++) {\r\n          if (!goog.isProvided_(dep.requires[i])) {\r\n            visit(dep.requires[i]);\r\n          }\r\n        }\r\n\r\n        deps.push(dep);\r\n      };\r\n\r\n      visit(namespace);\r\n\r\n      var wasLoading = !!this.depsToLoad_.length;\r\n      this.depsToLoad_ = this.depsToLoad_.concat(deps);\r\n\r\n      if (!this.paused_ && !wasLoading) {\r\n        this.loadDeps_();\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Loads any queued dependencies until they are all loaded or paused.\r\n   *\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.loadDeps_ = function() {\r\n    var loader = this;\r\n    var paused = this.paused_;\r\n\r\n    while (this.depsToLoad_.length && !paused) {\r\n      (function() {\r\n        var loadCallDone = false;\r\n        var dep = loader.depsToLoad_.shift();\r\n\r\n        var loaded = false;\r\n        loader.loading_(dep);\r\n\r\n        var controller = {\r\n          pause: function() {\r\n            if (loadCallDone) {\r\n              throw new Error('Cannot call pause after the call to load.');\r\n            } else {\r\n              paused = true;\r\n            }\r\n          },\r\n          resume: function() {\r\n            if (loadCallDone) {\r\n              loader.resume_();\r\n            } else {\r\n              // Some dep called pause and then resume in the same load call.\r\n              // Just keep running this same loop.\r\n              paused = false;\r\n            }\r\n          },\r\n          loaded: function() {\r\n            if (loaded) {\r\n              throw new Error('Double call to loaded.');\r\n            }\r\n\r\n            loaded = true;\r\n            loader.loaded_(dep);\r\n          },\r\n          pending: function() {\r\n            // Defensive copy.\r\n            var pending = [];\r\n            for (var i = 0; i < loader.loadingDeps_.length; i++) {\r\n              pending.push(loader.loadingDeps_[i]);\r\n            }\r\n            return pending;\r\n          },\r\n          /**\r\n           * @param {goog.ModuleType} type\r\n           */\r\n          setModuleState: function(type) {\r\n            goog.moduleLoaderState_ = {\r\n              type: type,\r\n              moduleName: '',\r\n              declareLegacyNamespace: false\r\n            };\r\n          },\r\n          /** @type {function(string, string, string=)} */\r\n          registerEs6ModuleExports: function(\r\n              path, exports, opt_closureNamespace) {\r\n            if (opt_closureNamespace) {\r\n              goog.loadedModules_[opt_closureNamespace] = {\r\n                exports: exports,\r\n                type: goog.ModuleType.ES6,\r\n                moduleId: opt_closureNamespace || ''\r\n              };\r\n            }\r\n          },\r\n          /** @type {function(string, ?)} */\r\n          registerGoogModuleExports: function(moduleId, exports) {\r\n            goog.loadedModules_[moduleId] = {\r\n              exports: exports,\r\n              type: goog.ModuleType.GOOG,\r\n              moduleId: moduleId\r\n            };\r\n          },\r\n          clearModuleState: function() {\r\n            goog.moduleLoaderState_ = null;\r\n          },\r\n          defer: function(callback) {\r\n            if (loadCallDone) {\r\n              throw new Error(\r\n                  'Cannot register with defer after the call to load.');\r\n            }\r\n            loader.defer_(dep, callback);\r\n          },\r\n          areDepsLoaded: function() {\r\n            return loader.areDepsLoaded_(dep.requires);\r\n          }\r\n        };\r\n\r\n        try {\r\n          dep.load(controller);\r\n        } finally {\r\n          loadCallDone = true;\r\n        }\r\n      })();\r\n    }\r\n\r\n    if (paused) {\r\n      this.pause_();\r\n    }\r\n  };\r\n\r\n\r\n  /** @private */\r\n  goog.DebugLoader_.prototype.pause_ = function() {\r\n    this.paused_ = true;\r\n  };\r\n\r\n\r\n  /** @private */\r\n  goog.DebugLoader_.prototype.resume_ = function() {\r\n    if (this.paused_) {\r\n      this.paused_ = false;\r\n      this.loadDeps_();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Marks the given dependency as loading (load has been called but it has not\r\n   * yet marked itself as finished). Useful for dependencies that want to know\r\n   * what else is loading. Example: goog.modules cannot eval if there are\r\n   * loading dependencies.\r\n   *\r\n   * @param {!goog.Dependency} dep\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.loading_ = function(dep) {\r\n    this.loadingDeps_.push(dep);\r\n  };\r\n\r\n\r\n  /**\r\n   * Marks the given dependency as having finished loading and being available\r\n   * for require.\r\n   *\r\n   * @param {!goog.Dependency} dep\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.loaded_ = function(dep) {\r\n    for (var i = 0; i < this.loadingDeps_.length; i++) {\r\n      if (this.loadingDeps_[i] == dep) {\r\n        this.loadingDeps_.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < this.deferredQueue_.length; i++) {\r\n      if (this.deferredQueue_[i] == dep.path) {\r\n        this.deferredQueue_.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (this.loadingDeps_.length == this.deferredQueue_.length &&\r\n        !this.depsToLoad_.length) {\r\n      // Something has asked to load these, but they may not be directly\r\n      // required again later, so load them now that we know we're done loading\r\n      // everything else. e.g. a goog module entry point.\r\n      while (this.deferredQueue_.length) {\r\n        this.requested(this.deferredQueue_.shift(), true);\r\n      }\r\n    }\r\n\r\n    dep.loaded();\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {!Array<string>} pathsOrIds\r\n   * @return {boolean}\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {\r\n    for (var i = 0; i < pathsOrIds.length; i++) {\r\n      var path = this.getPathFromDeps_(pathsOrIds[i]);\r\n      if (!path ||\r\n          (!(path in this.deferredCallbacks_) &&\r\n           !goog.isProvided_(pathsOrIds[i]))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} absPathOrId\r\n   * @return {?string}\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {\r\n    if (absPathOrId in this.idToPath_) {\r\n      return this.idToPath_[absPathOrId];\r\n    } else if (absPathOrId in this.dependencies_) {\r\n      return absPathOrId;\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {!goog.Dependency} dependency\r\n   * @param {!Function} callback\r\n   * @private\r\n   */\r\n  goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {\r\n    this.deferredCallbacks_[dependency.path] = callback;\r\n    this.deferredQueue_.push(dependency.path);\r\n  };\r\n\r\n\r\n  /**\r\n   * Interface for goog.Dependency implementations to have some control over\r\n   * loading of dependencies.\r\n   *\r\n   * @record\r\n   */\r\n  goog.LoadController = function() {};\r\n\r\n\r\n  /**\r\n   * Tells the controller to halt loading of more dependencies.\r\n   */\r\n  goog.LoadController.prototype.pause = function() {};\r\n\r\n\r\n  /**\r\n   * Tells the controller to resume loading of more dependencies if paused.\r\n   */\r\n  goog.LoadController.prototype.resume = function() {};\r\n\r\n\r\n  /**\r\n   * Tells the controller that this dependency has finished loading.\r\n   *\r\n   * This causes this to be removed from pending() and any load callbacks to\r\n   * fire.\r\n   */\r\n  goog.LoadController.prototype.loaded = function() {};\r\n\r\n\r\n  /**\r\n   * List of dependencies on which load has been called but which have not\r\n   * called loaded on their controller. This includes the current dependency.\r\n   *\r\n   * @return {!Array<!goog.Dependency>}\r\n   */\r\n  goog.LoadController.prototype.pending = function() {};\r\n\r\n\r\n  /**\r\n   * Registers an object as an ES6 module's exports so that goog.modules may\r\n   * require it by path.\r\n   *\r\n   * @param {string} path Full path of the module.\r\n   * @param {?} exports\r\n   * @param {string=} opt_closureNamespace Closure namespace to associate with\r\n   *     this module.\r\n   */\r\n  goog.LoadController.prototype.registerEs6ModuleExports = function(\r\n      path, exports, opt_closureNamespace) {};\r\n\r\n\r\n  /**\r\n   * Sets the current module state.\r\n   *\r\n   * @param {goog.ModuleType} type Type of module.\r\n   */\r\n  goog.LoadController.prototype.setModuleState = function(type) {};\r\n\r\n\r\n  /**\r\n   * Clears the current module state.\r\n   */\r\n  goog.LoadController.prototype.clearModuleState = function() {};\r\n\r\n\r\n  /**\r\n   * Registers a callback to call once the dependency is actually requested\r\n   * via goog.require + all of the immediate dependencies have been loaded or\r\n   * all other files have been loaded. Allows for lazy loading until\r\n   * require'd without pausing dependency loading, which is needed on old IE.\r\n   *\r\n   * @param {!Function} callback\r\n   */\r\n  goog.LoadController.prototype.defer = function(callback) {};\r\n\r\n\r\n  /**\r\n   * @return {boolean}\r\n   */\r\n  goog.LoadController.prototype.areDepsLoaded = function() {};\r\n\r\n\r\n  /**\r\n   * Basic super class for all dependencies Closure Library can load.\r\n   *\r\n   * This default implementation is designed to load untranspiled, non-module\r\n   * scripts in a web broswer.\r\n   *\r\n   * For transpiled non-goog.module files {@see goog.TranspiledDependency}.\r\n   * For goog.modules see {@see goog.GoogModuleDependency}.\r\n   * For untranspiled ES6 modules {@see goog.Es6ModuleDependency}.\r\n   *\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\r\n   *     in this file.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @struct @constructor\r\n   */\r\n  goog.Dependency = function(\r\n      path, relativePath, provides, requires, loadFlags) {\r\n    /** @const */\r\n    this.path = path;\r\n    /** @const */\r\n    this.relativePath = relativePath;\r\n    /** @const */\r\n    this.provides = provides;\r\n    /** @const */\r\n    this.requires = requires;\r\n    /** @const */\r\n    this.loadFlags = loadFlags;\r\n    /** @private {boolean} */\r\n    this.loaded_ = false;\r\n    /** @private {!Array<function()>} */\r\n    this.loadCallbacks_ = [];\r\n  };\r\n\r\n\r\n  /**\r\n   * @return {string} The pathname part of this dependency's path if it is a\r\n   *     URI.\r\n   */\r\n  goog.Dependency.prototype.getPathName = function() {\r\n    var pathName = this.path;\r\n    var protocolIndex = pathName.indexOf('://');\r\n    if (protocolIndex >= 0) {\r\n      pathName = pathName.substring(protocolIndex + 3);\r\n      var slashIndex = pathName.indexOf('/');\r\n      if (slashIndex >= 0) {\r\n        pathName = pathName.substring(slashIndex + 1);\r\n      }\r\n    }\r\n    return pathName;\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {function()} callback Callback to fire as soon as this has loaded.\r\n   * @final\r\n   */\r\n  goog.Dependency.prototype.onLoad = function(callback) {\r\n    if (this.loaded_) {\r\n      callback();\r\n    } else {\r\n      this.loadCallbacks_.push(callback);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Marks this dependency as loaded and fires any callbacks registered with\r\n   * onLoad.\r\n   * @final\r\n   */\r\n  goog.Dependency.prototype.loaded = function() {\r\n    this.loaded_ = true;\r\n    var callbacks = this.loadCallbacks_;\r\n    this.loadCallbacks_ = [];\r\n    for (var i = 0; i < callbacks.length; i++) {\r\n      callbacks[i]();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Whether or not document.written / appended script tags should be deferred.\r\n   *\r\n   * @private {boolean}\r\n   */\r\n  goog.Dependency.defer_ = false;\r\n\r\n\r\n  /**\r\n   * Map of script ready / state change callbacks. Old IE cannot handle putting\r\n   * these properties on goog.global.\r\n   *\r\n   * @private @const {!Object<string, function(?):undefined>}\r\n   */\r\n  goog.Dependency.callbackMap_ = {};\r\n\r\n\r\n  /**\r\n   * @param {function(...?):?} callback\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  goog.Dependency.registerCallback_ = function(callback) {\r\n    var key = Math.random().toString(32);\r\n    goog.Dependency.callbackMap_[key] = callback;\r\n    return key;\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} key\r\n   * @private\r\n   */\r\n  goog.Dependency.unregisterCallback_ = function(key) {\r\n    delete goog.Dependency.callbackMap_[key];\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} key\r\n   * @param {...?} var_args\r\n   * @private\r\n   * @suppress {unusedPrivateMembers}\r\n   */\r\n  goog.Dependency.callback_ = function(key, var_args) {\r\n    if (key in goog.Dependency.callbackMap_) {\r\n      var callback = goog.Dependency.callbackMap_[key];\r\n      var args = [];\r\n      for (var i = 1; i < arguments.length; i++) {\r\n        args.push(arguments[i]);\r\n      }\r\n      callback.apply(undefined, args);\r\n    } else {\r\n      var errorMessage = 'Callback key ' + key +\r\n          ' does not exist (was base.js loaded more than once?).';\r\n      throw Error(errorMessage);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Starts loading this dependency. This dependency can pause loading if it\r\n   * needs to and resume it later via the controller interface.\r\n   *\r\n   * When this is loaded it should call controller.loaded(). Note that this will\r\n   * end up calling the loaded method of this dependency; there is no need to\r\n   * call it explicitly.\r\n   *\r\n   * @param {!goog.LoadController} controller\r\n   */\r\n  goog.Dependency.prototype.load = function(controller) {\r\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\r\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\r\n        controller.loaded();\r\n      } else {\r\n        controller.pause();\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!goog.inHtmlDocument_()) {\r\n      goog.logToConsole_(\r\n          'Cannot use default debug loader outside of HTML documents.');\r\n      if (this.relativePath == 'deps.js') {\r\n        // Some old code is relying on base.js auto loading deps.js failing with\r\n        // no error before later setting CLOSURE_IMPORT_SCRIPT.\r\n        // CLOSURE_IMPORT_SCRIPT should be set *before* base.js is loaded, or\r\n        // CLOSURE_NO_DEPS set to true.\r\n        goog.logToConsole_(\r\n            'Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, ' +\r\n            'or setting CLOSURE_NO_DEPS to true.');\r\n        controller.loaded();\r\n      } else {\r\n        controller.pause();\r\n      }\r\n      return;\r\n    }\r\n\r\n    /** @type {!HTMLDocument} */\r\n    var doc = goog.global.document;\r\n\r\n    // If the user tries to require a new symbol after document load,\r\n    // something has gone terribly wrong. Doing a document.write would\r\n    // wipe out the page. This does not apply to the CSP-compliant method\r\n    // of writing script tags.\r\n    if (doc.readyState == 'complete' &&\r\n        !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {\r\n      // Certain test frameworks load base.js multiple times, which tries\r\n      // to write deps.js each time. If that happens, just fail silently.\r\n      // These frameworks wipe the page between each load of base.js, so this\r\n      // is OK.\r\n      var isDeps = /\\bdeps.js$/.test(this.path);\r\n      if (isDeps) {\r\n        controller.loaded();\r\n        return;\r\n      } else {\r\n        throw Error('Cannot write \"' + this.path + '\" after document load');\r\n      }\r\n    }\r\n\r\n    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&\r\n        goog.isDocumentLoading_()) {\r\n      var key = goog.Dependency.registerCallback_(function(script) {\r\n        if (!goog.DebugLoader_.IS_OLD_IE_ || script.readyState == 'complete') {\r\n          goog.Dependency.unregisterCallback_(key);\r\n          controller.loaded();\r\n        }\r\n      });\r\n      var nonceAttr = !goog.DebugLoader_.IS_OLD_IE_ && goog.getScriptNonce() ?\r\n          ' nonce=\"' + goog.getScriptNonce() + '\"' :\r\n          '';\r\n      var event =\r\n          goog.DebugLoader_.IS_OLD_IE_ ? 'onreadystatechange' : 'onload';\r\n      var defer = goog.Dependency.defer_ ? 'defer' : '';\r\n      var script = '<script src=\"' + this.path + '\" ' + event +\r\n          '=\"goog.Dependency.callback_(\\'' + key +\r\n          '\\', this)\" type=\"text/javascript\" ' + defer + nonceAttr + '><' +\r\n          '/script>';\r\n      doc.write(\r\n          goog.TRUSTED_TYPES_POLICY_ ?\r\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\r\n              script);\r\n    } else {\r\n      var scriptEl =\r\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\r\n      scriptEl.defer = goog.Dependency.defer_;\r\n      scriptEl.async = false;\r\n      scriptEl.type = 'text/javascript';\r\n\r\n      // If CSP nonces are used, propagate them to dynamically created scripts.\r\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\r\n      var nonce = goog.getScriptNonce();\r\n      if (nonce) {\r\n        scriptEl.setAttribute('nonce', nonce);\r\n      }\r\n\r\n      if (goog.DebugLoader_.IS_OLD_IE_) {\r\n        // Execution order is not guaranteed on old IE, halt loading and write\r\n        // these scripts one at a time, after each loads.\r\n        controller.pause();\r\n        scriptEl.onreadystatechange = function() {\r\n          if (scriptEl.readyState == 'loaded' ||\r\n              scriptEl.readyState == 'complete') {\r\n            controller.loaded();\r\n            controller.resume();\r\n          }\r\n        };\r\n      } else {\r\n        scriptEl.onload = function() {\r\n          scriptEl.onload = null;\r\n          controller.loaded();\r\n        };\r\n      }\r\n\r\n      scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\r\n          goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) :\r\n          this.path;\r\n      doc.head.appendChild(scriptEl);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides Should be an empty array.\r\n   *     TODO(johnplaisted) add support for adding closure namespaces to ES6\r\n   *     modules for interop purposes.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @struct @constructor\r\n   * @extends {goog.Dependency}\r\n   */\r\n  goog.Es6ModuleDependency = function(\r\n      path, relativePath, provides, requires, loadFlags) {\r\n    goog.Es6ModuleDependency.base(\r\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\r\n  };\r\n  goog.inherits(goog.Es6ModuleDependency, goog.Dependency);\r\n\r\n\r\n  /** @override */\r\n  goog.Es6ModuleDependency.prototype.load = function(controller) {\r\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\r\n      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {\r\n        controller.loaded();\r\n      } else {\r\n        controller.pause();\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!goog.inHtmlDocument_()) {\r\n      goog.logToConsole_(\r\n          'Cannot use default debug loader outside of HTML documents.');\r\n      controller.pause();\r\n      return;\r\n    }\r\n\r\n    /** @type {!HTMLDocument} */\r\n    var doc = goog.global.document;\r\n\r\n    var dep = this;\r\n\r\n    // TODO(johnplaisted): Does document.writing really speed up anything? Any\r\n    // difference between this and just waiting for interactive mode and then\r\n    // appending?\r\n    function write(src, contents) {\r\n      if (contents) {\r\n        var script = '<script type=\"module\" crossorigin>' + contents + '</' +\r\n            'script>';\r\n        doc.write(\r\n            goog.TRUSTED_TYPES_POLICY_ ?\r\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\r\n                script);\r\n      } else {\r\n        var script = '<script type=\"module\" crossorigin src=\"' + src + '\"></' +\r\n            'script>';\r\n        doc.write(\r\n            goog.TRUSTED_TYPES_POLICY_ ?\r\n                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\r\n                script);\r\n      }\r\n    }\r\n\r\n    function append(src, contents) {\r\n      var scriptEl =\r\n          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));\r\n      scriptEl.defer = true;\r\n      scriptEl.async = false;\r\n      scriptEl.type = 'module';\r\n      scriptEl.setAttribute('crossorigin', true);\r\n\r\n      // If CSP nonces are used, propagate them to dynamically created scripts.\r\n      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.\r\n      var nonce = goog.getScriptNonce();\r\n      if (nonce) {\r\n        scriptEl.setAttribute('nonce', nonce);\r\n      }\r\n\r\n      if (contents) {\r\n        scriptEl.textContent = goog.TRUSTED_TYPES_POLICY_ ?\r\n            goog.TRUSTED_TYPES_POLICY_.createScript(contents) :\r\n            contents;\r\n      } else {\r\n        scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?\r\n            goog.TRUSTED_TYPES_POLICY_.createScriptURL(src) :\r\n            src;\r\n      }\r\n\r\n      doc.head.appendChild(scriptEl);\r\n    }\r\n\r\n    var create;\r\n\r\n    if (goog.isDocumentLoading_()) {\r\n      create = write;\r\n      // We can ONLY call document.write if we are guaranteed that any\r\n      // non-module script tags document.written after this are deferred.\r\n      // Small optimization, in theory document.writing is faster.\r\n      goog.Dependency.defer_ = true;\r\n    } else {\r\n      create = append;\r\n    }\r\n\r\n    // Write 4 separate tags here:\r\n    // 1) Sets the module state at the correct time (just before execution).\r\n    // 2) A src node for this, which just hopefully lets the browser load it a\r\n    //    little early (no need to parse #3).\r\n    // 3) Import the module and register it.\r\n    // 4) Clear the module state at the correct time. Guaranteed to run even\r\n    //    if there is an error in the module (#3 will not run if there is an\r\n    //    error in the module).\r\n    var beforeKey = goog.Dependency.registerCallback_(function() {\r\n      goog.Dependency.unregisterCallback_(beforeKey);\r\n      controller.setModuleState(goog.ModuleType.ES6);\r\n    });\r\n    create(undefined, 'goog.Dependency.callback_(\"' + beforeKey + '\")');\r\n\r\n    // TODO(johnplaisted): Does this really speed up anything?\r\n    create(this.path, undefined);\r\n\r\n    var registerKey = goog.Dependency.registerCallback_(function(exports) {\r\n      goog.Dependency.unregisterCallback_(registerKey);\r\n      controller.registerEs6ModuleExports(\r\n          dep.path, exports, goog.moduleLoaderState_.moduleName);\r\n    });\r\n    create(\r\n        undefined,\r\n        'import * as m from \"' + this.path + '\"; goog.Dependency.callback_(\"' +\r\n            registerKey + '\", m)');\r\n\r\n    var afterKey = goog.Dependency.registerCallback_(function() {\r\n      goog.Dependency.unregisterCallback_(afterKey);\r\n      controller.clearModuleState();\r\n      controller.loaded();\r\n    });\r\n    create(undefined, 'goog.Dependency.callback_(\"' + afterKey + '\")');\r\n  };\r\n\r\n\r\n  /**\r\n   * Superclass of any dependency that needs to be loaded into memory,\r\n   * transformed, and then eval'd (goog.modules and transpiled files).\r\n   *\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\r\n   *     in this file.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @struct @constructor @abstract\r\n   * @extends {goog.Dependency}\r\n   */\r\n  goog.TransformedDependency = function(\r\n      path, relativePath, provides, requires, loadFlags) {\r\n    goog.TransformedDependency.base(\r\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\r\n    /** @private {?string} */\r\n    this.contents_ = null;\r\n\r\n    /**\r\n     * Whether to lazily make the synchronous XHR (when goog.require'd) or make\r\n     * the synchronous XHR when initially loading. On FireFox 61 there is a bug\r\n     * where an ES6 module cannot make a synchronous XHR (rather, it can, but if\r\n     * it does then no other ES6 modules will load after).\r\n     *\r\n     * tl;dr we lazy load due to bugs on older browsers and eager load due to\r\n     * bugs on newer ones.\r\n     *\r\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1477090\r\n     *\r\n     * @private @const {boolean}\r\n     */\r\n    this.lazyFetch_ = !goog.inHtmlDocument_() ||\r\n        !('noModule' in goog.global.document.createElement('script'));\r\n  };\r\n  goog.inherits(goog.TransformedDependency, goog.Dependency);\r\n\r\n\r\n  /** @override */\r\n  goog.TransformedDependency.prototype.load = function(controller) {\r\n    var dep = this;\r\n\r\n    function fetch() {\r\n      dep.contents_ = goog.loadFileSync_(dep.path);\r\n\r\n      if (dep.contents_) {\r\n        dep.contents_ = dep.transform(dep.contents_);\r\n        if (dep.contents_) {\r\n          dep.contents_ += '\\n//# sourceURL=' + dep.path;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (goog.global.CLOSURE_IMPORT_SCRIPT) {\r\n      fetch();\r\n      if (this.contents_ &&\r\n          goog.global.CLOSURE_IMPORT_SCRIPT('', this.contents_)) {\r\n        this.contents_ = null;\r\n        controller.loaded();\r\n      } else {\r\n        controller.pause();\r\n      }\r\n      return;\r\n    }\r\n\r\n\r\n    var isEs6 = this.loadFlags['module'] == goog.ModuleType.ES6;\r\n\r\n    if (!this.lazyFetch_) {\r\n      fetch();\r\n    }\r\n\r\n    function load() {\r\n      if (dep.lazyFetch_) {\r\n        fetch();\r\n      }\r\n\r\n      if (!dep.contents_) {\r\n        // loadFileSync_ or transform are responsible. Assume they logged an\r\n        // error.\r\n        return;\r\n      }\r\n\r\n      if (isEs6) {\r\n        controller.setModuleState(goog.ModuleType.ES6);\r\n      }\r\n\r\n      var namespace;\r\n\r\n      try {\r\n        var contents = dep.contents_;\r\n        dep.contents_ = null;\r\n        goog.globalEval(contents);\r\n        if (isEs6) {\r\n          namespace = goog.moduleLoaderState_.moduleName;\r\n        }\r\n      } finally {\r\n        if (isEs6) {\r\n          controller.clearModuleState();\r\n        }\r\n      }\r\n\r\n      if (isEs6) {\r\n        // Due to circular dependencies this may not be available for require\r\n        // right now.\r\n        goog.global['$jscomp']['require']['ensure'](\r\n            [dep.getPathName()], function() {\r\n              controller.registerEs6ModuleExports(\r\n                  dep.path,\r\n                  goog.global['$jscomp']['require'](dep.getPathName()),\r\n                  namespace);\r\n            });\r\n      }\r\n\r\n      controller.loaded();\r\n    }\r\n\r\n    // Do not fetch now; in FireFox 47 the synchronous XHR doesn't block all\r\n    // events. If we fetched now and then document.write'd the contents the\r\n    // document.write would be an eval and would execute too soon! Instead write\r\n    // a script tag to fetch and eval synchronously at the correct time.\r\n    function fetchInOwnScriptThenLoad() {\r\n      /** @type {!HTMLDocument} */\r\n      var doc = goog.global.document;\r\n\r\n      var key = goog.Dependency.registerCallback_(function() {\r\n        goog.Dependency.unregisterCallback_(key);\r\n        load();\r\n      });\r\n\r\n      var script = '<script type=\"text/javascript\">' +\r\n          goog.protectScriptTag_('goog.Dependency.callback_(\"' + key + '\");') +\r\n          '</' +\r\n          'script>';\r\n      doc.write(\r\n          goog.TRUSTED_TYPES_POLICY_ ?\r\n              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :\r\n              script);\r\n    }\r\n\r\n    // If one thing is pending it is this.\r\n    var anythingElsePending = controller.pending().length > 1;\r\n\r\n    // If anything else is loading we need to lazy load due to bugs in old IE.\r\n    // Specifically script tags with src and script tags with contents could\r\n    // execute out of order if document.write is used, so we cannot use\r\n    // document.write. Do not pause here; it breaks old IE as well.\r\n    var useOldIeWorkAround =\r\n        anythingElsePending && goog.DebugLoader_.IS_OLD_IE_;\r\n\r\n    // Additionally if we are meant to defer scripts but the page is still\r\n    // loading (e.g. an ES6 module is loading) then also defer. Or if we are\r\n    // meant to defer and anything else is pending then defer (those may be\r\n    // scripts that did not need transformation and are just script tags with\r\n    // defer set to true, and we need to evaluate after that deferred script).\r\n    var needsAsyncLoading = goog.Dependency.defer_ &&\r\n        (anythingElsePending || goog.isDocumentLoading_());\r\n\r\n    if (useOldIeWorkAround || needsAsyncLoading) {\r\n      // Note that we only defer when we have to rather than 100% of the time.\r\n      // Always defering would work, but then in theory the order of\r\n      // goog.require calls would then matter. We want to enforce that most of\r\n      // the time the order of the require calls does not matter.\r\n      controller.defer(function() {\r\n        load();\r\n      });\r\n      return;\r\n    }\r\n    // TODO(johnplaisted): Externs are missing onreadystatechange for\r\n    // HTMLDocument.\r\n    /** @type {?} */\r\n    var doc = goog.global.document;\r\n\r\n    var isInternetExplorer =\r\n        goog.inHtmlDocument_() && 'ActiveXObject' in goog.global;\r\n\r\n    // Don't delay in any version of IE. There's bug around this that will\r\n    // cause out of order script execution. This means that on older IE ES6\r\n    // modules will load too early (while the document is still loading + the\r\n    // dom is not available). The other option is to load too late (when the\r\n    // document is complete and the onload even will never fire). This seems\r\n    // to be the lesser of two evils as scripts already act like the former.\r\n    if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() &&\r\n        !isInternetExplorer) {\r\n      goog.Dependency.defer_ = true;\r\n      // Transpiled ES6 modules still need to load like regular ES6 modules,\r\n      // aka only after the document is interactive.\r\n      controller.pause();\r\n      var oldCallback = doc.onreadystatechange;\r\n      doc.onreadystatechange = function() {\r\n        if (doc.readyState == 'interactive') {\r\n          doc.onreadystatechange = oldCallback;\r\n          load();\r\n          controller.resume();\r\n        }\r\n        if (goog.isFunction(oldCallback)) {\r\n          oldCallback.apply(undefined, arguments);\r\n        }\r\n      };\r\n    } else {\r\n      // Always eval on old IE.\r\n      if (goog.DebugLoader_.IS_OLD_IE_ || !goog.inHtmlDocument_() ||\r\n          !goog.isDocumentLoading_()) {\r\n        load();\r\n      } else {\r\n        fetchInOwnScriptThenLoad();\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} contents\r\n   * @return {string}\r\n   * @abstract\r\n   */\r\n  goog.TransformedDependency.prototype.transform = function(contents) {};\r\n\r\n\r\n  /**\r\n   * Any non-goog.module dependency which needs to be transpiled before eval.\r\n   *\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\r\n   *     in this file.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @param {!goog.Transpiler} transpiler\r\n   * @struct @constructor\r\n   * @extends {goog.TransformedDependency}\r\n   */\r\n  goog.TranspiledDependency = function(\r\n      path, relativePath, provides, requires, loadFlags, transpiler) {\r\n    goog.TranspiledDependency.base(\r\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\r\n    /** @protected @const*/\r\n    this.transpiler = transpiler;\r\n  };\r\n  goog.inherits(goog.TranspiledDependency, goog.TransformedDependency);\r\n\r\n\r\n  /** @override */\r\n  goog.TranspiledDependency.prototype.transform = function(contents) {\r\n    // Transpile with the pathname so that ES6 modules are domain agnostic.\r\n    return this.transpiler.transpile(contents, this.getPathName());\r\n  };\r\n\r\n\r\n  /**\r\n   * An ES6 module dependency that was transpiled to a jscomp module outside\r\n   * of the debug loader, e.g. server side.\r\n   *\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\r\n   *     in this file.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @struct @constructor\r\n   * @extends {goog.TransformedDependency}\r\n   */\r\n  goog.PreTranspiledEs6ModuleDependency = function(\r\n      path, relativePath, provides, requires, loadFlags) {\r\n    goog.PreTranspiledEs6ModuleDependency.base(\r\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\r\n  };\r\n  goog.inherits(\r\n      goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency);\r\n\r\n\r\n  /** @override */\r\n  goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(\r\n      contents) {\r\n    return contents;\r\n  };\r\n\r\n\r\n  /**\r\n   * A goog.module, transpiled or not. Will always perform some minimal\r\n   * transformation even when not transpiled to wrap in a goog.loadModule\r\n   * statement.\r\n   *\r\n   * @param {string} path Absolute path of this script.\r\n   * @param {string} relativePath Path of this script relative to goog.basePath.\r\n   * @param {!Array<string>} provides goog.provided or goog.module symbols\r\n   *     in this file.\r\n   * @param {!Array<string>} requires goog symbols or relative paths to Closure\r\n   *     this depends on.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @param {boolean} needsTranspile\r\n   * @param {!goog.Transpiler} transpiler\r\n   * @struct @constructor\r\n   * @extends {goog.TransformedDependency}\r\n   */\r\n  goog.GoogModuleDependency = function(\r\n      path, relativePath, provides, requires, loadFlags, needsTranspile,\r\n      transpiler) {\r\n    goog.GoogModuleDependency.base(\r\n        this, 'constructor', path, relativePath, provides, requires, loadFlags);\r\n    /** @private @const */\r\n    this.needsTranspile_ = needsTranspile;\r\n    /** @private @const */\r\n    this.transpiler_ = transpiler;\r\n  };\r\n  goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);\r\n\r\n\r\n  /** @override */\r\n  goog.GoogModuleDependency.prototype.transform = function(contents) {\r\n    if (this.needsTranspile_) {\r\n      contents = this.transpiler_.transpile(contents, this.getPathName());\r\n    }\r\n\r\n    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {\r\n      return '' +\r\n          'goog.loadModule(function(exports) {' +\r\n          '\"use strict\";' + contents +\r\n          '\\n' +  // terminate any trailing single line comment.\r\n          ';return exports' +\r\n          '});' +\r\n          '\\n//# sourceURL=' + this.path + '\\n';\r\n    } else {\r\n      return '' +\r\n          'goog.loadModule(' +\r\n          goog.global.JSON.stringify(\r\n              contents + '\\n//# sourceURL=' + this.path + '\\n') +\r\n          ');';\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Whether the browser is IE9 or earlier, which needs special handling\r\n   * for deferred modules.\r\n   * @const @private {boolean}\r\n   */\r\n  goog.DebugLoader_.IS_OLD_IE_ = !!(\r\n      !goog.global.atob && goog.global.document && goog.global.document['all']);\r\n\r\n\r\n  /**\r\n   * @param {string} relPath\r\n   * @param {!Array<string>|undefined} provides\r\n   * @param {!Array<string>} requires\r\n   * @param {boolean|!Object<string>=} opt_loadFlags\r\n   * @see goog.addDependency\r\n   */\r\n  goog.DebugLoader_.prototype.addDependency = function(\r\n      relPath, provides, requires, opt_loadFlags) {\r\n    provides = provides || [];\r\n    relPath = relPath.replace(/\\\\/g, '/');\r\n    var path = goog.normalizePath_(goog.basePath + relPath);\r\n    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {\r\n      opt_loadFlags = opt_loadFlags ? {'module': goog.ModuleType.GOOG} : {};\r\n    }\r\n    var dep = this.factory_.createDependency(\r\n        path, relPath, provides, requires, opt_loadFlags,\r\n        goog.transpiler_.needsTranspile(\r\n            opt_loadFlags['lang'] || 'es3', opt_loadFlags['module']));\r\n    this.dependencies_[path] = dep;\r\n    for (var i = 0; i < provides.length; i++) {\r\n      this.idToPath_[provides[i]] = path;\r\n    }\r\n    this.idToPath_[relPath] = path;\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates goog.Dependency instances for the debug loader to load.\r\n   *\r\n   * Should be overridden to have the debug loader use custom subclasses of\r\n   * goog.Dependency.\r\n   *\r\n   * @param {!goog.Transpiler} transpiler\r\n   * @struct @constructor\r\n   */\r\n  goog.DependencyFactory = function(transpiler) {\r\n    /** @protected @const */\r\n    this.transpiler = transpiler;\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {string} path Absolute path of the file.\r\n   * @param {string} relativePath Path relative to closures base.js.\r\n   * @param {!Array<string>} provides Array of provided goog.provide/module ids.\r\n   * @param {!Array<string>} requires Array of required goog.provide/module /\r\n   *     relative ES6 module paths.\r\n   * @param {!Object<string, string>} loadFlags\r\n   * @param {boolean} needsTranspile True if the file needs to be transpiled\r\n   *     per the goog.Transpiler.\r\n   * @return {!goog.Dependency}\r\n   */\r\n  goog.DependencyFactory.prototype.createDependency = function(\r\n      path, relativePath, provides, requires, loadFlags, needsTranspile) {\r\n\r\n    if (loadFlags['module'] == goog.ModuleType.GOOG) {\r\n      return new goog.GoogModuleDependency(\r\n          path, relativePath, provides, requires, loadFlags, needsTranspile,\r\n          this.transpiler);\r\n    } else if (needsTranspile) {\r\n      return new goog.TranspiledDependency(\r\n          path, relativePath, provides, requires, loadFlags, this.transpiler);\r\n    } else {\r\n      if (loadFlags['module'] == goog.ModuleType.ES6) {\r\n        if (goog.TRANSPILE == 'never' && goog.ASSUME_ES_MODULES_TRANSPILED) {\r\n          return new goog.PreTranspiledEs6ModuleDependency(\r\n              path, relativePath, provides, requires, loadFlags);\r\n        } else {\r\n          return new goog.Es6ModuleDependency(\r\n              path, relativePath, provides, requires, loadFlags);\r\n        }\r\n      } else {\r\n        return new goog.Dependency(\r\n            path, relativePath, provides, requires, loadFlags);\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /** @private @const */\r\n  goog.debugLoader_ = new goog.DebugLoader_();\r\n\r\n\r\n  /**\r\n   * Loads the Closure Dependency file.\r\n   *\r\n   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base\r\n   * loaded, setDependencyFactory called, and then this called. i.e. allows\r\n   * custom loading of the deps file.\r\n   */\r\n  goog.loadClosureDeps = function() {\r\n    goog.debugLoader_.loadClosureDeps();\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the dependency factory, which can be used to create custom\r\n   * goog.Dependency implementations to control how dependencies are loaded.\r\n   *\r\n   * Note: if you wish to call this function and provide your own implemnetation\r\n   * it is a wise idea to set CLOSURE_NO_DEPS to true, otherwise the dependency\r\n   * file and all of its goog.addDependency calls will use the default factory.\r\n   * You can call goog.loadClosureDeps to load the Closure dependency file\r\n   * later, after your factory is injected.\r\n   *\r\n   * @param {!goog.DependencyFactory} factory\r\n   */\r\n  goog.setDependencyFactory = function(factory) {\r\n    goog.debugLoader_.setDependencyFactory(factory);\r\n  };\r\n\r\n\r\n  if (!goog.global.CLOSURE_NO_DEPS) {\r\n    goog.debugLoader_.loadClosureDeps();\r\n  }\r\n\r\n\r\n  /**\r\n   * Bootstraps the given namespaces and calls the callback once they are\r\n   * available either via goog.require. This is a replacement for using\r\n   * `goog.require` to bootstrap Closure JavaScript. Previously a `goog.require`\r\n   * in an HTML file would guarantee that the require'd namespace was available\r\n   * in the next immediate script tag. With ES6 modules this no longer a\r\n   * guarantee.\r\n   *\r\n   * @param {!Array<string>} namespaces\r\n   * @param {function(): ?} callback Function to call once all the namespaces\r\n   *     have loaded. Always called asynchronously.\r\n   */\r\n  goog.bootstrap = function(namespaces, callback) {\r\n    goog.debugLoader_.bootstrap(namespaces, callback);\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @define {string} Trusted Types policy name. If non-empty then Closure will\r\n * use Trusted Types.\r\n */\r\ngoog.TRUSTED_TYPES_POLICY_NAME =\r\n    goog.define('goog.TRUSTED_TYPES_POLICY_NAME', '');\r\n\r\n\r\n/**\r\n * Returns the parameter.\r\n * @param {string} s\r\n * @return {string}\r\n * @private\r\n */\r\ngoog.identity_ = function(s) {\r\n  return s;\r\n};\r\n\r\n\r\n/**\r\n * Creates Trusted Types policy if Trusted Types are supported by the browser.\r\n * The policy just blesses any string as a Trusted Type. It is not visibility\r\n * restricted because anyone can also call TrustedTypes.createPolicy directly.\r\n * However, the allowed names should be restricted by a HTTP header and the\r\n * reference to the created policy should be visibility restricted.\r\n * @param {string} name\r\n * @return {?TrustedTypePolicy}\r\n * @throws {!TypeError} If called with a name which is already registered.\r\n */\r\ngoog.createTrustedTypesPolicy = function(name) {\r\n  if (typeof TrustedTypes === 'undefined' || !TrustedTypes.createPolicy) {\r\n    return null;\r\n  }\r\n  return TrustedTypes.createPolicy(name, {\r\n    createHTML: goog.identity_,\r\n    createScript: goog.identity_,\r\n    createScriptURL: goog.identity_,\r\n    createURL: goog.identity_\r\n  });\r\n};\r\n\r\n\r\n/** @private @const {?TrustedTypePolicy} */\r\ngoog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ?\r\n    goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#base') :\r\n    null;\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Implements the disposable interface. The dispose method is used\r\n * to clean up references and resources.\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\n\r\ngoog.provide('goog.Disposable');\r\ngoog.provide('goog.dispose');\r\ngoog.provide('goog.disposeAll');\r\n\r\ngoog.require('goog.disposable.IDisposable');\r\n\r\n\r\n\r\n/**\r\n * Class that provides the basic implementation for disposable objects. If your\r\n * class holds one or more references to COM objects, DOM nodes, or other\r\n * disposable objects, it should extend this class or implement the disposable\r\n * interface (defined in goog.disposable.IDisposable).\r\n * @constructor\r\n * @implements {goog.disposable.IDisposable}\r\n */\r\ngoog.Disposable = function() {\r\n  /**\r\n   * If monitoring the goog.Disposable instances is enabled, stores the creation\r\n   * stack trace of the Disposable instance.\r\n   * @type {string|undefined}\r\n   */\r\n  this.creationStack;\r\n\r\n  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\r\n    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {\r\n      this.creationStack = new Error().stack;\r\n    }\r\n    goog.Disposable.instances_[goog.getUid(this)] = this;\r\n  }\r\n  // Support sealing\r\n  this.disposed_ = this.disposed_;\r\n  this.onDisposeCallbacks_ = this.onDisposeCallbacks_;\r\n};\r\n\r\n\r\n/**\r\n * @enum {number} Different monitoring modes for Disposable.\r\n */\r\ngoog.Disposable.MonitoringMode = {\r\n  /**\r\n   * No monitoring.\r\n   */\r\n  OFF: 0,\r\n  /**\r\n   * Creating and disposing the goog.Disposable instances is monitored. All\r\n   * disposable objects need to call the `goog.Disposable` base\r\n   * constructor. The PERMANENT mode must be switched on before creating any\r\n   * goog.Disposable instances.\r\n   */\r\n  PERMANENT: 1,\r\n  /**\r\n   * INTERACTIVE mode can be switched on and off on the fly without producing\r\n   * errors. It also doesn't warn if the disposable objects don't call the\r\n   * `goog.Disposable` base constructor.\r\n   */\r\n  INTERACTIVE: 2\r\n};\r\n\r\n\r\n/**\r\n * @define {number} The monitoring mode of the goog.Disposable\r\n *     instances. Default is OFF. Switching on the monitoring is only\r\n *     recommended for debugging because it has a significant impact on\r\n *     performance and memory usage. If switched off, the monitoring code\r\n *     compiles down to 0 bytes.\r\n */\r\ngoog.Disposable.MONITORING_MODE =\r\n    goog.define('goog.Disposable.MONITORING_MODE', 0);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to attach creation stack to each created disposable\r\n *     instance; This is only relevant for when MonitoringMode != OFF.\r\n */\r\ngoog.Disposable.INCLUDE_STACK_ON_CREATION =\r\n    goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);\r\n\r\n\r\n/**\r\n * Maps the unique ID of every undisposed `goog.Disposable` object to\r\n * the object itself.\r\n * @type {!Object<number, !goog.Disposable>}\r\n * @private\r\n */\r\ngoog.Disposable.instances_ = {};\r\n\r\n\r\n/**\r\n * @return {!Array<!goog.Disposable>} All `goog.Disposable` objects that\r\n *     haven't been disposed of.\r\n */\r\ngoog.Disposable.getUndisposedObjects = function() {\r\n  var ret = [];\r\n  for (var id in goog.Disposable.instances_) {\r\n    if (goog.Disposable.instances_.hasOwnProperty(id)) {\r\n      ret.push(goog.Disposable.instances_[Number(id)]);\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n\r\n\r\n/**\r\n * Clears the registry of undisposed objects but doesn't dispose of them.\r\n */\r\ngoog.Disposable.clearUndisposedObjects = function() {\r\n  goog.Disposable.instances_ = {};\r\n};\r\n\r\n\r\n/**\r\n * Whether the object has been disposed of.\r\n * @type {boolean}\r\n * @private\r\n */\r\ngoog.Disposable.prototype.disposed_ = false;\r\n\r\n\r\n/**\r\n * Callbacks to invoke when this object is disposed.\r\n * @type {Array<!Function>}\r\n * @private\r\n */\r\ngoog.Disposable.prototype.onDisposeCallbacks_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the object has been disposed of.\r\n * @override\r\n */\r\ngoog.Disposable.prototype.isDisposed = function() {\r\n  return this.disposed_;\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the object has been disposed of.\r\n * @deprecated Use {@link #isDisposed} instead.\r\n */\r\ngoog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;\r\n\r\n\r\n/**\r\n * Disposes of the object. If the object hasn't already been disposed of, calls\r\n * {@link #disposeInternal}. Classes that extend `goog.Disposable` should\r\n * override {@link #disposeInternal} in order to delete references to COM\r\n * objects, DOM nodes, and other disposable objects. Reentrant.\r\n *\r\n * @return {void} Nothing.\r\n * @override\r\n */\r\ngoog.Disposable.prototype.dispose = function() {\r\n  if (!this.disposed_) {\r\n    // Set disposed_ to true first, in case during the chain of disposal this\r\n    // gets disposed recursively.\r\n    this.disposed_ = true;\r\n    this.disposeInternal();\r\n    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {\r\n      var uid = goog.getUid(this);\r\n      if (goog.Disposable.MONITORING_MODE ==\r\n              goog.Disposable.MonitoringMode.PERMANENT &&\r\n          !goog.Disposable.instances_.hasOwnProperty(uid)) {\r\n        throw new Error(\r\n            this + ' did not call the goog.Disposable base ' +\r\n            'constructor or was disposed of after a clearUndisposedObjects ' +\r\n            'call');\r\n      }\r\n      if (goog.Disposable.MONITORING_MODE !=\r\n              goog.Disposable.MonitoringMode.OFF &&\r\n          this.onDisposeCallbacks_ && this.onDisposeCallbacks_.length > 0) {\r\n        throw new Error(\r\n            this + ' did not empty its onDisposeCallbacks queue. This ' +\r\n            'probably means it overrode dispose() or disposeInternal() ' +\r\n            'without calling the superclass\\' method.');\r\n      }\r\n      delete goog.Disposable.instances_[uid];\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Associates a disposable object with this object so that they will be disposed\r\n * together.\r\n * @param {goog.disposable.IDisposable} disposable that will be disposed when\r\n *     this object is disposed.\r\n */\r\ngoog.Disposable.prototype.registerDisposable = function(disposable) {\r\n  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));\r\n};\r\n\r\n\r\n/**\r\n * Invokes a callback function when this object is disposed. Callbacks are\r\n * invoked in the order in which they were added. If a callback is added to\r\n * an already disposed Disposable, it will be called immediately.\r\n * @param {function(this:T):?} callback The callback function.\r\n * @param {T=} opt_scope An optional scope to call the callback in.\r\n * @template T\r\n */\r\ngoog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {\r\n  if (this.disposed_) {\r\n    goog.isDef(opt_scope) ? callback.call(opt_scope) : callback();\r\n    return;\r\n  }\r\n  if (!this.onDisposeCallbacks_) {\r\n    this.onDisposeCallbacks_ = [];\r\n  }\r\n\r\n  this.onDisposeCallbacks_.push(\r\n      goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback);\r\n};\r\n\r\n\r\n/**\r\n * Deletes or nulls out any references to COM objects, DOM nodes, or other\r\n * disposable objects. Classes that extend `goog.Disposable` should\r\n * override this method.\r\n * Not reentrant. To avoid calling it twice, it must only be called from the\r\n * subclass' `disposeInternal` method. Everywhere else the public\r\n * `dispose` method must be used.\r\n * For example:\r\n * <pre>\r\n *   mypackage.MyClass = function() {\r\n *     mypackage.MyClass.base(this, 'constructor');\r\n *     // Constructor logic specific to MyClass.\r\n *     ...\r\n *   };\r\n *   goog.inherits(mypackage.MyClass, goog.Disposable);\r\n *\r\n *   mypackage.MyClass.prototype.disposeInternal = function() {\r\n *     // Dispose logic specific to MyClass.\r\n *     ...\r\n *     // Call superclass's disposeInternal at the end of the subclass's, like\r\n *     // in C++, to avoid hard-to-catch issues.\r\n *     mypackage.MyClass.base(this, 'disposeInternal');\r\n *   };\r\n * </pre>\r\n * @protected\r\n */\r\ngoog.Disposable.prototype.disposeInternal = function() {\r\n  if (this.onDisposeCallbacks_) {\r\n    while (this.onDisposeCallbacks_.length) {\r\n      this.onDisposeCallbacks_.shift()();\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns True if we can verify the object is disposed.\r\n * Calls `isDisposed` on the argument if it supports it.  If obj\r\n * is not an object with an isDisposed() method, return false.\r\n * @param {*} obj The object to investigate.\r\n * @return {boolean} True if we can verify the object is disposed.\r\n */\r\ngoog.Disposable.isDisposed = function(obj) {\r\n  if (obj && typeof obj.isDisposed == 'function') {\r\n    return obj.isDisposed();\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Calls `dispose` on the argument if it supports it. If obj is not an\r\n *     object with a dispose() method, this is a no-op.\r\n * @param {*} obj The object to dispose of.\r\n */\r\ngoog.dispose = function(obj) {\r\n  if (obj && typeof obj.dispose == 'function') {\r\n    obj.dispose();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls `dispose` on each member of the list that supports it. (If the\r\n * member is an ArrayLike, then `goog.disposeAll()` will be called\r\n * recursively on each of its members.) If the member is not an object with a\r\n * `dispose()` method, then it is ignored.\r\n * @param {...*} var_args The list.\r\n */\r\ngoog.disposeAll = function(var_args) {\r\n  for (var i = 0, len = arguments.length; i < len; ++i) {\r\n    var disposable = arguments[i];\r\n    if (goog.isArrayLike(disposable)) {\r\n      goog.disposeAll.apply(null, disposable);\r\n    } else {\r\n      goog.dispose(disposable);\r\n    }\r\n  }\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Utilities for manipulating arrays.\r\n *\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\n\r\ngoog.provide('goog.array');\r\n\r\ngoog.require('goog.asserts');\r\n\r\n\r\n/**\r\n * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should\r\n * rely on Array.prototype functions, if available.\r\n *\r\n * The Array.prototype functions can be defined by external libraries like\r\n * Prototype and setting this flag to false forces closure to use its own\r\n * goog.array implementation.\r\n *\r\n * If your javascript can be loaded by a third party site and you are wary about\r\n * relying on the prototype functions, specify\r\n * \"--define goog.NATIVE_ARRAY_PROTOTYPES=false\" to the JSCompiler.\r\n *\r\n * Setting goog.TRUSTED_SITE to false will automatically set\r\n * NATIVE_ARRAY_PROTOTYPES to false.\r\n */\r\ngoog.NATIVE_ARRAY_PROTOTYPES =\r\n    goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);\r\n\r\n\r\n/**\r\n * @define {boolean} If true, JSCompiler will use the native implementation of\r\n * array functions where appropriate (e.g., `Array#filter`) and remove the\r\n * unused pure JS implementation.\r\n */\r\ngoog.array.ASSUME_NATIVE_FUNCTIONS =\r\n    goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);\r\n\r\n\r\n/**\r\n * Returns the last element in an array without removing it.\r\n * Same as goog.array.last.\r\n * @param {IArrayLike<T>|string} array The array.\r\n * @return {T} Last item in array.\r\n * @template T\r\n */\r\ngoog.array.peek = function(array) {\r\n  return array[array.length - 1];\r\n};\r\n\r\n\r\n/**\r\n * Returns the last element in an array without removing it.\r\n * Same as goog.array.peek.\r\n * @param {IArrayLike<T>|string} array The array.\r\n * @return {T} Last item in array.\r\n * @template T\r\n */\r\ngoog.array.last = goog.array.peek;\r\n\r\n// NOTE(arv): Since most of the array functions are generic it allows you to\r\n// pass an array-like object. Strings have a length and are considered array-\r\n// like. However, the 'in' operator does not work on strings so we cannot just\r\n// use the array path even if the browser supports indexing into strings. We\r\n// therefore end up splitting the string.\r\n\r\n\r\n/**\r\n * Returns the index of the first element of an array with a specified value, or\r\n * -1 if the element is not present in the array.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}\r\n *\r\n * @param {IArrayLike<T>|string} arr The array to be searched.\r\n * @param {T} obj The object for which we are searching.\r\n * @param {number=} opt_fromIndex The index at which to start the search. If\r\n *     omitted the search starts at index 0.\r\n * @return {number} The index of the first matching array element.\r\n * @template T\r\n */\r\ngoog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ?\r\n    function(arr, obj, opt_fromIndex) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);\r\n    } :\r\n    function(arr, obj, opt_fromIndex) {\r\n      var fromIndex = opt_fromIndex == null ?\r\n          0 :\r\n          (opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) :\r\n                               opt_fromIndex);\r\n\r\n      if (goog.isString(arr)) {\r\n        // Array.prototype.indexOf uses === so only strings should be found.\r\n        if (!goog.isString(obj) || obj.length != 1) {\r\n          return -1;\r\n        }\r\n        return arr.indexOf(obj, fromIndex);\r\n      }\r\n\r\n      for (var i = fromIndex; i < arr.length; i++) {\r\n        if (i in arr && arr[i] === obj) return i;\r\n      }\r\n      return -1;\r\n    };\r\n\r\n\r\n/**\r\n * Returns the index of the last element of an array with a specified value, or\r\n * -1 if the element is not present in the array.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}\r\n *\r\n * @param {!IArrayLike<T>|string} arr The array to be searched.\r\n * @param {T} obj The object for which we are searching.\r\n * @param {?number=} opt_fromIndex The index at which to start the search. If\r\n *     omitted the search starts at the end of the array.\r\n * @return {number} The index of the last matching array element.\r\n * @template T\r\n */\r\ngoog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ?\r\n    function(arr, obj, opt_fromIndex) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      // Firefox treats undefined and null as 0 in the fromIndex argument which\r\n      // leads it to always return -1\r\n      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;\r\n      return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);\r\n    } :\r\n    function(arr, obj, opt_fromIndex) {\r\n      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;\r\n\r\n      if (fromIndex < 0) {\r\n        fromIndex = Math.max(0, arr.length + fromIndex);\r\n      }\r\n\r\n      if (goog.isString(arr)) {\r\n        // Array.prototype.lastIndexOf uses === so only strings should be found.\r\n        if (!goog.isString(obj) || obj.length != 1) {\r\n          return -1;\r\n        }\r\n        return arr.lastIndexOf(obj, fromIndex);\r\n      }\r\n\r\n      for (var i = fromIndex; i >= 0; i--) {\r\n        if (i in arr && arr[i] === obj) return i;\r\n      }\r\n      return -1;\r\n    };\r\n\r\n\r\n/**\r\n * Calls a function for each element in an array. Skips holes in the array.\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array like object over\r\n *     which to iterate.\r\n * @param {?function(this: S, T, number, ?): ?} f The function to call for every\r\n *     element. This function takes 3 arguments (the element, the index and the\r\n *     array). The return value is ignored.\r\n * @param {S=} opt_obj The object to be used as the value of 'this' within f.\r\n * @template T,S\r\n */\r\ngoog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ?\r\n    function(arr, f, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      Array.prototype.forEach.call(arr, f, opt_obj);\r\n    } :\r\n    function(arr, f, opt_obj) {\r\n      var l = arr.length;  // must be fixed during loop... see docs\r\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n      for (var i = 0; i < l; i++) {\r\n        if (i in arr2) {\r\n          f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\r\n        }\r\n      }\r\n    };\r\n\r\n\r\n/**\r\n * Calls a function for each element in an array, starting from the last\r\n * element rather than the first.\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this: S, T, number, ?): ?} f The function to call for every\r\n *     element. This function\r\n *     takes 3 arguments (the element, the index and the array). The return\r\n *     value is ignored.\r\n * @param {S=} opt_obj The object to be used as the value of 'this'\r\n *     within f.\r\n * @template T,S\r\n */\r\ngoog.array.forEachRight = function(arr, f, opt_obj) {\r\n  var l = arr.length;  // must be fixed during loop... see docs\r\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n  for (var i = l - 1; i >= 0; --i) {\r\n    if (i in arr2) {\r\n      f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each element in an array, and if the function returns\r\n * true adds the element to a new array.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?):boolean} f The function to call for\r\n *     every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and must\r\n *     return a Boolean. If the return value is true the element is added to the\r\n *     result array. If it is false the element is not included.\r\n * @param {S=} opt_obj The object to be used as the value of 'this'\r\n *     within f.\r\n * @return {!Array<T>} a new array in which only elements that passed the test\r\n *     are present.\r\n * @template T,S\r\n */\r\ngoog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ?\r\n    function(arr, f, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      return Array.prototype.filter.call(arr, f, opt_obj);\r\n    } :\r\n    function(arr, f, opt_obj) {\r\n      var l = arr.length;  // must be fixed during loop... see docs\r\n      var res = [];\r\n      var resLength = 0;\r\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n      for (var i = 0; i < l; i++) {\r\n        if (i in arr2) {\r\n          var val = arr2[i];  // in case f mutates arr2\r\n          if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {\r\n            res[resLength++] = val;\r\n          }\r\n        }\r\n      }\r\n      return res;\r\n    };\r\n\r\n\r\n/**\r\n * Calls a function for each element in an array and inserts the result into a\r\n * new array.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-map}\r\n *\r\n * @param {IArrayLike<VALUE>|string} arr Array or array like object\r\n *     over which to iterate.\r\n * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call\r\n *     for every element. This function takes 3 arguments (the element,\r\n *     the index and the array) and should return something. The result will be\r\n *     inserted into a new array.\r\n * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.\r\n * @return {!Array<RESULT>} a new array with the results from f.\r\n * @template THIS, VALUE, RESULT\r\n */\r\ngoog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ?\r\n    function(arr, f, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      return Array.prototype.map.call(arr, f, opt_obj);\r\n    } :\r\n    function(arr, f, opt_obj) {\r\n      var l = arr.length;  // must be fixed during loop... see docs\r\n      var res = new Array(l);\r\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n      for (var i = 0; i < l; i++) {\r\n        if (i in arr2) {\r\n          res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);\r\n        }\r\n      }\r\n      return res;\r\n    };\r\n\r\n\r\n/**\r\n * Passes every element of an array into a function and accumulates the result.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}\r\n *\r\n * For example:\r\n * var a = [1, 2, 3, 4];\r\n * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);\r\n * returns 10\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {function(this:S, R, T, number, ?) : R} f The function to call for\r\n *     every element. This function\r\n *     takes 4 arguments (the function's previous result or the initial value,\r\n *     the value of the current array element, the current array index, and the\r\n *     array itself)\r\n *     function(previousValue, currentValue, index, array).\r\n * @param {?} val The initial value to pass into the function on the first call.\r\n * @param {S=} opt_obj  The object to be used as the value of 'this'\r\n *     within f.\r\n * @return {R} Result of evaluating f repeatedly across the values of the array.\r\n * @template T,S,R\r\n */\r\ngoog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ?\r\n    function(arr, f, val, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n      if (opt_obj) {\r\n        f = goog.bind(f, opt_obj);\r\n      }\r\n      return Array.prototype.reduce.call(arr, f, val);\r\n    } :\r\n    function(arr, f, val, opt_obj) {\r\n      var rval = val;\r\n      goog.array.forEach(arr, function(val, index) {\r\n        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);\r\n      });\r\n      return rval;\r\n    };\r\n\r\n\r\n/**\r\n * Passes every element of an array into a function and accumulates the result,\r\n * starting from the last element and working towards the first.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}\r\n *\r\n * For example:\r\n * var a = ['a', 'b', 'c'];\r\n * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');\r\n * returns 'cba'\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, R, T, number, ?) : R} f The function to call for\r\n *     every element. This function\r\n *     takes 4 arguments (the function's previous result or the initial value,\r\n *     the value of the current array element, the current array index, and the\r\n *     array itself)\r\n *     function(previousValue, currentValue, index, array).\r\n * @param {?} val The initial value to pass into the function on the first call.\r\n * @param {S=} opt_obj The object to be used as the value of 'this'\r\n *     within f.\r\n * @return {R} Object returned as a result of evaluating f repeatedly across the\r\n *     values of the array.\r\n * @template T,S,R\r\n */\r\ngoog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ?\r\n    function(arr, f, val, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n      goog.asserts.assert(f != null);\r\n      if (opt_obj) {\r\n        f = goog.bind(f, opt_obj);\r\n      }\r\n      return Array.prototype.reduceRight.call(arr, f, val);\r\n    } :\r\n    function(arr, f, val, opt_obj) {\r\n      var rval = val;\r\n      goog.array.forEachRight(arr, function(val, index) {\r\n        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);\r\n      });\r\n      return rval;\r\n    };\r\n\r\n\r\n/**\r\n * Calls f for each element of an array. If any call returns true, some()\r\n * returns true (without checking the remaining elements). If all calls\r\n * return false, some() returns false.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-some}\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\r\n *     for every element. This function takes 3 arguments (the element, the\r\n *     index and the array) and should return a boolean.\r\n * @param {S=} opt_obj  The object to be used as the value of 'this'\r\n *     within f.\r\n * @return {boolean} true if any element passes the test.\r\n * @template T,S\r\n */\r\ngoog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ?\r\n    function(arr, f, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      return Array.prototype.some.call(arr, f, opt_obj);\r\n    } :\r\n    function(arr, f, opt_obj) {\r\n      var l = arr.length;  // must be fixed during loop... see docs\r\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n      for (var i = 0; i < l; i++) {\r\n        if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n\r\n/**\r\n * Call f for each element of an array. If all calls return true, every()\r\n * returns true. If any call returns false, every() returns false and\r\n * does not continue to check the remaining elements.\r\n *\r\n * See {@link http://tinyurl.com/developer-mozilla-org-array-every}\r\n *\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\r\n *     for every element. This function takes 3 arguments (the element, the\r\n *     index and the array) and should return a boolean.\r\n * @param {S=} opt_obj The object to be used as the value of 'this'\r\n *     within f.\r\n * @return {boolean} false if any element fails the test.\r\n * @template T,S\r\n */\r\ngoog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&\r\n        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ?\r\n    function(arr, f, opt_obj) {\r\n      goog.asserts.assert(arr.length != null);\r\n\r\n      return Array.prototype.every.call(arr, f, opt_obj);\r\n    } :\r\n    function(arr, f, opt_obj) {\r\n      var l = arr.length;  // must be fixed during loop... see docs\r\n      var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n      for (var i = 0; i < l; i++) {\r\n        if (i in arr2 && !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n\r\n/**\r\n * Counts the array elements that fulfill the predicate, i.e. for which the\r\n * callback function returns true. Skips holes in the array.\r\n *\r\n * @param {!IArrayLike<T>|string} arr Array or array like object\r\n *     over which to iterate.\r\n * @param {function(this: S, T, number, ?): boolean} f The function to call for\r\n *     every element. Takes 3 arguments (the element, the index and the array).\r\n * @param {S=} opt_obj The object to be used as the value of 'this' within f.\r\n * @return {number} The number of the matching elements.\r\n * @template T,S\r\n */\r\ngoog.array.count = function(arr, f, opt_obj) {\r\n  var count = 0;\r\n  goog.array.forEach(arr, function(element, index, arr) {\r\n    if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {\r\n      ++count;\r\n    }\r\n  }, opt_obj);\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Search an array for the first element that satisfies a given condition and\r\n * return that element.\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\r\n *     for every element. This function takes 3 arguments (the element, the\r\n *     index and the array) and should return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {T|null} The first array element that passes the test, or null if no\r\n *     element is found.\r\n * @template T,S\r\n */\r\ngoog.array.find = function(arr, f, opt_obj) {\r\n  var i = goog.array.findIndex(arr, f, opt_obj);\r\n  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];\r\n};\r\n\r\n\r\n/**\r\n * Search an array for the first element that satisfies a given condition and\r\n * return its index.\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call for\r\n *     every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and should\r\n *     return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {number} The index of the first array element that passes the test,\r\n *     or -1 if no element is found.\r\n * @template T,S\r\n */\r\ngoog.array.findIndex = function(arr, f, opt_obj) {\r\n  var l = arr.length;  // must be fixed during loop... see docs\r\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n  for (var i = 0; i < l; i++) {\r\n    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n/**\r\n * Search an array (in reverse order) for the last element that satisfies a\r\n * given condition and return that element.\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\r\n *     for every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and should\r\n *     return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {T|null} The last array element that passes the test, or null if no\r\n *     element is found.\r\n * @template T,S\r\n */\r\ngoog.array.findRight = function(arr, f, opt_obj) {\r\n  var i = goog.array.findIndexRight(arr, f, opt_obj);\r\n  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];\r\n};\r\n\r\n\r\n/**\r\n * Search an array (in reverse order) for the last element that satisfies a\r\n * given condition and return its index.\r\n * @param {IArrayLike<T>|string} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\r\n *     for every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and should\r\n *     return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {number} The index of the last array element that passes the test,\r\n *     or -1 if no element is found.\r\n * @template T,S\r\n */\r\ngoog.array.findIndexRight = function(arr, f, opt_obj) {\r\n  var l = arr.length;  // must be fixed during loop... see docs\r\n  var arr2 = goog.isString(arr) ? arr.split('') : arr;\r\n  for (var i = l - 1; i >= 0; i--) {\r\n    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n/**\r\n * Whether the array contains the given object.\r\n * @param {IArrayLike<?>|string} arr The array to test for the presence of the\r\n *     element.\r\n * @param {*} obj The object for which to test.\r\n * @return {boolean} true if obj is present.\r\n */\r\ngoog.array.contains = function(arr, obj) {\r\n  return goog.array.indexOf(arr, obj) >= 0;\r\n};\r\n\r\n\r\n/**\r\n * Whether the array is empty.\r\n * @param {IArrayLike<?>|string} arr The array to test.\r\n * @return {boolean} true if empty.\r\n */\r\ngoog.array.isEmpty = function(arr) {\r\n  return arr.length == 0;\r\n};\r\n\r\n\r\n/**\r\n * Clears the array.\r\n * @param {IArrayLike<?>} arr Array or array like object to clear.\r\n */\r\ngoog.array.clear = function(arr) {\r\n  // For non real arrays we don't have the magic length so we delete the\r\n  // indices.\r\n  if (!goog.isArray(arr)) {\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n      delete arr[i];\r\n    }\r\n  }\r\n  arr.length = 0;\r\n};\r\n\r\n\r\n/**\r\n * Pushes an item into an array, if it's not already in the array.\r\n * @param {Array<T>} arr Array into which to insert the item.\r\n * @param {T} obj Value to add.\r\n * @template T\r\n */\r\ngoog.array.insert = function(arr, obj) {\r\n  if (!goog.array.contains(arr, obj)) {\r\n    arr.push(obj);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Inserts an object at the given index of the array.\r\n * @param {IArrayLike<?>} arr The array to modify.\r\n * @param {*} obj The object to insert.\r\n * @param {number=} opt_i The index at which to insert the object. If omitted,\r\n *      treated as 0. A negative index is counted from the end of the array.\r\n */\r\ngoog.array.insertAt = function(arr, obj, opt_i) {\r\n  goog.array.splice(arr, opt_i, 0, obj);\r\n};\r\n\r\n\r\n/**\r\n * Inserts at the given index of the array, all elements of another array.\r\n * @param {IArrayLike<?>} arr The array to modify.\r\n * @param {IArrayLike<?>} elementsToAdd The array of elements to add.\r\n * @param {number=} opt_i The index at which to insert the object. If omitted,\r\n *      treated as 0. A negative index is counted from the end of the array.\r\n */\r\ngoog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {\r\n  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);\r\n};\r\n\r\n\r\n/**\r\n * Inserts an object into an array before a specified object.\r\n * @param {Array<T>} arr The array to modify.\r\n * @param {T} obj The object to insert.\r\n * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2\r\n *     is omitted or not found, obj is inserted at the end of the array.\r\n * @template T\r\n */\r\ngoog.array.insertBefore = function(arr, obj, opt_obj2) {\r\n  var i;\r\n  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {\r\n    arr.push(obj);\r\n  } else {\r\n    goog.array.insertAt(arr, obj, i);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes the first occurrence of a particular value from an array.\r\n * @param {IArrayLike<T>} arr Array from which to remove\r\n *     value.\r\n * @param {T} obj Object to remove.\r\n * @return {boolean} True if an element was removed.\r\n * @template T\r\n */\r\ngoog.array.remove = function(arr, obj) {\r\n  var i = goog.array.indexOf(arr, obj);\r\n  var rv;\r\n  if ((rv = i >= 0)) {\r\n    goog.array.removeAt(arr, i);\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Removes the last occurrence of a particular value from an array.\r\n * @param {!IArrayLike<T>} arr Array from which to remove value.\r\n * @param {T} obj Object to remove.\r\n * @return {boolean} True if an element was removed.\r\n * @template T\r\n */\r\ngoog.array.removeLast = function(arr, obj) {\r\n  var i = goog.array.lastIndexOf(arr, obj);\r\n  if (i >= 0) {\r\n    goog.array.removeAt(arr, i);\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Removes from an array the element at index i\r\n * @param {IArrayLike<?>} arr Array or array like object from which to\r\n *     remove value.\r\n * @param {number} i The index to remove.\r\n * @return {boolean} True if an element was removed.\r\n */\r\ngoog.array.removeAt = function(arr, i) {\r\n  goog.asserts.assert(arr.length != null);\r\n\r\n  // use generic form of splice\r\n  // splice returns the removed items and if successful the length of that\r\n  // will be 1\r\n  return Array.prototype.splice.call(arr, i, 1).length == 1;\r\n};\r\n\r\n\r\n/**\r\n * Removes the first value that satisfies the given condition.\r\n * @param {IArrayLike<T>} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\r\n *     for every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and should\r\n *     return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {boolean} True if an element was removed.\r\n * @template T,S\r\n */\r\ngoog.array.removeIf = function(arr, f, opt_obj) {\r\n  var i = goog.array.findIndex(arr, f, opt_obj);\r\n  if (i >= 0) {\r\n    goog.array.removeAt(arr, i);\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Removes all values that satisfy the given condition.\r\n * @param {IArrayLike<T>} arr Array or array\r\n *     like object over which to iterate.\r\n * @param {?function(this:S, T, number, ?) : boolean} f The function to call\r\n *     for every element. This function\r\n *     takes 3 arguments (the element, the index and the array) and should\r\n *     return a boolean.\r\n * @param {S=} opt_obj An optional \"this\" context for the function.\r\n * @return {number} The number of items removed\r\n * @template T,S\r\n */\r\ngoog.array.removeAllIf = function(arr, f, opt_obj) {\r\n  var removedCount = 0;\r\n  goog.array.forEachRight(arr, function(val, index) {\r\n    if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {\r\n      if (goog.array.removeAt(arr, index)) {\r\n        removedCount++;\r\n      }\r\n    }\r\n  });\r\n  return removedCount;\r\n};\r\n\r\n\r\n/**\r\n * Returns a new array that is the result of joining the arguments.  If arrays\r\n * are passed then their items are added, however, if non-arrays are passed they\r\n * will be added to the return array as is.\r\n *\r\n * Note that ArrayLike objects will be added as is, rather than having their\r\n * items added.\r\n *\r\n * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]\r\n * goog.array.concat(0, [1, 2]) -> [0, 1, 2]\r\n * goog.array.concat([1, 2], null) -> [1, 2, null]\r\n *\r\n * There is bug in all current versions of IE (6, 7 and 8) where arrays created\r\n * in an iframe become corrupted soon (not immediately) after the iframe is\r\n * destroyed. This is common if loading data via goog.net.IframeIo, for example.\r\n * This corruption only affects the concat method which will start throwing\r\n * Catastrophic Errors (#-2147418113).\r\n *\r\n * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.\r\n *\r\n * Internally goog.array should use this, so that all methods will continue to\r\n * work on these broken array objects.\r\n *\r\n * @param {...*} var_args Items to concatenate.  Arrays will have each item\r\n *     added, while primitives and objects will be added as is.\r\n * @return {!Array<?>} The new resultant array.\r\n */\r\ngoog.array.concat = function(var_args) {\r\n  return Array.prototype.concat.apply([], arguments);\r\n};\r\n\r\n\r\n/**\r\n * Returns a new array that contains the contents of all the arrays passed.\r\n * @param {...!Array<T>} var_args\r\n * @return {!Array<T>}\r\n * @template T\r\n */\r\ngoog.array.join = function(var_args) {\r\n  return Array.prototype.concat.apply([], arguments);\r\n};\r\n\r\n\r\n/**\r\n * Converts an object to an array.\r\n * @param {IArrayLike<T>|string} object  The object to convert to an\r\n *     array.\r\n * @return {!Array<T>} The object converted into an array. If object has a\r\n *     length property, every property indexed with a non-negative number\r\n *     less than length will be included in the result. If object does not\r\n *     have a length property, an empty array will be returned.\r\n * @template T\r\n */\r\ngoog.array.toArray = function(object) {\r\n  var length = object.length;\r\n\r\n  // If length is not a number the following is false. This case is kept for\r\n  // backwards compatibility since there are callers that pass objects that are\r\n  // not array like.\r\n  if (length > 0) {\r\n    var rv = new Array(length);\r\n    for (var i = 0; i < length; i++) {\r\n      rv[i] = object[i];\r\n    }\r\n    return rv;\r\n  }\r\n  return [];\r\n};\r\n\r\n\r\n/**\r\n * Does a shallow copy of an array.\r\n * @param {IArrayLike<T>|string} arr  Array or array-like object to\r\n *     clone.\r\n * @return {!Array<T>} Clone of the input array.\r\n * @template T\r\n */\r\ngoog.array.clone = goog.array.toArray;\r\n\r\n\r\n/**\r\n * Extends an array with another array, element, or \"array like\" object.\r\n * This function operates 'in-place', it does not create a new Array.\r\n *\r\n * Example:\r\n * var a = [];\r\n * goog.array.extend(a, [0, 1]);\r\n * a; // [0, 1]\r\n * goog.array.extend(a, 2);\r\n * a; // [0, 1, 2]\r\n *\r\n * @param {Array<VALUE>} arr1  The array to modify.\r\n * @param {...(IArrayLike<VALUE>|VALUE)} var_args The elements or arrays of\r\n *     elements to add to arr1.\r\n * @template VALUE\r\n */\r\ngoog.array.extend = function(arr1, var_args) {\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    var arr2 = arguments[i];\r\n    if (goog.isArrayLike(arr2)) {\r\n      var len1 = arr1.length || 0;\r\n      var len2 = arr2.length || 0;\r\n      arr1.length = len1 + len2;\r\n      for (var j = 0; j < len2; j++) {\r\n        arr1[len1 + j] = arr2[j];\r\n      }\r\n    } else {\r\n      arr1.push(arr2);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds or removes elements from an array. This is a generic version of Array\r\n * splice. This means that it might work on other objects similar to arrays,\r\n * such as the arguments object.\r\n *\r\n * @param {IArrayLike<T>} arr The array to modify.\r\n * @param {number|undefined} index The index at which to start changing the\r\n *     array. If not defined, treated as 0.\r\n * @param {number} howMany How many elements to remove (0 means no removal. A\r\n *     value below 0 is treated as zero and so is any other non number. Numbers\r\n *     are floored).\r\n * @param {...T} var_args Optional, additional elements to insert into the\r\n *     array.\r\n * @return {!Array<T>} the removed elements.\r\n * @template T\r\n */\r\ngoog.array.splice = function(arr, index, howMany, var_args) {\r\n  goog.asserts.assert(arr.length != null);\r\n\r\n  return Array.prototype.splice.apply(arr, goog.array.slice(arguments, 1));\r\n};\r\n\r\n\r\n/**\r\n * Returns a new array from a segment of an array. This is a generic version of\r\n * Array slice. This means that it might work on other objects similar to\r\n * arrays, such as the arguments object.\r\n *\r\n * @param {IArrayLike<T>|string} arr The array from\r\n * which to copy a segment.\r\n * @param {number} start The index of the first element to copy.\r\n * @param {number=} opt_end The index after the last element to copy.\r\n * @return {!Array<T>} A new array containing the specified segment of the\r\n *     original array.\r\n * @template T\r\n */\r\ngoog.array.slice = function(arr, start, opt_end) {\r\n  goog.asserts.assert(arr.length != null);\r\n\r\n  // passing 1 arg to slice is not the same as passing 2 where the second is\r\n  // null or undefined (in that case the second argument is treated as 0).\r\n  // we could use slice on the arguments object and then use apply instead of\r\n  // testing the length\r\n  if (arguments.length <= 2) {\r\n    return Array.prototype.slice.call(arr, start);\r\n  } else {\r\n    return Array.prototype.slice.call(arr, start, opt_end);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes all duplicates from an array (retaining only the first\r\n * occurrence of each array element).  This function modifies the\r\n * array in place and doesn't change the order of the non-duplicate items.\r\n *\r\n * For objects, duplicates are identified as having the same unique ID as\r\n * defined by {@link goog.getUid}.\r\n *\r\n * Alternatively you can specify a custom hash function that returns a unique\r\n * value for each item in the array it should consider unique.\r\n *\r\n * Runtime: N,\r\n * Worstcase space: 2N (no dupes)\r\n *\r\n * @param {IArrayLike<T>} arr The array from which to remove\r\n *     duplicates.\r\n * @param {Array=} opt_rv An optional array in which to return the results,\r\n *     instead of performing the removal inplace.  If specified, the original\r\n *     array will remain unchanged.\r\n * @param {function(T):string=} opt_hashFn An optional function to use to\r\n *     apply to every item in the array. This function should return a unique\r\n *     value for each item in the array it should consider unique.\r\n * @template T\r\n */\r\ngoog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {\r\n  var returnArray = opt_rv || arr;\r\n  var defaultHashFn = function(item) {\r\n    // Prefix each type with a single character representing the type to\r\n    // prevent conflicting keys (e.g. true and 'true').\r\n    return goog.isObject(item) ? 'o' + goog.getUid(item) :\r\n                                 (typeof item).charAt(0) + item;\r\n  };\r\n  var hashFn = opt_hashFn || defaultHashFn;\r\n\r\n  var seen = {}, cursorInsert = 0, cursorRead = 0;\r\n  while (cursorRead < arr.length) {\r\n    var current = arr[cursorRead++];\r\n    var key = hashFn(current);\r\n    if (!Object.prototype.hasOwnProperty.call(seen, key)) {\r\n      seen[key] = true;\r\n      returnArray[cursorInsert++] = current;\r\n    }\r\n  }\r\n  returnArray.length = cursorInsert;\r\n};\r\n\r\n\r\n/**\r\n * Searches the specified array for the specified target using the binary\r\n * search algorithm.  If no opt_compareFn is specified, elements are compared\r\n * using <code>goog.array.defaultCompare</code>, which compares the elements\r\n * using the built in < and > operators.  This will produce the expected\r\n * behavior for homogeneous arrays of String(s) and Number(s). The array\r\n * specified <b>must</b> be sorted in ascending order (as defined by the\r\n * comparison function).  If the array is not sorted, results are undefined.\r\n * If the array contains multiple instances of the specified target value, any\r\n * of these instances may be found.\r\n *\r\n * Runtime: O(log n)\r\n *\r\n * @param {IArrayLike<VALUE>} arr The array to be searched.\r\n * @param {TARGET} target The sought value.\r\n * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison\r\n *     function by which the array is ordered. Should take 2 arguments to\r\n *     compare, the target value and an element from your array, and return a\r\n *     negative number, zero, or a positive number depending on whether the\r\n *     first argument is less than, equal to, or greater than the second.\r\n * @return {number} Lowest index of the target value if found, otherwise\r\n *     (-(insertion point) - 1). The insertion point is where the value should\r\n *     be inserted into arr to preserve the sorted property.  Return value >= 0\r\n *     iff target is found.\r\n * @template TARGET, VALUE\r\n */\r\ngoog.array.binarySearch = function(arr, target, opt_compareFn) {\r\n  return goog.array.binarySearch_(\r\n      arr, opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,\r\n      target);\r\n};\r\n\r\n\r\n/**\r\n * Selects an index in the specified array using the binary search algorithm.\r\n * The evaluator receives an element and determines whether the desired index\r\n * is before, at, or after it.  The evaluator must be consistent (formally,\r\n * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)\r\n * must be monotonically non-increasing).\r\n *\r\n * Runtime: O(log n)\r\n *\r\n * @param {IArrayLike<VALUE>} arr The array to be searched.\r\n * @param {function(this:THIS, VALUE, number, ?): number} evaluator\r\n *     Evaluator function that receives 3 arguments (the element, the index and\r\n *     the array). Should return a negative number, zero, or a positive number\r\n *     depending on whether the desired index is before, at, or after the\r\n *     element passed to it.\r\n * @param {THIS=} opt_obj The object to be used as the value of 'this'\r\n *     within evaluator.\r\n * @return {number} Index of the leftmost element matched by the evaluator, if\r\n *     such exists; otherwise (-(insertion point) - 1). The insertion point is\r\n *     the index of the first element for which the evaluator returns negative,\r\n *     or arr.length if no such element exists. The return value is non-negative\r\n *     iff a match is found.\r\n * @template THIS, VALUE\r\n */\r\ngoog.array.binarySelect = function(arr, evaluator, opt_obj) {\r\n  return goog.array.binarySearch_(\r\n      arr, evaluator, true /* isEvaluator */, undefined /* opt_target */,\r\n      opt_obj);\r\n};\r\n\r\n\r\n/**\r\n * Implementation of a binary search algorithm which knows how to use both\r\n * comparison functions and evaluators. If an evaluator is provided, will call\r\n * the evaluator with the given optional data object, conforming to the\r\n * interface defined in binarySelect. Otherwise, if a comparison function is\r\n * provided, will call the comparison function against the given data object.\r\n *\r\n * This implementation purposefully does not use goog.bind or goog.partial for\r\n * performance reasons.\r\n *\r\n * Runtime: O(log n)\r\n *\r\n * @param {IArrayLike<?>} arr The array to be searched.\r\n * @param {function(?, ?, ?): number | function(?, ?): number} compareFn\r\n *     Either an evaluator or a comparison function, as defined by binarySearch\r\n *     and binarySelect above.\r\n * @param {boolean} isEvaluator Whether the function is an evaluator or a\r\n *     comparison function.\r\n * @param {?=} opt_target If the function is a comparison function, then\r\n *     this is the target to binary search for.\r\n * @param {Object=} opt_selfObj If the function is an evaluator, this is an\r\n *     optional this object for the evaluator.\r\n * @return {number} Lowest index of the target value if found, otherwise\r\n *     (-(insertion point) - 1). The insertion point is where the value should\r\n *     be inserted into arr to preserve the sorted property.  Return value >= 0\r\n *     iff target is found.\r\n * @private\r\n */\r\ngoog.array.binarySearch_ = function(\r\n    arr, compareFn, isEvaluator, opt_target, opt_selfObj) {\r\n  var left = 0;            // inclusive\r\n  var right = arr.length;  // exclusive\r\n  var found;\r\n  while (left < right) {\r\n    var middle = (left + right) >> 1;\r\n    var compareResult;\r\n    if (isEvaluator) {\r\n      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);\r\n    } else {\r\n      // NOTE(dimvar): To avoid this cast, we'd have to use function overloading\r\n      // for the type of binarySearch_, which the type system can't express yet.\r\n      compareResult = /** @type {function(?, ?): number} */ (compareFn)(\r\n          opt_target, arr[middle]);\r\n    }\r\n    if (compareResult > 0) {\r\n      left = middle + 1;\r\n    } else {\r\n      right = middle;\r\n      // We are looking for the lowest index so we can't return immediately.\r\n      found = !compareResult;\r\n    }\r\n  }\r\n  // left is the index if found, or the insertion point otherwise.\r\n  // ~left is a shorthand for -left - 1.\r\n  return found ? left : ~left;\r\n};\r\n\r\n\r\n/**\r\n * Sorts the specified array into ascending order.  If no opt_compareFn is\r\n * specified, elements are compared using\r\n * <code>goog.array.defaultCompare</code>, which compares the elements using\r\n * the built in < and > operators.  This will produce the expected behavior\r\n * for homogeneous arrays of String(s) and Number(s), unlike the native sort,\r\n * but will give unpredictable results for heterogeneous lists of strings and\r\n * numbers with different numbers of digits.\r\n *\r\n * This sort is not guaranteed to be stable.\r\n *\r\n * Runtime: Same as <code>Array.prototype.sort</code>\r\n *\r\n * @param {Array<T>} arr The array to be sorted.\r\n * @param {?function(T,T):number=} opt_compareFn Optional comparison\r\n *     function by which the\r\n *     array is to be ordered. Should take 2 arguments to compare, and return a\r\n *     negative number, zero, or a positive number depending on whether the\r\n *     first argument is less than, equal to, or greater than the second.\r\n * @template T\r\n */\r\ngoog.array.sort = function(arr, opt_compareFn) {\r\n  // TODO(arv): Update type annotation since null is not accepted.\r\n  arr.sort(opt_compareFn || goog.array.defaultCompare);\r\n};\r\n\r\n\r\n/**\r\n * Sorts the specified array into ascending order in a stable way.  If no\r\n * opt_compareFn is specified, elements are compared using\r\n * <code>goog.array.defaultCompare</code>, which compares the elements using\r\n * the built in < and > operators.  This will produce the expected behavior\r\n * for homogeneous arrays of String(s) and Number(s).\r\n *\r\n * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional\r\n * O(n) overhead of copying the array twice.\r\n *\r\n * @param {Array<T>} arr The array to be sorted.\r\n * @param {?function(T, T): number=} opt_compareFn Optional comparison function\r\n *     by which the array is to be ordered. Should take 2 arguments to compare,\r\n *     and return a negative number, zero, or a positive number depending on\r\n *     whether the first argument is less than, equal to, or greater than the\r\n *     second.\r\n * @template T\r\n */\r\ngoog.array.stableSort = function(arr, opt_compareFn) {\r\n  var compArr = new Array(arr.length);\r\n  for (var i = 0; i < arr.length; i++) {\r\n    compArr[i] = {index: i, value: arr[i]};\r\n  }\r\n  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;\r\n  function stableCompareFn(obj1, obj2) {\r\n    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;\r\n  }\r\n  goog.array.sort(compArr, stableCompareFn);\r\n  for (var i = 0; i < arr.length; i++) {\r\n    arr[i] = compArr[i].value;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Sort the specified array into ascending order based on item keys\r\n * returned by the specified key function.\r\n * If no opt_compareFn is specified, the keys are compared in ascending order\r\n * using <code>goog.array.defaultCompare</code>.\r\n *\r\n * Runtime: O(S(f(n)), where S is runtime of <code>goog.array.sort</code>\r\n * and f(n) is runtime of the key function.\r\n *\r\n * @param {Array<T>} arr The array to be sorted.\r\n * @param {function(T): K} keyFn Function taking array element and returning\r\n *     a key used for sorting this element.\r\n * @param {?function(K, K): number=} opt_compareFn Optional comparison function\r\n *     by which the keys are to be ordered. Should take 2 arguments to compare,\r\n *     and return a negative number, zero, or a positive number depending on\r\n *     whether the first argument is less than, equal to, or greater than the\r\n *     second.\r\n * @template T,K\r\n */\r\ngoog.array.sortByKey = function(arr, keyFn, opt_compareFn) {\r\n  var keyCompareFn = opt_compareFn || goog.array.defaultCompare;\r\n  goog.array.sort(\r\n      arr, function(a, b) { return keyCompareFn(keyFn(a), keyFn(b)); });\r\n};\r\n\r\n\r\n/**\r\n * Sorts an array of objects by the specified object key and compare\r\n * function. If no compare function is provided, the key values are\r\n * compared in ascending order using <code>goog.array.defaultCompare</code>.\r\n * This won't work for keys that get renamed by the compiler. So use\r\n * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.\r\n * @param {Array<Object>} arr An array of objects to sort.\r\n * @param {string} key The object key to sort by.\r\n * @param {Function=} opt_compareFn The function to use to compare key\r\n *     values.\r\n */\r\ngoog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {\r\n  goog.array.sortByKey(arr, function(obj) { return obj[key]; }, opt_compareFn);\r\n};\r\n\r\n\r\n/**\r\n * Tells if the array is sorted.\r\n * @param {!IArrayLike<T>} arr The array.\r\n * @param {?function(T,T):number=} opt_compareFn Function to compare the\r\n *     array elements.\r\n *     Should take 2 arguments to compare, and return a negative number, zero,\r\n *     or a positive number depending on whether the first argument is less\r\n *     than, equal to, or greater than the second.\r\n * @param {boolean=} opt_strict If true no equal elements are allowed.\r\n * @return {boolean} Whether the array is sorted.\r\n * @template T\r\n */\r\ngoog.array.isSorted = function(arr, opt_compareFn, opt_strict) {\r\n  var compare = opt_compareFn || goog.array.defaultCompare;\r\n  for (var i = 1; i < arr.length; i++) {\r\n    var compareResult = compare(arr[i - 1], arr[i]);\r\n    if (compareResult > 0 || compareResult == 0 && opt_strict) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Compares two arrays for equality. Two arrays are considered equal if they\r\n * have the same length and their corresponding elements are equal according to\r\n * the comparison function.\r\n *\r\n * @param {IArrayLike<?>} arr1 The first array to compare.\r\n * @param {IArrayLike<?>} arr2 The second array to compare.\r\n * @param {Function=} opt_equalsFn Optional comparison function.\r\n *     Should take 2 arguments to compare, and return true if the arguments\r\n *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which\r\n *     compares the elements using the built-in '===' operator.\r\n * @return {boolean} Whether the two arrays are equal.\r\n */\r\ngoog.array.equals = function(arr1, arr2, opt_equalsFn) {\r\n  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||\r\n      arr1.length != arr2.length) {\r\n    return false;\r\n  }\r\n  var l = arr1.length;\r\n  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;\r\n  for (var i = 0; i < l; i++) {\r\n    if (!equalsFn(arr1[i], arr2[i])) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * 3-way array compare function.\r\n * @param {!IArrayLike<VALUE>} arr1 The first array to\r\n *     compare.\r\n * @param {!IArrayLike<VALUE>} arr2 The second array to\r\n *     compare.\r\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\r\n *     function by which the array is to be ordered. Should take 2 arguments to\r\n *     compare, and return a negative number, zero, or a positive number\r\n *     depending on whether the first argument is less than, equal to, or\r\n *     greater than the second.\r\n * @return {number} Negative number, zero, or a positive number depending on\r\n *     whether the first argument is less than, equal to, or greater than the\r\n *     second.\r\n * @template VALUE\r\n */\r\ngoog.array.compare3 = function(arr1, arr2, opt_compareFn) {\r\n  var compare = opt_compareFn || goog.array.defaultCompare;\r\n  var l = Math.min(arr1.length, arr2.length);\r\n  for (var i = 0; i < l; i++) {\r\n    var result = compare(arr1[i], arr2[i]);\r\n    if (result != 0) {\r\n      return result;\r\n    }\r\n  }\r\n  return goog.array.defaultCompare(arr1.length, arr2.length);\r\n};\r\n\r\n\r\n/**\r\n * Compares its two arguments for order, using the built in < and >\r\n * operators.\r\n * @param {VALUE} a The first object to be compared.\r\n * @param {VALUE} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is less than, equal to, or greater than the second,\r\n *     respectively.\r\n * @template VALUE\r\n */\r\ngoog.array.defaultCompare = function(a, b) {\r\n  return a > b ? 1 : a < b ? -1 : 0;\r\n};\r\n\r\n\r\n/**\r\n * Compares its two arguments for inverse order, using the built in < and >\r\n * operators.\r\n * @param {VALUE} a The first object to be compared.\r\n * @param {VALUE} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is greater than, equal to, or less than the second,\r\n *     respectively.\r\n * @template VALUE\r\n */\r\ngoog.array.inverseDefaultCompare = function(a, b) {\r\n  return -goog.array.defaultCompare(a, b);\r\n};\r\n\r\n\r\n/**\r\n * Compares its two arguments for equality, using the built in === operator.\r\n * @param {*} a The first object to compare.\r\n * @param {*} b The second object to compare.\r\n * @return {boolean} True if the two arguments are equal, false otherwise.\r\n */\r\ngoog.array.defaultCompareEquality = function(a, b) {\r\n  return a === b;\r\n};\r\n\r\n\r\n/**\r\n * Inserts a value into a sorted array. The array is not modified if the\r\n * value is already present.\r\n * @param {IArrayLike<VALUE>} array The array to modify.\r\n * @param {VALUE} value The object to insert.\r\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\r\n *     function by which the array is ordered. Should take 2 arguments to\r\n *     compare, and return a negative number, zero, or a positive number\r\n *     depending on whether the first argument is less than, equal to, or\r\n *     greater than the second.\r\n * @return {boolean} True if an element was inserted.\r\n * @template VALUE\r\n */\r\ngoog.array.binaryInsert = function(array, value, opt_compareFn) {\r\n  var index = goog.array.binarySearch(array, value, opt_compareFn);\r\n  if (index < 0) {\r\n    goog.array.insertAt(array, value, -(index + 1));\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Removes a value from a sorted array.\r\n * @param {!IArrayLike<VALUE>} array The array to modify.\r\n * @param {VALUE} value The object to remove.\r\n * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison\r\n *     function by which the array is ordered. Should take 2 arguments to\r\n *     compare, and return a negative number, zero, or a positive number\r\n *     depending on whether the first argument is less than, equal to, or\r\n *     greater than the second.\r\n * @return {boolean} True if an element was removed.\r\n * @template VALUE\r\n */\r\ngoog.array.binaryRemove = function(array, value, opt_compareFn) {\r\n  var index = goog.array.binarySearch(array, value, opt_compareFn);\r\n  return (index >= 0) ? goog.array.removeAt(array, index) : false;\r\n};\r\n\r\n\r\n/**\r\n * Splits an array into disjoint buckets according to a splitting function.\r\n * @param {IArrayLike<T>} array The array.\r\n * @param {function(this:S, T, number, !IArrayLike<T>):?} sorter Function to\r\n *     call for every element.  This takes 3 arguments (the element, the index\r\n *     and the array) and must return a valid object key (a string, number,\r\n *     etc), or undefined, if that object should not be placed in a bucket.\r\n * @param {S=} opt_obj The object to be used as the value of 'this' within\r\n *     sorter.\r\n * @return {!Object<!Array<T>>} An object, with keys being all of the unique\r\n *     return values of sorter, and values being arrays containing the items for\r\n *     which the splitter returned that key.\r\n * @template T,S\r\n */\r\ngoog.array.bucket = function(array, sorter, opt_obj) {\r\n  var buckets = {};\r\n\r\n  for (var i = 0; i < array.length; i++) {\r\n    var value = array[i];\r\n    var key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);\r\n    if (goog.isDef(key)) {\r\n      // Push the value to the right bucket, creating it if necessary.\r\n      var bucket = buckets[key] || (buckets[key] = []);\r\n      bucket.push(value);\r\n    }\r\n  }\r\n\r\n  return buckets;\r\n};\r\n\r\n\r\n/**\r\n * Creates a new object built from the provided array and the key-generation\r\n * function.\r\n * @param {IArrayLike<T>} arr Array or array like object over\r\n *     which to iterate whose elements will be the values in the new object.\r\n * @param {?function(this:S, T, number, ?) : string} keyFunc The function to\r\n *     call for every element. This function takes 3 arguments (the element, the\r\n *     index and the array) and should return a string that will be used as the\r\n *     key for the element in the new object. If the function returns the same\r\n *     key for more than one element, the value for that key is\r\n *     implementation-defined.\r\n * @param {S=} opt_obj The object to be used as the value of 'this'\r\n *     within keyFunc.\r\n * @return {!Object<T>} The new object.\r\n * @template T,S\r\n */\r\ngoog.array.toObject = function(arr, keyFunc, opt_obj) {\r\n  var ret = {};\r\n  goog.array.forEach(arr, function(element, index) {\r\n    ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =\r\n        element;\r\n  });\r\n  return ret;\r\n};\r\n\r\n\r\n/**\r\n * Creates a range of numbers in an arithmetic progression.\r\n *\r\n * Range takes 1, 2, or 3 arguments:\r\n * <pre>\r\n * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]\r\n * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]\r\n * range(-2, -5, -1) produces [-2, -3, -4]\r\n * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.\r\n * </pre>\r\n *\r\n * @param {number} startOrEnd The starting value of the range if an end argument\r\n *     is provided. Otherwise, the start value is 0, and this is the end value.\r\n * @param {number=} opt_end The optional end value of the range.\r\n * @param {number=} opt_step The step size between range values. Defaults to 1\r\n *     if opt_step is undefined or 0.\r\n * @return {!Array<number>} An array of numbers for the requested range. May be\r\n *     an empty array if adding the step would not converge toward the end\r\n *     value.\r\n */\r\ngoog.array.range = function(startOrEnd, opt_end, opt_step) {\r\n  var array = [];\r\n  var start = 0;\r\n  var end = startOrEnd;\r\n  var step = opt_step || 1;\r\n  if (opt_end !== undefined) {\r\n    start = startOrEnd;\r\n    end = opt_end;\r\n  }\r\n\r\n  if (step * (end - start) < 0) {\r\n    // Sign mismatch: start + step will never reach the end value.\r\n    return [];\r\n  }\r\n\r\n  if (step > 0) {\r\n    for (var i = start; i < end; i += step) {\r\n      array.push(i);\r\n    }\r\n  } else {\r\n    for (var i = start; i > end; i += step) {\r\n      array.push(i);\r\n    }\r\n  }\r\n  return array;\r\n};\r\n\r\n\r\n/**\r\n * Returns an array consisting of the given value repeated N times.\r\n *\r\n * @param {VALUE} value The value to repeat.\r\n * @param {number} n The repeat count.\r\n * @return {!Array<VALUE>} An array with the repeated value.\r\n * @template VALUE\r\n */\r\ngoog.array.repeat = function(value, n) {\r\n  var array = [];\r\n  for (var i = 0; i < n; i++) {\r\n    array[i] = value;\r\n  }\r\n  return array;\r\n};\r\n\r\n\r\n/**\r\n * Returns an array consisting of every argument with all arrays\r\n * expanded in-place recursively.\r\n *\r\n * @param {...*} var_args The values to flatten.\r\n * @return {!Array<?>} An array containing the flattened values.\r\n */\r\ngoog.array.flatten = function(var_args) {\r\n  var CHUNK_SIZE = 8192;\r\n\r\n  var result = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var element = arguments[i];\r\n    if (goog.isArray(element)) {\r\n      for (var c = 0; c < element.length; c += CHUNK_SIZE) {\r\n        var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);\r\n        var recurseResult = goog.array.flatten.apply(null, chunk);\r\n        for (var r = 0; r < recurseResult.length; r++) {\r\n          result.push(recurseResult[r]);\r\n        }\r\n      }\r\n    } else {\r\n      result.push(element);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Rotates an array in-place. After calling this method, the element at\r\n * index i will be the element previously at index (i - n) %\r\n * array.length, for all values of i between 0 and array.length - 1,\r\n * inclusive.\r\n *\r\n * For example, suppose list comprises [t, a, n, k, s]. After invoking\r\n * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].\r\n *\r\n * @param {!Array<T>} array The array to rotate.\r\n * @param {number} n The amount to rotate.\r\n * @return {!Array<T>} The array.\r\n * @template T\r\n */\r\ngoog.array.rotate = function(array, n) {\r\n  goog.asserts.assert(array.length != null);\r\n\r\n  if (array.length) {\r\n    n %= array.length;\r\n    if (n > 0) {\r\n      Array.prototype.unshift.apply(array, array.splice(-n, n));\r\n    } else if (n < 0) {\r\n      Array.prototype.push.apply(array, array.splice(0, -n));\r\n    }\r\n  }\r\n  return array;\r\n};\r\n\r\n\r\n/**\r\n * Moves one item of an array to a new position keeping the order of the rest\r\n * of the items. Example use case: keeping a list of JavaScript objects\r\n * synchronized with the corresponding list of DOM elements after one of the\r\n * elements has been dragged to a new position.\r\n * @param {!IArrayLike<?>} arr The array to modify.\r\n * @param {number} fromIndex Index of the item to move between 0 and\r\n *     {@code arr.length - 1}.\r\n * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.\r\n */\r\ngoog.array.moveItem = function(arr, fromIndex, toIndex) {\r\n  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);\r\n  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);\r\n  // Remove 1 item at fromIndex.\r\n  var removedItems = Array.prototype.splice.call(arr, fromIndex, 1);\r\n  // Insert the removed item at toIndex.\r\n  Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);\r\n  // We don't use goog.array.insertAt and goog.array.removeAt, because they're\r\n  // significantly slower than splice.\r\n};\r\n\r\n\r\n/**\r\n * Creates a new array for which the element at position i is an array of the\r\n * ith element of the provided arrays.  The returned array will only be as long\r\n * as the shortest array provided; additional values are ignored.  For example,\r\n * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].\r\n *\r\n * This is similar to the zip() function in Python.  See {@link\r\n * http://docs.python.org/library/functions.html#zip}\r\n *\r\n * @param {...!IArrayLike<?>} var_args Arrays to be combined.\r\n * @return {!Array<!Array<?>>} A new array of arrays created from\r\n *     provided arrays.\r\n */\r\ngoog.array.zip = function(var_args) {\r\n  if (!arguments.length) {\r\n    return [];\r\n  }\r\n  var result = [];\r\n  var minLen = arguments[0].length;\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    if (arguments[i].length < minLen) {\r\n      minLen = arguments[i].length;\r\n    }\r\n  }\r\n  for (var i = 0; i < minLen; i++) {\r\n    var value = [];\r\n    for (var j = 0; j < arguments.length; j++) {\r\n      value.push(arguments[j][i]);\r\n    }\r\n    result.push(value);\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Shuffles the values in the specified array using the Fisher-Yates in-place\r\n * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()\r\n * and so resets the state of that random number generator. Similarly, may reset\r\n * the state of any other specified random number generator.\r\n *\r\n * Runtime: O(n)\r\n *\r\n * @param {!Array<?>} arr The array to be shuffled.\r\n * @param {function():number=} opt_randFn Optional random function to use for\r\n *     shuffling.\r\n *     Takes no arguments, and returns a random number on the interval [0, 1).\r\n *     Defaults to Math.random() using JavaScript's built-in Math library.\r\n */\r\ngoog.array.shuffle = function(arr, opt_randFn) {\r\n  var randFn = opt_randFn || Math.random;\r\n\r\n  for (var i = arr.length - 1; i > 0; i--) {\r\n    // Choose a random array index in [0, i] (inclusive with i).\r\n    var j = Math.floor(randFn() * (i + 1));\r\n\r\n    var tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns a new array of elements from arr, based on the indexes of elements\r\n * provided by index_arr. For example, the result of index copying\r\n * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].\r\n *\r\n * @param {!IArrayLike<T>} arr The array to get a indexed copy from.\r\n * @param {!IArrayLike<number>} index_arr An array of indexes to get from arr.\r\n * @return {!Array<T>} A new array of elements from arr in index_arr order.\r\n * @template T\r\n */\r\ngoog.array.copyByIndex = function(arr, index_arr) {\r\n  var result = [];\r\n  goog.array.forEach(index_arr, function(index) { result.push(arr[index]); });\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Maps each element of the input array into zero or more elements of the output\r\n * array.\r\n *\r\n * @param {!IArrayLike<VALUE>|string} arr Array or array like object\r\n *     over which to iterate.\r\n * @param {function(this:THIS, VALUE, number, ?): !Array<RESULT>} f The function\r\n *     to call for every element. This function takes 3 arguments (the element,\r\n *     the index and the array) and should return an array. The result will be\r\n *     used to extend a new array.\r\n * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.\r\n * @return {!Array<RESULT>} a new array with the concatenation of all arrays\r\n *     returned from f.\r\n * @template THIS, VALUE, RESULT\r\n */\r\ngoog.array.concatMap = function(arr, f, opt_obj) {\r\n  return goog.array.concat.apply([], goog.array.map(arr, f, opt_obj));\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview String functions called from Closure packages that couldn't\r\n * depend on each other. Outside Closure, use goog.string function which\r\n * delegate to these.\r\n */\r\n\r\n\r\ngoog.provide('goog.string.internal');\r\n\r\n\r\n/**\r\n * Fast prefix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} prefix A string to look for at the start of `str`.\r\n * @return {boolean} True if `str` begins with `prefix`.\r\n * @see goog.string.startsWith\r\n */\r\ngoog.string.internal.startsWith = function(str, prefix) {\r\n  return str.lastIndexOf(prefix, 0) == 0;\r\n};\r\n\r\n\r\n/**\r\n * Fast suffix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} suffix A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` ends with `suffix`.\r\n * @see goog.string.endsWith\r\n */\r\ngoog.string.internal.endsWith = function(str, suffix) {\r\n  var l = str.length - suffix.length;\r\n  return l >= 0 && str.indexOf(suffix, l) == l;\r\n};\r\n\r\n\r\n/**\r\n * Case-insensitive prefix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} prefix  A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` begins with `prefix` (ignoring\r\n *     case).\r\n * @see goog.string.caseInsensitiveStartsWith\r\n */\r\ngoog.string.internal.caseInsensitiveStartsWith = function(str, prefix) {\r\n  return goog.string.internal.caseInsensitiveCompare(\r\n             prefix, str.substr(0, prefix.length)) == 0;\r\n};\r\n\r\n\r\n/**\r\n * Case-insensitive suffix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} suffix A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` ends with `suffix` (ignoring\r\n *     case).\r\n * @see goog.string.caseInsensitiveEndsWith\r\n */\r\ngoog.string.internal.caseInsensitiveEndsWith = function(str, suffix) {\r\n  return (\r\n      goog.string.internal.caseInsensitiveCompare(\r\n          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);\r\n};\r\n\r\n\r\n/**\r\n * Case-insensitive equality checker.\r\n * @param {string} str1 First string to check.\r\n * @param {string} str2 Second string to check.\r\n * @return {boolean} True if `str1` and `str2` are the same string,\r\n *     ignoring case.\r\n * @see goog.string.caseInsensitiveEquals\r\n */\r\ngoog.string.internal.caseInsensitiveEquals = function(str1, str2) {\r\n  return str1.toLowerCase() == str2.toLowerCase();\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string is empty or contains only whitespaces.\r\n * @param {string} str The string to check.\r\n * @return {boolean} Whether `str` is empty or whitespace only.\r\n * @see goog.string.isEmptyOrWhitespace\r\n */\r\ngoog.string.internal.isEmptyOrWhitespace = function(str) {\r\n  // testing length == 0 first is actually slower in all browsers (about the\r\n  // same in Opera).\r\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\r\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\r\n  // include it in the regexp to enforce consistent cross-browser behavior.\r\n  return /^[\\s\\xa0]*$/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Trims white spaces to the left and right of a string.\r\n * @param {string} str The string to trim.\r\n * @return {string} A trimmed copy of `str`.\r\n */\r\ngoog.string.internal.trim =\r\n    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {\r\n      return str.trim();\r\n    } : function(str) {\r\n      // Since IE doesn't include non-breaking-space (0xa0) in their \\s\r\n      // character class (as required by section 7.2 of the ECMAScript spec),\r\n      // we explicitly include it in the regexp to enforce consistent\r\n      // cross-browser behavior.\r\n      // NOTE: We don't use String#replace because it might have side effects\r\n      // causing this function to not compile to 0 bytes.\r\n      return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(str)[1];\r\n    };\r\n\r\n\r\n/**\r\n * A string comparator that ignores case.\r\n * -1 = str1 less than str2\r\n *  0 = str1 equals str2\r\n *  1 = str1 greater than str2\r\n *\r\n * @param {string} str1 The string to compare.\r\n * @param {string} str2 The string to compare `str1` to.\r\n * @return {number} The comparator result, as described above.\r\n * @see goog.string.caseInsensitiveCompare\r\n */\r\ngoog.string.internal.caseInsensitiveCompare = function(str1, str2) {\r\n  var test1 = String(str1).toLowerCase();\r\n  var test2 = String(str2).toLowerCase();\r\n\r\n  if (test1 < test2) {\r\n    return -1;\r\n  } else if (test1 == test2) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Converts \\n to <br>s or <br />s.\r\n * @param {string} str The string in which to convert newlines.\r\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\r\n * @return {string} A copy of `str` with converted newlines.\r\n * @see goog.string.newLineToBr\r\n */\r\ngoog.string.internal.newLineToBr = function(str, opt_xml) {\r\n  return str.replace(/(\\r\\n|\\r|\\n)/g, opt_xml ? '<br />' : '<br>');\r\n};\r\n\r\n\r\n/**\r\n * Escapes double quote '\"' and single quote '\\'' characters in addition to\r\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\r\n * value within double or single quotes.\r\n * @param {string} str string to be escaped.\r\n * @param {boolean=} opt_isLikelyToContainHtmlChars\r\n * @return {string} An escaped copy of `str`.\r\n * @see goog.string.htmlEscape\r\n */\r\ngoog.string.internal.htmlEscape = function(\r\n    str, opt_isLikelyToContainHtmlChars) {\r\n  if (opt_isLikelyToContainHtmlChars) {\r\n    str = str.replace(goog.string.internal.AMP_RE_, '&amp;')\r\n              .replace(goog.string.internal.LT_RE_, '&lt;')\r\n              .replace(goog.string.internal.GT_RE_, '&gt;')\r\n              .replace(goog.string.internal.QUOT_RE_, '&quot;')\r\n              .replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;')\r\n              .replace(goog.string.internal.NULL_RE_, '&#0;');\r\n    return str;\r\n\r\n  } else {\r\n    // quick test helps in the case when there are no chars to replace, in\r\n    // worst case this makes barely a difference to the time taken\r\n    if (!goog.string.internal.ALL_RE_.test(str)) return str;\r\n\r\n    // str.indexOf is faster than regex.test in this case\r\n    if (str.indexOf('&') != -1) {\r\n      str = str.replace(goog.string.internal.AMP_RE_, '&amp;');\r\n    }\r\n    if (str.indexOf('<') != -1) {\r\n      str = str.replace(goog.string.internal.LT_RE_, '&lt;');\r\n    }\r\n    if (str.indexOf('>') != -1) {\r\n      str = str.replace(goog.string.internal.GT_RE_, '&gt;');\r\n    }\r\n    if (str.indexOf('\"') != -1) {\r\n      str = str.replace(goog.string.internal.QUOT_RE_, '&quot;');\r\n    }\r\n    if (str.indexOf('\\'') != -1) {\r\n      str = str.replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;');\r\n    }\r\n    if (str.indexOf('\\x00') != -1) {\r\n      str = str.replace(goog.string.internal.NULL_RE_, '&#0;');\r\n    }\r\n    return str;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Regular expression that matches an ampersand, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.AMP_RE_ = /&/g;\r\n\r\n\r\n/**\r\n * Regular expression that matches a less than sign, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.LT_RE_ = /</g;\r\n\r\n\r\n/**\r\n * Regular expression that matches a greater than sign, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.GT_RE_ = />/g;\r\n\r\n\r\n/**\r\n * Regular expression that matches a double quote, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.QUOT_RE_ = /\"/g;\r\n\r\n\r\n/**\r\n * Regular expression that matches a single quote, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.SINGLE_QUOTE_RE_ = /'/g;\r\n\r\n\r\n/**\r\n * Regular expression that matches null character, for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.NULL_RE_ = /\\x00/g;\r\n\r\n\r\n/**\r\n * Regular expression that matches any character that needs to be escaped.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.internal.ALL_RE_ = /[\\x00&<>\"']/;\r\n\r\n\r\n/**\r\n * Do escaping of whitespace to preserve spatial formatting. We use character\r\n * entity #160 to make it safer for xml.\r\n * @param {string} str The string in which to escape whitespace.\r\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\r\n * @return {string} An escaped copy of `str`.\r\n * @see goog.string.whitespaceEscape\r\n */\r\ngoog.string.internal.whitespaceEscape = function(str, opt_xml) {\r\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\r\n  return goog.string.internal.newLineToBr(\r\n      str.replace(/  /g, ' &#160;'), opt_xml);\r\n};\r\n\r\n\r\n/**\r\n * Determines whether a string contains a substring.\r\n * @param {string} str The string to search.\r\n * @param {string} subString The substring to search for.\r\n * @return {boolean} Whether `str` contains `subString`.\r\n * @see goog.string.contains\r\n */\r\ngoog.string.internal.contains = function(str, subString) {\r\n  return str.indexOf(subString) != -1;\r\n};\r\n\r\n\r\n/**\r\n * Determines whether a string contains a substring, ignoring case.\r\n * @param {string} str The string to search.\r\n * @param {string} subString The substring to search for.\r\n * @return {boolean} Whether `str` contains `subString`.\r\n * @see goog.string.caseInsensitiveContains\r\n */\r\ngoog.string.internal.caseInsensitiveContains = function(str, subString) {\r\n  return goog.string.internal.contains(\r\n      str.toLowerCase(), subString.toLowerCase());\r\n};\r\n\r\n\r\n/**\r\n * Compares two version numbers.\r\n *\r\n * @param {string|number} version1 Version of first item.\r\n * @param {string|number} version2 Version of second item.\r\n *\r\n * @return {number}  1 if `version1` is higher.\r\n *                   0 if arguments are equal.\r\n *                  -1 if `version2` is higher.\r\n * @see goog.string.compareVersions\r\n */\r\ngoog.string.internal.compareVersions = function(version1, version2) {\r\n  var order = 0;\r\n  // Trim leading and trailing whitespace and split the versions into\r\n  // subversions.\r\n  var v1Subs = goog.string.internal.trim(String(version1)).split('.');\r\n  var v2Subs = goog.string.internal.trim(String(version2)).split('.');\r\n  var subCount = Math.max(v1Subs.length, v2Subs.length);\r\n\r\n  // Iterate over the subversions, as long as they appear to be equivalent.\r\n  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {\r\n    var v1Sub = v1Subs[subIdx] || '';\r\n    var v2Sub = v2Subs[subIdx] || '';\r\n\r\n    do {\r\n      // Split the subversions into pairs of numbers and qualifiers (like 'b').\r\n      // Two different RegExp objects are use to make it clear the code\r\n      // is side-effect free\r\n      var v1Comp = /(\\d*)(\\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];\r\n      var v2Comp = /(\\d*)(\\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];\r\n      // Break if there are no more matches.\r\n      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {\r\n        break;\r\n      }\r\n\r\n      // Parse the numeric part of the subversion. A missing number is\r\n      // equivalent to 0.\r\n      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);\r\n      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);\r\n\r\n      // Compare the subversion components. The number has the highest\r\n      // precedence. Next, if the numbers are equal, a subversion without any\r\n      // qualifier is always higher than a subversion with any qualifier. Next,\r\n      // the qualifiers are compared as strings.\r\n      order = goog.string.internal.compareElements_(v1CompNum, v2CompNum) ||\r\n          goog.string.internal.compareElements_(\r\n              v1Comp[2].length == 0, v2Comp[2].length == 0) ||\r\n          goog.string.internal.compareElements_(v1Comp[2], v2Comp[2]);\r\n      // Stop as soon as an inequality is discovered.\r\n\r\n      v1Sub = v1Comp[3];\r\n      v2Sub = v2Comp[3];\r\n    } while (order == 0);\r\n  }\r\n\r\n  return order;\r\n};\r\n\r\n\r\n/**\r\n * Compares elements of a version number.\r\n *\r\n * @param {string|number|boolean} left An element from a version number.\r\n * @param {string|number|boolean} right An element from a version number.\r\n *\r\n * @return {number}  1 if `left` is higher.\r\n *                   0 if arguments are equal.\r\n *                  -1 if `right` is higher.\r\n * @private\r\n */\r\ngoog.string.internal.compareElements_ = function(left, right) {\r\n  if (left < right) {\r\n    return -1;\r\n  } else if (left > right) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Utilities used by goog.labs.userAgent tools. These functions\r\n * should not be used outside of goog.labs.userAgent.*.\r\n *\r\n * @author nnaze@google.com (Nathan Naze)\r\n */\r\n\r\ngoog.provide('goog.labs.userAgent.util');\r\n\r\ngoog.require('goog.string.internal');\r\n\r\n\r\n/**\r\n * Gets the native userAgent string from navigator if it exists.\r\n * If navigator or navigator.userAgent string is missing, returns an empty\r\n * string.\r\n * @return {string}\r\n * @private\r\n */\r\ngoog.labs.userAgent.util.getNativeUserAgentString_ = function() {\r\n  var navigator = goog.labs.userAgent.util.getNavigator_();\r\n  if (navigator) {\r\n    var userAgent = navigator.userAgent;\r\n    if (userAgent) {\r\n      return userAgent;\r\n    }\r\n  }\r\n  return '';\r\n};\r\n\r\n\r\n/**\r\n * Getter for the native navigator.\r\n * This is a separate function so it can be stubbed out in testing.\r\n * @return {Navigator}\r\n * @private\r\n */\r\ngoog.labs.userAgent.util.getNavigator_ = function() {\r\n  return goog.global.navigator;\r\n};\r\n\r\n\r\n/**\r\n * A possible override for applications which wish to not check\r\n * navigator.userAgent but use a specified value for detection instead.\r\n * @private {string}\r\n */\r\ngoog.labs.userAgent.util.userAgent_ =\r\n    goog.labs.userAgent.util.getNativeUserAgentString_();\r\n\r\n\r\n/**\r\n * Applications may override browser detection on the built in\r\n * navigator.userAgent object by setting this string. Set to null to use the\r\n * browser object instead.\r\n * @param {?string=} opt_userAgent The User-Agent override.\r\n */\r\ngoog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {\r\n  goog.labs.userAgent.util.userAgent_ =\r\n      opt_userAgent || goog.labs.userAgent.util.getNativeUserAgentString_();\r\n};\r\n\r\n\r\n/**\r\n * @return {string} The user agent string.\r\n */\r\ngoog.labs.userAgent.util.getUserAgent = function() {\r\n  return goog.labs.userAgent.util.userAgent_;\r\n};\r\n\r\n\r\n/**\r\n * @param {string} str\r\n * @return {boolean} Whether the user agent contains the given string.\r\n */\r\ngoog.labs.userAgent.util.matchUserAgent = function(str) {\r\n  var userAgent = goog.labs.userAgent.util.getUserAgent();\r\n  return goog.string.internal.contains(userAgent, str);\r\n};\r\n\r\n\r\n/**\r\n * @param {string} str\r\n * @return {boolean} Whether the user agent contains the given string, ignoring\r\n *     case.\r\n */\r\ngoog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {\r\n  var userAgent = goog.labs.userAgent.util.getUserAgent();\r\n  return goog.string.internal.caseInsensitiveContains(userAgent, str);\r\n};\r\n\r\n\r\n/**\r\n * Parses the user agent into tuples for each section.\r\n * @param {string} userAgent\r\n * @return {!Array<!Array<string>>} Tuples of key, version, and the contents\r\n *     of the parenthetical.\r\n */\r\ngoog.labs.userAgent.util.extractVersionTuples = function(userAgent) {\r\n  // Matches each section of a user agent string.\r\n  // Example UA:\r\n  // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)\r\n  // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405\r\n  // This has three version tuples: Mozilla, AppleWebKit, and Mobile.\r\n\r\n  var versionRegExp = new RegExp(\r\n      // Key. Note that a key may have a space.\r\n      // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')\r\n      '(\\\\w[\\\\w ]+)' +\r\n\r\n          '/' +                // slash\r\n          '([^\\\\s]+)' +        // version (i.e. '5.0b')\r\n          '\\\\s*' +             // whitespace\r\n          '(?:\\\\((.*?)\\\\))?',  // parenthetical info. parentheses not matched.\r\n      'g');\r\n\r\n  var data = [];\r\n  var match;\r\n\r\n  // Iterate and collect the version tuples.  Each iteration will be the\r\n  // next regex match.\r\n  while (match = versionRegExp.exec(userAgent)) {\r\n    data.push([\r\n      match[1],  // key\r\n      match[2],  // value\r\n      // || undefined as this is not undefined in IE7 and IE8\r\n      match[3] || undefined  // info\r\n    ]);\r\n  }\r\n\r\n  return data;\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Utilities for manipulating objects/maps/hashes.\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\ngoog.provide('goog.object');\r\n\r\n\r\n/**\r\n * Whether two values are not observably distinguishable. This\r\n * correctly detects that 0 is not the same as -0 and two NaNs are\r\n * practically equivalent.\r\n *\r\n * The implementation is as suggested by harmony:egal proposal.\r\n *\r\n * @param {*} v The first value to compare.\r\n * @param {*} v2 The second value to compare.\r\n * @return {boolean} Whether two values are not observably distinguishable.\r\n * @see http://wiki.ecmascript.org/doku.php?id=harmony:egal\r\n */\r\ngoog.object.is = function(v, v2) {\r\n  if (v === v2) {\r\n    // 0 === -0, but they are not identical.\r\n    // We need the cast because the compiler requires that v2 is a\r\n    // number (although 1/v2 works with non-number). We cast to ? to\r\n    // stop the compiler from type-checking this statement.\r\n    return v !== 0 || 1 / v === 1 / /** @type {?} */ (v2);\r\n  }\r\n\r\n  // NaN is non-reflexive: NaN !== NaN, although they are identical.\r\n  return v !== v && v2 !== v2;\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each element in an object/map/hash.\r\n *\r\n * @param {Object<K,V>} obj The object over which to iterate.\r\n * @param {function(this:T,V,?,Object<K,V>):?} f The function to call\r\n *     for every element. This function takes 3 arguments (the value, the\r\n *     key and the object) and the return value is ignored.\r\n * @param {T=} opt_obj This is used as the 'this' object within f.\r\n * @template T,K,V\r\n */\r\ngoog.object.forEach = function(obj, f, opt_obj) {\r\n  for (var key in obj) {\r\n    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each element in an object/map/hash. If that call returns\r\n * true, adds the element to a new object.\r\n *\r\n * @param {Object<K,V>} obj The object over which to iterate.\r\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to call\r\n *     for every element. This\r\n *     function takes 3 arguments (the value, the key and the object)\r\n *     and should return a boolean. If the return value is true the\r\n *     element is added to the result object. If it is false the\r\n *     element is not included.\r\n * @param {T=} opt_obj This is used as the 'this' object within f.\r\n * @return {!Object<K,V>} a new object in which only elements that passed the\r\n *     test are present.\r\n * @template T,K,V\r\n */\r\ngoog.object.filter = function(obj, f, opt_obj) {\r\n  var res = {};\r\n  for (var key in obj) {\r\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\r\n      res[key] = obj[key];\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n\r\n/**\r\n * For every element in an object/map/hash calls a function and inserts the\r\n * result into a new object.\r\n *\r\n * @param {Object<K,V>} obj The object over which to iterate.\r\n * @param {function(this:T,V,?,Object<K,V>):R} f The function to call\r\n *     for every element. This function\r\n *     takes 3 arguments (the value, the key and the object)\r\n *     and should return something. The result will be inserted\r\n *     into a new object.\r\n * @param {T=} opt_obj This is used as the 'this' object within f.\r\n * @return {!Object<K,R>} a new object with the results from f.\r\n * @template T,K,V,R\r\n */\r\ngoog.object.map = function(obj, f, opt_obj) {\r\n  var res = {};\r\n  for (var key in obj) {\r\n    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);\r\n  }\r\n  return res;\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each element in an object/map/hash. If any\r\n * call returns true, returns true (without checking the rest). If\r\n * all calls return false, returns false.\r\n *\r\n * @param {Object<K,V>} obj The object to check.\r\n * @param {function(this:T,V,?,Object<K,V>):boolean} f The function to\r\n *     call for every element. This function\r\n *     takes 3 arguments (the value, the key and the object) and should\r\n *     return a boolean.\r\n * @param {T=} opt_obj This is used as the 'this' object within f.\r\n * @return {boolean} true if any element passes the test.\r\n * @template T,K,V\r\n */\r\ngoog.object.some = function(obj, f, opt_obj) {\r\n  for (var key in obj) {\r\n    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each element in an object/map/hash. If\r\n * all calls return true, returns true. If any call returns false, returns\r\n * false at this point and does not continue to check the remaining elements.\r\n *\r\n * @param {Object<K,V>} obj The object to check.\r\n * @param {?function(this:T,V,?,Object<K,V>):boolean} f The function to\r\n *     call for every element. This function\r\n *     takes 3 arguments (the value, the key and the object) and should\r\n *     return a boolean.\r\n * @param {T=} opt_obj This is used as the 'this' object within f.\r\n * @return {boolean} false if any element fails the test.\r\n * @template T,K,V\r\n */\r\ngoog.object.every = function(obj, f, opt_obj) {\r\n  for (var key in obj) {\r\n    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Returns the number of key-value pairs in the object map.\r\n *\r\n * @param {Object} obj The object for which to get the number of key-value\r\n *     pairs.\r\n * @return {number} The number of key-value pairs in the object map.\r\n */\r\ngoog.object.getCount = function(obj) {\r\n  var rv = 0;\r\n  for (var key in obj) {\r\n    rv++;\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Returns one key from the object map, if any exists.\r\n * For map literals the returned key will be the first one in most of the\r\n * browsers (a know exception is Konqueror).\r\n *\r\n * @param {Object} obj The object to pick a key from.\r\n * @return {string|undefined} The key or undefined if the object is empty.\r\n */\r\ngoog.object.getAnyKey = function(obj) {\r\n  for (var key in obj) {\r\n    return key;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns one value from the object map, if any exists.\r\n * For map literals the returned value will be the first one in most of the\r\n * browsers (a know exception is Konqueror).\r\n *\r\n * @param {Object<K,V>} obj The object to pick a value from.\r\n * @return {V|undefined} The value or undefined if the object is empty.\r\n * @template K,V\r\n */\r\ngoog.object.getAnyValue = function(obj) {\r\n  for (var key in obj) {\r\n    return obj[key];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Whether the object/hash/map contains the given object as a value.\r\n * An alias for goog.object.containsValue(obj, val).\r\n *\r\n * @param {Object<K,V>} obj The object in which to look for val.\r\n * @param {V} val The object for which to check.\r\n * @return {boolean} true if val is present.\r\n * @template K,V\r\n */\r\ngoog.object.contains = function(obj, val) {\r\n  return goog.object.containsValue(obj, val);\r\n};\r\n\r\n\r\n/**\r\n * Returns the values of the object/map/hash.\r\n *\r\n * @param {Object<K,V>} obj The object from which to get the values.\r\n * @return {!Array<V>} The values in the object/map/hash.\r\n * @template K,V\r\n */\r\ngoog.object.getValues = function(obj) {\r\n  var res = [];\r\n  var i = 0;\r\n  for (var key in obj) {\r\n    res[i++] = obj[key];\r\n  }\r\n  return res;\r\n};\r\n\r\n\r\n/**\r\n * Returns the keys of the object/map/hash.\r\n *\r\n * @param {Object} obj The object from which to get the keys.\r\n * @return {!Array<string>} Array of property keys.\r\n */\r\ngoog.object.getKeys = function(obj) {\r\n  var res = [];\r\n  var i = 0;\r\n  for (var key in obj) {\r\n    res[i++] = key;\r\n  }\r\n  return res;\r\n};\r\n\r\n\r\n/**\r\n * Get a value from an object multiple levels deep.  This is useful for\r\n * pulling values from deeply nested objects, such as JSON responses.\r\n * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)\r\n *\r\n * @param {!Object} obj An object to get the value from.  Can be array-like.\r\n * @param {...(string|number|!IArrayLike<number|string>)}\r\n *     var_args A number of keys\r\n *     (as strings, or numbers, for array-like objects).  Can also be\r\n *     specified as a single array of keys.\r\n * @return {*} The resulting value.  If, at any point, the value for a key\r\n *     in the current object is null or undefined, returns undefined.\r\n */\r\ngoog.object.getValueByKeys = function(obj, var_args) {\r\n  var isArrayLike = goog.isArrayLike(var_args);\r\n  var keys = isArrayLike ?\r\n      /** @type {!IArrayLike<number|string>} */ (var_args) :\r\n      arguments;\r\n\r\n  // Start with the 2nd parameter for the variable parameters syntax.\r\n  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {\r\n    if (obj == null) return undefined;\r\n    obj = obj[keys[i]];\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n\r\n/**\r\n * Whether the object/map/hash contains the given key.\r\n *\r\n * @param {Object} obj The object in which to look for key.\r\n * @param {?} key The key for which to check.\r\n * @return {boolean} true If the map contains the key.\r\n */\r\ngoog.object.containsKey = function(obj, key) {\r\n  return obj !== null && key in obj;\r\n};\r\n\r\n\r\n/**\r\n * Whether the object/map/hash contains the given value. This is O(n).\r\n *\r\n * @param {Object<K,V>} obj The object in which to look for val.\r\n * @param {V} val The value for which to check.\r\n * @return {boolean} true If the map contains the value.\r\n * @template K,V\r\n */\r\ngoog.object.containsValue = function(obj, val) {\r\n  for (var key in obj) {\r\n    if (obj[key] == val) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Searches an object for an element that satisfies the given condition and\r\n * returns its key.\r\n * @param {Object<K,V>} obj The object to search in.\r\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The\r\n *      function to call for every element. Takes 3 arguments (the value,\r\n *     the key and the object) and should return a boolean.\r\n * @param {T=} opt_this An optional \"this\" context for the function.\r\n * @return {string|undefined} The key of an element for which the function\r\n *     returns true or undefined if no such element is found.\r\n * @template T,K,V\r\n */\r\ngoog.object.findKey = function(obj, f, opt_this) {\r\n  for (var key in obj) {\r\n    if (f.call(/** @type {?} */ (opt_this), obj[key], key, obj)) {\r\n      return key;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n\r\n\r\n/**\r\n * Searches an object for an element that satisfies the given condition and\r\n * returns its value.\r\n * @param {Object<K,V>} obj The object to search in.\r\n * @param {function(this:T,V,string,Object<K,V>):boolean} f The function\r\n *     to call for every element. Takes 3 arguments (the value, the key\r\n *     and the object) and should return a boolean.\r\n * @param {T=} opt_this An optional \"this\" context for the function.\r\n * @return {V} The value of an element for which the function returns true or\r\n *     undefined if no such element is found.\r\n * @template T,K,V\r\n */\r\ngoog.object.findValue = function(obj, f, opt_this) {\r\n  var key = goog.object.findKey(obj, f, opt_this);\r\n  return key && obj[key];\r\n};\r\n\r\n\r\n/**\r\n * Whether the object/map/hash is empty.\r\n *\r\n * @param {Object} obj The object to test.\r\n * @return {boolean} true if obj is empty.\r\n */\r\ngoog.object.isEmpty = function(obj) {\r\n  for (var key in obj) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Removes all key value pairs from the object/map/hash.\r\n *\r\n * @param {Object} obj The object to clear.\r\n */\r\ngoog.object.clear = function(obj) {\r\n  for (var i in obj) {\r\n    delete obj[i];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes a key-value pair based on the key.\r\n *\r\n * @param {Object} obj The object from which to remove the key.\r\n * @param {?} key The key to remove.\r\n * @return {boolean} Whether an element was removed.\r\n */\r\ngoog.object.remove = function(obj, key) {\r\n  var rv;\r\n  if (rv = key in /** @type {!Object} */ (obj)) {\r\n    delete obj[key];\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Adds a key-value pair to the object. Throws an exception if the key is\r\n * already in use. Use set if you want to change an existing pair.\r\n *\r\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\r\n * @param {string} key The key to add.\r\n * @param {V} val The value to add.\r\n * @template K,V\r\n */\r\ngoog.object.add = function(obj, key, val) {\r\n  if (obj !== null && key in obj) {\r\n    throw new Error('The object already contains the key \"' + key + '\"');\r\n  }\r\n  goog.object.set(obj, key, val);\r\n};\r\n\r\n\r\n/**\r\n * Returns the value for the given key.\r\n *\r\n * @param {Object<K,V>} obj The object from which to get the value.\r\n * @param {string} key The key for which to get the value.\r\n * @param {R=} opt_val The value to return if no item is found for the given\r\n *     key (default is undefined).\r\n * @return {V|R|undefined} The value for the given key.\r\n * @template K,V,R\r\n */\r\ngoog.object.get = function(obj, key, opt_val) {\r\n  if (obj !== null && key in obj) {\r\n    return obj[key];\r\n  }\r\n  return opt_val;\r\n};\r\n\r\n\r\n/**\r\n * Adds a key-value pair to the object/map/hash.\r\n *\r\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\r\n * @param {string} key The key to add.\r\n * @param {V} value The value to add.\r\n * @template K,V\r\n */\r\ngoog.object.set = function(obj, key, value) {\r\n  obj[key] = value;\r\n};\r\n\r\n\r\n/**\r\n * Adds a key-value pair to the object/map/hash if it doesn't exist yet.\r\n *\r\n * @param {Object<K,V>} obj The object to which to add the key-value pair.\r\n * @param {string} key The key to add.\r\n * @param {V} value The value to add if the key wasn't present.\r\n * @return {V} The value of the entry at the end of the function.\r\n * @template K,V\r\n */\r\ngoog.object.setIfUndefined = function(obj, key, value) {\r\n  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);\r\n};\r\n\r\n\r\n/**\r\n * Sets a key and value to an object if the key is not set. The value will be\r\n * the return value of the given function. If the key already exists, the\r\n * object will not be changed and the function will not be called (the function\r\n * will be lazily evaluated -- only called if necessary).\r\n *\r\n * This function is particularly useful when used with an `Object` which is\r\n * acting as a cache.\r\n *\r\n * @param {!Object<K,V>} obj The object to which to add the key-value pair.\r\n * @param {string} key The key to add.\r\n * @param {function():V} f The value to add if the key wasn't present.\r\n * @return {V} The value of the entry at the end of the function.\r\n * @template K,V\r\n */\r\ngoog.object.setWithReturnValueIfNotSet = function(obj, key, f) {\r\n  if (key in obj) {\r\n    return obj[key];\r\n  }\r\n\r\n  var val = f();\r\n  obj[key] = val;\r\n  return val;\r\n};\r\n\r\n\r\n/**\r\n * Compares two objects for equality using === on the values.\r\n *\r\n * @param {!Object<K,V>} a\r\n * @param {!Object<K,V>} b\r\n * @return {boolean}\r\n * @template K,V\r\n */\r\ngoog.object.equals = function(a, b) {\r\n  for (var k in a) {\r\n    if (!(k in b) || a[k] !== b[k]) {\r\n      return false;\r\n    }\r\n  }\r\n  for (var k in b) {\r\n    if (!(k in a)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Returns a shallow clone of the object.\r\n *\r\n * @param {Object<K,V>} obj Object to clone.\r\n * @return {!Object<K,V>} Clone of the input object.\r\n * @template K,V\r\n */\r\ngoog.object.clone = function(obj) {\r\n  // We cannot use the prototype trick because a lot of methods depend on where\r\n  // the actual key is set.\r\n\r\n  var res = {};\r\n  for (var key in obj) {\r\n    res[key] = obj[key];\r\n  }\r\n  return res;\r\n  // We could also use goog.mixin but I wanted this to be independent from that.\r\n};\r\n\r\n\r\n/**\r\n * Clones a value. The input may be an Object, Array, or basic type. Objects and\r\n * arrays will be cloned recursively.\r\n *\r\n * WARNINGS:\r\n * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects\r\n * that refer to themselves will cause infinite recursion.\r\n *\r\n * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and\r\n * copies UIDs created by <code>getUid</code> into cloned results.\r\n *\r\n * @param {T} obj The value to clone.\r\n * @return {T} A clone of the input value.\r\n * @template T\r\n */\r\ngoog.object.unsafeClone = function(obj) {\r\n  var type = goog.typeOf(obj);\r\n  if (type == 'object' || type == 'array') {\r\n    if (goog.isFunction(obj.clone)) {\r\n      return obj.clone();\r\n    }\r\n    var clone = type == 'array' ? [] : {};\r\n    for (var key in obj) {\r\n      clone[key] = goog.object.unsafeClone(obj[key]);\r\n    }\r\n    return clone;\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n\r\n/**\r\n * Returns a new object in which all the keys and values are interchanged\r\n * (keys become values and values become keys). If multiple keys map to the\r\n * same value, the chosen transposed value is implementation-dependent.\r\n *\r\n * @param {Object} obj The object to transpose.\r\n * @return {!Object} The transposed object.\r\n */\r\ngoog.object.transpose = function(obj) {\r\n  var transposed = {};\r\n  for (var key in obj) {\r\n    transposed[obj[key]] = key;\r\n  }\r\n  return transposed;\r\n};\r\n\r\n\r\n/**\r\n * The names of the fields that are defined on Object.prototype.\r\n * @type {Array<string>}\r\n * @private\r\n */\r\ngoog.object.PROTOTYPE_FIELDS_ = [\r\n  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\r\n  'toLocaleString', 'toString', 'valueOf'\r\n];\r\n\r\n\r\n/**\r\n * Extends an object with another object.\r\n * This operates 'in-place'; it does not create a new Object.\r\n *\r\n * Example:\r\n * var o = {};\r\n * goog.object.extend(o, {a: 0, b: 1});\r\n * o; // {a: 0, b: 1}\r\n * goog.object.extend(o, {b: 2, c: 3});\r\n * o; // {a: 0, b: 2, c: 3}\r\n *\r\n * @param {Object} target The object to modify. Existing properties will be\r\n *     overwritten if they are also present in one of the objects in\r\n *     `var_args`.\r\n * @param {...(Object|null|undefined)} var_args The objects from which values\r\n *     will be copied.\r\n */\r\ngoog.object.extend = function(target, var_args) {\r\n  var key, source;\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    source = arguments[i];\r\n    for (key in source) {\r\n      target[key] = source[key];\r\n    }\r\n\r\n    // For IE the for-in-loop does not contain any properties that are not\r\n    // enumerable on the prototype object (for example isPrototypeOf from\r\n    // Object.prototype) and it will also not include 'replace' on objects that\r\n    // extend String and change 'replace' (not that it is common for anyone to\r\n    // extend anything except Object).\r\n\r\n    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {\r\n      key = goog.object.PROTOTYPE_FIELDS_[j];\r\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Creates a new object built from the key-value pairs provided as arguments.\r\n * @param {...*} var_args If only one argument is provided and it is an array\r\n *     then this is used as the arguments, otherwise even arguments are used as\r\n *     the property names and odd arguments are used as the property values.\r\n * @return {!Object} The new object.\r\n * @throws {Error} If there are uneven number of arguments or there is only one\r\n *     non array argument.\r\n */\r\ngoog.object.create = function(var_args) {\r\n  var argLength = arguments.length;\r\n  if (argLength == 1 && goog.isArray(arguments[0])) {\r\n    return goog.object.create.apply(null, arguments[0]);\r\n  }\r\n\r\n  if (argLength % 2) {\r\n    throw new Error('Uneven number of arguments');\r\n  }\r\n\r\n  var rv = {};\r\n  for (var i = 0; i < argLength; i += 2) {\r\n    rv[arguments[i]] = arguments[i + 1];\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Creates a new object where the property names come from the arguments but\r\n * the value is always set to true\r\n * @param {...*} var_args If only one argument is provided and it is an array\r\n *     then this is used as the arguments, otherwise the arguments are used\r\n *     as the property names.\r\n * @return {!Object} The new object.\r\n */\r\ngoog.object.createSet = function(var_args) {\r\n  var argLength = arguments.length;\r\n  if (argLength == 1 && goog.isArray(arguments[0])) {\r\n    return goog.object.createSet.apply(null, arguments[0]);\r\n  }\r\n\r\n  var rv = {};\r\n  for (var i = 0; i < argLength; i++) {\r\n    rv[arguments[i]] = true;\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Creates an immutable view of the underlying object, if the browser\r\n * supports immutable objects.\r\n *\r\n * In default mode, writes to this view will fail silently. In strict mode,\r\n * they will throw an error.\r\n *\r\n * @param {!Object<K,V>} obj An object.\r\n * @return {!Object<K,V>} An immutable view of that object, or the\r\n *     original object if this browser does not support immutables.\r\n * @template K,V\r\n */\r\ngoog.object.createImmutableView = function(obj) {\r\n  var result = obj;\r\n  if (Object.isFrozen && !Object.isFrozen(obj)) {\r\n    result = Object.create(obj);\r\n    Object.freeze(result);\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * @param {!Object} obj An object.\r\n * @return {boolean} Whether this is an immutable view of the object.\r\n */\r\ngoog.object.isImmutableView = function(obj) {\r\n  return !!Object.isFrozen && Object.isFrozen(obj);\r\n};\r\n\r\n\r\n/**\r\n * Get all properties names on a given Object regardless of enumerability.\r\n *\r\n * <p> If the browser does not support `Object.getOwnPropertyNames` nor\r\n * `Object.getPrototypeOf` then this is equivalent to using\r\n * `goog.object.getKeys`\r\n *\r\n * @param {?Object} obj The object to get the properties of.\r\n * @param {boolean=} opt_includeObjectPrototype Whether properties defined on\r\n *     `Object.prototype` should be included in the result.\r\n * @param {boolean=} opt_includeFunctionPrototype Whether properties defined on\r\n *     `Function.prototype` should be included in the result.\r\n * @return {!Array<string>}\r\n * @public\r\n */\r\ngoog.object.getAllPropertyNames = function(\r\n    obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {\r\n  if (!obj) {\r\n    return [];\r\n  }\r\n\r\n  // Naively use a for..in loop to get the property names if the browser doesn't\r\n  // support any other APIs for getting it.\r\n  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\r\n    return goog.object.getKeys(obj);\r\n  }\r\n\r\n  var visitedSet = {};\r\n\r\n  // Traverse the prototype chain and add all properties to the visited set.\r\n  var proto = obj;\r\n  while (proto &&\r\n         (proto !== Object.prototype || !!opt_includeObjectPrototype) &&\r\n         (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {\r\n    var names = Object.getOwnPropertyNames(proto);\r\n    for (var i = 0; i < names.length; i++) {\r\n      visitedSet[names[i]] = true;\r\n    }\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return goog.object.getKeys(visitedSet);\r\n};\r\n","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Useful compiler idioms.\r\n *\r\n * @author johnlenz@google.com (John Lenz)\r\n */\r\n\r\ngoog.provide('goog.reflect');\r\n\r\n\r\n/**\r\n * Syntax for object literal casts.\r\n * @see http://go/jscompiler-renaming\r\n * @see https://goo.gl/CRs09P\r\n *\r\n * Use this if you have an object literal whose keys need to have the same names\r\n * as the properties of some class even after they are renamed by the compiler.\r\n *\r\n * @param {!Function} type Type to cast to.\r\n * @param {Object} object Object literal to cast.\r\n * @return {Object} The object literal.\r\n */\r\ngoog.reflect.object = function(type, object) {\r\n  return object;\r\n};\r\n\r\n/**\r\n * Syntax for renaming property strings.\r\n * @see http://go/jscompiler-renaming\r\n * @see https://goo.gl/CRs09P\r\n *\r\n * Use this if you have an need to access a property as a string, but want\r\n * to also have the property renamed by the compiler. In contrast to\r\n * goog.reflect.object, this method takes an instance of an object.\r\n *\r\n * Properties must be simple names (not qualified names).\r\n *\r\n * @param {string} prop Name of the property\r\n * @param {!Object} object Instance of the object whose type will be used\r\n *     for renaming\r\n * @return {string} The renamed property.\r\n */\r\ngoog.reflect.objectProperty = function(prop, object) {\r\n  return prop;\r\n};\r\n\r\n/**\r\n * To assert to the compiler that an operation is needed when it would\r\n * otherwise be stripped. For example:\r\n * <code>\r\n *     // Force a layout\r\n *     goog.reflect.sinkValue(dialog.offsetHeight);\r\n * </code>\r\n * @param {T} x\r\n * @return {T}\r\n * @template T\r\n */\r\ngoog.reflect.sinkValue = function(x) {\r\n  goog.reflect.sinkValue[' '](x);\r\n  return x;\r\n};\r\n\r\n\r\n/**\r\n * The compiler should optimize this function away iff no one ever uses\r\n * goog.reflect.sinkValue.\r\n */\r\ngoog.reflect.sinkValue[' '] = goog.nullFunction;\r\n\r\n\r\n/**\r\n * Check if a property can be accessed without throwing an exception.\r\n * @param {Object} obj The owner of the property.\r\n * @param {string} prop The property name.\r\n * @return {boolean} Whether the property is accessible. Will also return true\r\n *     if obj is null.\r\n */\r\ngoog.reflect.canAccessProperty = function(obj, prop) {\r\n\r\n  try {\r\n    goog.reflect.sinkValue(obj[prop]);\r\n    return true;\r\n  } catch (e) {\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Retrieves a value from a cache given a key. The compiler provides special\r\n * consideration for this call such that it is generally considered side-effect\r\n * free. However, if the `opt_keyFn` or `valueFn` have side-effects\r\n * then the entire call is considered to have side-effects.\r\n *\r\n * Conventionally storing the value on the cache would be considered a\r\n * side-effect and preclude unused calls from being pruned, ie. even if\r\n * the value was never used, it would still always be stored in the cache.\r\n *\r\n * Providing a side-effect free `valueFn` and `opt_keyFn`\r\n * allows unused calls to `goog.reflect.cache` to be pruned.\r\n *\r\n * @param {!Object<K, V>} cacheObj The object that contains the cached values.\r\n * @param {?} key The key to lookup in the cache. If it is not string or number\r\n *     then a `opt_keyFn` should be provided. The key is also used as the\r\n *     parameter to the `valueFn`.\r\n * @param {function(?):V} valueFn The value provider to use to calculate the\r\n *     value to store in the cache. This function should be side-effect free\r\n *     to take advantage of the optimization.\r\n * @param {function(?):K=} opt_keyFn The key provider to determine the cache\r\n *     map key. This should be used if the given key is not a string or number.\r\n *     If not provided then the given key is used. This function should be\r\n *     side-effect free to take advantage of the optimization.\r\n * @return {V} The cached or calculated value.\r\n * @template K\r\n * @template V\r\n */\r\ngoog.reflect.cache = function(cacheObj, key, valueFn, opt_keyFn) {\r\n  var storedKey = opt_keyFn ? opt_keyFn(key) : key;\r\n\r\n  if (Object.prototype.hasOwnProperty.call(cacheObj, storedKey)) {\r\n    return cacheObj[storedKey];\r\n  }\r\n\r\n  return (cacheObj[storedKey] = valueFn(key));\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Rendering engine detection.\r\n * @see <a href=\"http://www.useragentstring.com/\">User agent strings</a>\r\n * For information on the browser brand (such as Safari versus Chrome), see\r\n * goog.userAgent.product.\r\n * @author arv@google.com (Erik Arvidsson)\r\n * @see ../demos/useragent.html\r\n */\r\n\r\ngoog.provide('goog.userAgent');\r\n\r\ngoog.require('goog.labs.userAgent.browser');\r\ngoog.require('goog.labs.userAgent.engine');\r\ngoog.require('goog.labs.userAgent.platform');\r\ngoog.require('goog.labs.userAgent.util');\r\ngoog.require('goog.reflect');\r\ngoog.require('goog.string');\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is IE.\r\n */\r\ngoog.userAgent.ASSUME_IE = goog.define('goog.userAgent.ASSUME_IE', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is EDGE.\r\n */\r\ngoog.userAgent.ASSUME_EDGE = goog.define('goog.userAgent.ASSUME_EDGE', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is GECKO.\r\n */\r\ngoog.userAgent.ASSUME_GECKO = goog.define('goog.userAgent.ASSUME_GECKO', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.\r\n */\r\ngoog.userAgent.ASSUME_WEBKIT =\r\n    goog.define('goog.userAgent.ASSUME_WEBKIT', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is a\r\n *     mobile device running WebKit e.g. iPhone or Android.\r\n */\r\ngoog.userAgent.ASSUME_MOBILE_WEBKIT =\r\n    goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether we know at compile-time that the browser is OPERA.\r\n */\r\ngoog.userAgent.ASSUME_OPERA = goog.define('goog.userAgent.ASSUME_OPERA', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the\r\n *     `goog.userAgent.isVersionOrHigher`\r\n *     function will return true for any version.\r\n */\r\ngoog.userAgent.ASSUME_ANY_VERSION =\r\n    goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);\r\n\r\n\r\n/**\r\n * Whether we know the browser engine at compile-time.\r\n * @type {boolean}\r\n * @private\r\n */\r\ngoog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE ||\r\n    goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO ||\r\n    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT ||\r\n    goog.userAgent.ASSUME_OPERA;\r\n\r\n\r\n/**\r\n * Returns the userAgent string for the current browser.\r\n *\r\n * @return {string} The userAgent string.\r\n */\r\ngoog.userAgent.getUserAgentString = function() {\r\n  return goog.labs.userAgent.util.getUserAgent();\r\n};\r\n\r\n\r\n/**\r\n * @return {?Navigator} The native navigator object.\r\n */\r\ngoog.userAgent.getNavigatorTyped = function() {\r\n  // Need a local navigator reference instead of using the global one,\r\n  // to avoid the rare case where they reference different objects.\r\n  // (in a WorkerPool, for example).\r\n  return goog.global['navigator'] || null;\r\n};\r\n\r\n\r\n/**\r\n * TODO(nnaze): Change type to \"Navigator\" and update compilation targets.\r\n * @return {?Object} The native navigator object.\r\n */\r\ngoog.userAgent.getNavigator = function() {\r\n  return goog.userAgent.getNavigatorTyped();\r\n};\r\n\r\n\r\n/**\r\n * Whether the user agent is Opera.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?\r\n    goog.userAgent.ASSUME_OPERA :\r\n    goog.labs.userAgent.browser.isOpera();\r\n\r\n\r\n/**\r\n * Whether the user agent is Internet Explorer.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?\r\n    goog.userAgent.ASSUME_IE :\r\n    goog.labs.userAgent.browser.isIE();\r\n\r\n\r\n/**\r\n * Whether the user agent is Microsoft Edge.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ?\r\n    goog.userAgent.ASSUME_EDGE :\r\n    goog.labs.userAgent.engine.isEdge();\r\n\r\n\r\n/**\r\n * Whether the user agent is MS Internet Explorer or MS Edge.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;\r\n\r\n\r\n/**\r\n * Whether the user agent is Gecko. Gecko is the rendering engine used by\r\n * Mozilla, Firefox, and others.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?\r\n    goog.userAgent.ASSUME_GECKO :\r\n    goog.labs.userAgent.engine.isGecko();\r\n\r\n\r\n/**\r\n * Whether the user agent is WebKit. WebKit is the rendering engine that\r\n * Safari, Android and others use.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?\r\n    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :\r\n    goog.labs.userAgent.engine.isWebKit();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a mobile device.\r\n *\r\n * This is a separate function so that the logic can be tested.\r\n *\r\n * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().\r\n *\r\n * @return {boolean} Whether the user agent is running on a mobile device.\r\n * @private\r\n */\r\ngoog.userAgent.isMobile_ = function() {\r\n  return goog.userAgent.WEBKIT &&\r\n      goog.labs.userAgent.util.matchUserAgent('Mobile');\r\n};\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a mobile device.\r\n *\r\n * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent\r\n *   is promoted as the gecko/webkit logic is likely inaccurate.\r\n *\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.MOBILE =\r\n    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();\r\n\r\n\r\n/**\r\n * Used while transitioning code to use WEBKIT instead.\r\n * @type {boolean}\r\n * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.\r\n * TODO(nicksantos): Delete this from goog.userAgent.\r\n */\r\ngoog.userAgent.SAFARI = goog.userAgent.WEBKIT;\r\n\r\n\r\n/**\r\n * @return {string} the platform (operating system) the user agent is running\r\n *     on. Default to empty string because navigator.platform may not be defined\r\n *     (on Rhino, for example).\r\n * @private\r\n */\r\ngoog.userAgent.determinePlatform_ = function() {\r\n  var navigator = goog.userAgent.getNavigatorTyped();\r\n  return navigator && navigator.platform || '';\r\n};\r\n\r\n\r\n/**\r\n * The platform (operating system) the user agent is running on. Default to\r\n * empty string because navigator.platform may not be defined (on Rhino, for\r\n * example).\r\n * @type {string}\r\n */\r\ngoog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on a Macintosh operating\r\n *     system.\r\n */\r\ngoog.userAgent.ASSUME_MAC = goog.define('goog.userAgent.ASSUME_MAC', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on a Windows operating\r\n *     system.\r\n */\r\ngoog.userAgent.ASSUME_WINDOWS =\r\n    goog.define('goog.userAgent.ASSUME_WINDOWS', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on a Linux operating\r\n *     system.\r\n */\r\ngoog.userAgent.ASSUME_LINUX = goog.define('goog.userAgent.ASSUME_LINUX', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on a X11 windowing\r\n *     system.\r\n */\r\ngoog.userAgent.ASSUME_X11 = goog.define('goog.userAgent.ASSUME_X11', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on Android.\r\n */\r\ngoog.userAgent.ASSUME_ANDROID =\r\n    goog.define('goog.userAgent.ASSUME_ANDROID', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on an iPhone.\r\n */\r\ngoog.userAgent.ASSUME_IPHONE =\r\n    goog.define('goog.userAgent.ASSUME_IPHONE', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on an iPad.\r\n */\r\ngoog.userAgent.ASSUME_IPAD = goog.define('goog.userAgent.ASSUME_IPAD', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on an iPod.\r\n */\r\ngoog.userAgent.ASSUME_IPOD = goog.define('goog.userAgent.ASSUME_IPOD', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on KaiOS.\r\n */\r\ngoog.userAgent.ASSUME_KAIOS = goog.define('goog.userAgent.ASSUME_KAIOS', false);\r\n\r\n/**\r\n * @define {boolean} Whether the user agent is running on Go2Phone.\r\n */\r\ngoog.userAgent.ASSUME_GO2PHONE =\r\n    goog.define('goog.userAgent.ASSUME_GO2PHONE', false);\r\n\r\n\r\n/**\r\n * @type {boolean}\r\n * @private\r\n */\r\ngoog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC ||\r\n    goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX ||\r\n    goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID ||\r\n    goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||\r\n    goog.userAgent.ASSUME_IPOD;\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a Macintosh operating system.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_MAC :\r\n    goog.labs.userAgent.platform.isMacintosh();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a Windows operating system.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_WINDOWS :\r\n    goog.labs.userAgent.platform.isWindows();\r\n\r\n\r\n/**\r\n * Whether the user agent is Linux per the legacy behavior of\r\n * goog.userAgent.LINUX, which considered ChromeOS to also be\r\n * Linux.\r\n * @return {boolean}\r\n * @private\r\n */\r\ngoog.userAgent.isLegacyLinux_ = function() {\r\n  return goog.labs.userAgent.platform.isLinux() ||\r\n      goog.labs.userAgent.platform.isChromeOS();\r\n};\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a Linux operating system.\r\n *\r\n * Note that goog.userAgent.LINUX considers ChromeOS to be Linux,\r\n * while goog.labs.userAgent.platform considers ChromeOS and\r\n * Linux to be different OSes.\r\n *\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_LINUX :\r\n    goog.userAgent.isLegacyLinux_();\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user agent is an X11 windowing system.\r\n * @private\r\n */\r\ngoog.userAgent.isX11_ = function() {\r\n  var navigator = goog.userAgent.getNavigatorTyped();\r\n  return !!navigator &&\r\n      goog.string.contains(navigator['appVersion'] || '', 'X11');\r\n};\r\n\r\n\r\n/**\r\n * Whether the user agent is running on a X11 windowing system.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_X11 :\r\n    goog.userAgent.isX11_();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on Android.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_ANDROID :\r\n    goog.labs.userAgent.platform.isAndroid();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on an iPhone.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_IPHONE :\r\n    goog.labs.userAgent.platform.isIphone();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on an iPad.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_IPAD :\r\n    goog.labs.userAgent.platform.isIpad();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on an iPod.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_IPOD :\r\n    goog.labs.userAgent.platform.isIpod();\r\n\r\n\r\n/**\r\n * Whether the user agent is running on iOS.\r\n * @type {boolean}\r\n */\r\ngoog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    (goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||\r\n     goog.userAgent.ASSUME_IPOD) :\r\n    goog.labs.userAgent.platform.isIos();\r\n\r\n/**\r\n * Whether the user agent is running on KaiOS.\r\n */\r\ngoog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_KAIOS :\r\n    goog.labs.userAgent.platform.isKaiOS();\r\n\r\n/**\r\n * Whether the user agent is running on Go2Phone.\r\n */\r\ngoog.userAgent.GO2PHONE = goog.userAgent.PLATFORM_KNOWN_ ?\r\n    goog.userAgent.ASSUME_GO2PHONE :\r\n    goog.labs.userAgent.platform.isGo2Phone();\r\n\r\n\r\n/**\r\n * @return {string} The string that describes the version number of the user\r\n *     agent.\r\n * @private\r\n */\r\ngoog.userAgent.determineVersion_ = function() {\r\n  // All browsers have different ways to detect the version and they all have\r\n  // different naming schemes.\r\n  // version is a string rather than a number because it may contain 'b', 'a',\r\n  // and so on.\r\n  var version = '';\r\n  var arr = goog.userAgent.getVersionRegexResult_();\r\n  if (arr) {\r\n    version = arr ? arr[1] : '';\r\n  }\r\n\r\n  if (goog.userAgent.IE) {\r\n    // IE9 can be in document mode 9 but be reporting an inconsistent user agent\r\n    // version.  If it is identifying as a version lower than 9 we take the\r\n    // documentMode as the version instead.  IE8 has similar behavior.\r\n    // It is recommended to set the X-UA-Compatible header to ensure that IE9\r\n    // uses documentMode 9.\r\n    var docMode = goog.userAgent.getDocumentMode_();\r\n    if (docMode != null && docMode > parseFloat(version)) {\r\n      return String(docMode);\r\n    }\r\n  }\r\n\r\n  return version;\r\n};\r\n\r\n\r\n/**\r\n * @return {?IArrayLike<string>|undefined} The version regex matches from\r\n *     parsing the user\r\n *     agent string. These regex statements must be executed inline so they can\r\n *     be compiled out by the closure compiler with the rest of the useragent\r\n *     detection logic when ASSUME_* is specified.\r\n * @private\r\n */\r\ngoog.userAgent.getVersionRegexResult_ = function() {\r\n  var userAgent = goog.userAgent.getUserAgentString();\r\n  if (goog.userAgent.GECKO) {\r\n    return /rv\\:([^\\);]+)(\\)|;)/.exec(userAgent);\r\n  }\r\n  if (goog.userAgent.EDGE) {\r\n    return /Edge\\/([\\d\\.]+)/.exec(userAgent);\r\n  }\r\n  if (goog.userAgent.IE) {\r\n    return /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(userAgent);\r\n  }\r\n  if (goog.userAgent.WEBKIT) {\r\n    // WebKit/125.4\r\n    return /WebKit\\/(\\S+)/.exec(userAgent);\r\n  }\r\n  if (goog.userAgent.OPERA) {\r\n    // If none of the above browsers were detected but the browser is Opera, the\r\n    // only string that is of interest is 'Version/<number>'.\r\n    return /(?:Version)[ \\/]?(\\S+)/.exec(userAgent);\r\n  }\r\n  return undefined;\r\n};\r\n\r\n\r\n/**\r\n * @return {number|undefined} Returns the document mode (for testing).\r\n * @private\r\n */\r\ngoog.userAgent.getDocumentMode_ = function() {\r\n  // NOTE(user): goog.userAgent may be used in context where there is no DOM.\r\n  var doc = goog.global['document'];\r\n  return doc ? doc['documentMode'] : undefined;\r\n};\r\n\r\n\r\n/**\r\n * The version of the user agent. This is a string because it might contain\r\n * 'b' (as in beta) as well as multiple dots.\r\n * @type {string}\r\n */\r\ngoog.userAgent.VERSION = goog.userAgent.determineVersion_();\r\n\r\n\r\n/**\r\n * Compares two version numbers.\r\n *\r\n * @param {string} v1 Version of first item.\r\n * @param {string} v2 Version of second item.\r\n *\r\n * @return {number}  1 if first argument is higher\r\n *                   0 if arguments are equal\r\n *                  -1 if second argument is higher.\r\n * @deprecated Use goog.string.compareVersions.\r\n */\r\ngoog.userAgent.compare = function(v1, v2) {\r\n  return goog.string.compareVersions(v1, v2);\r\n};\r\n\r\n\r\n/**\r\n * Cache for {@link goog.userAgent.isVersionOrHigher}.\r\n * Calls to compareVersions are surprisingly expensive and, as a browser's\r\n * version number is unlikely to change during a session, we cache the results.\r\n * @const\r\n * @private\r\n */\r\ngoog.userAgent.isVersionOrHigherCache_ = {};\r\n\r\n\r\n/**\r\n * Whether the user agent version is higher or the same as the given version.\r\n * NOTE: When checking the version numbers for Firefox and Safari, be sure to\r\n * use the engine's version, not the browser's version number.  For example,\r\n * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.\r\n * Opera and Internet Explorer versions match the product release number.<br>\r\n * @see <a href=\"http://en.wikipedia.org/wiki/Safari_version_history\">\r\n *     Webkit</a>\r\n * @see <a href=\"http://en.wikipedia.org/wiki/Gecko_engine\">Gecko</a>\r\n *\r\n * @param {string|number} version The version to check.\r\n * @return {boolean} Whether the user agent version is higher or the same as\r\n *     the given version.\r\n */\r\ngoog.userAgent.isVersionOrHigher = function(version) {\r\n  return goog.userAgent.ASSUME_ANY_VERSION ||\r\n      goog.reflect.cache(\r\n          goog.userAgent.isVersionOrHigherCache_, version, function() {\r\n            return goog.string.compareVersions(\r\n                       goog.userAgent.VERSION, version) >= 0;\r\n          });\r\n};\r\n\r\n\r\n/**\r\n * Deprecated alias to `goog.userAgent.isVersionOrHigher`.\r\n * @param {string|number} version The version to check.\r\n * @return {boolean} Whether the user agent version is higher or the same as\r\n *     the given version.\r\n * @deprecated Use goog.userAgent.isVersionOrHigher().\r\n */\r\ngoog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;\r\n\r\n\r\n/**\r\n * Whether the IE effective document mode is higher or the same as the given\r\n * document mode version.\r\n * NOTE: Only for IE, return false for another browser.\r\n *\r\n * @param {number} documentMode The document mode version to check.\r\n * @return {boolean} Whether the IE effective document mode is higher or the\r\n *     same as the given version.\r\n */\r\ngoog.userAgent.isDocumentModeOrHigher = function(documentMode) {\r\n  return Number(goog.userAgent.DOCUMENT_MODE) >= documentMode;\r\n};\r\n\r\n\r\n/**\r\n * Deprecated alias to `goog.userAgent.isDocumentModeOrHigher`.\r\n * @param {number} version The version to check.\r\n * @return {boolean} Whether the IE effective document mode is higher or the\r\n *      same as the given version.\r\n * @deprecated Use goog.userAgent.isDocumentModeOrHigher().\r\n */\r\ngoog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;\r\n\r\n\r\n/**\r\n * For IE version < 7, documentMode is undefined, so attempt to use the\r\n * CSS1Compat property to see if we are in standards mode. If we are in\r\n * standards mode, treat the browser version as the document mode. Otherwise,\r\n * IE is emulating version 5.\r\n * @type {number|undefined}\r\n * @const\r\n */\r\ngoog.userAgent.DOCUMENT_MODE = (function() {\r\n  var doc = goog.global['document'];\r\n  var mode = goog.userAgent.getDocumentMode_();\r\n  if (!doc || !goog.userAgent.IE) {\r\n    return undefined;\r\n  }\r\n  return mode || (doc['compatMode'] == 'CSS1Compat' ?\r\n                      parseInt(goog.userAgent.VERSION, 10) :\r\n                      5);\r\n})();\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Closure user agent detection (Browser).\r\n * @see <a href=\"http://www.useragentstring.com/\">User agent strings</a>\r\n * For more information on rendering engine, platform, or device see the other\r\n * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,\r\n * goog.labs.userAgent.device respectively.)\r\n *\r\n * @author martone@google.com (Andy Martone)\r\n */\r\n\r\ngoog.provide('goog.labs.userAgent.browser');\r\n\r\ngoog.require('goog.array');\r\ngoog.require('goog.labs.userAgent.util');\r\ngoog.require('goog.object');\r\ngoog.require('goog.string.internal');\r\n\r\n\r\n// TODO(nnaze): Refactor to remove excessive exclusion logic in matching\r\n// functions.\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Opera.  Note: Chromium\r\n *     based Opera (Opera 15+) is detected as Chrome to avoid unnecessary\r\n *     special casing.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchOpera_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Opera');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is IE.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchIE_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Trident') ||\r\n      goog.labs.userAgent.util.matchUserAgent('MSIE');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Edge.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchEdge_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Edge');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Firefox.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchFirefox_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Firefox') ||\r\n      goog.labs.userAgent.util.matchUserAgent('FxiOS');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Safari.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchSafari_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Safari') &&\r\n      !(goog.labs.userAgent.browser.matchChrome_() ||\r\n        goog.labs.userAgent.browser.matchCoast_() ||\r\n        goog.labs.userAgent.browser.matchOpera_() ||\r\n        goog.labs.userAgent.browser.matchEdge_() ||\r\n        goog.labs.userAgent.browser.matchFirefox_() ||\r\n        goog.labs.userAgent.browser.isSilk() ||\r\n        goog.labs.userAgent.util.matchUserAgent('Android'));\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based\r\n *     iOS browser).\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchCoast_ = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Coast');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is iOS Webview.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchIosWebview_ = function() {\r\n  // iOS Webview does not show up as Chrome or Safari. Also check for Opera's\r\n  // WebKit-based iOS browser, Coast.\r\n  return (goog.labs.userAgent.util.matchUserAgent('iPad') ||\r\n          goog.labs.userAgent.util.matchUserAgent('iPhone')) &&\r\n      !goog.labs.userAgent.browser.matchSafari_() &&\r\n      !goog.labs.userAgent.browser.matchChrome_() &&\r\n      !goog.labs.userAgent.browser.matchCoast_() &&\r\n      !goog.labs.userAgent.browser.matchFirefox_() &&\r\n      goog.labs.userAgent.util.matchUserAgent('AppleWebKit');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Chrome.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchChrome_ = function() {\r\n  return (goog.labs.userAgent.util.matchUserAgent('Chrome') ||\r\n          goog.labs.userAgent.util.matchUserAgent('CriOS')) &&\r\n      !goog.labs.userAgent.browser.matchEdge_();\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is the Android browser.\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.matchAndroidBrowser_ = function() {\r\n  // Android can appear in the user agent string for Chrome on Android.\r\n  // This is not the Android standalone browser if it does.\r\n  return goog.labs.userAgent.util.matchUserAgent('Android') &&\r\n      !(goog.labs.userAgent.browser.isChrome() ||\r\n        goog.labs.userAgent.browser.isFirefox() ||\r\n        goog.labs.userAgent.browser.isOpera() ||\r\n        goog.labs.userAgent.browser.isSilk());\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Opera.\r\n */\r\ngoog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is IE.\r\n */\r\ngoog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Edge.\r\n */\r\ngoog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdge_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Firefox.\r\n */\r\ngoog.labs.userAgent.browser.isFirefox =\r\n    goog.labs.userAgent.browser.matchFirefox_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Safari.\r\n */\r\ngoog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based\r\n *     iOS browser).\r\n */\r\ngoog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is iOS Webview.\r\n */\r\ngoog.labs.userAgent.browser.isIosWebview =\r\n    goog.labs.userAgent.browser.matchIosWebview_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is Chrome.\r\n */\r\ngoog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the user's browser is the Android browser.\r\n */\r\ngoog.labs.userAgent.browser.isAndroidBrowser =\r\n    goog.labs.userAgent.browser.matchAndroidBrowser_;\r\n\r\n\r\n/**\r\n * For more information, see:\r\n * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html\r\n * @return {boolean} Whether the user's browser is Silk.\r\n */\r\ngoog.labs.userAgent.browser.isSilk = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Silk');\r\n};\r\n\r\n\r\n/**\r\n * @return {string} The browser version or empty string if version cannot be\r\n *     determined. Note that for Internet Explorer, this returns the version of\r\n *     the browser, not the version of the rendering engine. (IE 8 in\r\n *     compatibility mode will return 8.0 rather than 7.0. To determine the\r\n *     rendering engine version, look at document.documentMode instead. See\r\n *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more\r\n *     details.)\r\n */\r\ngoog.labs.userAgent.browser.getVersion = function() {\r\n  var userAgentString = goog.labs.userAgent.util.getUserAgent();\r\n  // Special case IE since IE's version is inside the parenthesis and\r\n  // without the '/'.\r\n  if (goog.labs.userAgent.browser.isIE()) {\r\n    return goog.labs.userAgent.browser.getIEVersion_(userAgentString);\r\n  }\r\n\r\n  var versionTuples =\r\n      goog.labs.userAgent.util.extractVersionTuples(userAgentString);\r\n\r\n  // Construct a map for easy lookup.\r\n  var versionMap = {};\r\n  goog.array.forEach(versionTuples, function(tuple) {\r\n    // Note that the tuple is of length three, but we only care about the\r\n    // first two.\r\n    var key = tuple[0];\r\n    var value = tuple[1];\r\n    versionMap[key] = value;\r\n  });\r\n\r\n  var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);\r\n\r\n  // Gives the value with the first key it finds, otherwise empty string.\r\n  function lookUpValueWithKeys(keys) {\r\n    var key = goog.array.find(keys, versionMapHasKey);\r\n    return versionMap[key] || '';\r\n  }\r\n\r\n  // Check Opera before Chrome since Opera 15+ has \"Chrome\" in the string.\r\n  // See\r\n  // http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond\r\n  if (goog.labs.userAgent.browser.isOpera()) {\r\n    // Opera 10 has Version/10.0 but Opera/9.8, so look for \"Version\" first.\r\n    // Opera uses 'OPR' for more recent UAs.\r\n    return lookUpValueWithKeys(['Version', 'Opera']);\r\n  }\r\n\r\n  // Check Edge before Chrome since it has Chrome in the string.\r\n  if (goog.labs.userAgent.browser.isEdge()) {\r\n    return lookUpValueWithKeys(['Edge']);\r\n  }\r\n\r\n  if (goog.labs.userAgent.browser.isChrome()) {\r\n    return lookUpValueWithKeys(['Chrome', 'CriOS']);\r\n  }\r\n\r\n  // Usually products browser versions are in the third tuple after \"Mozilla\"\r\n  // and the engine.\r\n  var tuple = versionTuples[2];\r\n  return tuple && tuple[1] || '';\r\n};\r\n\r\n\r\n/**\r\n * @param {string|number} version The version to check.\r\n * @return {boolean} Whether the browser version is higher or the same as the\r\n *     given version.\r\n */\r\ngoog.labs.userAgent.browser.isVersionOrHigher = function(version) {\r\n  return goog.string.internal.compareVersions(\r\n             goog.labs.userAgent.browser.getVersion(), version) >= 0;\r\n};\r\n\r\n\r\n/**\r\n * Determines IE version. More information:\r\n * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString\r\n * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx\r\n * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx\r\n * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx\r\n *\r\n * @param {string} userAgent the User-Agent.\r\n * @return {string}\r\n * @private\r\n */\r\ngoog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {\r\n  // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade\r\n  // bug. Example UA:\r\n  // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)\r\n  // like Gecko.\r\n  // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.\r\n  var rv = /rv: *([\\d\\.]*)/.exec(userAgent);\r\n  if (rv && rv[1]) {\r\n    return rv[1];\r\n  }\r\n\r\n  var version = '';\r\n  var msie = /MSIE +([\\d\\.]+)/.exec(userAgent);\r\n  if (msie && msie[1]) {\r\n    // IE in compatibility mode usually identifies itself as MSIE 7.0; in this\r\n    // case, use the Trident version to determine the version of IE. For more\r\n    // details, see the links above.\r\n    var tridentVersion = /Trident\\/(\\d.\\d)/.exec(userAgent);\r\n    if (msie[1] == '7.0') {\r\n      if (tridentVersion && tridentVersion[1]) {\r\n        switch (tridentVersion[1]) {\r\n          case '4.0':\r\n            version = '8.0';\r\n            break;\r\n          case '5.0':\r\n            version = '9.0';\r\n            break;\r\n          case '6.0':\r\n            version = '10.0';\r\n            break;\r\n          case '7.0':\r\n            version = '11.0';\r\n            break;\r\n        }\r\n      } else {\r\n        version = '7.0';\r\n      }\r\n    } else {\r\n      version = msie[1];\r\n    }\r\n  }\r\n  return version;\r\n};\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Closure user agent detection.\r\n * @see http://en.wikipedia.org/wiki/User_agent\r\n * For more information on browser brand, platform, or device see the other\r\n * sub-namespaces in goog.labs.userAgent (browser, platform, and device).\r\n *\r\n */\r\n\r\ngoog.provide('goog.labs.userAgent.engine');\r\n\r\ngoog.require('goog.array');\r\ngoog.require('goog.labs.userAgent.util');\r\ngoog.require('goog.string');\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the rendering engine is Presto.\r\n */\r\ngoog.labs.userAgent.engine.isPresto = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Presto');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the rendering engine is Trident.\r\n */\r\ngoog.labs.userAgent.engine.isTrident = function() {\r\n  // IE only started including the Trident token in IE8.\r\n  return goog.labs.userAgent.util.matchUserAgent('Trident') ||\r\n      goog.labs.userAgent.util.matchUserAgent('MSIE');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the rendering engine is Edge.\r\n */\r\ngoog.labs.userAgent.engine.isEdge = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Edge');\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the rendering engine is WebKit.\r\n */\r\ngoog.labs.userAgent.engine.isWebKit = function() {\r\n  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit') &&\r\n      !goog.labs.userAgent.engine.isEdge();\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the rendering engine is Gecko.\r\n */\r\ngoog.labs.userAgent.engine.isGecko = function() {\r\n  return goog.labs.userAgent.util.matchUserAgent('Gecko') &&\r\n      !goog.labs.userAgent.engine.isWebKit() &&\r\n      !goog.labs.userAgent.engine.isTrident() &&\r\n      !goog.labs.userAgent.engine.isEdge();\r\n};\r\n\r\n\r\n/**\r\n * @return {string} The rendering engine's version or empty string if version\r\n *     can't be determined.\r\n */\r\ngoog.labs.userAgent.engine.getVersion = function() {\r\n  var userAgentString = goog.labs.userAgent.util.getUserAgent();\r\n  if (userAgentString) {\r\n    var tuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);\r\n\r\n    var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);\r\n    if (engineTuple) {\r\n      // In Gecko, the version string is either in the browser info or the\r\n      // Firefox version.  See Gecko user agent string reference:\r\n      // http://goo.gl/mULqa\r\n      if (engineTuple[0] == 'Gecko') {\r\n        return goog.labs.userAgent.engine.getVersionForKey_(tuples, 'Firefox');\r\n      }\r\n\r\n      return engineTuple[1];\r\n    }\r\n\r\n    // MSIE has only one version identifier, and the Trident version is\r\n    // specified in the parenthetical. IE Edge is covered in the engine tuple\r\n    // detection.\r\n    var browserTuple = tuples[0];\r\n    var info;\r\n    if (browserTuple && (info = browserTuple[2])) {\r\n      var match = /Trident\\/([^\\s;]+)/.exec(info);\r\n      if (match) {\r\n        return match[1];\r\n      }\r\n    }\r\n  }\r\n  return '';\r\n};\r\n\r\n\r\n/**\r\n * @param {!Array<!Array<string>>} tuples Extracted version tuples.\r\n * @return {!Array<string>|undefined} The engine tuple or undefined if not\r\n *     found.\r\n * @private\r\n */\r\ngoog.labs.userAgent.engine.getEngineTuple_ = function(tuples) {\r\n  if (!goog.labs.userAgent.engine.isEdge()) {\r\n    return tuples[1];\r\n  }\r\n  for (var i = 0; i < tuples.length; i++) {\r\n    var tuple = tuples[i];\r\n    if (tuple[0] == 'Edge') {\r\n      return tuple;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @param {string|number} version The version to check.\r\n * @return {boolean} Whether the rendering engine version is higher or the same\r\n *     as the given version.\r\n */\r\ngoog.labs.userAgent.engine.isVersionOrHigher = function(version) {\r\n  return goog.string.compareVersions(\r\n             goog.labs.userAgent.engine.getVersion(), version) >= 0;\r\n};\r\n\r\n\r\n/**\r\n * @param {!Array<!Array<string>>} tuples Version tuples.\r\n * @param {string} key The key to look for.\r\n * @return {string} The version string of the given key, if present.\r\n *     Otherwise, the empty string.\r\n * @private\r\n */\r\ngoog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {\r\n  // TODO(nnaze): Move to util if useful elsewhere.\r\n\r\n  var pair = goog.array.find(tuples, function(pair) { return key == pair[0]; });\r\n\r\n  return pair && pair[1] || '';\r\n};\r\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Browser capability checks for the events package.\r\n *\r\n */\r\n\r\n\r\ngoog.provide('goog.events.BrowserFeature');\r\n\r\ngoog.require('goog.userAgent');\r\ngoog.scope(function() {\r\n\r\n\r\n\r\n/**\r\n * Enum of browser capabilities.\r\n * @enum {boolean}\r\n */\r\ngoog.events.BrowserFeature = {\r\n  /**\r\n   * Whether the button attribute of the event is W3C compliant.  False in\r\n   * Internet Explorer prior to version 9; document-version dependent.\r\n   */\r\n  HAS_W3C_BUTTON:\r\n      !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),\r\n\r\n  /**\r\n   * Whether the browser supports full W3C event model.\r\n   */\r\n  HAS_W3C_EVENT_SUPPORT:\r\n      !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),\r\n\r\n  /**\r\n   * To prevent default in IE7-8 for certain keydown events we need set the\r\n   * keyCode to -1.\r\n   */\r\n  SET_KEY_CODE_TO_PREVENT_DEFAULT:\r\n      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),\r\n\r\n  /**\r\n   * Whether the `navigator.onLine` property is supported.\r\n   */\r\n  HAS_NAVIGATOR_ONLINE_PROPERTY:\r\n      !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher('528'),\r\n\r\n  /**\r\n   * Whether HTML5 network online/offline events are supported.\r\n   */\r\n  HAS_HTML5_NETWORK_EVENT_SUPPORT:\r\n      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||\r\n      goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||\r\n      goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||\r\n      goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),\r\n\r\n  /**\r\n   * Whether HTML5 network events fire on document.body, or otherwise the\r\n   * window.\r\n   */\r\n  HTML5_NETWORK_EVENTS_FIRE_ON_BODY:\r\n      goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||\r\n      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),\r\n\r\n  /**\r\n   * Whether touch is enabled in the browser.\r\n   */\r\n  TOUCH_ENABLED:\r\n      ('ontouchstart' in goog.global ||\r\n       !!(goog.global['document'] && document.documentElement &&\r\n          'ontouchstart' in document.documentElement) ||\r\n       // IE10 uses non-standard touch events, so it has a different check.\r\n       !!(goog.global['navigator'] &&\r\n          (goog.global['navigator']['maxTouchPoints'] ||\r\n           goog.global['navigator']['msMaxTouchPoints']))),\r\n\r\n  /**\r\n   * Whether addEventListener supports W3C standard pointer events.\r\n   * http://www.w3.org/TR/pointerevents/\r\n   */\r\n  POINTER_EVENTS: ('PointerEvent' in goog.global),\r\n\r\n  /**\r\n   * Whether addEventListener supports MSPointer events (only used in IE10).\r\n   * http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx\r\n   * http://msdn.microsoft.com/library/hh673557(v=vs.85).aspx\r\n   */\r\n  MSPOINTER_EVENTS:\r\n      ('MSPointerEvent' in goog.global &&\r\n       !!(goog.global['navigator'] &&\r\n          goog.global['navigator']['msPointerEnabled'])),\r\n\r\n  /**\r\n   * Whether addEventListener supports {passive: true}.\r\n   * https://developers.google.com/web/updates/2016/06/passive-event-listeners\r\n   */\r\n  PASSIVE_EVENTS: purify(function() {\r\n    // If we're in a web worker or other custom environment, we can't tell.\r\n    if (!goog.global.addEventListener || !Object.defineProperty) {  // IE 8\r\n      return false;\r\n    }\r\n\r\n    var passive = false;\r\n    var options = Object.defineProperty({}, 'passive', {\r\n      get: function() {\r\n        passive = true;\r\n      }\r\n    });\r\n    try {\r\n      goog.global.addEventListener('test', goog.nullFunction, options);\r\n      goog.global.removeEventListener('test', goog.nullFunction, options);\r\n    } catch (e) {\r\n    }\r\n\r\n    return passive;\r\n  })\r\n};\r\n\r\n\r\n/**\r\n * Tricks Closure Compiler into believing that a function is pure.  The compiler\r\n * assumes that any `valueOf` function is pure, without analyzing its contents.\r\n *\r\n * @param {function(): T} fn\r\n * @return {T}\r\n * @template T\r\n */\r\nfunction purify(fn) {\r\n  return ({valueOf: fn}).valueOf();\r\n}\r\n});  // goog.scope\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A base class for event objects.\r\n *\r\n */\r\n\r\n\r\ngoog.provide('goog.events.Event');\r\ngoog.provide('goog.events.EventLike');\r\n\r\n/**\r\n * goog.events.Event no longer depends on goog.Disposable. Keep requiring\r\n * goog.Disposable here to not break projects which assume this dependency.\r\n * @suppress {extraRequire}\r\n */\r\ngoog.require('goog.Disposable');\r\ngoog.require('goog.events.EventId');\r\n\r\n\r\n/**\r\n * A typedef for event like objects that are dispatchable via the\r\n * goog.events.dispatchEvent function. strings are treated as the type for a\r\n * goog.events.Event. Objects are treated as an extension of a new\r\n * goog.events.Event with the type property of the object being used as the type\r\n * of the Event.\r\n * @typedef {string|Object|goog.events.Event|goog.events.EventId}\r\n */\r\ngoog.events.EventLike;\r\n\r\n\r\n\r\n/**\r\n * A base class for event objects, so that they can support preventDefault and\r\n * stopPropagation.\r\n *\r\n * @suppress {underscore} Several properties on this class are technically\r\n *     public, but referencing these properties outside this package is strongly\r\n *     discouraged.\r\n *\r\n * @param {string|!goog.events.EventId} type Event Type.\r\n * @param {Object=} opt_target Reference to the object that is the target of\r\n *     this event. It has to implement the `EventTarget` interface\r\n *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.\r\n * @constructor\r\n */\r\ngoog.events.Event = function(type, opt_target) {\r\n  /**\r\n   * Event type.\r\n   * @type {string}\r\n   */\r\n  this.type = type instanceof goog.events.EventId ? String(type) : type;\r\n\r\n  /**\r\n   * TODO(tbreisacher): The type should probably be\r\n   * EventTarget|goog.events.EventTarget.\r\n   *\r\n   * Target of the event.\r\n   * @type {Object|undefined}\r\n   */\r\n  this.target = opt_target;\r\n\r\n  /**\r\n   * Object that had the listener attached.\r\n   * @type {Object|undefined}\r\n   */\r\n  this.currentTarget = this.target;\r\n\r\n  /**\r\n   * Whether to cancel the event in internal capture/bubble processing for IE.\r\n   * @type {boolean}\r\n   * @public\r\n   */\r\n  this.propagationStopped_ = false;\r\n\r\n  /**\r\n   * Whether the default action has been prevented.\r\n   * This is a property to match the W3C specification at\r\n   * {@link http://www.w3.org/TR/DOM-Level-3-Events/\r\n   * #events-event-type-defaultPrevented}.\r\n   * Must be treated as read-only outside the class.\r\n   * @type {boolean}\r\n   */\r\n  this.defaultPrevented = false;\r\n\r\n  /**\r\n   * Return value for in internal capture/bubble processing for IE.\r\n   * @type {boolean}\r\n   * @public\r\n   */\r\n  this.returnValue_ = true;\r\n};\r\n\r\n\r\n/**\r\n * Stops event propagation.\r\n */\r\ngoog.events.Event.prototype.stopPropagation = function() {\r\n  this.propagationStopped_ = true;\r\n};\r\n\r\n\r\n/**\r\n * Prevents the default action, for example a link redirecting to a url.\r\n */\r\ngoog.events.Event.prototype.preventDefault = function() {\r\n  this.defaultPrevented = true;\r\n  this.returnValue_ = false;\r\n};\r\n\r\n\r\n/**\r\n * Stops the propagation of the event. It is equivalent to\r\n * `e.stopPropagation()`, but can be used as the callback argument of\r\n * {@link goog.events.listen} without declaring another function.\r\n * @param {!goog.events.Event} e An event.\r\n */\r\ngoog.events.Event.stopPropagation = function(e) {\r\n  e.stopPropagation();\r\n};\r\n\r\n\r\n/**\r\n * Prevents the default action. It is equivalent to\r\n * `e.preventDefault()`, but can be used as the callback argument of\r\n * {@link goog.events.listen} without declaring another function.\r\n * @param {!goog.events.Event} e An event.\r\n */\r\ngoog.events.Event.preventDefault = function(e) {\r\n  e.preventDefault();\r\n};\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A patched, standardized event object for browser events.\r\n *\r\n * <pre>\r\n * The patched event object contains the following members:\r\n * - type           {string}    Event type, e.g. 'click'\r\n * - target         {Object}    The element that actually triggered the event\r\n * - currentTarget  {Object}    The element the listener is attached to\r\n * - relatedTarget  {Object}    For mouseover and mouseout, the previous object\r\n * - offsetX        {number}    X-coordinate relative to target\r\n * - offsetY        {number}    Y-coordinate relative to target\r\n * - clientX        {number}    X-coordinate relative to viewport\r\n * - clientY        {number}    Y-coordinate relative to viewport\r\n * - screenX        {number}    X-coordinate relative to the edge of the screen\r\n * - screenY        {number}    Y-coordinate relative to the edge of the screen\r\n * - button         {number}    Mouse button. Use isButton() to test.\r\n * - keyCode        {number}    Key-code\r\n * - ctrlKey        {boolean}   Was ctrl key depressed\r\n * - altKey         {boolean}   Was alt key depressed\r\n * - shiftKey       {boolean}   Was shift key depressed\r\n * - metaKey        {boolean}   Was meta key depressed\r\n * - pointerId      {number}    Pointer ID\r\n * - pointerType    {string}    Pointer type, e.g. 'mouse', 'pen', or 'touch'\r\n * - defaultPrevented {boolean} Whether the default action has been prevented\r\n * - state          {Object}    History state object\r\n *\r\n * NOTE: The keyCode member contains the raw browser keyCode. For normalized\r\n * key and character code use {@link goog.events.KeyHandler}.\r\n * </pre>\r\n *\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\ngoog.provide('goog.events.BrowserEvent');\r\ngoog.provide('goog.events.BrowserEvent.MouseButton');\r\ngoog.provide('goog.events.BrowserEvent.PointerType');\r\n\r\ngoog.require('goog.debug');\r\ngoog.require('goog.events.BrowserFeature');\r\ngoog.require('goog.events.Event');\r\ngoog.require('goog.events.EventType');\r\ngoog.require('goog.reflect');\r\ngoog.require('goog.userAgent');\r\n\r\n/**\r\n * @define {boolean} If true, use the layerX and layerY properties of a native\r\n * browser event over the offsetX and offsetY properties, which cause expensive\r\n * reflow. If layerX or layerY is not defined, offsetX and offsetY will be used\r\n * as usual.\r\n */\r\ngoog.events.USE_LAYER_XY_AS_OFFSET_XY =\r\n    goog.define('goog.events.USE_LAYER_XY_AS_OFFSET_XY', false);\r\n\r\n/**\r\n * Accepts a browser event object and creates a patched, cross browser event\r\n * object.\r\n * The content of this object will not be initialized if no event object is\r\n * provided. If this is the case, init() needs to be invoked separately.\r\n * @param {Event=} opt_e Browser event object.\r\n * @param {EventTarget=} opt_currentTarget Current target for event.\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\ngoog.events.BrowserEvent = function(opt_e, opt_currentTarget) {\r\n  goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');\r\n\r\n  /**\r\n   * Target that fired the event.\r\n   * @override\r\n   * @type {?Node}\r\n   */\r\n  this.target = null;\r\n\r\n  /**\r\n   * Node that had the listener attached.\r\n   * @override\r\n   * @type {?Node|undefined}\r\n   */\r\n  this.currentTarget = null;\r\n\r\n  /**\r\n   * For mouseover and mouseout events, the related object for the event.\r\n   * @type {?Node}\r\n   */\r\n  this.relatedTarget = null;\r\n\r\n  /**\r\n   * X-coordinate relative to target.\r\n   * @type {number}\r\n   */\r\n  this.offsetX = 0;\r\n\r\n  /**\r\n   * Y-coordinate relative to target.\r\n   * @type {number}\r\n   */\r\n  this.offsetY = 0;\r\n\r\n  /**\r\n   * X-coordinate relative to the window.\r\n   * @type {number}\r\n   */\r\n  this.clientX = 0;\r\n\r\n  /**\r\n   * Y-coordinate relative to the window.\r\n   * @type {number}\r\n   */\r\n  this.clientY = 0;\r\n\r\n  /**\r\n   * X-coordinate relative to the monitor.\r\n   * @type {number}\r\n   */\r\n  this.screenX = 0;\r\n\r\n  /**\r\n   * Y-coordinate relative to the monitor.\r\n   * @type {number}\r\n   */\r\n  this.screenY = 0;\r\n\r\n  /**\r\n   * Which mouse button was pressed.\r\n   * @type {number}\r\n   */\r\n  this.button = 0;\r\n\r\n  /**\r\n   * Key of key press.\r\n   * @type {string}\r\n   */\r\n  this.key = '';\r\n\r\n  /**\r\n   * Keycode of key press.\r\n   * @type {number}\r\n   */\r\n  this.keyCode = 0;\r\n\r\n  /**\r\n   * Keycode of key press.\r\n   * @type {number}\r\n   */\r\n  this.charCode = 0;\r\n\r\n  /**\r\n   * Whether control was pressed at time of event.\r\n   * @type {boolean}\r\n   */\r\n  this.ctrlKey = false;\r\n\r\n  /**\r\n   * Whether alt was pressed at time of event.\r\n   * @type {boolean}\r\n   */\r\n  this.altKey = false;\r\n\r\n  /**\r\n   * Whether shift was pressed at time of event.\r\n   * @type {boolean}\r\n   */\r\n  this.shiftKey = false;\r\n\r\n  /**\r\n   * Whether the meta key was pressed at time of event.\r\n   * @type {boolean}\r\n   */\r\n  this.metaKey = false;\r\n\r\n  /**\r\n   * History state object, only set for PopState events where it's a copy of the\r\n   * state object provided to pushState or replaceState.\r\n   * @type {?Object}\r\n   */\r\n  this.state = null;\r\n\r\n  /**\r\n   * Whether the default platform modifier key was pressed at time of event.\r\n   * (This is control for all platforms except Mac, where it's Meta.)\r\n   * @type {boolean}\r\n   */\r\n  this.platformModifierKey = false;\r\n\r\n  /**\r\n   * @type {number}\r\n   */\r\n  this.pointerId = 0;\r\n\r\n  /**\r\n   * @type {string}\r\n   */\r\n  this.pointerType = '';\r\n\r\n  /**\r\n   * The browser event object.\r\n   * @private {?Event}\r\n   */\r\n  this.event_ = null;\r\n\r\n  if (opt_e) {\r\n    this.init(opt_e, opt_currentTarget);\r\n  }\r\n};\r\ngoog.inherits(goog.events.BrowserEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * Normalized button constants for the mouse.\r\n * @enum {number}\r\n */\r\ngoog.events.BrowserEvent.MouseButton = {\r\n  LEFT: 0,\r\n  MIDDLE: 1,\r\n  RIGHT: 2\r\n};\r\n\r\n\r\n/**\r\n * Normalized pointer type constants for pointer events.\r\n * @enum {string}\r\n */\r\ngoog.events.BrowserEvent.PointerType = {\r\n  MOUSE: 'mouse',\r\n  PEN: 'pen',\r\n  TOUCH: 'touch'\r\n};\r\n\r\n\r\n/**\r\n * Static data for mapping mouse buttons.\r\n * @type {!Array<number>}\r\n * @deprecated Use `goog.events.BrowserEvent.IE_BUTTON_MAP` instead.\r\n */\r\ngoog.events.BrowserEvent.IEButtonMap = goog.debug.freeze([\r\n  1,  // LEFT\r\n  4,  // MIDDLE\r\n  2   // RIGHT\r\n]);\r\n\r\n\r\n/**\r\n * Static data for mapping mouse buttons.\r\n * @const {!Array<number>}\r\n */\r\ngoog.events.BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;\r\n\r\n\r\n/**\r\n * Static data for mapping MSPointerEvent types to PointerEvent types.\r\n * @const {!Object<number, goog.events.BrowserEvent.PointerType>}\r\n */\r\ngoog.events.BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({\r\n  2: goog.events.BrowserEvent.PointerType.TOUCH,\r\n  3: goog.events.BrowserEvent.PointerType.PEN,\r\n  4: goog.events.BrowserEvent.PointerType.MOUSE\r\n});\r\n\r\n\r\n/**\r\n * Accepts a browser event object and creates a patched, cross browser event\r\n * object.\r\n * @param {Event} e Browser event object.\r\n * @param {EventTarget=} opt_currentTarget Current target for event.\r\n */\r\ngoog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {\r\n  var type = this.type = e.type;\r\n\r\n  /**\r\n   * On touch devices use the first \"changed touch\" as the relevant touch.\r\n   * @type {?Touch}\r\n   */\r\n  var relevantTouch =\r\n      e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;\r\n\r\n  // TODO(nicksantos): Change this.target to type EventTarget.\r\n  this.target = /** @type {Node} */ (e.target) || e.srcElement;\r\n\r\n  // TODO(nicksantos): Change this.currentTarget to type EventTarget.\r\n  this.currentTarget = /** @type {Node} */ (opt_currentTarget);\r\n\r\n  var relatedTarget = /** @type {Node} */ (e.relatedTarget);\r\n  if (relatedTarget) {\r\n    // There's a bug in FireFox where sometimes, relatedTarget will be a\r\n    // chrome element, and accessing any property of it will get a permission\r\n    // denied exception. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780\r\n    if (goog.userAgent.GECKO) {\r\n      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {\r\n        relatedTarget = null;\r\n      }\r\n    }\r\n  } else if (type == goog.events.EventType.MOUSEOVER) {\r\n    relatedTarget = e.fromElement;\r\n  } else if (type == goog.events.EventType.MOUSEOUT) {\r\n    relatedTarget = e.toElement;\r\n  }\r\n\r\n  this.relatedTarget = relatedTarget;\r\n\r\n  if (relevantTouch) {\r\n    this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX :\r\n                                                         relevantTouch.pageX;\r\n    this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY :\r\n                                                         relevantTouch.pageY;\r\n    this.screenX = relevantTouch.screenX || 0;\r\n    this.screenY = relevantTouch.screenY || 0;\r\n  } else {\r\n    if (goog.events.USE_LAYER_XY_AS_OFFSET_XY) {\r\n      this.offsetX = (e.layerX !== undefined) ? e.layerX : e.offsetX;\r\n      this.offsetY = (e.layerY !== undefined) ? e.layerY : e.offsetY;\r\n    } else {\r\n      // Webkit emits a lame warning whenever layerX/layerY is accessed.\r\n      // http://code.google.com/p/chromium/issues/detail?id=101733\r\n      this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?\r\n          e.offsetX :\r\n          e.layerX;\r\n      this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?\r\n          e.offsetY :\r\n          e.layerY;\r\n    }\r\n    this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;\r\n    this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;\r\n    this.screenX = e.screenX || 0;\r\n    this.screenY = e.screenY || 0;\r\n  }\r\n\r\n  this.button = e.button;\r\n\r\n  this.keyCode = e.keyCode || 0;\r\n  this.key = e.key || '';\r\n  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);\r\n  this.ctrlKey = e.ctrlKey;\r\n  this.altKey = e.altKey;\r\n  this.shiftKey = e.shiftKey;\r\n  this.metaKey = e.metaKey;\r\n  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;\r\n  this.pointerId = e.pointerId || 0;\r\n  this.pointerType = goog.events.BrowserEvent.getPointerType_(e);\r\n  this.state = e.state;\r\n  this.event_ = e;\r\n  if (e.defaultPrevented) {\r\n    this.preventDefault();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Tests to see which button was pressed during the event. This is really only\r\n * useful in IE and Gecko browsers. And in IE, it's only useful for\r\n * mousedown/mouseup events, because click only fires for the left mouse button.\r\n *\r\n * Safari 2 only reports the left button being clicked, and uses the value '1'\r\n * instead of 0. Opera only reports a mousedown event for the middle button, and\r\n * no mouse events for the right button. Opera has default behavior for left and\r\n * middle click that can only be overridden via a configuration setting.\r\n *\r\n * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.\r\n *\r\n * @param {goog.events.BrowserEvent.MouseButton} button The button\r\n *     to test for.\r\n * @return {boolean} True if button was pressed.\r\n */\r\ngoog.events.BrowserEvent.prototype.isButton = function(button) {\r\n  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {\r\n    if (this.type == 'click') {\r\n      return button == goog.events.BrowserEvent.MouseButton.LEFT;\r\n    } else {\r\n      return !!(\r\n          this.event_.button & goog.events.BrowserEvent.IE_BUTTON_MAP[button]);\r\n    }\r\n  } else {\r\n    return this.event_.button == button;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Whether this has an \"action\"-producing mouse button.\r\n *\r\n * By definition, this includes left-click on windows/linux, and left-click\r\n * without the ctrl key on Macs.\r\n *\r\n * @return {boolean} The result.\r\n */\r\ngoog.events.BrowserEvent.prototype.isMouseActionButton = function() {\r\n  // Webkit does not ctrl+click to be a right-click, so we\r\n  // normalize it to behave like Gecko and Opera.\r\n  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&\r\n      !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\ngoog.events.BrowserEvent.prototype.stopPropagation = function() {\r\n  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);\r\n  if (this.event_.stopPropagation) {\r\n    this.event_.stopPropagation();\r\n  } else {\r\n    this.event_.cancelBubble = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\ngoog.events.BrowserEvent.prototype.preventDefault = function() {\r\n  goog.events.BrowserEvent.superClass_.preventDefault.call(this);\r\n  var be = this.event_;\r\n  if (!be.preventDefault) {\r\n    be.returnValue = false;\r\n    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {\r\n\r\n      try {\r\n        // Most keys can be prevented using returnValue. Some special keys\r\n        // require setting the keyCode to -1 as well:\r\n        //\r\n        // In IE7:\r\n        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)\r\n        //\r\n        // In IE8:\r\n        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)\r\n        //\r\n        // We therefore do this for all function keys as well as when Ctrl key\r\n        // is pressed.\r\n        var VK_F1 = 112;\r\n        var VK_F12 = 123;\r\n        if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {\r\n          be.keyCode = -1;\r\n        }\r\n      } catch (ex) {\r\n        // IE throws an 'access denied' exception when trying to change\r\n        // keyCode in some situations (e.g. srcElement is input[type=file],\r\n        // or srcElement is an anchor tag rewritten by parent's innerHTML).\r\n        // Do nothing in this case.\r\n      }\r\n    }\r\n  } else {\r\n    be.preventDefault();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @return {Event} The underlying browser event object.\r\n */\r\ngoog.events.BrowserEvent.prototype.getBrowserEvent = function() {\r\n  return this.event_;\r\n};\r\n\r\n\r\n/**\r\n * Extracts the pointer type from the given event.\r\n * @param {!Event} e\r\n * @return {string} The pointer type, e.g. 'mouse', 'pen', or 'touch'.\r\n * @private\r\n */\r\ngoog.events.BrowserEvent.getPointerType_ = function(e) {\r\n  if (goog.isString(e.pointerType)) {\r\n    return e.pointerType;\r\n  }\r\n  // IE10 uses integer codes for pointer type.\r\n  // https://msdn.microsoft.com/en-us/library/hh772359(v=vs.85).aspx\r\n  return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || '';\r\n};\r\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Event Types.\r\n *\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\n\r\ngoog.provide('goog.events.EventType');\r\ngoog.provide('goog.events.MouseAsMouseEventType');\r\ngoog.provide('goog.events.MouseEvents');\r\ngoog.provide('goog.events.PointerAsMouseEventType');\r\ngoog.provide('goog.events.PointerAsTouchEventType');\r\ngoog.provide('goog.events.PointerFallbackEventType');\r\ngoog.provide('goog.events.PointerTouchFallbackEventType');\r\n\r\ngoog.require('goog.events.BrowserFeature');\r\ngoog.require('goog.userAgent');\r\n\r\n\r\n/**\r\n * Returns a prefixed event name for the current browser.\r\n * @param {string} eventName The name of the event.\r\n * @return {string} The prefixed event name.\r\n * @suppress {missingRequire|missingProvide}\r\n * @private\r\n */\r\ngoog.events.getVendorPrefixedName_ = function(eventName) {\r\n  return goog.userAgent.WEBKIT ?\r\n      'webkit' + eventName :\r\n      (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :\r\n                              eventName.toLowerCase());\r\n};\r\n\r\n\r\n/**\r\n * Constants for event names.\r\n * @enum {string}\r\n */\r\ngoog.events.EventType = {\r\n  // Mouse events\r\n  CLICK: 'click',\r\n  RIGHTCLICK: 'rightclick',\r\n  DBLCLICK: 'dblclick',\r\n  AUXCLICK: 'auxclick',\r\n  MOUSEDOWN: 'mousedown',\r\n  MOUSEUP: 'mouseup',\r\n  MOUSEOVER: 'mouseover',\r\n  MOUSEOUT: 'mouseout',\r\n  MOUSEMOVE: 'mousemove',\r\n  MOUSEENTER: 'mouseenter',\r\n  MOUSELEAVE: 'mouseleave',\r\n\r\n  // Non-existent event; will never fire. This exists as a mouse counterpart to\r\n  // POINTERCANCEL.\r\n  MOUSECANCEL: 'mousecancel',\r\n\r\n  // Selection events.\r\n  // https://www.w3.org/TR/selection-api/\r\n  SELECTIONCHANGE: 'selectionchange',\r\n  SELECTSTART: 'selectstart',  // IE, Safari, Chrome\r\n\r\n  // Wheel events\r\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\r\n  WHEEL: 'wheel',\r\n\r\n  // Key events\r\n  KEYPRESS: 'keypress',\r\n  KEYDOWN: 'keydown',\r\n  KEYUP: 'keyup',\r\n\r\n  // Focus\r\n  BLUR: 'blur',\r\n  FOCUS: 'focus',\r\n  DEACTIVATE: 'deactivate',  // IE only\r\n  FOCUSIN: 'focusin',\r\n  FOCUSOUT: 'focusout',\r\n\r\n  // Forms\r\n  CHANGE: 'change',\r\n  RESET: 'reset',\r\n  SELECT: 'select',\r\n  SUBMIT: 'submit',\r\n  INPUT: 'input',\r\n  PROPERTYCHANGE: 'propertychange',  // IE only\r\n\r\n  // Drag and drop\r\n  DRAGSTART: 'dragstart',\r\n  DRAG: 'drag',\r\n  DRAGENTER: 'dragenter',\r\n  DRAGOVER: 'dragover',\r\n  DRAGLEAVE: 'dragleave',\r\n  DROP: 'drop',\r\n  DRAGEND: 'dragend',\r\n\r\n  // Touch events\r\n  // Note that other touch events exist, but we should follow the W3C list here.\r\n  // http://www.w3.org/TR/touch-events/#list-of-touchevent-types\r\n  TOUCHSTART: 'touchstart',\r\n  TOUCHMOVE: 'touchmove',\r\n  TOUCHEND: 'touchend',\r\n  TOUCHCANCEL: 'touchcancel',\r\n\r\n  // Misc\r\n  BEFOREUNLOAD: 'beforeunload',\r\n  CONSOLEMESSAGE: 'consolemessage',\r\n  CONTEXTMENU: 'contextmenu',\r\n  DEVICECHANGE: 'devicechange',\r\n  DEVICEMOTION: 'devicemotion',\r\n  DEVICEORIENTATION: 'deviceorientation',\r\n  DOMCONTENTLOADED: 'DOMContentLoaded',\r\n  ERROR: 'error',\r\n  HELP: 'help',\r\n  LOAD: 'load',\r\n  LOSECAPTURE: 'losecapture',\r\n  ORIENTATIONCHANGE: 'orientationchange',\r\n  READYSTATECHANGE: 'readystatechange',\r\n  RESIZE: 'resize',\r\n  SCROLL: 'scroll',\r\n  UNLOAD: 'unload',\r\n\r\n  // Media events\r\n  CANPLAY: 'canplay',\r\n  CANPLAYTHROUGH: 'canplaythrough',\r\n  DURATIONCHANGE: 'durationchange',\r\n  EMPTIED: 'emptied',\r\n  ENDED: 'ended',\r\n  LOADEDDATA: 'loadeddata',\r\n  LOADEDMETADATA: 'loadedmetadata',\r\n  PAUSE: 'pause',\r\n  PLAY: 'play',\r\n  PLAYING: 'playing',\r\n  RATECHANGE: 'ratechange',\r\n  SEEKED: 'seeked',\r\n  SEEKING: 'seeking',\r\n  STALLED: 'stalled',\r\n  SUSPEND: 'suspend',\r\n  TIMEUPDATE: 'timeupdate',\r\n  VOLUMECHANGE: 'volumechange',\r\n  WAITING: 'waiting',\r\n\r\n  // Media Source Extensions events\r\n  // https://www.w3.org/TR/media-source/#mediasource-events\r\n  SOURCEOPEN: 'sourceopen',\r\n  SOURCEENDED: 'sourceended',\r\n  SOURCECLOSED: 'sourceclosed',\r\n  // https://www.w3.org/TR/media-source/#sourcebuffer-events\r\n  ABORT: 'abort',\r\n  UPDATE: 'update',\r\n  UPDATESTART: 'updatestart',\r\n  UPDATEEND: 'updateend',\r\n\r\n  // HTML 5 History events\r\n  // See http://www.w3.org/TR/html5/browsers.html#event-definitions-0\r\n  HASHCHANGE: 'hashchange',\r\n  PAGEHIDE: 'pagehide',\r\n  PAGESHOW: 'pageshow',\r\n  POPSTATE: 'popstate',\r\n\r\n  // Copy and Paste\r\n  // Support is limited. Make sure it works on your favorite browser\r\n  // before using.\r\n  // http://www.quirksmode.org/dom/events/cutcopypaste.html\r\n  COPY: 'copy',\r\n  PASTE: 'paste',\r\n  CUT: 'cut',\r\n  BEFORECOPY: 'beforecopy',\r\n  BEFORECUT: 'beforecut',\r\n  BEFOREPASTE: 'beforepaste',\r\n\r\n  // HTML5 online/offline events.\r\n  // http://www.w3.org/TR/offline-webapps/#related\r\n  ONLINE: 'online',\r\n  OFFLINE: 'offline',\r\n\r\n  // HTML 5 worker events\r\n  MESSAGE: 'message',\r\n  CONNECT: 'connect',\r\n\r\n  // Service Worker Events - ServiceWorkerGlobalScope context\r\n  // See https://w3c.github.io/ServiceWorker/#execution-context-events\r\n  // Note: message event defined in worker events section\r\n  INSTALL: 'install',\r\n  ACTIVATE: 'activate',\r\n  FETCH: 'fetch',\r\n  FOREIGNFETCH: 'foreignfetch',\r\n  MESSAGEERROR: 'messageerror',\r\n\r\n  // Service Worker Events - Document context\r\n  // See https://w3c.github.io/ServiceWorker/#document-context-events\r\n  STATECHANGE: 'statechange',\r\n  UPDATEFOUND: 'updatefound',\r\n  CONTROLLERCHANGE: 'controllerchange',\r\n\r\n  // CSS animation events.\r\n  /** @suppress {missingRequire} */\r\n  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),\r\n  /** @suppress {missingRequire} */\r\n  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),\r\n  /** @suppress {missingRequire} */\r\n  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),\r\n\r\n  // CSS transition events. Based on the browser support described at:\r\n  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility\r\n  /** @suppress {missingRequire} */\r\n  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),\r\n\r\n  // W3C Pointer Events\r\n  // http://www.w3.org/TR/pointerevents/\r\n  POINTERDOWN: 'pointerdown',\r\n  POINTERUP: 'pointerup',\r\n  POINTERCANCEL: 'pointercancel',\r\n  POINTERMOVE: 'pointermove',\r\n  POINTEROVER: 'pointerover',\r\n  POINTEROUT: 'pointerout',\r\n  POINTERENTER: 'pointerenter',\r\n  POINTERLEAVE: 'pointerleave',\r\n  GOTPOINTERCAPTURE: 'gotpointercapture',\r\n  LOSTPOINTERCAPTURE: 'lostpointercapture',\r\n\r\n  // IE specific events.\r\n  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx\r\n  // Note: these events will be supplanted in IE11.\r\n  MSGESTURECHANGE: 'MSGestureChange',\r\n  MSGESTUREEND: 'MSGestureEnd',\r\n  MSGESTUREHOLD: 'MSGestureHold',\r\n  MSGESTURESTART: 'MSGestureStart',\r\n  MSGESTURETAP: 'MSGestureTap',\r\n  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',\r\n  MSINERTIASTART: 'MSInertiaStart',\r\n  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',\r\n  MSPOINTERCANCEL: 'MSPointerCancel',\r\n  MSPOINTERDOWN: 'MSPointerDown',\r\n  MSPOINTERENTER: 'MSPointerEnter',\r\n  MSPOINTERHOVER: 'MSPointerHover',\r\n  MSPOINTERLEAVE: 'MSPointerLeave',\r\n  MSPOINTERMOVE: 'MSPointerMove',\r\n  MSPOINTEROUT: 'MSPointerOut',\r\n  MSPOINTEROVER: 'MSPointerOver',\r\n  MSPOINTERUP: 'MSPointerUp',\r\n\r\n  // Native IMEs/input tools events.\r\n  TEXT: 'text',\r\n  // The textInput event is supported in IE9+, but only in lower case. All other\r\n  // browsers use the camel-case event name.\r\n  TEXTINPUT: goog.userAgent.IE ? 'textinput' : 'textInput',\r\n  COMPOSITIONSTART: 'compositionstart',\r\n  COMPOSITIONUPDATE: 'compositionupdate',\r\n  COMPOSITIONEND: 'compositionend',\r\n\r\n  // The beforeinput event is initially only supported in Safari. See\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=342670 for Chrome\r\n  // implementation tracking.\r\n  BEFOREINPUT: 'beforeinput',\r\n\r\n  // Webview tag events\r\n  // See https://developer.chrome.com/apps/tags/webview\r\n  EXIT: 'exit',\r\n  LOADABORT: 'loadabort',\r\n  LOADCOMMIT: 'loadcommit',\r\n  LOADREDIRECT: 'loadredirect',\r\n  LOADSTART: 'loadstart',\r\n  LOADSTOP: 'loadstop',\r\n  RESPONSIVE: 'responsive',\r\n  SIZECHANGED: 'sizechanged',\r\n  UNRESPONSIVE: 'unresponsive',\r\n\r\n  // HTML5 Page Visibility API.  See details at\r\n  // `goog.labs.dom.PageVisibilityMonitor`.\r\n  VISIBILITYCHANGE: 'visibilitychange',\r\n\r\n  // LocalStorage event.\r\n  STORAGE: 'storage',\r\n\r\n  // DOM Level 2 mutation events (deprecated).\r\n  DOMSUBTREEMODIFIED: 'DOMSubtreeModified',\r\n  DOMNODEINSERTED: 'DOMNodeInserted',\r\n  DOMNODEREMOVED: 'DOMNodeRemoved',\r\n  DOMNODEREMOVEDFROMDOCUMENT: 'DOMNodeRemovedFromDocument',\r\n  DOMNODEINSERTEDINTODOCUMENT: 'DOMNodeInsertedIntoDocument',\r\n  DOMATTRMODIFIED: 'DOMAttrModified',\r\n  DOMCHARACTERDATAMODIFIED: 'DOMCharacterDataModified',\r\n\r\n  // Print events.\r\n  BEFOREPRINT: 'beforeprint',\r\n  AFTERPRINT: 'afterprint',\r\n\r\n  // Web app manifest events.\r\n  BEFOREINSTALLPROMPT: 'beforeinstallprompt',\r\n  APPINSTALLED: 'appinstalled'\r\n};\r\n\r\n\r\n/**\r\n * Returns one of the given pointer fallback event names in order of preference:\r\n *   1. pointerEventName\r\n *   2. msPointerEventName\r\n *   3. fallbackEventName\r\n * @param {string} pointerEventName\r\n * @param {string} msPointerEventName\r\n * @param {string} fallbackEventName\r\n * @return {string} The supported pointer or fallback (mouse or touch) event\r\n *     name.\r\n * @private\r\n */\r\ngoog.events.getPointerFallbackEventName_ = function(\r\n    pointerEventName, msPointerEventName, fallbackEventName) {\r\n  if (goog.events.BrowserFeature.POINTER_EVENTS) {\r\n    return pointerEventName;\r\n  }\r\n  if (goog.events.BrowserFeature.MSPOINTER_EVENTS) {\r\n    return msPointerEventName;\r\n  }\r\n  return fallbackEventName;\r\n};\r\n\r\n\r\n/**\r\n * Constants for pointer event names that fall back to corresponding mouse event\r\n * names on unsupported platforms. These are intended to be drop-in replacements\r\n * for corresponding values in `goog.events.EventType`.\r\n * @enum {string}\r\n */\r\ngoog.events.PointerFallbackEventType = {\r\n  POINTERDOWN: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,\r\n      goog.events.EventType.MOUSEDOWN),\r\n  POINTERUP: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,\r\n      goog.events.EventType.MOUSEUP),\r\n  POINTERCANCEL: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERCANCEL,\r\n      goog.events.EventType.MSPOINTERCANCEL,\r\n      // When falling back to mouse events, there is no MOUSECANCEL equivalent\r\n      // of POINTERCANCEL. In this case POINTERUP already falls back to MOUSEUP\r\n      // which represents both UP and CANCEL. POINTERCANCEL does not fall back\r\n      // to MOUSEUP to prevent listening twice on the same event.\r\n      goog.events.EventType.MOUSECANCEL),\r\n  POINTERMOVE: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,\r\n      goog.events.EventType.MOUSEMOVE),\r\n  POINTEROVER: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTEROVER, goog.events.EventType.MSPOINTEROVER,\r\n      goog.events.EventType.MOUSEOVER),\r\n  POINTEROUT: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTEROUT, goog.events.EventType.MSPOINTEROUT,\r\n      goog.events.EventType.MOUSEOUT),\r\n  POINTERENTER: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERENTER, goog.events.EventType.MSPOINTERENTER,\r\n      goog.events.EventType.MOUSEENTER),\r\n  POINTERLEAVE: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERLEAVE, goog.events.EventType.MSPOINTERLEAVE,\r\n      goog.events.EventType.MOUSELEAVE)\r\n};\r\n\r\n\r\n/**\r\n * Constants for pointer event names that fall back to corresponding touch event\r\n * names on unsupported platforms. These are intended to be drop-in replacements\r\n * for corresponding values in `goog.events.EventType`.\r\n * @enum {string}\r\n */\r\ngoog.events.PointerTouchFallbackEventType = {\r\n  POINTERDOWN: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,\r\n      goog.events.EventType.TOUCHSTART),\r\n  POINTERUP: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,\r\n      goog.events.EventType.TOUCHEND),\r\n  POINTERCANCEL: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERCANCEL,\r\n      goog.events.EventType.MSPOINTERCANCEL, goog.events.EventType.TOUCHCANCEL),\r\n  POINTERMOVE: goog.events.getPointerFallbackEventName_(\r\n      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,\r\n      goog.events.EventType.TOUCHMOVE)\r\n};\r\n\r\n\r\n/**\r\n * Mapping of mouse event names to underlying browser event names.\r\n * @typedef {{\r\n *     MOUSEDOWN: string,\r\n *     MOUSEUP: string,\r\n *     MOUSECANCEL:string,\r\n *     MOUSEMOVE:string,\r\n *     MOUSEOVER:string,\r\n *     MOUSEOUT:string,\r\n *     MOUSEENTER:string,\r\n *     MOUSELEAVE: string,\r\n * }}\r\n */\r\ngoog.events.MouseEvents;\r\n\r\n\r\n/**\r\n * An alias for `goog.events.EventType.MOUSE*` event types that is overridden by\r\n * corresponding `POINTER*` event types.\r\n * @const {!goog.events.MouseEvents}\r\n */\r\ngoog.events.PointerAsMouseEventType = {\r\n  MOUSEDOWN: goog.events.PointerFallbackEventType.POINTERDOWN,\r\n  MOUSEUP: goog.events.PointerFallbackEventType.POINTERUP,\r\n  MOUSECANCEL: goog.events.PointerFallbackEventType.POINTERCANCEL,\r\n  MOUSEMOVE: goog.events.PointerFallbackEventType.POINTERMOVE,\r\n  MOUSEOVER: goog.events.PointerFallbackEventType.POINTEROVER,\r\n  MOUSEOUT: goog.events.PointerFallbackEventType.POINTEROUT,\r\n  MOUSEENTER: goog.events.PointerFallbackEventType.POINTERENTER,\r\n  MOUSELEAVE: goog.events.PointerFallbackEventType.POINTERLEAVE\r\n};\r\n\r\n\r\n/**\r\n * An alias for `goog.events.EventType.MOUSE*` event types that continue to use\r\n * mouse events.\r\n * @const {!goog.events.MouseEvents}\r\n */\r\ngoog.events.MouseAsMouseEventType = {\r\n  MOUSEDOWN: goog.events.EventType.MOUSEDOWN,\r\n  MOUSEUP: goog.events.EventType.MOUSEUP,\r\n  MOUSECANCEL: goog.events.EventType.MOUSECANCEL,\r\n  MOUSEMOVE: goog.events.EventType.MOUSEMOVE,\r\n  MOUSEOVER: goog.events.EventType.MOUSEOVER,\r\n  MOUSEOUT: goog.events.EventType.MOUSEOUT,\r\n  MOUSEENTER: goog.events.EventType.MOUSEENTER,\r\n  MOUSELEAVE: goog.events.EventType.MOUSELEAVE\r\n};\r\n\r\n\r\n/**\r\n * An alias for `goog.events.EventType.TOUCH*` event types that is overridden by\r\n * corresponding `POINTER*` event types.\r\n * @enum {string}\r\n */\r\ngoog.events.PointerAsTouchEventType = {\r\n  TOUCHCANCEL: goog.events.PointerTouchFallbackEventType.POINTERCANCEL,\r\n  TOUCHEND: goog.events.PointerTouchFallbackEventType.POINTERUP,\r\n  TOUCHMOVE: goog.events.PointerTouchFallbackEventType.POINTERMOVE,\r\n  TOUCHSTART: goog.events.PointerTouchFallbackEventType.POINTERDOWN\r\n};\r\n","// Copyright 2012 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview An interface for a listenable JavaScript object.\r\n * @author chrishenry@google.com (Chris Henry)\r\n */\r\n\r\ngoog.provide('goog.events.Listenable');\r\ngoog.provide('goog.events.ListenableKey');\r\n\r\n/** @suppress {extraRequire} */\r\ngoog.require('goog.events.EventId');\r\n\r\ngoog.forwardDeclare('goog.events.EventLike');\r\ngoog.forwardDeclare('goog.events.EventTarget');\r\n\r\n\r\n\r\n/**\r\n * A listenable interface. A listenable is an object with the ability\r\n * to dispatch/broadcast events to \"event listeners\" registered via\r\n * listen/listenOnce.\r\n *\r\n * The interface allows for an event propagation mechanism similar\r\n * to one offered by native browser event targets, such as\r\n * capture/bubble mechanism, stopping propagation, and preventing\r\n * default actions. Capture/bubble mechanism depends on the ancestor\r\n * tree constructed via `#getParentEventTarget`; this tree\r\n * must be directed acyclic graph. The meaning of default action(s)\r\n * in preventDefault is specific to a particular use case.\r\n *\r\n * Implementations that do not support capture/bubble or can not have\r\n * a parent listenable can simply not implement any ability to set the\r\n * parent listenable (and have `#getParentEventTarget` return\r\n * null).\r\n *\r\n * Implementation of this class can be used with or independently from\r\n * goog.events.\r\n *\r\n * Implementation must call `#addImplementation(implClass)`.\r\n *\r\n * @interface\r\n * @see goog.events\r\n * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html\r\n */\r\ngoog.events.Listenable = function() {};\r\n\r\n\r\n/**\r\n * An expando property to indicate that an object implements\r\n * goog.events.Listenable.\r\n *\r\n * See addImplementation/isImplementedBy.\r\n *\r\n * @type {string}\r\n * @const\r\n */\r\ngoog.events.Listenable.IMPLEMENTED_BY_PROP =\r\n    'closure_listenable_' + ((Math.random() * 1e6) | 0);\r\n\r\n\r\n/**\r\n * Marks a given class (constructor) as an implementation of\r\n * Listenable, so that we can query that fact at runtime. The class\r\n * must have already implemented the interface.\r\n * @param {function(new:goog.events.Listenable,...)} cls The class constructor.\r\n *     The corresponding class must have already implemented the interface.\r\n */\r\ngoog.events.Listenable.addImplementation = function(cls) {\r\n  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;\r\n};\r\n\r\n\r\n/**\r\n * @param {Object} obj The object to check.\r\n * @return {boolean} Whether a given instance implements Listenable. The\r\n *     class/superclass of the instance must call addImplementation.\r\n */\r\ngoog.events.Listenable.isImplementedBy = function(obj) {\r\n  return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener. A listener can only be added once to an\r\n * object and if it is added again the key for the listener is\r\n * returned. Note that if the existing listener is a one-off listener\r\n * (registered via listenOnce), it will no longer be a one-off\r\n * listener after a call to listen().\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\r\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\r\n *     method.\r\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\r\n *     (defaults to false).\r\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {!goog.events.ListenableKey} Unique key for the listener.\r\n * @template SCOPE,EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.listen;\r\n\r\n\r\n/**\r\n * Adds an event listener that is removed automatically after the\r\n * listener fired once.\r\n *\r\n * If an existing listener already exists, listenOnce will do\r\n * nothing. In particular, if the listener was previously registered\r\n * via listen(), listenOnce() will not turn the listener into a\r\n * one-off listener. Similarly, if there is already an existing\r\n * one-off listener, listenOnce does not modify the listeners (it is\r\n * still a once listener).\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\r\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\r\n *     method.\r\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\r\n *     (defaults to false).\r\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {!goog.events.ListenableKey} Unique key for the listener.\r\n * @template SCOPE,EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.listenOnce;\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listen() or listenOnce().\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.\r\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback\r\n *     method.\r\n * @param {boolean=} opt_useCapture Whether to fire in capture phase\r\n *     (defaults to false).\r\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call\r\n *     the listener.\r\n * @return {boolean} Whether any listener was removed.\r\n * @template SCOPE,EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.unlisten;\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listen() by the key\r\n * returned by listen().\r\n *\r\n * @param {!goog.events.ListenableKey} key The key returned by\r\n *     listen() or listenOnce().\r\n * @return {boolean} Whether any listener was removed.\r\n */\r\ngoog.events.Listenable.prototype.unlistenByKey;\r\n\r\n\r\n/**\r\n * Dispatches an event (or event like object) and calls all listeners\r\n * listening for events of this type. The type of the event is decided by the\r\n * type property on the event object.\r\n *\r\n * If any of the listeners returns false OR calls preventDefault then this\r\n * function will return false.  If one of the capture listeners calls\r\n * stopPropagation, then the bubble listeners won't fire.\r\n *\r\n * @param {goog.events.EventLike} e Event object.\r\n * @return {boolean} If anyone called preventDefault on the event object (or\r\n *     if any of the listeners returns false) this will also return false.\r\n */\r\ngoog.events.Listenable.prototype.dispatchEvent;\r\n\r\n\r\n/**\r\n * Removes all listeners from this listenable. If type is specified,\r\n * it will only remove listeners of the particular type. otherwise all\r\n * registered listeners will be removed.\r\n *\r\n * @param {string=} opt_type Type of event to remove, default is to\r\n *     remove all types.\r\n * @return {number} Number of listeners removed.\r\n */\r\ngoog.events.Listenable.prototype.removeAllListeners;\r\n\r\n\r\n/**\r\n * Returns the parent of this event target to use for capture/bubble\r\n * mechanism.\r\n *\r\n * NOTE(chrishenry): The name reflects the original implementation of\r\n * custom event target (`goog.events.EventTarget`). We decided\r\n * that changing the name is not worth it.\r\n *\r\n * @return {goog.events.Listenable} The parent EventTarget or null if\r\n *     there is no parent.\r\n */\r\ngoog.events.Listenable.prototype.getParentEventTarget;\r\n\r\n\r\n/**\r\n * Fires all registered listeners in this listenable for the given\r\n * type and capture mode, passing them the given eventObject. This\r\n * does not perform actual capture/bubble. Only implementors of the\r\n * interface should be using this.\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The type of the\r\n *     listeners to fire.\r\n * @param {boolean} capture The capture mode of the listeners to fire.\r\n * @param {EVENTOBJ} eventObject The event object to fire.\r\n * @return {boolean} Whether all listeners succeeded without\r\n *     attempting to prevent default behavior. If any listener returns\r\n *     false or called goog.events.Event#preventDefault, this returns\r\n *     false.\r\n * @template EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.fireListeners;\r\n\r\n\r\n/**\r\n * Gets all listeners in this listenable for the given type and\r\n * capture mode.\r\n *\r\n * @param {string|!goog.events.EventId} type The type of the listeners to fire.\r\n * @param {boolean} capture The capture mode of the listeners to fire.\r\n * @return {!Array<!goog.events.ListenableKey>} An array of registered\r\n *     listeners.\r\n * @template EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.getListeners;\r\n\r\n\r\n/**\r\n * Gets the goog.events.ListenableKey for the event or null if no such\r\n * listener is in use.\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>} type The name of the event\r\n *     without the 'on' prefix.\r\n * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The\r\n *     listener function to get.\r\n * @param {boolean} capture Whether the listener is a capturing listener.\r\n * @param {SCOPE=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {goog.events.ListenableKey} the found listener or null if not found.\r\n * @template SCOPE,EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.getListener;\r\n\r\n\r\n/**\r\n * Whether there is any active listeners matching the specified\r\n * signature. If either the type or capture parameters are\r\n * unspecified, the function will match on the remaining criteria.\r\n *\r\n * @param {string|!goog.events.EventId<EVENTOBJ>=} opt_type Event type.\r\n * @param {boolean=} opt_capture Whether to check for capture or bubble\r\n *     listeners.\r\n * @return {boolean} Whether there is any active listeners matching\r\n *     the requested type and/or capture phase.\r\n * @template EVENTOBJ\r\n */\r\ngoog.events.Listenable.prototype.hasListener;\r\n\r\n\r\n\r\n/**\r\n * An interface that describes a single registered listener.\r\n * @interface\r\n */\r\ngoog.events.ListenableKey = function() {};\r\n\r\n\r\n/**\r\n * Counter used to create a unique key\r\n * @type {number}\r\n * @private\r\n */\r\ngoog.events.ListenableKey.counter_ = 0;\r\n\r\n\r\n/**\r\n * Reserves a key to be used for ListenableKey#key field.\r\n * @return {number} A number to be used to fill ListenableKey#key\r\n *     field.\r\n */\r\ngoog.events.ListenableKey.reserveKey = function() {\r\n  return ++goog.events.ListenableKey.counter_;\r\n};\r\n\r\n\r\n/**\r\n * The source event target.\r\n * @type {Object|goog.events.Listenable|goog.events.EventTarget}\r\n */\r\ngoog.events.ListenableKey.prototype.src;\r\n\r\n\r\n/**\r\n * The event type the listener is listening to.\r\n * @type {string}\r\n */\r\ngoog.events.ListenableKey.prototype.type;\r\n\r\n\r\n/**\r\n * The listener function.\r\n * @type {function(?):?|{handleEvent:function(?):?}|null}\r\n */\r\ngoog.events.ListenableKey.prototype.listener;\r\n\r\n\r\n/**\r\n * Whether the listener works on capture phase.\r\n * @type {boolean}\r\n */\r\ngoog.events.ListenableKey.prototype.capture;\r\n\r\n\r\n/**\r\n * The 'this' object for the listener function's scope.\r\n * @type {Object|undefined}\r\n */\r\ngoog.events.ListenableKey.prototype.handler;\r\n\r\n\r\n/**\r\n * A globally unique number to identify the key.\r\n * @type {number}\r\n */\r\ngoog.events.ListenableKey.prototype.key;\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Listener object.\r\n * @see ../demos/events.html\r\n */\r\n\r\ngoog.provide('goog.events.Listener');\r\n\r\ngoog.require('goog.events.ListenableKey');\r\n\r\n\r\n\r\n/**\r\n * Simple class that stores information about a listener\r\n * @param {function(?):?} listener Callback function.\r\n * @param {Function} proxy Wrapper for the listener that patches the event.\r\n * @param {EventTarget|goog.events.Listenable} src Source object for\r\n *     the event.\r\n * @param {string} type Event type.\r\n * @param {boolean} capture Whether in capture or bubble phase.\r\n * @param {Object=} opt_handler Object in whose context to execute the callback.\r\n * @implements {goog.events.ListenableKey}\r\n * @constructor\r\n */\r\ngoog.events.Listener = function(\r\n    listener, proxy, src, type, capture, opt_handler) {\r\n  if (goog.events.Listener.ENABLE_MONITORING) {\r\n    this.creationStack = new Error().stack;\r\n  }\r\n\r\n  /** @override */\r\n  this.listener = listener;\r\n\r\n  /**\r\n   * A wrapper over the original listener. This is used solely to\r\n   * handle native browser events (it is used to simulate the capture\r\n   * phase and to patch the event object).\r\n   * @type {Function}\r\n   */\r\n  this.proxy = proxy;\r\n\r\n  /**\r\n   * Object or node that callback is listening to\r\n   * @type {EventTarget|goog.events.Listenable}\r\n   */\r\n  this.src = src;\r\n\r\n  /**\r\n   * The event type.\r\n   * @const {string}\r\n   */\r\n  this.type = type;\r\n\r\n  /**\r\n   * Whether the listener is being called in the capture or bubble phase\r\n   * @const {boolean}\r\n   */\r\n  this.capture = !!capture;\r\n\r\n  /**\r\n   * Optional object whose context to execute the listener in\r\n   * @type {Object|undefined}\r\n   */\r\n  this.handler = opt_handler;\r\n\r\n  /**\r\n   * The key of the listener.\r\n   * @const {number}\r\n   * @override\r\n   */\r\n  this.key = goog.events.ListenableKey.reserveKey();\r\n\r\n  /**\r\n   * Whether to remove the listener after it has been called.\r\n   * @type {boolean}\r\n   */\r\n  this.callOnce = false;\r\n\r\n  /**\r\n   * Whether the listener has been removed.\r\n   * @type {boolean}\r\n   */\r\n  this.removed = false;\r\n};\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to enable the monitoring of the\r\n *     goog.events.Listener instances. Switching on the monitoring is only\r\n *     recommended for debugging because it has a significant impact on\r\n *     performance and memory usage. If switched off, the monitoring code\r\n *     compiles down to 0 bytes.\r\n */\r\ngoog.events.Listener.ENABLE_MONITORING =\r\n    goog.define('goog.events.Listener.ENABLE_MONITORING', false);\r\n\r\n\r\n/**\r\n * If monitoring the goog.events.Listener instances is enabled, stores the\r\n * creation stack trace of the Disposable instance.\r\n * @type {string}\r\n */\r\ngoog.events.Listener.prototype.creationStack;\r\n\r\n\r\n/**\r\n * Marks this listener as removed. This also remove references held by\r\n * this listener object (such as listener and event source).\r\n */\r\ngoog.events.Listener.prototype.markAsRemoved = function() {\r\n  this.removed = true;\r\n  this.listener = null;\r\n  this.proxy = null;\r\n  this.src = null;\r\n  this.handler = null;\r\n};\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A map of listeners that provides utility functions to\r\n * deal with listeners on an event target. Used by\r\n * `goog.events.EventTarget`.\r\n *\r\n * WARNING: Do not use this class from outside goog.events package.\r\n */\r\n\r\ngoog.provide('goog.events.ListenerMap');\r\n\r\ngoog.require('goog.array');\r\ngoog.require('goog.events.Listener');\r\ngoog.require('goog.object');\r\n\r\n\r\n\r\n/**\r\n * Creates a new listener map.\r\n * @param {EventTarget|goog.events.Listenable} src The src object.\r\n * @constructor\r\n * @final\r\n */\r\ngoog.events.ListenerMap = function(src) {\r\n  /** @type {EventTarget|goog.events.Listenable} */\r\n  this.src = src;\r\n\r\n  /**\r\n   * Maps of event type to an array of listeners.\r\n   * @type {!Object<string, !Array<!goog.events.Listener>>}\r\n   */\r\n  this.listeners = {};\r\n\r\n  /**\r\n   * The count of types in this map that have registered listeners.\r\n   * @private {number}\r\n   */\r\n  this.typeCount_ = 0;\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The count of event types in this map that actually\r\n *     have registered listeners.\r\n */\r\ngoog.events.ListenerMap.prototype.getTypeCount = function() {\r\n  return this.typeCount_;\r\n};\r\n\r\n\r\n/**\r\n * @return {number} Total number of registered listeners.\r\n */\r\ngoog.events.ListenerMap.prototype.getListenerCount = function() {\r\n  var count = 0;\r\n  for (var type in this.listeners) {\r\n    count += this.listeners[type].length;\r\n  }\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener. A listener can only be added once to an\r\n * object and if it is added again the key for the listener is\r\n * returned.\r\n *\r\n * Note that a one-off listener will not change an existing listener,\r\n * if any. On the other hand a normal listener will change existing\r\n * one-off listener to become a normal listener.\r\n *\r\n * @param {string|!goog.events.EventId} type The listener event type.\r\n * @param {!Function} listener This listener callback method.\r\n * @param {boolean} callOnce Whether the listener is a one-off\r\n *     listener.\r\n * @param {boolean=} opt_useCapture The capture mode of the listener.\r\n * @param {Object=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {!goog.events.ListenableKey} Unique key for the listener.\r\n */\r\ngoog.events.ListenerMap.prototype.add = function(\r\n    type, listener, callOnce, opt_useCapture, opt_listenerScope) {\r\n  var typeStr = type.toString();\r\n  var listenerArray = this.listeners[typeStr];\r\n  if (!listenerArray) {\r\n    listenerArray = this.listeners[typeStr] = [];\r\n    this.typeCount_++;\r\n  }\r\n\r\n  var listenerObj;\r\n  var index = goog.events.ListenerMap.findListenerIndex_(\r\n      listenerArray, listener, opt_useCapture, opt_listenerScope);\r\n  if (index > -1) {\r\n    listenerObj = listenerArray[index];\r\n    if (!callOnce) {\r\n      // Ensure that, if there is an existing callOnce listener, it is no\r\n      // longer a callOnce listener.\r\n      listenerObj.callOnce = false;\r\n    }\r\n  } else {\r\n    listenerObj = new goog.events.Listener(\r\n        listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);\r\n    listenerObj.callOnce = callOnce;\r\n    listenerArray.push(listenerObj);\r\n  }\r\n  return listenerObj;\r\n};\r\n\r\n\r\n/**\r\n * Removes a matching listener.\r\n * @param {string|!goog.events.EventId} type The listener event type.\r\n * @param {!Function} listener This listener callback method.\r\n * @param {boolean=} opt_useCapture The capture mode of the listener.\r\n * @param {Object=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {boolean} Whether any listener was removed.\r\n */\r\ngoog.events.ListenerMap.prototype.remove = function(\r\n    type, listener, opt_useCapture, opt_listenerScope) {\r\n  var typeStr = type.toString();\r\n  if (!(typeStr in this.listeners)) {\r\n    return false;\r\n  }\r\n\r\n  var listenerArray = this.listeners[typeStr];\r\n  var index = goog.events.ListenerMap.findListenerIndex_(\r\n      listenerArray, listener, opt_useCapture, opt_listenerScope);\r\n  if (index > -1) {\r\n    var listenerObj = listenerArray[index];\r\n    listenerObj.markAsRemoved();\r\n    goog.array.removeAt(listenerArray, index);\r\n    if (listenerArray.length == 0) {\r\n      delete this.listeners[typeStr];\r\n      this.typeCount_--;\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Removes the given listener object.\r\n * @param {!goog.events.ListenableKey} listener The listener to remove.\r\n * @return {boolean} Whether the listener is removed.\r\n */\r\ngoog.events.ListenerMap.prototype.removeByKey = function(listener) {\r\n  var type = listener.type;\r\n  if (!(type in this.listeners)) {\r\n    return false;\r\n  }\r\n\r\n  var removed = goog.array.remove(this.listeners[type], listener);\r\n  if (removed) {\r\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\r\n    if (this.listeners[type].length == 0) {\r\n      delete this.listeners[type];\r\n      this.typeCount_--;\r\n    }\r\n  }\r\n  return removed;\r\n};\r\n\r\n\r\n/**\r\n * Removes all listeners from this map. If opt_type is provided, only\r\n * listeners that match the given type are removed.\r\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\r\n * @return {number} Number of listeners removed.\r\n */\r\ngoog.events.ListenerMap.prototype.removeAll = function(opt_type) {\r\n  var typeStr = opt_type && opt_type.toString();\r\n  var count = 0;\r\n  for (var type in this.listeners) {\r\n    if (!typeStr || type == typeStr) {\r\n      var listenerArray = this.listeners[type];\r\n      for (var i = 0; i < listenerArray.length; i++) {\r\n        ++count;\r\n        listenerArray[i].markAsRemoved();\r\n      }\r\n      delete this.listeners[type];\r\n      this.typeCount_--;\r\n    }\r\n  }\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Gets all listeners that match the given type and capture mode. The\r\n * returned array is a copy (but the listener objects are not).\r\n * @param {string|!goog.events.EventId} type The type of the listeners\r\n *     to retrieve.\r\n * @param {boolean} capture The capture mode of the listeners to retrieve.\r\n * @return {!Array<!goog.events.ListenableKey>} An array of matching\r\n *     listeners.\r\n */\r\ngoog.events.ListenerMap.prototype.getListeners = function(type, capture) {\r\n  var listenerArray = this.listeners[type.toString()];\r\n  var rv = [];\r\n  if (listenerArray) {\r\n    for (var i = 0; i < listenerArray.length; ++i) {\r\n      var listenerObj = listenerArray[i];\r\n      if (listenerObj.capture == capture) {\r\n        rv.push(listenerObj);\r\n      }\r\n    }\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Gets the goog.events.ListenableKey for the event or null if no such\r\n * listener is in use.\r\n *\r\n * @param {string|!goog.events.EventId} type The type of the listener\r\n *     to retrieve.\r\n * @param {!Function} listener The listener function to get.\r\n * @param {boolean} capture Whether the listener is a capturing listener.\r\n * @param {Object=} opt_listenerScope Object in whose scope to call the\r\n *     listener.\r\n * @return {goog.events.ListenableKey} the found listener or null if not found.\r\n */\r\ngoog.events.ListenerMap.prototype.getListener = function(\r\n    type, listener, capture, opt_listenerScope) {\r\n  var listenerArray = this.listeners[type.toString()];\r\n  var i = -1;\r\n  if (listenerArray) {\r\n    i = goog.events.ListenerMap.findListenerIndex_(\r\n        listenerArray, listener, capture, opt_listenerScope);\r\n  }\r\n  return i > -1 ? listenerArray[i] : null;\r\n};\r\n\r\n\r\n/**\r\n * Whether there is a matching listener. If either the type or capture\r\n * parameters are unspecified, the function will match on the\r\n * remaining criteria.\r\n *\r\n * @param {string|!goog.events.EventId=} opt_type The type of the listener.\r\n * @param {boolean=} opt_capture The capture mode of the listener.\r\n * @return {boolean} Whether there is an active listener matching\r\n *     the requested type and/or capture phase.\r\n */\r\ngoog.events.ListenerMap.prototype.hasListener = function(\r\n    opt_type, opt_capture) {\r\n  var hasType = goog.isDef(opt_type);\r\n  var typeStr = hasType ? opt_type.toString() : '';\r\n  var hasCapture = goog.isDef(opt_capture);\r\n\r\n  return goog.object.some(this.listeners, function(listenerArray, type) {\r\n    for (var i = 0; i < listenerArray.length; ++i) {\r\n      if ((!hasType || listenerArray[i].type == typeStr) &&\r\n          (!hasCapture || listenerArray[i].capture == opt_capture)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Finds the index of a matching goog.events.Listener in the given\r\n * listenerArray.\r\n * @param {!Array<!goog.events.Listener>} listenerArray Array of listener.\r\n * @param {!Function} listener The listener function.\r\n * @param {boolean=} opt_useCapture The capture flag for the listener.\r\n * @param {Object=} opt_listenerScope The listener scope.\r\n * @return {number} The index of the matching listener within the\r\n *     listenerArray.\r\n * @private\r\n */\r\ngoog.events.ListenerMap.findListenerIndex_ = function(\r\n    listenerArray, listener, opt_useCapture, opt_listenerScope) {\r\n  for (var i = 0; i < listenerArray.length; ++i) {\r\n    var listenerObj = listenerArray[i];\r\n    if (!listenerObj.removed && listenerObj.listener == listener &&\r\n        listenerObj.capture == !!opt_useCapture &&\r\n        listenerObj.handler == opt_listenerScope) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview An event manager for both native browser event\r\n * targets and custom JavaScript event targets\r\n * (`goog.events.Listenable`). This provides an abstraction\r\n * over browsers' event systems.\r\n *\r\n * It also provides a simulation of W3C event model's capture phase in\r\n * Internet Explorer (IE 8 and below). Caveat: the simulation does not\r\n * interact well with listeners registered directly on the elements\r\n * (bypassing goog.events) or even with listeners registered via\r\n * goog.events in a separate JS binary. In these cases, we provide\r\n * no ordering guarantees.\r\n *\r\n * The listeners will receive a \"patched\" event object. Such event object\r\n * contains normalized values for certain event properties that differs in\r\n * different browsers.\r\n *\r\n * Example usage:\r\n * <pre>\r\n * goog.events.listen(myNode, 'click', function(e) { alert('woo') });\r\n * goog.events.listen(myNode, 'mouseover', mouseHandler, true);\r\n * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);\r\n * goog.events.removeAll(myNode);\r\n * </pre>\r\n *\r\n *                                            in IE and event object patching]\r\n * @author arv@google.com (Erik Arvidsson)\r\n *\r\n * @see ../demos/events.html\r\n * @see ../demos/event-propagation.html\r\n * @see ../demos/stopevent.html\r\n */\r\n\r\n// IMPLEMENTATION NOTES:\r\n// goog.events stores an auxiliary data structure on each EventTarget\r\n// source being listened on. This allows us to take advantage of GC,\r\n// having the data structure GC'd when the EventTarget is GC'd. This\r\n// GC behavior is equivalent to using W3C DOM Events directly.\r\n\r\ngoog.provide('goog.events');\r\ngoog.provide('goog.events.CaptureSimulationMode');\r\ngoog.provide('goog.events.Key');\r\ngoog.provide('goog.events.ListenableType');\r\n\r\ngoog.require('goog.asserts');\r\ngoog.require('goog.debug.entryPointRegistry');\r\ngoog.require('goog.events.BrowserEvent');\r\ngoog.require('goog.events.BrowserFeature');\r\ngoog.require('goog.events.Listenable');\r\ngoog.require('goog.events.ListenerMap');\r\n\r\ngoog.forwardDeclare('goog.debug.ErrorHandler');\r\ngoog.forwardDeclare('goog.events.EventWrapper');\r\n\r\n\r\n/**\r\n * @typedef {number|goog.events.ListenableKey}\r\n */\r\ngoog.events.Key;\r\n\r\n\r\n/**\r\n * @typedef {EventTarget|goog.events.Listenable}\r\n */\r\ngoog.events.ListenableType;\r\n\r\n\r\n/**\r\n * Property name on a native event target for the listener map\r\n * associated with the event target.\r\n * @private @const {string}\r\n */\r\ngoog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);\r\n\r\n\r\n/**\r\n * String used to prepend to IE event types.\r\n * @const\r\n * @private\r\n */\r\ngoog.events.onString_ = 'on';\r\n\r\n\r\n/**\r\n * Map of computed \"on<eventname>\" strings for IE event types. Caching\r\n * this removes an extra object allocation in goog.events.listen which\r\n * improves IE6 performance.\r\n * @const\r\n * @dict\r\n * @private\r\n */\r\ngoog.events.onStringMap_ = {};\r\n\r\n\r\n/**\r\n * @enum {number} Different capture simulation mode for IE8-.\r\n */\r\ngoog.events.CaptureSimulationMode = {\r\n  /**\r\n   * Does not perform capture simulation. Will asserts in IE8- when you\r\n   * add capture listeners.\r\n   */\r\n  OFF_AND_FAIL: 0,\r\n\r\n  /**\r\n   * Does not perform capture simulation, silently ignore capture\r\n   * listeners.\r\n   */\r\n  OFF_AND_SILENT: 1,\r\n\r\n  /**\r\n   * Performs capture simulation.\r\n   */\r\n  ON: 2\r\n};\r\n\r\n\r\n/**\r\n * @define {number} The capture simulation mode for IE8-. By default,\r\n *     this is ON.\r\n */\r\ngoog.events.CAPTURE_SIMULATION_MODE =\r\n    goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);\r\n\r\n\r\n/**\r\n * Estimated count of total native listeners.\r\n * @private {number}\r\n */\r\ngoog.events.listenerCountEstimate_ = 0;\r\n\r\n\r\n/**\r\n * Adds an event listener for a specific event on a native event\r\n * target (such as a DOM element) or an object that has implemented\r\n * {@link goog.events.Listenable}. A listener can only be added once\r\n * to an object and if it is added again the key for the listener is\r\n * returned. Note that if the existing listener is a one-off listener\r\n * (registered via listenOnce), it will no longer be a one-off\r\n * listener after a call to listen().\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The node to listen\r\n *     to events on.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type or array of event types.\r\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\r\n *     listener Callback method, or an object with a handleEvent function.\r\n *     WARNING: passing an Object is now softly deprecated.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @param {T=} opt_handler Element in whose scope to call the listener.\r\n * @return {goog.events.Key} Unique key for the listener.\r\n * @template T,EVENTOBJ\r\n */\r\ngoog.events.listen = function(src, type, listener, opt_options, opt_handler) {\r\n  if (opt_options && opt_options.once) {\r\n    return goog.events.listenOnce(\r\n        src, type, listener, opt_options, opt_handler);\r\n  }\r\n  if (goog.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      goog.events.listen(src, type[i], listener, opt_options, opt_handler);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  listener = goog.events.wrapListener(listener);\r\n  if (goog.events.Listenable.isImplementedBy(src)) {\r\n    var capture =\r\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\r\n    return src.listen(\r\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\r\n        opt_handler);\r\n  } else {\r\n    return goog.events.listen_(\r\n        /** @type {!EventTarget} */ (src), type, listener,\r\n        /* callOnce */ false, opt_options, opt_handler);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener for a specific event on a native event\r\n * target. A listener can only be added once to an object and if it\r\n * is added again the key for the listener is returned.\r\n *\r\n * Note that a one-off listener will not change an existing listener,\r\n * if any. On the other hand a normal listener will change existing\r\n * one-off listener to become a normal listener.\r\n *\r\n * @param {EventTarget} src The node to listen to events on.\r\n * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.\r\n * @param {!Function} listener Callback function.\r\n * @param {boolean} callOnce Whether the listener is a one-off\r\n *     listener or otherwise.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @param {Object=} opt_handler Element in whose scope to call the listener.\r\n * @return {goog.events.ListenableKey} Unique key for the listener.\r\n * @template EVENTOBJ\r\n * @private\r\n */\r\ngoog.events.listen_ = function(\r\n    src, type, listener, callOnce, opt_options, opt_handler) {\r\n  if (!type) {\r\n    throw new Error('Invalid event type');\r\n  }\r\n\r\n  var capture =\r\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\r\n  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\r\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\r\n        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {\r\n      goog.asserts.fail('Can not register capture listener in IE8-.');\r\n      return null;\r\n    } else if (\r\n        goog.events.CAPTURE_SIMULATION_MODE ==\r\n        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  var listenerMap = goog.events.getListenerMap_(src);\r\n  if (!listenerMap) {\r\n    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =\r\n        new goog.events.ListenerMap(src);\r\n  }\r\n\r\n  var listenerObj = /** @type {goog.events.Listener} */ (\r\n      listenerMap.add(type, listener, callOnce, capture, opt_handler));\r\n\r\n  // If the listenerObj already has a proxy, it has been set up\r\n  // previously. We simply return.\r\n  if (listenerObj.proxy) {\r\n    return listenerObj;\r\n  }\r\n\r\n  var proxy = goog.events.getProxy();\r\n  listenerObj.proxy = proxy;\r\n\r\n  proxy.src = src;\r\n  proxy.listener = listenerObj;\r\n\r\n  // Attach the proxy through the browser's API\r\n  if (src.addEventListener) {\r\n    // Don't pass an object as `capture` if the browser doesn't support that.\r\n    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {\r\n      opt_options = capture;\r\n    }\r\n    // Don't break tests that expect a boolean.\r\n    if (opt_options === undefined) opt_options = false;\r\n    src.addEventListener(type.toString(), proxy, opt_options);\r\n  } else if (src.attachEvent) {\r\n    // The else if above used to be an unconditional else. It would call\r\n    // exception on IE11, spoiling the day of some callers. The previous\r\n    // incarnation of this code, from 2007, indicates that it replaced an\r\n    // earlier still version that caused excess allocations on IE6.\r\n    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);\r\n  } else if (src.addListener && src.removeListener) {\r\n    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In\r\n    // Safari, there is no global for the MediaQueryList constructor, so we just\r\n    // check whether the object \"looks like\" MediaQueryList.\r\n    goog.asserts.assert(\r\n        type === 'change', 'MediaQueryList only has a change event');\r\n    src.addListener(proxy);\r\n  } else {\r\n    throw new Error('addEventListener and attachEvent are unavailable.');\r\n  }\r\n\r\n  goog.events.listenerCountEstimate_++;\r\n  return listenerObj;\r\n};\r\n\r\n\r\n/**\r\n * Helper function for returning a proxy function.\r\n * @return {!Function} A new or reused function object.\r\n */\r\ngoog.events.getProxy = function() {\r\n  var proxyCallbackFunction = goog.events.handleBrowserEvent_;\r\n  // Use a local var f to prevent one allocation.\r\n  var f =\r\n      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {\r\n        return proxyCallbackFunction.call(f.src, f.listener, eventObject);\r\n      } : function(eventObject) {\r\n        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);\r\n        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if\r\n        // there is inline event handler which tries to prevent default (for\r\n        // example <a href=\"...\" onclick=\"return false\">...</a>) in a\r\n        // descendant element, the prevent default will be overridden\r\n        // by this listener if this listener were to return true. Hence, we\r\n        // return undefined.\r\n        if (!v) return v;\r\n      };\r\n  return f;\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener for a specific event on a native event\r\n * target (such as a DOM element) or an object that has implemented\r\n * {@link goog.events.Listenable}. After the event has fired the event\r\n * listener is removed from the target.\r\n *\r\n * If an existing listener already exists, listenOnce will do\r\n * nothing. In particular, if the listener was previously registered\r\n * via listen(), listenOnce() will not turn the listener into a\r\n * one-off listener. Similarly, if there is already an existing\r\n * one-off listener, listenOnce does not modify the listeners (it is\r\n * still a once listener).\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The node to listen\r\n *     to events on.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type or array of event types.\r\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\r\n *     listener Callback method.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @param {T=} opt_handler Element in whose scope to call the listener.\r\n * @return {goog.events.Key} Unique key for the listener.\r\n * @template T,EVENTOBJ\r\n */\r\ngoog.events.listenOnce = function(\r\n    src, type, listener, opt_options, opt_handler) {\r\n  if (goog.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  listener = goog.events.wrapListener(listener);\r\n  if (goog.events.Listenable.isImplementedBy(src)) {\r\n    var capture =\r\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\r\n    return src.listenOnce(\r\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\r\n        opt_handler);\r\n  } else {\r\n    return goog.events.listen_(\r\n        /** @type {!EventTarget} */ (src), type, listener,\r\n        /* callOnce */ true, opt_options, opt_handler);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener with a specific event wrapper on a DOM Node or an\r\n * object that has implemented {@link goog.events.Listenable}. A listener can\r\n * only be added once to an object.\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The target to\r\n *     listen to events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener\r\n *     Callback method, or an object with a handleEvent function.\r\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\r\n *     false).\r\n * @param {T=} opt_handler Element in whose scope to call the listener.\r\n * @template T\r\n */\r\ngoog.events.listenWithWrapper = function(\r\n    src, wrapper, listener, opt_capt, opt_handler) {\r\n  wrapper.listen(src, listener, opt_capt, opt_handler);\r\n};\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listen().\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The target to stop\r\n *     listening to events on.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type or array of event types to unlisten to.\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\r\n *     listener function to remove.\r\n * @param {(boolean|!EventListenerOptions)=} opt_options\r\n *     whether the listener is fired during the capture or bubble phase of the\r\n *     event.\r\n * @param {Object=} opt_handler Element in whose scope to call the listener.\r\n * @return {?boolean} indicating whether the listener was there to remove.\r\n * @template EVENTOBJ\r\n */\r\ngoog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {\r\n  if (goog.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);\r\n    }\r\n    return null;\r\n  }\r\n  var capture =\r\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\r\n\r\n  listener = goog.events.wrapListener(listener);\r\n  if (goog.events.Listenable.isImplementedBy(src)) {\r\n    return src.unlisten(\r\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\r\n        opt_handler);\r\n  }\r\n\r\n  if (!src) {\r\n    // TODO(chrishenry): We should tighten the API to only accept\r\n    // non-null objects, or add an assertion here.\r\n    return false;\r\n  }\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {!EventTarget} */ (src));\r\n  if (listenerMap) {\r\n    var listenerObj = listenerMap.getListener(\r\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\r\n        opt_handler);\r\n    if (listenerObj) {\r\n      return goog.events.unlistenByKey(listenerObj);\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listen() by the key\r\n * returned by listen().\r\n *\r\n * @param {goog.events.Key} key The key returned by listen() for this\r\n *     event listener.\r\n * @return {boolean} indicating whether the listener was there to remove.\r\n */\r\ngoog.events.unlistenByKey = function(key) {\r\n  // TODO(chrishenry): Remove this check when tests that rely on this\r\n  // are fixed.\r\n  if (goog.isNumber(key)) {\r\n    return false;\r\n  }\r\n\r\n  var listener = key;\r\n  if (!listener || listener.removed) {\r\n    return false;\r\n  }\r\n\r\n  var src = listener.src;\r\n  if (goog.events.Listenable.isImplementedBy(src)) {\r\n    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);\r\n  }\r\n\r\n  var type = listener.type;\r\n  var proxy = listener.proxy;\r\n  if (src.removeEventListener) {\r\n    src.removeEventListener(type, proxy, listener.capture);\r\n  } else if (src.detachEvent) {\r\n    src.detachEvent(goog.events.getOnString_(type), proxy);\r\n  } else if (src.addListener && src.removeListener) {\r\n    src.removeListener(proxy);\r\n  }\r\n  goog.events.listenerCountEstimate_--;\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {!EventTarget} */ (src));\r\n  // TODO(chrishenry): Try to remove this conditional and execute the\r\n  // first branch always. This should be safe.\r\n  if (listenerMap) {\r\n    listenerMap.removeByKey(listener);\r\n    if (listenerMap.getTypeCount() == 0) {\r\n      // Null the src, just because this is simple to do (and useful\r\n      // for IE <= 7).\r\n      listenerMap.src = null;\r\n      // We don't use delete here because IE does not allow delete\r\n      // on a window object.\r\n      src[goog.events.LISTENER_MAP_PROP_] = null;\r\n    }\r\n  } else {\r\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listenWithWrapper().\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The target to stop\r\n *     listening to events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\r\n *     listener function to remove.\r\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\r\n *     whether the listener is fired during the capture or bubble phase of the\r\n *     event.\r\n * @param {Object=} opt_handler Element in whose scope to call the listener.\r\n */\r\ngoog.events.unlistenWithWrapper = function(\r\n    src, wrapper, listener, opt_capt, opt_handler) {\r\n  wrapper.unlisten(src, listener, opt_capt, opt_handler);\r\n};\r\n\r\n\r\n/**\r\n * Removes all listeners from an object. You can also optionally\r\n * remove listeners of a particular type.\r\n *\r\n * @param {Object|undefined} obj Object to remove listeners from. Must be an\r\n *     EventTarget or a goog.events.Listenable.\r\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\r\n *     Default is all types.\r\n * @return {number} Number of listeners removed.\r\n */\r\ngoog.events.removeAll = function(obj, opt_type) {\r\n  // TODO(chrishenry): Change the type of obj to\r\n  // (!EventTarget|!goog.events.Listenable).\r\n\r\n  if (!obj) {\r\n    return 0;\r\n  }\r\n\r\n  if (goog.events.Listenable.isImplementedBy(obj)) {\r\n    return /** @type {?} */ (obj).removeAllListeners(opt_type);\r\n  }\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {!EventTarget} */ (obj));\r\n  if (!listenerMap) {\r\n    return 0;\r\n  }\r\n\r\n  var count = 0;\r\n  var typeStr = opt_type && opt_type.toString();\r\n  for (var type in listenerMap.listeners) {\r\n    if (!typeStr || type == typeStr) {\r\n      // Clone so that we don't need to worry about unlistenByKey\r\n      // changing the content of the ListenerMap.\r\n      var listeners = listenerMap.listeners[type].concat();\r\n      for (var i = 0; i < listeners.length; ++i) {\r\n        if (goog.events.unlistenByKey(listeners[i])) {\r\n          ++count;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Gets the listeners for a given object, type and capture phase.\r\n *\r\n * @param {Object} obj Object to get listeners for.\r\n * @param {string|!goog.events.EventId} type Event type.\r\n * @param {boolean} capture Capture phase?.\r\n * @return {Array<!goog.events.Listener>} Array of listener objects.\r\n */\r\ngoog.events.getListeners = function(obj, type, capture) {\r\n  if (goog.events.Listenable.isImplementedBy(obj)) {\r\n    return /** @type {!goog.events.Listenable} */ (obj).getListeners(\r\n        type, capture);\r\n  } else {\r\n    if (!obj) {\r\n      // TODO(chrishenry): We should tighten the API to accept\r\n      // !EventTarget|goog.events.Listenable, and add an assertion here.\r\n      return [];\r\n    }\r\n\r\n    var listenerMap = goog.events.getListenerMap_(\r\n        /** @type {!EventTarget} */ (obj));\r\n    return listenerMap ? listenerMap.getListeners(type, capture) : [];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Gets the goog.events.Listener for the event or null if no such listener is\r\n * in use.\r\n *\r\n * @param {EventTarget|goog.events.Listenable} src The target from\r\n *     which to get listeners.\r\n * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.\r\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The\r\n *     listener function to get.\r\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\r\n *                            whether the listener is fired during the\r\n *                            capture or bubble phase of the event.\r\n * @param {Object=} opt_handler Element in whose scope to call the listener.\r\n * @return {goog.events.ListenableKey} the found listener or null if not found.\r\n * @template EVENTOBJ\r\n */\r\ngoog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {\r\n  // TODO(chrishenry): Change type from ?string to string, or add assertion.\r\n  type = /** @type {string} */ (type);\r\n  listener = goog.events.wrapListener(listener);\r\n  var capture = !!opt_capt;\r\n  if (goog.events.Listenable.isImplementedBy(src)) {\r\n    return src.getListener(type, listener, capture, opt_handler);\r\n  }\r\n\r\n  if (!src) {\r\n    // TODO(chrishenry): We should tighten the API to only accept\r\n    // non-null objects, or add an assertion here.\r\n    return null;\r\n  }\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {!EventTarget} */ (src));\r\n  if (listenerMap) {\r\n    return listenerMap.getListener(type, listener, capture, opt_handler);\r\n  }\r\n  return null;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether an event target has any active listeners matching the\r\n * specified signature. If either the type or capture parameters are\r\n * unspecified, the function will match on the remaining criteria.\r\n *\r\n * @param {EventTarget|goog.events.Listenable} obj Target to get\r\n *     listeners for.\r\n * @param {string|!goog.events.EventId=} opt_type Event type.\r\n * @param {boolean=} opt_capture Whether to check for capture or bubble-phase\r\n *     listeners.\r\n * @return {boolean} Whether an event target has one or more listeners matching\r\n *     the requested type and/or capture phase.\r\n */\r\ngoog.events.hasListener = function(obj, opt_type, opt_capture) {\r\n  if (goog.events.Listenable.isImplementedBy(obj)) {\r\n    return obj.hasListener(opt_type, opt_capture);\r\n  }\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {!EventTarget} */ (obj));\r\n  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);\r\n};\r\n\r\n\r\n/**\r\n * Provides a nice string showing the normalized event objects public members\r\n * @param {Object} e Event Object.\r\n * @return {string} String of the public members of the normalized event object.\r\n */\r\ngoog.events.expose = function(e) {\r\n  var str = [];\r\n  for (var key in e) {\r\n    if (e[key] && e[key].id) {\r\n      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');\r\n    } else {\r\n      str.push(key + ' = ' + e[key]);\r\n    }\r\n  }\r\n  return str.join('\\n');\r\n};\r\n\r\n\r\n/**\r\n * Returns a string with on prepended to the specified type. This is used for IE\r\n * which expects \"on\" to be prepended. This function caches the string in order\r\n * to avoid extra allocations in steady state.\r\n * @param {string} type Event type.\r\n * @return {string} The type string with 'on' prepended.\r\n * @private\r\n */\r\ngoog.events.getOnString_ = function(type) {\r\n  if (type in goog.events.onStringMap_) {\r\n    return goog.events.onStringMap_[type];\r\n  }\r\n  return goog.events.onStringMap_[type] = goog.events.onString_ + type;\r\n};\r\n\r\n\r\n/**\r\n * Fires an object's listeners of a particular type and phase\r\n *\r\n * @param {Object} obj Object whose listeners to call.\r\n * @param {string|!goog.events.EventId} type Event type.\r\n * @param {boolean} capture Which event phase.\r\n * @param {Object} eventObject Event object to be passed to listener.\r\n * @return {boolean} True if all listeners returned true else false.\r\n */\r\ngoog.events.fireListeners = function(obj, type, capture, eventObject) {\r\n  if (goog.events.Listenable.isImplementedBy(obj)) {\r\n    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(\r\n        type, capture, eventObject);\r\n  }\r\n\r\n  return goog.events.fireListeners_(obj, type, capture, eventObject);\r\n};\r\n\r\n\r\n/**\r\n * Fires an object's listeners of a particular type and phase.\r\n * @param {Object} obj Object whose listeners to call.\r\n * @param {string|!goog.events.EventId} type Event type.\r\n * @param {boolean} capture Which event phase.\r\n * @param {Object} eventObject Event object to be passed to listener.\r\n * @return {boolean} True if all listeners returned true else false.\r\n * @private\r\n */\r\ngoog.events.fireListeners_ = function(obj, type, capture, eventObject) {\r\n  /** @type {boolean} */\r\n  var retval = true;\r\n\r\n  var listenerMap = goog.events.getListenerMap_(\r\n      /** @type {EventTarget} */ (obj));\r\n  if (listenerMap) {\r\n    // TODO(chrishenry): Original code avoids array creation when there\r\n    // is no listener, so we do the same. If this optimization turns\r\n    // out to be not required, we can replace this with\r\n    // listenerMap.getListeners(type, capture) instead, which is simpler.\r\n    var listenerArray = listenerMap.listeners[type.toString()];\r\n    if (listenerArray) {\r\n      listenerArray = listenerArray.concat();\r\n      for (var i = 0; i < listenerArray.length; i++) {\r\n        var listener = listenerArray[i];\r\n        // We might not have a listener if the listener was removed.\r\n        if (listener && listener.capture == capture && !listener.removed) {\r\n          var result = goog.events.fireListener(listener, eventObject);\r\n          retval = retval && (result !== false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return retval;\r\n};\r\n\r\n\r\n/**\r\n * Fires a listener with a set of arguments\r\n *\r\n * @param {goog.events.Listener} listener The listener object to call.\r\n * @param {Object} eventObject The event object to pass to the listener.\r\n * @return {*} Result of listener.\r\n */\r\ngoog.events.fireListener = function(listener, eventObject) {\r\n  var listenerFn = listener.listener;\r\n  var listenerHandler = listener.handler || listener.src;\r\n\r\n  if (listener.callOnce) {\r\n    goog.events.unlistenByKey(listener);\r\n  }\r\n  return listenerFn.call(listenerHandler, eventObject);\r\n};\r\n\r\n\r\n/**\r\n * Gets the total number of listeners currently in the system.\r\n * @return {number} Number of listeners.\r\n * @deprecated This returns estimated count, now that Closure no longer\r\n * stores a central listener registry. We still return an estimation\r\n * to keep existing listener-related tests passing. In the near future,\r\n * this function will be removed.\r\n */\r\ngoog.events.getTotalListenerCount = function() {\r\n  return goog.events.listenerCountEstimate_;\r\n};\r\n\r\n\r\n/**\r\n * Dispatches an event (or event like object) and calls all listeners\r\n * listening for events of this type. The type of the event is decided by the\r\n * type property on the event object.\r\n *\r\n * If any of the listeners returns false OR calls preventDefault then this\r\n * function will return false.  If one of the capture listeners calls\r\n * stopPropagation, then the bubble listeners won't fire.\r\n *\r\n * @param {goog.events.Listenable} src The event target.\r\n * @param {goog.events.EventLike} e Event object.\r\n * @return {boolean} If anyone called preventDefault on the event object (or\r\n *     if any of the handlers returns false) this will also return false.\r\n *     If there are no handlers, or if all handlers return true, this returns\r\n *     true.\r\n */\r\ngoog.events.dispatchEvent = function(src, e) {\r\n  goog.asserts.assert(\r\n      goog.events.Listenable.isImplementedBy(src),\r\n      'Can not use goog.events.dispatchEvent with ' +\r\n          'non-goog.events.Listenable instance.');\r\n  return src.dispatchEvent(e);\r\n};\r\n\r\n\r\n/**\r\n * Installs exception protection for the browser event entry point using the\r\n * given error handler.\r\n *\r\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\r\n *     protect the entry point.\r\n */\r\ngoog.events.protectBrowserEventEntryPoint = function(errorHandler) {\r\n  goog.events.handleBrowserEvent_ =\r\n      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);\r\n};\r\n\r\n\r\n/**\r\n * Handles an event and dispatches it to the correct listeners. This\r\n * function is a proxy for the real listener the user specified.\r\n *\r\n * @param {goog.events.Listener} listener The listener object.\r\n * @param {Event=} opt_evt Optional event object that gets passed in via the\r\n *     native event handlers.\r\n * @return {*} Result of the event handler.\r\n * @this {EventTarget} The object or Element that fired the event.\r\n * @private\r\n */\r\ngoog.events.handleBrowserEvent_ = function(listener, opt_evt) {\r\n  if (listener.removed) {\r\n    return true;\r\n  }\r\n\r\n  // Synthesize event propagation if the browser does not support W3C\r\n  // event model.\r\n  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\r\n    var ieEvent = opt_evt ||\r\n        /** @type {Event} */ (goog.getObjectByName('window.event'));\r\n    var evt = new goog.events.BrowserEvent(ieEvent, this);\r\n    /** @type {*} */\r\n    var retval = true;\r\n\r\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\r\n        goog.events.CaptureSimulationMode.ON) {\r\n      // If we have not marked this event yet, we should perform capture\r\n      // simulation.\r\n      if (!goog.events.isMarkedIeEvent_(ieEvent)) {\r\n        goog.events.markIeEvent_(ieEvent);\r\n\r\n        var ancestors = [];\r\n        for (var parent = evt.currentTarget; parent;\r\n             parent = parent.parentNode) {\r\n          ancestors.push(parent);\r\n        }\r\n\r\n        // Fire capture listeners.\r\n        var type = listener.type;\r\n        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;\r\n             i--) {\r\n          evt.currentTarget = ancestors[i];\r\n          var result =\r\n              goog.events.fireListeners_(ancestors[i], type, true, evt);\r\n          retval = retval && result;\r\n        }\r\n\r\n        // Fire bubble listeners.\r\n        //\r\n        // We can technically rely on IE to perform bubble event\r\n        // propagation. However, it turns out that IE fires events in\r\n        // opposite order of attachEvent registration, which broke\r\n        // some code and tests that rely on the order. (While W3C DOM\r\n        // Level 2 Events TR leaves the event ordering unspecified,\r\n        // modern browsers and W3C DOM Level 3 Events Working Draft\r\n        // actually specify the order as the registration order.)\r\n        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {\r\n          evt.currentTarget = ancestors[i];\r\n          var result =\r\n              goog.events.fireListeners_(ancestors[i], type, false, evt);\r\n          retval = retval && result;\r\n        }\r\n      }\r\n    } else {\r\n      retval = goog.events.fireListener(listener, evt);\r\n    }\r\n    return retval;\r\n  }\r\n\r\n  // Otherwise, simply fire the listener.\r\n  return goog.events.fireListener(\r\n      listener, new goog.events.BrowserEvent(opt_evt, this));\r\n};\r\n\r\n\r\n/**\r\n * This is used to mark the IE event object so we do not do the Closure pass\r\n * twice for a bubbling event.\r\n * @param {Event} e The IE browser event.\r\n * @private\r\n */\r\ngoog.events.markIeEvent_ = function(e) {\r\n  // Only the keyCode and the returnValue can be changed. We use keyCode for\r\n  // non keyboard events.\r\n  // event.returnValue is a bit more tricky. It is undefined by default. A\r\n  // boolean false prevents the default action. In a window.onbeforeunload and\r\n  // the returnValue is non undefined it will be alerted. However, we will only\r\n  // modify the returnValue for keyboard events. We can get a problem if non\r\n  // closure events sets the keyCode or the returnValue\r\n\r\n  var useReturnValue = false;\r\n\r\n  if (e.keyCode == 0) {\r\n    // We cannot change the keyCode in case that srcElement is input[type=file].\r\n    // We could test that that is the case but that would allocate 3 objects.\r\n    // If we use try/catch we will only allocate extra objects in the case of a\r\n    // failure.\r\n\r\n    try {\r\n      e.keyCode = -1;\r\n      return;\r\n    } catch (ex) {\r\n      useReturnValue = true;\r\n    }\r\n  }\r\n\r\n  if (useReturnValue ||\r\n      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {\r\n    e.returnValue = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * This is used to check if an IE event has already been handled by the Closure\r\n * system so we do not do the Closure pass twice for a bubbling event.\r\n * @param {Event} e  The IE browser event.\r\n * @return {boolean} True if the event object has been marked.\r\n * @private\r\n */\r\ngoog.events.isMarkedIeEvent_ = function(e) {\r\n  return e.keyCode < 0 || e.returnValue != undefined;\r\n};\r\n\r\n\r\n/**\r\n * Counter to create unique event ids.\r\n * @private {number}\r\n */\r\ngoog.events.uniqueIdCounter_ = 0;\r\n\r\n\r\n/**\r\n * Creates a unique event id.\r\n *\r\n * @param {string} identifier The identifier.\r\n * @return {string} A unique identifier.\r\n * @idGenerator {unique}\r\n */\r\ngoog.events.getUniqueId = function(identifier) {\r\n  return identifier + '_' + goog.events.uniqueIdCounter_++;\r\n};\r\n\r\n\r\n/**\r\n * @param {EventTarget} src The source object.\r\n * @return {goog.events.ListenerMap} A listener map for the given\r\n *     source object, or null if none exists.\r\n * @private\r\n */\r\ngoog.events.getListenerMap_ = function(src) {\r\n  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];\r\n  // IE serializes the property as well (e.g. when serializing outer\r\n  // HTML). So we must check that the value is of the correct type.\r\n  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;\r\n};\r\n\r\n\r\n/**\r\n * Expando property for listener function wrapper for Object with\r\n * handleEvent.\r\n * @private @const {string}\r\n */\r\ngoog.events.LISTENER_WRAPPER_PROP_ =\r\n    '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);\r\n\r\n\r\n/**\r\n * @param {Object|Function} listener The listener function or an\r\n *     object that contains handleEvent method.\r\n * @return {!Function} Either the original function or a function that\r\n *     calls obj.handleEvent. If the same listener is passed to this\r\n *     function more than once, the same function is guaranteed to be\r\n *     returned.\r\n */\r\ngoog.events.wrapListener = function(listener) {\r\n  goog.asserts.assert(listener, 'Listener can not be null.');\r\n\r\n  if (goog.isFunction(listener)) {\r\n    return listener;\r\n  }\r\n\r\n  goog.asserts.assert(\r\n      listener.handleEvent, 'An object listener must have handleEvent method.');\r\n  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {\r\n    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {\r\n      return /** @type {?} */ (listener).handleEvent(e);\r\n    };\r\n  }\r\n  return listener[goog.events.LISTENER_WRAPPER_PROP_];\r\n};\r\n\r\n\r\n// Register the browser event handler as an entry point, so that\r\n// it can be monitored for exception handling, etc.\r\ngoog.debug.entryPointRegistry.register(\r\n    /**\r\n     * @param {function(!Function): !Function} transformer The transforming\r\n     *     function.\r\n     */\r\n    function(transformer) {\r\n      goog.events.handleBrowserEvent_ =\r\n          transformer(goog.events.handleBrowserEvent_);\r\n    });\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A disposable implementation of a custom\r\n * listenable/event target. See also: documentation for\r\n * `goog.events.Listenable`.\r\n *\r\n * @author arv@google.com (Erik Arvidsson) [Original implementation]\r\n * @see ../demos/eventtarget.html\r\n * @see goog.events.Listenable\r\n */\r\n\r\ngoog.provide('goog.events.EventTarget');\r\n\r\ngoog.require('goog.Disposable');\r\ngoog.require('goog.asserts');\r\ngoog.require('goog.events');\r\ngoog.require('goog.events.Event');\r\ngoog.require('goog.events.Listenable');\r\ngoog.require('goog.events.ListenerMap');\r\ngoog.require('goog.object');\r\n\r\n\r\n\r\n/**\r\n * An implementation of `goog.events.Listenable` with full W3C\r\n * EventTarget-like support (capture/bubble mechanism, stopping event\r\n * propagation, preventing default actions).\r\n *\r\n * You may subclass this class to turn your class into a Listenable.\r\n *\r\n * Unless propagation is stopped, an event dispatched by an\r\n * EventTarget will bubble to the parent returned by\r\n * `getParentEventTarget`. To set the parent, call\r\n * `setParentEventTarget`. Subclasses that don't support\r\n * changing the parent can override the setter to throw an error.\r\n *\r\n * Example usage:\r\n * <pre>\r\n *   var source = new goog.events.EventTarget();\r\n *   function handleEvent(e) {\r\n *     alert('Type: ' + e.type + '; Target: ' + e.target);\r\n *   }\r\n *   source.listen('foo', handleEvent);\r\n *   // Or: goog.events.listen(source, 'foo', handleEvent);\r\n *   ...\r\n *   source.dispatchEvent('foo');  // will call handleEvent\r\n *   ...\r\n *   source.unlisten('foo', handleEvent);\r\n *   // Or: goog.events.unlisten(source, 'foo', handleEvent);\r\n * </pre>\r\n *\r\n * @constructor\r\n * @extends {goog.Disposable}\r\n * @implements {goog.events.Listenable}\r\n */\r\ngoog.events.EventTarget = function() {\r\n  goog.Disposable.call(this);\r\n\r\n  /**\r\n   * Maps of event type to an array of listeners.\r\n   * @private {!goog.events.ListenerMap}\r\n   */\r\n  this.eventTargetListeners_ = new goog.events.ListenerMap(this);\r\n\r\n  /**\r\n   * The object to use for event.target. Useful when mixing in an\r\n   * EventTarget to another object.\r\n   * @private {!Object}\r\n   */\r\n  this.actualEventTarget_ = this;\r\n\r\n  /**\r\n   * Parent event target, used during event bubbling.\r\n   *\r\n   * TODO(chrishenry): Change this to goog.events.Listenable. This\r\n   * currently breaks people who expect getParentEventTarget to return\r\n   * goog.events.EventTarget.\r\n   *\r\n   * @private {?goog.events.EventTarget}\r\n   */\r\n  this.parentEventTarget_ = null;\r\n};\r\ngoog.inherits(goog.events.EventTarget, goog.Disposable);\r\ngoog.events.Listenable.addImplementation(goog.events.EventTarget);\r\n\r\n\r\n/**\r\n * An artificial cap on the number of ancestors you can have. This is mainly\r\n * for loop detection.\r\n * @const {number}\r\n * @private\r\n */\r\ngoog.events.EventTarget.MAX_ANCESTORS_ = 1000;\r\n\r\n\r\n/**\r\n * Returns the parent of this event target to use for bubbling.\r\n *\r\n * @return {goog.events.EventTarget} The parent EventTarget or null if\r\n *     there is no parent.\r\n * @override\r\n */\r\ngoog.events.EventTarget.prototype.getParentEventTarget = function() {\r\n  return this.parentEventTarget_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the parent of this event target to use for capture/bubble\r\n * mechanism.\r\n * @param {goog.events.EventTarget} parent Parent listenable (null if none).\r\n */\r\ngoog.events.EventTarget.prototype.setParentEventTarget = function(parent) {\r\n  this.parentEventTarget_ = parent;\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener to the event target. The same handler can only be\r\n * added once per the type. Even if you add the same handler multiple times\r\n * using the same type then it will only be called once when the event is\r\n * dispatched.\r\n *\r\n * @param {string|!goog.events.EventId} type The type of the event to listen for\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function\r\n *     to handle the event. The handler can also be an object that implements\r\n *     the handleEvent method which takes the event object as argument.\r\n * @param {boolean=} opt_capture In DOM-compliant browsers, this determines\r\n *     whether the listener is fired during the capture or bubble phase\r\n *     of the event.\r\n * @param {Object=} opt_handlerScope Object in whose scope to call\r\n *     the listener.\r\n * @deprecated Use `#listen` instead, when possible. Otherwise, use\r\n *     `goog.events.listen` if you are passing Object\r\n *     (instead of Function) as handler.\r\n */\r\ngoog.events.EventTarget.prototype.addEventListener = function(\r\n    type, handler, opt_capture, opt_handlerScope) {\r\n  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);\r\n};\r\n\r\n\r\n/**\r\n * Removes an event listener from the event target. The handler must be the\r\n * same object as the one added. If the handler has not been added then\r\n * nothing is done.\r\n *\r\n * @param {string} type The type of the event to listen for.\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function\r\n *     to handle the event. The handler can also be an object that implements\r\n *     the handleEvent method which takes the event object as argument.\r\n * @param {boolean=} opt_capture In DOM-compliant browsers, this determines\r\n *     whether the listener is fired during the capture or bubble phase\r\n *     of the event.\r\n * @param {Object=} opt_handlerScope Object in whose scope to call\r\n *     the listener.\r\n * @deprecated Use `#unlisten` instead, when possible. Otherwise, use\r\n *     `goog.events.unlisten` if you are passing Object\r\n *     (instead of Function) as handler.\r\n */\r\ngoog.events.EventTarget.prototype.removeEventListener = function(\r\n    type, handler, opt_capture, opt_handlerScope) {\r\n  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.dispatchEvent = function(e) {\r\n  this.assertInitialized_();\r\n\r\n  var ancestorsTree, ancestor = this.getParentEventTarget();\r\n  if (ancestor) {\r\n    ancestorsTree = [];\r\n    var ancestorCount = 1;\r\n    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {\r\n      ancestorsTree.push(ancestor);\r\n      goog.asserts.assert(\r\n          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),\r\n          'infinite loop');\r\n    }\r\n  }\r\n\r\n  return goog.events.EventTarget.dispatchEventInternal_(\r\n      this.actualEventTarget_, e, ancestorsTree);\r\n};\r\n\r\n\r\n/**\r\n * Removes listeners from this object.  Classes that extend EventTarget may\r\n * need to override this method in order to remove references to DOM Elements\r\n * and additional listeners.\r\n * @override\r\n * @protected\r\n */\r\ngoog.events.EventTarget.prototype.disposeInternal = function() {\r\n  goog.events.EventTarget.superClass_.disposeInternal.call(this);\r\n\r\n  this.removeAllListeners();\r\n  this.parentEventTarget_ = null;\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.listen = function(\r\n    type, listener, opt_useCapture, opt_listenerScope) {\r\n  this.assertInitialized_();\r\n  return this.eventTargetListeners_.add(\r\n      String(type), listener, false /* callOnce */, opt_useCapture,\r\n      opt_listenerScope);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.listenOnce = function(\r\n    type, listener, opt_useCapture, opt_listenerScope) {\r\n  return this.eventTargetListeners_.add(\r\n      String(type), listener, true /* callOnce */, opt_useCapture,\r\n      opt_listenerScope);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.unlisten = function(\r\n    type, listener, opt_useCapture, opt_listenerScope) {\r\n  return this.eventTargetListeners_.remove(\r\n      String(type), listener, opt_useCapture, opt_listenerScope);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.unlistenByKey = function(key) {\r\n  return this.eventTargetListeners_.removeByKey(key);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {\r\n  // TODO(chrishenry): Previously, removeAllListeners can be called on\r\n  // uninitialized EventTarget, so we preserve that behavior. We\r\n  // should remove this when usages that rely on that fact are purged.\r\n  if (!this.eventTargetListeners_) {\r\n    return 0;\r\n  }\r\n  return this.eventTargetListeners_.removeAll(opt_type);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.fireListeners = function(\r\n    type, capture, eventObject) {\r\n  // TODO(chrishenry): Original code avoids array creation when there\r\n  // is no listener, so we do the same. If this optimization turns\r\n  // out to be not required, we can replace this with\r\n  // getListeners(type, capture) instead, which is simpler.\r\n  var listenerArray = this.eventTargetListeners_.listeners[String(type)];\r\n  if (!listenerArray) {\r\n    return true;\r\n  }\r\n  listenerArray = listenerArray.concat();\r\n\r\n  var rv = true;\r\n  for (var i = 0; i < listenerArray.length; ++i) {\r\n    var listener = listenerArray[i];\r\n    // We might not have a listener if the listener was removed.\r\n    if (listener && !listener.removed && listener.capture == capture) {\r\n      var listenerFn = listener.listener;\r\n      var listenerHandler = listener.handler || listener.src;\r\n\r\n      if (listener.callOnce) {\r\n        this.unlistenByKey(listener);\r\n      }\r\n      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;\r\n    }\r\n  }\r\n\r\n  return rv && eventObject.returnValue_ != false;\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.getListeners = function(type, capture) {\r\n  return this.eventTargetListeners_.getListeners(String(type), capture);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.getListener = function(\r\n    type, listener, capture, opt_listenerScope) {\r\n  return this.eventTargetListeners_.getListener(\r\n      String(type), listener, capture, opt_listenerScope);\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.events.EventTarget.prototype.hasListener = function(\r\n    opt_type, opt_capture) {\r\n  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;\r\n  return this.eventTargetListeners_.hasListener(id, opt_capture);\r\n};\r\n\r\n\r\n/**\r\n * Sets the target to be used for `event.target` when firing\r\n * event. Mainly used for testing. For example, see\r\n * `goog.testing.events.mixinListenable`.\r\n * @param {!Object} target The target.\r\n */\r\ngoog.events.EventTarget.prototype.setTargetForTesting = function(target) {\r\n  this.actualEventTarget_ = target;\r\n};\r\n\r\n\r\n/**\r\n * Asserts that the event target instance is initialized properly.\r\n * @private\r\n */\r\ngoog.events.EventTarget.prototype.assertInitialized_ = function() {\r\n  goog.asserts.assert(\r\n      this.eventTargetListeners_,\r\n      'Event target is not initialized. Did you call the superclass ' +\r\n          '(goog.events.EventTarget) constructor?');\r\n};\r\n\r\n\r\n/**\r\n * Dispatches the given event on the ancestorsTree.\r\n *\r\n * @param {!Object} target The target to dispatch on.\r\n * @param {goog.events.Event|Object|string} e The event object.\r\n * @param {Array<goog.events.Listenable>=} opt_ancestorsTree The ancestors\r\n *     tree of the target, in reverse order from the closest ancestor\r\n *     to the root event target. May be null if the target has no ancestor.\r\n * @return {boolean} If anyone called preventDefault on the event object (or\r\n *     if any of the listeners returns false) this will also return false.\r\n * @private\r\n */\r\ngoog.events.EventTarget.dispatchEventInternal_ = function(\r\n    target, e, opt_ancestorsTree) {\r\n  /** @suppress {missingProperties} */\r\n  var type = e.type || /** @type {string} */ (e);\r\n\r\n  // If accepting a string or object, create a custom event object so that\r\n  // preventDefault and stopPropagation work with the event.\r\n  if (goog.isString(e)) {\r\n    e = new goog.events.Event(e, target);\r\n  } else if (!(e instanceof goog.events.Event)) {\r\n    var oldEvent = e;\r\n    e = new goog.events.Event(type, target);\r\n    goog.object.extend(e, oldEvent);\r\n  } else {\r\n    e.target = e.target || target;\r\n  }\r\n\r\n  var rv = true, currentTarget;\r\n\r\n  // Executes all capture listeners on the ancestors, if any.\r\n  if (opt_ancestorsTree) {\r\n    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0;\r\n         i--) {\r\n      currentTarget = e.currentTarget = opt_ancestorsTree[i];\r\n      rv = currentTarget.fireListeners(type, true, e) && rv;\r\n    }\r\n  }\r\n\r\n  // Executes capture and bubble listeners on the target.\r\n  if (!e.propagationStopped_) {\r\n    currentTarget = /** @type {?} */ (e.currentTarget = target);\r\n    rv = currentTarget.fireListeners(type, true, e) && rv;\r\n    if (!e.propagationStopped_) {\r\n      rv = currentTarget.fireListeners(type, false, e) && rv;\r\n    }\r\n  }\r\n\r\n  // Executes all bubble listeners on the ancestors, if any.\r\n  if (opt_ancestorsTree) {\r\n    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {\r\n      currentTarget = e.currentTarget = opt_ancestorsTree[i];\r\n      rv = currentTarget.fireListeners(type, false, e) && rv;\r\n    }\r\n  }\r\n\r\n  return rv;\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview JSON utility functions.\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\n\r\ngoog.provide('goog.json');\r\ngoog.provide('goog.json.Replacer');\r\ngoog.provide('goog.json.Reviver');\r\ngoog.provide('goog.json.Serializer');\r\n\r\n\r\n/**\r\n * @define {boolean} If true, use the native JSON parsing API.\r\n * NOTE: The default `goog.json.parse` implementation is able to handle\r\n * invalid JSON. JSPB used to produce invalid JSON which is not the case\r\n * anymore so this is safe to enable for parsing JSPB. Using native JSON is\r\n * faster and safer than the default implementation using `eval`.\r\n */\r\ngoog.json.USE_NATIVE_JSON = goog.define('goog.json.USE_NATIVE_JSON', false);\r\n\r\n/**\r\n * @define {boolean} If true, try the native JSON parsing API first. If it\r\n * fails, log an error and use `eval` instead. This is useful when\r\n * transitioning to `goog.json.USE_NATIVE_JSON`. The error logger needs to\r\n * be set by `goog.json.setErrorLogger`. If it is not set then the error\r\n * is ignored.\r\n */\r\ngoog.json.TRY_NATIVE_JSON = goog.define('goog.json.TRY_NATIVE_JSON', false);\r\n\r\n\r\n/**\r\n * Tests if a string is an invalid JSON string. This only ensures that we are\r\n * not using any invalid characters\r\n * @param {string} s The string to test.\r\n * @return {boolean} True if the input is a valid JSON string.\r\n */\r\ngoog.json.isValid = function(s) {\r\n  // All empty whitespace is not valid.\r\n  if (/^\\s*$/.test(s)) {\r\n    return false;\r\n  }\r\n\r\n  // This is taken from http://www.json.org/json2.js which is released to the\r\n  // public domain.\r\n  // Changes: We dissallow \\u2028 Line separator and \\u2029 Paragraph separator\r\n  // inside strings.  We also treat \\u2028 and \\u2029 as whitespace which they\r\n  // are in the RFC but IE and Safari does not match \\s to these so we need to\r\n  // include them in the reg exps in all places where whitespace is allowed.\r\n  // We allowed \\x7f inside strings because some tools don't escape it,\r\n  // e.g. http://www.json.org/java/org/json/JSONObject.java\r\n\r\n  // Parsing happens in three stages. In the first stage, we run the text\r\n  // against regular expressions that look for non-JSON patterns. We are\r\n  // especially concerned with '()' and 'new' because they can cause invocation,\r\n  // and '=' because it can cause mutation. But just to be safe, we want to\r\n  // reject all unexpected forms.\r\n\r\n  // We split the first stage into 4 regexp operations in order to work around\r\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\r\n  // replace all backslash pairs with '@' (a non-JSON character). Second, we\r\n  // replace all simple value tokens with ']' characters, but only when followed\r\n  // by a colon, comma, closing bracket or end of string. Third, we delete all\r\n  // open brackets that follow a colon or comma or that begin the text. Finally,\r\n  // we look to see that the remaining characters are only whitespace or ']' or\r\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\r\n\r\n  // Don't make these static since they have the global flag.\r\n  var backslashesRe = /\\\\[\"\\\\\\/bfnrtu]/g;\r\n  var simpleValuesRe =\r\n      /(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g;\r\n  var openBracketsRe = /(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g;\r\n  var remainderRe = /^[\\],:{}\\s\\u2028\\u2029]*$/;\r\n\r\n  return remainderRe.test(\r\n      s.replace(backslashesRe, '@')\r\n          .replace(simpleValuesRe, ']')\r\n          .replace(openBracketsRe, ''));\r\n};\r\n\r\n/**\r\n * Logs a parsing error in `JSON.parse` solvable by using `eval`\r\n * if `goog.json.TRY_NATIVE_JSON` is enabled.\r\n * @private {function(string, !Error)} The first parameter is the error message,\r\n *     the second is the exception thrown by `JSON.parse`.\r\n */\r\ngoog.json.errorLogger_ = goog.nullFunction;\r\n\r\n\r\n/**\r\n * Sets an error logger to use if there's a recoverable parsing error and\r\n * `goog.json.TRY_NATIVE_JSON` is enabled.\r\n * @param {function(string, !Error)} errorLogger The first parameter is the\r\n *     error message, the second is the exception thrown by `JSON.parse`.\r\n */\r\ngoog.json.setErrorLogger = function(errorLogger) {\r\n  goog.json.errorLogger_ = errorLogger;\r\n};\r\n\r\n\r\n/**\r\n * Parses a JSON string and returns the result. This throws an exception if\r\n * the string is an invalid JSON string.\r\n *\r\n * Note that this is very slow on large strings. Use JSON.parse if possible.\r\n *\r\n * @param {*} s The JSON string to parse.\r\n * @throws Error if s is invalid JSON.\r\n * @return {Object} The object generated from the JSON string, or null.\r\n * @deprecated Use JSON.parse.\r\n */\r\ngoog.json.parse = goog.json.USE_NATIVE_JSON ?\r\n    /** @type {function(*):Object} */ (goog.global['JSON']['parse']) :\r\n    function(s) {\r\n      var error;\r\n      if (goog.json.TRY_NATIVE_JSON) {\r\n        try {\r\n          return goog.global['JSON']['parse'](s);\r\n        } catch (ex) {\r\n          error = ex;\r\n        }\r\n      }\r\n      var o = String(s);\r\n      if (goog.json.isValid(o)) {\r\n\r\n        try {\r\n          var result = /** @type {?Object} */ (eval('(' + o + ')'));\r\n          if (error) {\r\n            goog.json.errorLogger_('Invalid JSON: ' + o, error);\r\n          }\r\n          return result;\r\n        } catch (ex) {\r\n        }\r\n      }\r\n      throw new Error('Invalid JSON string: ' + o);\r\n    };\r\n\r\n\r\n/**\r\n * JSON replacer, as defined in Section 15.12.3 of the ES5 spec.\r\n * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3\r\n *\r\n * TODO(nicksantos): Array should also be a valid replacer.\r\n *\r\n * @typedef {function(this:Object, string, *): *}\r\n */\r\ngoog.json.Replacer;\r\n\r\n\r\n/**\r\n * JSON reviver, as defined in Section 15.12.2 of the ES5 spec.\r\n * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3\r\n *\r\n * @typedef {function(this:Object, string, *): *}\r\n */\r\ngoog.json.Reviver;\r\n\r\n\r\n/**\r\n * Serializes an object or a value to a JSON string.\r\n *\r\n * @param {*} object The object to serialize.\r\n * @param {?goog.json.Replacer=} opt_replacer A replacer function\r\n *     called for each (key, value) pair that determines how the value\r\n *     should be serialized. By defult, this just returns the value\r\n *     and allows default serialization to kick in.\r\n * @throws Error if there are loops in the object graph.\r\n * @return {string} A JSON string representation of the input.\r\n */\r\ngoog.json.serialize = goog.json.USE_NATIVE_JSON ?\r\n    /** @type {function(*, ?goog.json.Replacer=):string} */\r\n    (goog.global['JSON']['stringify']) :\r\n    function(object, opt_replacer) {\r\n      // NOTE(nicksantos): Currently, we never use JSON.stringify.\r\n      //\r\n      // The last time I evaluated this, JSON.stringify had subtle bugs and\r\n      // behavior differences on all browsers, and the performance win was not\r\n      // large enough to justify all the issues. This may change in the future\r\n      // as browser implementations get better.\r\n      //\r\n      // assertSerialize in json_test contains if branches for the cases\r\n      // that fail.\r\n      return new goog.json.Serializer(opt_replacer).serialize(object);\r\n    };\r\n\r\n\r\n\r\n/**\r\n * Class that is used to serialize JSON objects to a string.\r\n * @param {?goog.json.Replacer=} opt_replacer Replacer.\r\n * @constructor\r\n */\r\ngoog.json.Serializer = function(opt_replacer) {\r\n  /**\r\n   * @type {goog.json.Replacer|null|undefined}\r\n   * @private\r\n   */\r\n  this.replacer_ = opt_replacer;\r\n};\r\n\r\n\r\n/**\r\n * Serializes an object or a value to a JSON string.\r\n *\r\n * @param {*} object The object to serialize.\r\n * @throws Error if there are loops in the object graph.\r\n * @return {string} A JSON string representation of the input.\r\n */\r\ngoog.json.Serializer.prototype.serialize = function(object) {\r\n  var sb = [];\r\n  this.serializeInternal(object, sb);\r\n  return sb.join('');\r\n};\r\n\r\n\r\n/**\r\n * Serializes a generic value to a JSON string\r\n * @protected\r\n * @param {*} object The object to serialize.\r\n * @param {Array<string>} sb Array used as a string builder.\r\n * @throws Error if there are loops in the object graph.\r\n */\r\ngoog.json.Serializer.prototype.serializeInternal = function(object, sb) {\r\n  if (object == null) {\r\n    // undefined == null so this branch covers undefined as well as null\r\n    sb.push('null');\r\n    return;\r\n  }\r\n\r\n  if (typeof object == 'object') {\r\n    if (goog.isArray(object)) {\r\n      this.serializeArray(object, sb);\r\n      return;\r\n    } else if (\r\n        object instanceof String || object instanceof Number ||\r\n        object instanceof Boolean) {\r\n      object = object.valueOf();\r\n      // Fall through to switch below.\r\n    } else {\r\n      this.serializeObject_(/** @type {!Object} */ (object), sb);\r\n      return;\r\n    }\r\n  }\r\n\r\n  switch (typeof object) {\r\n    case 'string':\r\n      this.serializeString_(object, sb);\r\n      break;\r\n    case 'number':\r\n      this.serializeNumber_(object, sb);\r\n      break;\r\n    case 'boolean':\r\n      sb.push(String(object));\r\n      break;\r\n    case 'function':\r\n      sb.push('null');\r\n      break;\r\n    default:\r\n      throw new Error('Unknown type: ' + typeof object);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Character mappings used internally for goog.string.quote\r\n * @private\r\n * @type {!Object}\r\n */\r\ngoog.json.Serializer.charToJsonCharCache_ = {\r\n  '\\\"': '\\\\\"',\r\n  '\\\\': '\\\\\\\\',\r\n  '/': '\\\\/',\r\n  '\\b': '\\\\b',\r\n  '\\f': '\\\\f',\r\n  '\\n': '\\\\n',\r\n  '\\r': '\\\\r',\r\n  '\\t': '\\\\t',\r\n\r\n  '\\x0B': '\\\\u000b'  // '\\v' is not supported in JScript\r\n};\r\n\r\n\r\n/**\r\n * Regular expression used to match characters that need to be replaced.\r\n * The S60 browser has a bug where unicode characters are not matched by\r\n * regular expressions. The condition below detects such behaviour and\r\n * adjusts the regular expression accordingly.\r\n * @private\r\n * @type {!RegExp}\r\n */\r\ngoog.json.Serializer.charsToReplace_ = /\\uffff/.test('\\uffff') ?\r\n    /[\\\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g :\r\n    /[\\\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\r\n\r\n\r\n/**\r\n * Serializes a string to a JSON string\r\n * @private\r\n * @param {string} s The string to serialize.\r\n * @param {Array<string>} sb Array used as a string builder.\r\n */\r\ngoog.json.Serializer.prototype.serializeString_ = function(s, sb) {\r\n  // The official JSON implementation does not work with international\r\n  // characters.\r\n  sb.push('\"', s.replace(goog.json.Serializer.charsToReplace_, function(c) {\r\n    // caching the result improves performance by a factor 2-3\r\n    var rv = goog.json.Serializer.charToJsonCharCache_[c];\r\n    if (!rv) {\r\n      rv = '\\\\u' + (c.charCodeAt(0) | 0x10000).toString(16).substr(1);\r\n      goog.json.Serializer.charToJsonCharCache_[c] = rv;\r\n    }\r\n    return rv;\r\n  }), '\"');\r\n};\r\n\r\n\r\n/**\r\n * Serializes a number to a JSON string\r\n * @private\r\n * @param {number} n The number to serialize.\r\n * @param {Array<string>} sb Array used as a string builder.\r\n */\r\ngoog.json.Serializer.prototype.serializeNumber_ = function(n, sb) {\r\n  sb.push(isFinite(n) && !isNaN(n) ? String(n) : 'null');\r\n};\r\n\r\n\r\n/**\r\n * Serializes an array to a JSON string\r\n * @param {Array<string>} arr The array to serialize.\r\n * @param {Array<string>} sb Array used as a string builder.\r\n * @protected\r\n */\r\ngoog.json.Serializer.prototype.serializeArray = function(arr, sb) {\r\n  var l = arr.length;\r\n  sb.push('[');\r\n  var sep = '';\r\n  for (var i = 0; i < l; i++) {\r\n    sb.push(sep);\r\n\r\n    var value = arr[i];\r\n    this.serializeInternal(\r\n        this.replacer_ ? this.replacer_.call(arr, String(i), value) : value,\r\n        sb);\r\n\r\n    sep = ',';\r\n  }\r\n  sb.push(']');\r\n};\r\n\r\n\r\n/**\r\n * Serializes an object to a JSON string\r\n * @private\r\n * @param {!Object} obj The object to serialize.\r\n * @param {Array<string>} sb Array used as a string builder.\r\n */\r\ngoog.json.Serializer.prototype.serializeObject_ = function(obj, sb) {\r\n  sb.push('{');\r\n  var sep = '';\r\n  for (var key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      var value = obj[key];\r\n      // Skip functions.\r\n      if (typeof value != 'function') {\r\n        sb.push(sep);\r\n        this.serializeString_(key, sb);\r\n        sb.push(':');\r\n\r\n        this.serializeInternal(\r\n            this.replacer_ ? this.replacer_.call(obj, key, value) : value, sb);\r\n\r\n        sep = ',';\r\n      }\r\n    }\r\n  }\r\n  sb.push('}');\r\n};\r\n","// Copyright 2015 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Simple freelist.\r\n *\r\n * An anterative to goog.structs.SimplePool, it imposes the requirement that the\r\n * objects in the list contain a \"next\" property that can be used to maintain\r\n * the pool.\r\n */\r\n\r\ngoog.provide('goog.async.FreeList');\r\n\r\n\r\n/**\r\n * @template ITEM\r\n */\r\ngoog.async.FreeList = goog.defineClass(null, {\r\n  /**\r\n   * @param {function():ITEM} create\r\n   * @param {function(ITEM):void} reset\r\n   * @param {number} limit\r\n   */\r\n  constructor: function(create, reset, limit) {\r\n    /** @private @const {number} */\r\n    this.limit_ = limit;\r\n    /** @private @const {function()} */\r\n    this.create_ = create;\r\n    /** @private @const {function(ITEM):void} */\r\n    this.reset_ = reset;\r\n\r\n    /** @private {number} */\r\n    this.occupants_ = 0;\r\n    /** @private {ITEM} */\r\n    this.head_ = null;\r\n  },\r\n\r\n  /**\r\n   * @return {ITEM}\r\n   */\r\n  get: function() {\r\n    var item;\r\n    if (this.occupants_ > 0) {\r\n      this.occupants_--;\r\n      item = this.head_;\r\n      this.head_ = item.next;\r\n      item.next = null;\r\n    } else {\r\n      item = this.create_();\r\n    }\r\n    return item;\r\n  },\r\n\r\n  /**\r\n   * @param {ITEM} item An item available for possible future reuse.\r\n   */\r\n  put: function(item) {\r\n    this.reset_(item);\r\n    if (this.occupants_ < this.limit_) {\r\n      this.occupants_++;\r\n      item.next = this.head_;\r\n      this.head_ = item;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Visible for testing.\r\n   * @package\r\n   * @return {number}\r\n   */\r\n  occupants: function() { return this.occupants_; }\r\n});\r\n","// Copyright 2015 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\ngoog.provide('goog.async.WorkItem');\r\ngoog.provide('goog.async.WorkQueue');\r\n\r\ngoog.require('goog.asserts');\r\ngoog.require('goog.async.FreeList');\r\n\r\n\r\n// TODO(johnlenz): generalize the WorkQueue if this is used by more\r\n// than goog.async.run.\r\n\r\n\r\n\r\n/**\r\n * A low GC workqueue. The key elements of this design:\r\n *   - avoids the need for goog.bind or equivalent by carrying scope\r\n *   - avoids the need for array reallocation by using a linked list\r\n *   - minimizes work entry objects allocation by recycling objects\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\ngoog.async.WorkQueue = function() {\r\n  this.workHead_ = null;\r\n  this.workTail_ = null;\r\n};\r\n\r\n\r\n/** @define {number} The maximum number of entries to keep for recycling. */\r\ngoog.async.WorkQueue.DEFAULT_MAX_UNUSED =\r\n    goog.define('goog.async.WorkQueue.DEFAULT_MAX_UNUSED', 100);\r\n\r\n\r\n/** @const @private {goog.async.FreeList<goog.async.WorkItem>} */\r\ngoog.async.WorkQueue.freelist_ = new goog.async.FreeList(\r\n    function() { return new goog.async.WorkItem(); },\r\n    function(item) { item.reset(); }, goog.async.WorkQueue.DEFAULT_MAX_UNUSED);\r\n\r\n\r\n/**\r\n * @param {function()} fn\r\n * @param {Object|null|undefined} scope\r\n */\r\ngoog.async.WorkQueue.prototype.add = function(fn, scope) {\r\n  var item = this.getUnusedItem_();\r\n  item.set(fn, scope);\r\n\r\n  if (this.workTail_) {\r\n    this.workTail_.next = item;\r\n    this.workTail_ = item;\r\n  } else {\r\n    goog.asserts.assert(!this.workHead_);\r\n    this.workHead_ = item;\r\n    this.workTail_ = item;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @return {goog.async.WorkItem}\r\n */\r\ngoog.async.WorkQueue.prototype.remove = function() {\r\n  var item = null;\r\n\r\n  if (this.workHead_) {\r\n    item = this.workHead_;\r\n    this.workHead_ = this.workHead_.next;\r\n    if (!this.workHead_) {\r\n      this.workTail_ = null;\r\n    }\r\n    item.next = null;\r\n  }\r\n  return item;\r\n};\r\n\r\n\r\n/**\r\n * @param {goog.async.WorkItem} item\r\n */\r\ngoog.async.WorkQueue.prototype.returnUnused = function(item) {\r\n  goog.async.WorkQueue.freelist_.put(item);\r\n};\r\n\r\n\r\n/**\r\n * @return {goog.async.WorkItem}\r\n * @private\r\n */\r\ngoog.async.WorkQueue.prototype.getUnusedItem_ = function() {\r\n  return goog.async.WorkQueue.freelist_.get();\r\n};\r\n\r\n\r\n\r\n/**\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\ngoog.async.WorkItem = function() {\r\n  /** @type {?function()} */\r\n  this.fn = null;\r\n  /** @type {?Object|null|undefined} */\r\n  this.scope = null;\r\n  /** @type {?goog.async.WorkItem} */\r\n  this.next = null;\r\n};\r\n\r\n\r\n/**\r\n * @param {function()} fn\r\n * @param {Object|null|undefined} scope\r\n */\r\ngoog.async.WorkItem.prototype.set = function(fn, scope) {\r\n  this.fn = fn;\r\n  this.scope = scope;\r\n  this.next = null;\r\n};\r\n\r\n\r\n/** Reset the work item so they don't prevent GC before reuse */\r\ngoog.async.WorkItem.prototype.reset = function() {\r\n  this.fn = null;\r\n  this.scope = null;\r\n  this.next = null;\r\n};\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\ngoog.provide('goog.async.run');\r\n\r\ngoog.require('goog.async.WorkQueue');\r\ngoog.require('goog.async.nextTick');\r\ngoog.require('goog.async.throwException');\r\n\r\n/**\r\n * @define {boolean} If true, use the global Promise to implement goog.async.run\r\n * assuming either the native, or polyfill version will be used. Does still\r\n * permit tests to use forceNextTick.\r\n */\r\ngoog.ASSUME_NATIVE_PROMISE = goog.define('goog.ASSUME_NATIVE_PROMISE', false);\r\n\r\n/**\r\n * Fires the provided callback just before the current callstack unwinds, or as\r\n * soon as possible after the current JS execution context.\r\n * @param {function(this:THIS)} callback\r\n * @param {THIS=} opt_context Object to use as the \"this value\" when calling\r\n *     the provided function.\r\n * @template THIS\r\n */\r\ngoog.async.run = function(callback, opt_context) {\r\n  if (!goog.async.run.schedule_) {\r\n    goog.async.run.initializeRunner_();\r\n  }\r\n  if (!goog.async.run.workQueueScheduled_) {\r\n    // Nothing is currently scheduled, schedule it now.\r\n    goog.async.run.schedule_();\r\n    goog.async.run.workQueueScheduled_ = true;\r\n  }\r\n\r\n  goog.async.run.workQueue_.add(callback, opt_context);\r\n};\r\n\r\n\r\n/**\r\n * Initializes the function to use to process the work queue.\r\n * @private\r\n */\r\ngoog.async.run.initializeRunner_ = function() {\r\n  if (goog.ASSUME_NATIVE_PROMISE ||\r\n      (goog.global.Promise && goog.global.Promise.resolve)) {\r\n    // Use goog.global.Promise instead of just Promise because the relevant\r\n    // externs may be missing, and don't alias it because this could confuse the\r\n    // compiler into thinking the polyfill is required when it should be treated\r\n    // as optional.\r\n    var promise = goog.global.Promise.resolve(undefined);\r\n    goog.async.run.schedule_ = function() {\r\n      promise.then(goog.async.run.processWorkQueue);\r\n    };\r\n  } else {\r\n    goog.async.run.schedule_ = function() {\r\n      goog.async.nextTick(goog.async.run.processWorkQueue);\r\n    };\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Forces goog.async.run to use nextTick instead of Promise.\r\n *\r\n * This should only be done in unit tests. It's useful because MockClock\r\n * replaces nextTick, but not the browser Promise implementation, so it allows\r\n * Promise-based code to be tested with MockClock.\r\n *\r\n * However, we also want to run promises if the MockClock is no longer in\r\n * control so we schedule a backup \"setTimeout\" to the unmocked timeout if\r\n * provided.\r\n *\r\n * @param {function(function())=} opt_realSetTimeout\r\n */\r\ngoog.async.run.forceNextTick = function(opt_realSetTimeout) {\r\n  goog.async.run.schedule_ = function() {\r\n    goog.async.nextTick(goog.async.run.processWorkQueue);\r\n    if (opt_realSetTimeout) {\r\n      opt_realSetTimeout(goog.async.run.processWorkQueue);\r\n    }\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * The function used to schedule work asynchronousely.\r\n * @private {function()}\r\n */\r\ngoog.async.run.schedule_;\r\n\r\n\r\n/** @private {boolean} */\r\ngoog.async.run.workQueueScheduled_ = false;\r\n\r\n\r\n/** @private {!goog.async.WorkQueue} */\r\ngoog.async.run.workQueue_ = new goog.async.WorkQueue();\r\n\r\n\r\nif (goog.DEBUG) {\r\n  /**\r\n   * Reset the work queue. Only available for tests in debug mode.\r\n   */\r\n  goog.async.run.resetQueue = function() {\r\n    goog.async.run.workQueueScheduled_ = false;\r\n    goog.async.run.workQueue_ = new goog.async.WorkQueue();\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Run any pending goog.async.run work items. This function is not intended\r\n * for general use, but for use by entry point handlers to run items ahead of\r\n * goog.async.nextTick.\r\n */\r\ngoog.async.run.processWorkQueue = function() {\r\n  // NOTE: additional work queue items may be added while processing.\r\n  var item = null;\r\n  while (item = goog.async.run.workQueue_.remove()) {\r\n    try {\r\n      item.fn.call(item.scope);\r\n    } catch (e) {\r\n      goog.async.throwException(e);\r\n    }\r\n    goog.async.run.workQueue_.returnUnused(item);\r\n  }\r\n\r\n  // There are no more work items, allow processing to be scheduled again.\r\n  goog.async.run.workQueueScheduled_ = false;\r\n};\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Provides a function to schedule running a function as soon\r\n * as possible after the current JS execution stops and yields to the event\r\n * loop.\r\n *\r\n */\r\n\r\ngoog.provide('goog.async.nextTick');\r\ngoog.provide('goog.async.throwException');\r\n\r\ngoog.require('goog.debug.entryPointRegistry');\r\ngoog.require('goog.dom.TagName');\r\ngoog.require('goog.functions');\r\ngoog.require('goog.labs.userAgent.browser');\r\ngoog.require('goog.labs.userAgent.engine');\r\n\r\n\r\n/**\r\n * Throw an item without interrupting the current execution context.  For\r\n * example, if processing a group of items in a loop, sometimes it is useful\r\n * to report an error while still allowing the rest of the batch to be\r\n * processed.\r\n * @param {*} exception\r\n */\r\ngoog.async.throwException = function(exception) {\r\n  // Each throw needs to be in its own context.\r\n  goog.global.setTimeout(function() { throw exception; }, 0);\r\n};\r\n\r\n\r\n/**\r\n * Fires the provided callbacks as soon as possible after the current JS\r\n * execution context. setTimeout(, 0) takes at least 4ms when called from\r\n * within another setTimeout(, 0) for legacy reasons.\r\n *\r\n * This will not schedule the callback as a microtask (i.e. a task that can\r\n * preempt user input or networking callbacks). It is meant to emulate what\r\n * setTimeout(_, 0) would do if it were not throttled. If you desire microtask\r\n * behavior, use {@see goog.Promise} instead.\r\n *\r\n * @param {function(this:SCOPE)} callback Callback function to fire as soon as\r\n *     possible.\r\n * @param {SCOPE=} opt_context Object in whose scope to call the listener.\r\n * @param {boolean=} opt_useSetImmediate Avoid the IE workaround that\r\n *     ensures correctness at the cost of speed. See comments for details.\r\n * @template SCOPE\r\n */\r\ngoog.async.nextTick = function(callback, opt_context, opt_useSetImmediate) {\r\n  var cb = callback;\r\n  if (opt_context) {\r\n    cb = goog.bind(callback, opt_context);\r\n  }\r\n  cb = goog.async.nextTick.wrapCallback_(cb);\r\n  // Note we do allow callers to also request setImmediate if they are willing\r\n  // to accept the possible tradeoffs of incorrectness in exchange for speed.\r\n  // The IE fallback of readystate change is much slower. See useSetImmediate_\r\n  // for details.\r\n  if (goog.isFunction(goog.global.setImmediate) &&\r\n      (opt_useSetImmediate || goog.async.nextTick.useSetImmediate_())) {\r\n    goog.global.setImmediate(cb);\r\n    return;\r\n  }\r\n\r\n  // Look for and cache the custom fallback version of setImmediate.\r\n  if (!goog.async.nextTick.setImmediate_) {\r\n    goog.async.nextTick.setImmediate_ =\r\n        goog.async.nextTick.getSetImmediateEmulator_();\r\n  }\r\n  goog.async.nextTick.setImmediate_(cb);\r\n};\r\n\r\n\r\n/**\r\n * Returns whether should use setImmediate implementation currently on window.\r\n *\r\n * window.setImmediate was introduced and currently only supported by IE10+,\r\n * but due to a bug in the implementation it is not guaranteed that\r\n * setImmediate is faster than setTimeout nor that setImmediate N is before\r\n * setImmediate N+1. That is why we do not use the native version if\r\n * available. We do, however, call setImmediate if it is a non-native function\r\n * because that indicates that it has been replaced by goog.testing.MockClock\r\n * which we do want to support.\r\n * See\r\n * http://connect.microsoft.com/IE/feedback/details/801823/setimmediate-and-messagechannel-are-broken-in-ie10\r\n *\r\n * @return {boolean} Whether to use the implementation of setImmediate defined\r\n *     on Window.\r\n * @private\r\n * @suppress {missingProperties} For \"Window.prototype.setImmediate\"\r\n */\r\ngoog.async.nextTick.useSetImmediate_ = function() {\r\n  // Not a browser environment.\r\n  if (!goog.global.Window || !goog.global.Window.prototype) {\r\n    return true;\r\n  }\r\n\r\n  // MS Edge has window.setImmediate natively, but it's not on Window.prototype.\r\n  // Also, there's no clean way to detect if the goog.global.setImmediate has\r\n  // been replaced by mockClock as its replacement also shows up as \"[native\r\n  // code]\" when using toString. Therefore, just always use\r\n  // goog.global.setImmediate for Edge. It's unclear if it suffers the same\r\n  // issues as IE10/11, but based on\r\n  // https://dev.modern.ie/testdrive/demos/setimmediatesorting/\r\n  // it seems they've been working to ensure it's WAI.\r\n  if (goog.labs.userAgent.browser.isEdge() ||\r\n      goog.global.Window.prototype.setImmediate != goog.global.setImmediate) {\r\n    // Something redefined setImmediate in which case we decide to use it (This\r\n    // is so that we use the mockClock setImmediate).\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Cache for the setImmediate implementation.\r\n * @type {function(function())}\r\n * @private\r\n */\r\ngoog.async.nextTick.setImmediate_;\r\n\r\n\r\n/**\r\n * Determines the best possible implementation to run a function as soon as\r\n * the JS event loop is idle.\r\n * @return {function(function())} The \"setImmediate\" implementation.\r\n * @private\r\n */\r\ngoog.async.nextTick.getSetImmediateEmulator_ = function() {\r\n  // Create a private message channel and use it to postMessage empty messages\r\n  // to ourselves.\r\n  /** @type {!Function|undefined} */\r\n  var Channel = goog.global['MessageChannel'];\r\n  // If MessageChannel is not available and we are in a browser, implement\r\n  // an iframe based polyfill in browsers that have postMessage and\r\n  // document.addEventListener. The latter excludes IE8 because it has a\r\n  // synchronous postMessage implementation.\r\n  if (typeof Channel === 'undefined' && typeof window !== 'undefined' &&\r\n      window.postMessage && window.addEventListener &&\r\n      // Presto (The old pre-blink Opera engine) has problems with iframes\r\n      // and contentWindow.\r\n      !goog.labs.userAgent.engine.isPresto()) {\r\n    /** @constructor */\r\n    Channel = function() {\r\n      // Make an empty, invisible iframe.\r\n      var iframe = /** @type {!HTMLIFrameElement} */ (\r\n          document.createElement(String(goog.dom.TagName.IFRAME)));\r\n      iframe.style.display = 'none';\r\n      iframe.src = '';\r\n      document.documentElement.appendChild(iframe);\r\n      var win = iframe.contentWindow;\r\n      var doc = win.document;\r\n      doc.open();\r\n      doc.write('');\r\n      doc.close();\r\n      // Do not post anything sensitive over this channel, as the workaround for\r\n      // pages with file: origin could allow that information to be modified or\r\n      // intercepted.\r\n      var message = 'callImmediate' + Math.random();\r\n      // The same origin policy rejects attempts to postMessage from file: urls\r\n      // unless the origin is '*'.\r\n      var origin = win.location.protocol == 'file:' ?\r\n          '*' :\r\n          win.location.protocol + '//' + win.location.host;\r\n      var onmessage = goog.bind(function(e) {\r\n        // Validate origin and message to make sure that this message was\r\n        // intended for us. If the origin is set to '*' (see above) only the\r\n        // message needs to match since, for example, '*' != 'file://'. Allowing\r\n        // the wildcard is ok, as we are not concerned with security here.\r\n        if ((origin != '*' && e.origin != origin) || e.data != message) {\r\n          return;\r\n        }\r\n        this['port1'].onmessage();\r\n      }, this);\r\n      win.addEventListener('message', onmessage, false);\r\n      this['port1'] = {};\r\n      this['port2'] = {\r\n        postMessage: function() { win.postMessage(message, origin); }\r\n      };\r\n    };\r\n  }\r\n  if (typeof Channel !== 'undefined' && !goog.labs.userAgent.browser.isIE()) {\r\n    // Exclude all of IE due to\r\n    // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/\r\n    // which allows starving postMessage with a busy setTimeout loop.\r\n    // This currently affects IE10 and IE11 which would otherwise be able\r\n    // to use the postMessage based fallbacks.\r\n    var channel = new Channel();\r\n    // Use a fifo linked list to call callbacks in the right order.\r\n    var head = {};\r\n    var tail = head;\r\n    channel['port1'].onmessage = function() {\r\n      if (goog.isDef(head.next)) {\r\n        head = head.next;\r\n        var cb = head.cb;\r\n        head.cb = null;\r\n        cb();\r\n      }\r\n    };\r\n    return function(cb) {\r\n      tail.next = {cb: cb};\r\n      tail = tail.next;\r\n      channel['port2'].postMessage(0);\r\n    };\r\n  }\r\n  // Implementation for IE6 to IE10: Script elements fire an asynchronous\r\n  // onreadystatechange event when inserted into the DOM.\r\n  if (typeof document !== 'undefined' &&\r\n      'onreadystatechange' in\r\n          document.createElement(String(goog.dom.TagName.SCRIPT))) {\r\n    return function(cb) {\r\n      var script = /** @type {!HTMLScriptElement} */ (\r\n          document.createElement(String(goog.dom.TagName.SCRIPT)));\r\n      script.onreadystatechange = function() {\r\n        // Clean up and call the callback.\r\n        script.onreadystatechange = null;\r\n        script.parentNode.removeChild(script);\r\n        script = null;\r\n        cb();\r\n        cb = null;\r\n      };\r\n      document.documentElement.appendChild(script);\r\n    };\r\n  }\r\n  // Fall back to setTimeout with 0. In browsers this creates a delay of 5ms\r\n  // or more.\r\n  // NOTE(user): This fallback is used for IE11.\r\n  return function(cb) {\r\n    goog.global.setTimeout(/** @type {function()} */ (cb), 0);\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Helper function that is overrided to protect callbacks with entry point\r\n * monitor if the application monitors entry points.\r\n * @param {function()} callback Callback function to fire as soon as possible.\r\n * @return {function()} The wrapped callback.\r\n * @private\r\n */\r\ngoog.async.nextTick.wrapCallback_ = goog.functions.identity;\r\n\r\n\r\n// Register the callback function as an entry point, so that it can be\r\n// monitored for exception handling, etc. This has to be done in this file\r\n// since it requires special code to handle all browsers.\r\ngoog.debug.entryPointRegistry.register(\r\n    /**\r\n     * @param {function(!Function): !Function} transformer The transforming\r\n     *     function.\r\n     */\r\n    function(transformer) { goog.async.nextTick.wrapCallback_ = transformer; });\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A timer class to which other classes and objects can listen on.\r\n * This is only an abstraction above `setInterval`.\r\n *\r\n * @see ../demos/timers.html\r\n */\r\n\r\ngoog.provide('goog.Timer');\r\n\r\ngoog.require('goog.Promise');\r\ngoog.require('goog.events.EventTarget');\r\n\r\n\r\n\r\n/**\r\n * Class for handling timing events.\r\n *\r\n * @param {number=} opt_interval Number of ms between ticks (default: 1ms).\r\n * @param {Object=} opt_timerObject  An object that has `setTimeout`,\r\n *     `setInterval`, `clearTimeout` and `clearInterval`\r\n *     (e.g., `window`).\r\n * @constructor\r\n * @extends {goog.events.EventTarget}\r\n */\r\ngoog.Timer = function(opt_interval, opt_timerObject) {\r\n  goog.events.EventTarget.call(this);\r\n\r\n  /**\r\n   * Number of ms between ticks\r\n   * @private {number}\r\n   */\r\n  this.interval_ = opt_interval || 1;\r\n\r\n  /**\r\n   * An object that implements `setTimeout`, `setInterval`,\r\n   * `clearTimeout` and `clearInterval`. We default to the window\r\n   * object. Changing this on {@link goog.Timer.prototype} changes the object\r\n   * for all timer instances which can be useful if your environment has some\r\n   * other implementation of timers than the `window` object.\r\n   * @private {{setTimeout:!Function, clearTimeout:!Function}}\r\n   */\r\n  this.timerObject_ = /** @type {{setTimeout, clearTimeout}} */ (\r\n      opt_timerObject || goog.Timer.defaultTimerObject);\r\n\r\n  /**\r\n   * Cached `tick_` bound to the object for later use in the timer.\r\n   * @private {Function}\r\n   * @const\r\n   */\r\n  this.boundTick_ = goog.bind(this.tick_, this);\r\n\r\n  /**\r\n   * Firefox browser often fires the timer event sooner (sometimes MUCH sooner)\r\n   * than the requested timeout. So we compare the time to when the event was\r\n   * last fired, and reschedule if appropriate. See also\r\n   * {@link goog.Timer.intervalScale}.\r\n   * @private {number}\r\n   */\r\n  this.last_ = goog.now();\r\n};\r\ngoog.inherits(goog.Timer, goog.events.EventTarget);\r\n\r\n\r\n/**\r\n * Maximum timeout value.\r\n *\r\n * Timeout values too big to fit into a signed 32-bit integer may cause overflow\r\n * in FF, Safari, and Chrome, resulting in the timeout being scheduled\r\n * immediately. It makes more sense simply not to schedule these timeouts, since\r\n * 24.8 days is beyond a reasonable expectation for the browser to stay open.\r\n *\r\n * @private {number}\r\n * @const\r\n */\r\ngoog.Timer.MAX_TIMEOUT_ = 2147483647;\r\n\r\n\r\n/**\r\n * A timer ID that cannot be returned by any known implementation of\r\n * `window.setTimeout`. Passing this value to `window.clearTimeout`\r\n * should therefore be a no-op.\r\n *\r\n * @private {number}\r\n * @const\r\n */\r\ngoog.Timer.INVALID_TIMEOUT_ID_ = -1;\r\n\r\n\r\n/**\r\n * Whether this timer is enabled\r\n * @type {boolean}\r\n */\r\ngoog.Timer.prototype.enabled = false;\r\n\r\n\r\n/**\r\n * An object that implements `setTimeout`, `setInterval`,\r\n * `clearTimeout` and `clearInterval`. We default to the global\r\n * object. Changing `goog.Timer.defaultTimerObject` changes the object for\r\n * all timer instances which can be useful if your environment has some other\r\n * implementation of timers you'd like to use.\r\n * @type {{setTimeout, clearTimeout}}\r\n */\r\ngoog.Timer.defaultTimerObject = goog.global;\r\n\r\n\r\n/**\r\n * Variable that controls the timer error correction. If the timer is called\r\n * before the requested interval times `intervalScale`, which often\r\n * happens on Mozilla, the timer is rescheduled.\r\n * @see {@link #last_}\r\n * @type {number}\r\n */\r\ngoog.Timer.intervalScale = 0.8;\r\n\r\n\r\n/**\r\n * Variable for storing the result of `setInterval`.\r\n * @private {?number}\r\n */\r\ngoog.Timer.prototype.timer_ = null;\r\n\r\n\r\n/**\r\n * Gets the interval of the timer.\r\n * @return {number} interval Number of ms between ticks.\r\n */\r\ngoog.Timer.prototype.getInterval = function() {\r\n  return this.interval_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the interval of the timer.\r\n * @param {number} interval Number of ms between ticks.\r\n */\r\ngoog.Timer.prototype.setInterval = function(interval) {\r\n  this.interval_ = interval;\r\n  if (this.timer_ && this.enabled) {\r\n    // Stop and then start the timer to reset the interval.\r\n    this.stop();\r\n    this.start();\r\n  } else if (this.timer_) {\r\n    this.stop();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Callback for the `setTimeout` used by the timer.\r\n * @private\r\n */\r\ngoog.Timer.prototype.tick_ = function() {\r\n  if (this.enabled) {\r\n    var elapsed = goog.now() - this.last_;\r\n    if (elapsed > 0 && elapsed < this.interval_ * goog.Timer.intervalScale) {\r\n      this.timer_ = this.timerObject_.setTimeout(\r\n          this.boundTick_, this.interval_ - elapsed);\r\n      return;\r\n    }\r\n\r\n    // Prevents setInterval from registering a duplicate timeout when called\r\n    // in the timer event handler.\r\n    if (this.timer_) {\r\n      this.timerObject_.clearTimeout(this.timer_);\r\n      this.timer_ = null;\r\n    }\r\n\r\n    this.dispatchTick();\r\n    // The timer could be stopped in the timer event handler.\r\n    if (this.enabled) {\r\n      // Stop and start to ensure there is always only one timeout even if\r\n      // start is called in the timer event handler.\r\n      this.stop();\r\n      this.start();\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Dispatches the TICK event. This is its own method so subclasses can override.\r\n */\r\ngoog.Timer.prototype.dispatchTick = function() {\r\n  this.dispatchEvent(goog.Timer.TICK);\r\n};\r\n\r\n\r\n/**\r\n * Starts the timer.\r\n */\r\ngoog.Timer.prototype.start = function() {\r\n  this.enabled = true;\r\n\r\n  // If there is no interval already registered, start it now\r\n  if (!this.timer_) {\r\n    // IMPORTANT!\r\n    // window.setInterval in FireFox has a bug - it fires based on\r\n    // absolute time, rather than on relative time. What this means\r\n    // is that if a computer is sleeping/hibernating for 24 hours\r\n    // and the timer interval was configured to fire every 1000ms,\r\n    // then after the PC wakes up the timer will fire, in rapid\r\n    // succession, 3600*24 times.\r\n    // This bug is described here and is already fixed, but it will\r\n    // take time to propagate, so for now I am switching this over\r\n    // to setTimeout logic.\r\n    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643\r\n    //\r\n    this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_);\r\n    this.last_ = goog.now();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Stops the timer.\r\n */\r\ngoog.Timer.prototype.stop = function() {\r\n  this.enabled = false;\r\n  if (this.timer_) {\r\n    this.timerObject_.clearTimeout(this.timer_);\r\n    this.timer_ = null;\r\n  }\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.Timer.prototype.disposeInternal = function() {\r\n  goog.Timer.superClass_.disposeInternal.call(this);\r\n  this.stop();\r\n  delete this.timerObject_;\r\n};\r\n\r\n\r\n/**\r\n * Constant for the timer's event type.\r\n * @const\r\n */\r\ngoog.Timer.TICK = 'tick';\r\n\r\n\r\n/**\r\n * Calls the given function once, after the optional pause.\r\n * <p>\r\n * The function is always called asynchronously, even if the delay is 0. This\r\n * is a common trick to schedule a function to run after a batch of browser\r\n * event processing.\r\n *\r\n * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function\r\n *     or object that has a handleEvent method.\r\n * @param {number=} opt_delay Milliseconds to wait; default is 0.\r\n * @param {SCOPE=} opt_handler Object in whose scope to call the listener.\r\n * @return {number} A handle to the timer ID.\r\n * @template SCOPE\r\n */\r\ngoog.Timer.callOnce = function(listener, opt_delay, opt_handler) {\r\n  if (goog.isFunction(listener)) {\r\n    if (opt_handler) {\r\n      listener = goog.bind(listener, opt_handler);\r\n    }\r\n  } else if (listener && typeof listener.handleEvent == 'function') {\r\n    // using typeof to prevent strict js warning\r\n    listener = goog.bind(listener.handleEvent, listener);\r\n  } else {\r\n    throw new Error('Invalid listener argument');\r\n  }\r\n\r\n  if (Number(opt_delay) > goog.Timer.MAX_TIMEOUT_) {\r\n    // Timeouts greater than MAX_INT return immediately due to integer\r\n    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don't\r\n    // schedule anything at all.\r\n    return goog.Timer.INVALID_TIMEOUT_ID_;\r\n  } else {\r\n    return goog.Timer.defaultTimerObject.setTimeout(listener, opt_delay || 0);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clears a timeout initiated by {@link #callOnce}.\r\n * @param {?number} timerId A timer ID.\r\n */\r\ngoog.Timer.clear = function(timerId) {\r\n  goog.Timer.defaultTimerObject.clearTimeout(timerId);\r\n};\r\n\r\n\r\n/**\r\n * @param {number} delay Milliseconds to wait.\r\n * @param {(RESULT|goog.Thenable<RESULT>|Thenable)=} opt_result The value\r\n *     with which the promise will be resolved.\r\n * @return {!goog.Promise<RESULT>} A promise that will be resolved after\r\n *     the specified delay, unless it is canceled first.\r\n * @template RESULT\r\n */\r\ngoog.Timer.promise = function(delay, opt_result) {\r\n  var timerKey = null;\r\n  return new goog\r\n      .Promise(function(resolve, reject) {\r\n        timerKey =\r\n            goog.Timer.callOnce(function() { resolve(opt_result); }, delay);\r\n        if (timerKey == goog.Timer.INVALID_TIMEOUT_ID_) {\r\n          reject(new Error('Failed to schedule timer.'));\r\n        }\r\n      })\r\n      .thenCatch(function(error) {\r\n        // Clear the timer. The most likely reason is \"cancel\" signal.\r\n        goog.Timer.clear(timerKey);\r\n        throw error;\r\n      });\r\n};\r\n","// Copyright 2007 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Definition of the goog.async.Throttle class.\r\n *\r\n * @see ../demos/timers.html\r\n */\r\n\r\ngoog.provide('goog.Throttle');\r\ngoog.provide('goog.async.Throttle');\r\n\r\ngoog.require('goog.Disposable');\r\ngoog.require('goog.Timer');\r\n\r\n\r\n\r\n/**\r\n * Throttle will perform an action that is passed in no more than once\r\n * per interval (specified in milliseconds). If it gets multiple signals\r\n * to perform the action while it is waiting, it will only perform the action\r\n * once at the end of the interval.\r\n * @param {function(this: T, ...?)} listener Function to callback when the\r\n *     action is triggered.\r\n * @param {number} interval Interval over which to throttle. The listener can\r\n *     only be called once per interval.\r\n * @param {T=} opt_handler Object in whose scope to call the listener.\r\n * @constructor\r\n * @struct\r\n * @extends {goog.Disposable}\r\n * @final\r\n * @template T\r\n */\r\ngoog.async.Throttle = function(listener, interval, opt_handler) {\r\n  goog.async.Throttle.base(this, 'constructor');\r\n\r\n  /**\r\n   * Function to callback\r\n   * @type {function(this: T, ...?)}\r\n   * @private\r\n   */\r\n  this.listener_ =\r\n      opt_handler != null ? goog.bind(listener, opt_handler) : listener;\r\n\r\n  /**\r\n   * Interval for the throttle time\r\n   * @type {number}\r\n   * @private\r\n   */\r\n  this.interval_ = interval;\r\n\r\n  /**\r\n   * Cached callback function invoked after the throttle timeout completes\r\n   * @type {Function}\r\n   * @private\r\n   */\r\n  this.callback_ = goog.bind(this.onTimer_, this);\r\n\r\n  /**\r\n   * The last arguments passed into `fire`.\r\n   * @private {!IArrayLike}\r\n   */\r\n  this.args_ = [];\r\n};\r\ngoog.inherits(goog.async.Throttle, goog.Disposable);\r\n\r\n\r\n\r\n/**\r\n * A deprecated alias.\r\n * @deprecated Use goog.async.Throttle instead.\r\n * @constructor\r\n * @final\r\n */\r\ngoog.Throttle = goog.async.Throttle;\r\n\r\n\r\n/**\r\n * Indicates that the action is pending and needs to be fired.\r\n * @type {boolean}\r\n * @private\r\n */\r\ngoog.async.Throttle.prototype.shouldFire_ = false;\r\n\r\n\r\n/**\r\n * Indicates the count of nested pauses currently in effect on the throttle.\r\n * When this count is not zero, fired actions will be postponed until the\r\n * throttle is resumed enough times to drop the pause count to zero.\r\n * @type {number}\r\n * @private\r\n */\r\ngoog.async.Throttle.prototype.pauseCount_ = 0;\r\n\r\n\r\n/**\r\n * Timer for scheduling the next callback\r\n * @type {?number}\r\n * @private\r\n */\r\ngoog.async.Throttle.prototype.timer_ = null;\r\n\r\n\r\n/**\r\n * Notifies the throttle that the action has happened. It will throttle the call\r\n * so that the callback is not called too often according to the interval\r\n * parameter passed to the constructor, passing the arguments from the last call\r\n * of this function into the throttled function.\r\n * @param {...?} var_args Arguments to pass on to the throttled function.\r\n */\r\ngoog.async.Throttle.prototype.fire = function(var_args) {\r\n  this.args_ = arguments;\r\n  if (!this.timer_ && !this.pauseCount_) {\r\n    this.doAction_();\r\n  } else {\r\n    this.shouldFire_ = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Cancels any pending action callback. The throttle can be restarted by\r\n * calling {@link #fire}.\r\n */\r\ngoog.async.Throttle.prototype.stop = function() {\r\n  if (this.timer_) {\r\n    goog.Timer.clear(this.timer_);\r\n    this.timer_ = null;\r\n    this.shouldFire_ = false;\r\n    this.args_ = [];\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Pauses the throttle.  All pending and future action callbacks will be\r\n * delayed until the throttle is resumed.  Pauses can be nested.\r\n */\r\ngoog.async.Throttle.prototype.pause = function() {\r\n  this.pauseCount_++;\r\n};\r\n\r\n\r\n/**\r\n * Resumes the throttle.  If doing so drops the pausing count to zero, pending\r\n * action callbacks will be executed as soon as possible, but still no sooner\r\n * than an interval's delay after the previous call.  Future action callbacks\r\n * will be executed as normal.\r\n */\r\ngoog.async.Throttle.prototype.resume = function() {\r\n  this.pauseCount_--;\r\n  if (!this.pauseCount_ && this.shouldFire_ && !this.timer_) {\r\n    this.shouldFire_ = false;\r\n    this.doAction_();\r\n  }\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.async.Throttle.prototype.disposeInternal = function() {\r\n  goog.async.Throttle.base(this, 'disposeInternal');\r\n  this.stop();\r\n};\r\n\r\n\r\n/**\r\n * Handler for the timer to fire the throttle\r\n * @private\r\n */\r\ngoog.async.Throttle.prototype.onTimer_ = function() {\r\n  this.timer_ = null;\r\n\r\n  if (this.shouldFire_ && !this.pauseCount_) {\r\n    this.shouldFire_ = false;\r\n    this.doAction_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls the callback\r\n * @private\r\n */\r\ngoog.async.Throttle.prototype.doAction_ = function() {\r\n  this.timer_ = goog.Timer.callOnce(this.callback_, this.interval_);\r\n  this.listener_.apply(null, this.args_);\r\n};\r\n","// Copyright 2005 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Class to create objects which want to handle multiple events\r\n * and have their listeners easily cleaned up via a dispose method.\r\n *\r\n * Example:\r\n * <pre>\r\n * function Something() {\r\n *   Something.base(this);\r\n *\r\n *   ... set up object ...\r\n *\r\n *   // Add event listeners\r\n *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);\r\n *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);\r\n *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);\r\n *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);\r\n *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);\r\n * }\r\n * goog.inherits(Something, goog.events.EventHandler);\r\n *\r\n * Something.prototype.disposeInternal = function() {\r\n *   Something.base(this, 'disposeInternal');\r\n *   goog.dom.removeNode(this.container);\r\n * };\r\n *\r\n *\r\n * // Then elsewhere:\r\n *\r\n * var activeSomething = null;\r\n * function openSomething() {\r\n *   activeSomething = new Something();\r\n * }\r\n *\r\n * function closeSomething() {\r\n *   if (activeSomething) {\r\n *     activeSomething.dispose();  // Remove event listeners\r\n *     activeSomething = null;\r\n *   }\r\n * }\r\n * </pre>\r\n *\r\n */\r\n\r\ngoog.provide('goog.events.EventHandler');\r\n\r\ngoog.require('goog.Disposable');\r\ngoog.require('goog.events');\r\ngoog.require('goog.object');\r\n\r\ngoog.forwardDeclare('goog.events.EventWrapper');\r\n\r\n\r\n\r\n/**\r\n * Super class for objects that want to easily manage a number of event\r\n * listeners.  It allows a short cut to listen and also provides a quick way\r\n * to remove all events listeners belonging to this object.\r\n * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.\r\n * @constructor\r\n * @extends {goog.Disposable}\r\n * @template SCOPE\r\n */\r\ngoog.events.EventHandler = function(opt_scope) {\r\n  goog.Disposable.call(this);\r\n  // TODO(mknichel): Rename this to this.scope_ and fix the classes in google3\r\n  // that access this private variable. :(\r\n  this.handler_ = opt_scope;\r\n\r\n  /**\r\n   * Keys for events that are being listened to.\r\n   * @type {!Object<!goog.events.Key>}\r\n   * @private\r\n   */\r\n  this.keys_ = {};\r\n};\r\ngoog.inherits(goog.events.EventHandler, goog.Disposable);\r\n\r\n\r\n/**\r\n * Utility array used to unify the cases of listening for an array of types\r\n * and listening for a single event, without using recursion or allocating\r\n * an array each time.\r\n * @type {!Array<string>}\r\n * @const\r\n * @private\r\n */\r\ngoog.events.EventHandler.typeArray_ = [];\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted then the\r\n * EventHandler's handleEvent method will be used.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}\r\n *     opt_fn Optional callback function to be used as the listener or an object\r\n *     with handleEvent function.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template EVENTOBJ, THIS\r\n */\r\ngoog.events.EventHandler.prototype.listen = function(\r\n    src, type, opt_fn, opt_options) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  return self.listen_(src, type, opt_fn, opt_options);\r\n};\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted then the\r\n * EventHandler's handleEvent method will be used.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|\r\n *     null|undefined} fn Optional callback function to be used as the\r\n *     listener or an object with handleEvent function.\r\n * @param {boolean|!AddEventListenerOptions|undefined} options\r\n * @param {T} scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template T, EVENTOBJ, THIS\r\n */\r\ngoog.events.EventHandler.prototype.listenWithScope = function(\r\n    src, type, fn, options, scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  // TODO(mknichel): Deprecate this function.\r\n  return self.listen_(src, type, fn, options, scope);\r\n};\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted then the\r\n * EventHandler's handleEvent method will be used.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn\r\n *     Optional callback function to be used as the listener or an object with\r\n *     handleEvent function.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @param {Object=} opt_scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template EVENTOBJ, THIS\r\n * @private\r\n */\r\ngoog.events.EventHandler.prototype.listen_ = function(\r\n    src, type, opt_fn, opt_options, opt_scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  if (!goog.isArray(type)) {\r\n    if (type) {\r\n      goog.events.EventHandler.typeArray_[0] = type.toString();\r\n    }\r\n    type = goog.events.EventHandler.typeArray_;\r\n  }\r\n  for (var i = 0; i < type.length; i++) {\r\n    var listenerObj = goog.events.listen(\r\n        src, type[i], opt_fn || self.handleEvent, opt_options || false,\r\n        opt_scope || self.handler_ || self);\r\n\r\n    if (!listenerObj) {\r\n      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT\r\n      // (goog.events.CaptureSimulationMode) in IE8-, it will return null\r\n      // value.\r\n      return self;\r\n    }\r\n\r\n    var key = listenerObj.key;\r\n    self.keys_[key] = listenerObj;\r\n  }\r\n\r\n  return self;\r\n};\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted, then the\r\n * EventHandler's handleEvent method will be used. After the event has fired the\r\n * event listener is removed from the target. If an array of event types is\r\n * provided, each event type will be listened to once.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}\r\n * opt_fn\r\n *    Optional callback function to be used as the listener or an object with\r\n *    handleEvent function.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template EVENTOBJ, THIS\r\n */\r\ngoog.events.EventHandler.prototype.listenOnce = function(\r\n    src, type, opt_fn, opt_options) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  return self.listenOnce_(src, type, opt_fn, opt_options);\r\n};\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted, then the\r\n * EventHandler's handleEvent method will be used. After the event has fired the\r\n * event listener is removed from the target. If an array of event types is\r\n * provided, each event type will be listened to once.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|\r\n *     null|undefined} fn Optional callback function to be used as the\r\n *     listener or an object with handleEvent function.\r\n * @param {boolean|undefined} capture Optional whether to use capture phase.\r\n * @param {T} scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template T, EVENTOBJ, THIS\r\n */\r\ngoog.events.EventHandler.prototype.listenOnceWithScope = function(\r\n    src, type, fn, capture, scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  // TODO(mknichel): Deprecate this function.\r\n  return self.listenOnce_(src, type, fn, capture, scope);\r\n};\r\n\r\n\r\n/**\r\n * Listen to an event on a Listenable.  If the function is omitted, then the\r\n * EventHandler's handleEvent method will be used. After the event has fired\r\n * the event listener is removed from the target. If an array of event types is\r\n * provided, each event type will be listened to once.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type to listen for or array of event types.\r\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn\r\n *    Optional callback function to be used as the listener or an object with\r\n *    handleEvent function.\r\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\r\n * @param {Object=} opt_scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template EVENTOBJ, THIS\r\n * @private\r\n */\r\ngoog.events.EventHandler.prototype.listenOnce_ = function(\r\n    src, type, opt_fn, opt_options, opt_scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  if (goog.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      self.listenOnce_(src, type[i], opt_fn, opt_options, opt_scope);\r\n    }\r\n  } else {\r\n    var listenerObj = goog.events.listenOnce(\r\n        src, type, opt_fn || self.handleEvent, opt_options,\r\n        opt_scope || self.handler_ || self);\r\n    if (!listenerObj) {\r\n      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT\r\n      // (goog.events.CaptureSimulationMode) in IE8-, it will return null\r\n      // value.\r\n      return self;\r\n    }\r\n\r\n    var key = listenerObj.key;\r\n    self.keys_[key] = listenerObj;\r\n  }\r\n\r\n  return self;\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener with a specific event wrapper on a DOM Node or an\r\n * object that has implemented {@link goog.events.EventTarget}. A listener can\r\n * only be added once to an object.\r\n *\r\n * @param {EventTarget|goog.events.EventTarget} src The node to listen to\r\n *     events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener\r\n *     Callback method, or an object with a handleEvent function.\r\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\r\n *     false).\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template THIS\r\n */\r\ngoog.events.EventHandler.prototype.listenWithWrapper = function(\r\n    src, wrapper, listener, opt_capt) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  // TODO(mknichel): Remove the opt_scope from this function and then\r\n  // templatize it.\r\n  return self.listenWithWrapper_(src, wrapper, listener, opt_capt);\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener with a specific event wrapper on a DOM Node or an\r\n * object that has implemented {@link goog.events.EventTarget}. A listener can\r\n * only be added once to an object.\r\n *\r\n * @param {EventTarget|goog.events.EventTarget} src The node to listen to\r\n *     events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}\r\n *     listener Optional callback function to be used as the\r\n *     listener or an object with handleEvent function.\r\n * @param {boolean|undefined} capture Optional whether to use capture phase.\r\n * @param {T} scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template T, THIS\r\n */\r\ngoog.events.EventHandler.prototype.listenWithWrapperAndScope = function(\r\n    src, wrapper, listener, capture, scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  // TODO(mknichel): Deprecate this function.\r\n  return self.listenWithWrapper_(src, wrapper, listener, capture, scope);\r\n};\r\n\r\n\r\n/**\r\n * Adds an event listener with a specific event wrapper on a DOM Node or an\r\n * object that has implemented {@link goog.events.EventTarget}. A listener can\r\n * only be added once to an object.\r\n *\r\n * @param {EventTarget|goog.events.EventTarget} src The node to listen to\r\n *     events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback\r\n *     method, or an object with a handleEvent function.\r\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\r\n *     false).\r\n * @param {Object=} opt_scope Element in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template THIS\r\n * @private\r\n */\r\ngoog.events.EventHandler.prototype.listenWithWrapper_ = function(\r\n    src, wrapper, listener, opt_capt, opt_scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  wrapper.listen(\r\n      src, listener, opt_capt, opt_scope || self.handler_ || self, self);\r\n  return self;\r\n};\r\n\r\n\r\n/**\r\n * @return {number} Number of listeners registered by this handler.\r\n */\r\ngoog.events.EventHandler.prototype.getListenerCount = function() {\r\n  var count = 0;\r\n  for (var key in this.keys_) {\r\n    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Unlistens on an event.\r\n * @param {goog.events.ListenableType} src Event source.\r\n * @param {string|Array<string>|\r\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\r\n *     type Event type or array of event types to unlisten to.\r\n * @param {function(this:?, EVENTOBJ):?|{handleEvent:function(?):?}|null=}\r\n *     opt_fn Optional callback function to be used as the listener or an object\r\n *     with handleEvent function.\r\n * @param {(boolean|!EventListenerOptions)=} opt_options\r\n * @param {Object=} opt_scope Object in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template EVENTOBJ, THIS\r\n */\r\ngoog.events.EventHandler.prototype.unlisten = function(\r\n    src, type, opt_fn, opt_options, opt_scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  if (goog.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      self.unlisten(src, type[i], opt_fn, opt_options, opt_scope);\r\n    }\r\n  } else {\r\n    var capture =\r\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\r\n    var listener = goog.events.getListener(\r\n        src, type, opt_fn || self.handleEvent, capture,\r\n        opt_scope || self.handler_ || self);\r\n\r\n    if (listener) {\r\n      goog.events.unlistenByKey(listener);\r\n      delete self.keys_[listener.key];\r\n    }\r\n  }\r\n\r\n  return self;\r\n};\r\n\r\n\r\n/**\r\n * Removes an event listener which was added with listenWithWrapper().\r\n *\r\n * @param {EventTarget|goog.events.EventTarget} src The target to stop\r\n *     listening to events on.\r\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\r\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\r\n *     listener function to remove.\r\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\r\n *     whether the listener is fired during the capture or bubble phase of the\r\n *     event.\r\n * @param {Object=} opt_scope Element in whose scope to call the listener.\r\n * @return {THIS} This object, allowing for chaining of calls.\r\n * @this {THIS}\r\n * @template THIS\r\n */\r\ngoog.events.EventHandler.prototype.unlistenWithWrapper = function(\r\n    src, wrapper, listener, opt_capt, opt_scope) {\r\n  var self = /** @type {!goog.events.EventHandler} */ (this);\r\n  wrapper.unlisten(\r\n      src, listener, opt_capt, opt_scope || self.handler_ || self, self);\r\n  return self;\r\n};\r\n\r\n\r\n/**\r\n * Unlistens to all events.\r\n */\r\ngoog.events.EventHandler.prototype.removeAll = function() {\r\n  goog.object.forEach(this.keys_, function(listenerObj, key) {\r\n    if (this.keys_.hasOwnProperty(key)) {\r\n      goog.events.unlistenByKey(listenerObj);\r\n    }\r\n  }, this);\r\n\r\n  this.keys_ = {};\r\n};\r\n\r\n\r\n/**\r\n * Disposes of this EventHandler and removes all listeners that it registered.\r\n * @override\r\n * @protected\r\n */\r\ngoog.events.EventHandler.prototype.disposeInternal = function() {\r\n  goog.events.EventHandler.superClass_.disposeInternal.call(this);\r\n  this.removeAll();\r\n};\r\n\r\n\r\n/**\r\n * Default event handler\r\n * @param {goog.events.Event} e Event object.\r\n */\r\ngoog.events.EventHandler.prototype.handleEvent = function(e) {\r\n  throw new Error('EventHandler.handleEvent not implemented');\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Provides a utility for tracing and debugging WebChannel\r\n *     requests.\r\n */\r\n\r\n\r\ngoog.provide('goog.labs.net.webChannel.WebChannelDebug');\r\n\r\ngoog.require('goog.json');\r\ngoog.require('goog.log');\r\n\r\ngoog.forwardDeclare('goog.Uri');\r\ngoog.forwardDeclare('goog.net.XmlHttp.ReadyState');\r\n\r\n\r\n\r\n/**\r\n * Logs and keeps a buffer of debugging info for the Channel.\r\n *\r\n * @constructor\r\n * @struct\r\n * @final\r\n */\r\ngoog.labs.net.webChannel.WebChannelDebug = function() {\r\n  /**\r\n   * The logger instance.\r\n   * @const\r\n   * @private {?goog.log.Logger}\r\n   */\r\n  this.logger_ = goog.log.getLogger('goog.labs.net.webChannel.WebChannelDebug');\r\n\r\n  /**\r\n   * Whether to enable redact. Defaults to true.\r\n   * @private {boolean}\r\n   */\r\n  this.redactEnabled_ = true;\r\n};\r\n\r\n\r\ngoog.scope(function() {\r\nvar WebChannelDebug = goog.labs.net.webChannel.WebChannelDebug;\r\n\r\n\r\n/**\r\n * Turns off redact.\r\n */\r\nWebChannelDebug.prototype.disableRedact = function() {\r\n  this.redactEnabled_ = false;\r\n};\r\n\r\n\r\n/**\r\n * Logs that the browser went offline during the lifetime of a request.\r\n * @param {goog.Uri} url The URL being requested.\r\n */\r\nWebChannelDebug.prototype.browserOfflineResponse = function(url) {\r\n  this.info(function() {\r\n    return 'BROWSER_OFFLINE: ' + url;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Logs an XmlHttp request..\r\n * @param {string} verb The request type (GET/POST).\r\n * @param {goog.Uri} uri The request destination.\r\n * @param {string|number|undefined} id The request id.\r\n * @param {number} attempt Which attempt # the request was.\r\n * @param {?string} postData The data posted in the request.\r\n */\r\nWebChannelDebug.prototype.xmlHttpChannelRequest = function(\r\n    verb, uri, id, attempt, postData) {\r\n  var self = this;\r\n  this.info(function() {\r\n    return 'XMLHTTP REQ (' + id + ') [attempt ' + attempt + ']: ' + verb +\r\n        '\\n' + uri + '\\n' + self.maybeRedactPostData_(postData);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Logs the meta data received from an XmlHttp request.\r\n * @param {string} verb The request type (GET/POST).\r\n * @param {goog.Uri} uri The request destination.\r\n * @param {string|number|undefined} id The request id.\r\n * @param {number} attempt Which attempt # the request was.\r\n * @param {goog.net.XmlHttp.ReadyState} readyState The ready state.\r\n * @param {number} statusCode The HTTP status code.\r\n */\r\nWebChannelDebug.prototype.xmlHttpChannelResponseMetaData = function(\r\n    verb, uri, id, attempt, readyState, statusCode) {\r\n  this.info(function() {\r\n    return 'XMLHTTP RESP (' + id + ') [ attempt ' + attempt + ']: ' + verb +\r\n        '\\n' + uri + '\\n' + readyState + ' ' + statusCode;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Logs the response data received from an XmlHttp request.\r\n * @param {string|number|undefined} id The request id.\r\n * @param {?string} responseText The response text.\r\n * @param {?string=} opt_desc Optional request description.\r\n */\r\nWebChannelDebug.prototype.xmlHttpChannelResponseText = function(\r\n    id, responseText, opt_desc) {\r\n  var self = this;\r\n  this.info(function() {\r\n    return 'XMLHTTP TEXT (' + id + '): ' + self.redactResponse_(responseText) +\r\n        (opt_desc ? ' ' + opt_desc : '');\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Logs a request timeout.\r\n * @param {goog.Uri} uri The uri that timed out.\r\n */\r\nWebChannelDebug.prototype.timeoutResponse = function(uri) {\r\n  this.info(function() {\r\n    return 'TIMEOUT: ' + uri;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Logs a debug message.\r\n * @param {!goog.debug.Loggable} text The message.\r\n */\r\nWebChannelDebug.prototype.debug = function(text) {\r\n  goog.log.fine(this.logger_, text);\r\n};\r\n\r\n\r\n/**\r\n * Logs an exception\r\n * @param {Error} e The error or error event.\r\n * @param {goog.debug.Loggable=} opt_msg The optional message,\r\n *     defaults to 'Exception'.\r\n */\r\nWebChannelDebug.prototype.dumpException = function(e, opt_msg) {\r\n  goog.log.error(this.logger_, opt_msg || 'Exception', e);\r\n};\r\n\r\n\r\n/**\r\n * Logs an info message.\r\n * @param {!goog.debug.Loggable} text The message.\r\n */\r\nWebChannelDebug.prototype.info = function(text) {\r\n  goog.log.info(this.logger_, text);\r\n};\r\n\r\n\r\n/**\r\n * Logs a warning message.\r\n * @param {!goog.debug.Loggable} text The message.\r\n */\r\nWebChannelDebug.prototype.warning = function(text) {\r\n  goog.log.warning(this.logger_, text);\r\n};\r\n\r\n\r\n/**\r\n * Logs a severe message.\r\n * @param {!goog.debug.Loggable} text The message.\r\n */\r\nWebChannelDebug.prototype.severe = function(text) {\r\n  goog.log.error(this.logger_, text);\r\n};\r\n\r\n\r\n/**\r\n * Removes potentially private data from a response so that we don't\r\n * accidentally save private and personal data to the server logs.\r\n * @param {?string} responseText A JSON response to clean.\r\n * @return {?string} The cleaned response.\r\n * @private\r\n */\r\nWebChannelDebug.prototype.redactResponse_ = function(responseText) {\r\n  if (!this.redactEnabled_) {\r\n    return responseText;\r\n  }\r\n\r\n  if (!responseText) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    var responseArray = JSON.parse(responseText);\r\n    if (responseArray) {\r\n      for (var i = 0; i < responseArray.length; i++) {\r\n        if (goog.isArray(responseArray[i])) {\r\n          this.maybeRedactArray_(responseArray[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return goog.json.serialize(responseArray);\r\n  } catch (e) {\r\n    this.debug('Exception parsing expected JS array - probably was not JS');\r\n    return responseText;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes data from a response array that may be sensitive.\r\n * @param {!Array<?>} array The array to clean.\r\n * @private\r\n */\r\nWebChannelDebug.prototype.maybeRedactArray_ = function(array) {\r\n  if (array.length < 2) {\r\n    return;\r\n  }\r\n  var dataPart = array[1];\r\n  if (!goog.isArray(dataPart)) {\r\n    return;\r\n  }\r\n  if (dataPart.length < 1) {\r\n    return;\r\n  }\r\n\r\n  var type = dataPart[0];\r\n  if (type != 'noop' && type != 'stop' && type != 'close') {\r\n    // redact all fields in the array\r\n    for (var i = 1; i < dataPart.length; i++) {\r\n      dataPart[i] = '';\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Removes potentially private data from a request POST body so that we don't\r\n * accidentally save private and personal data to the server logs.\r\n * @param {?string} data The data string to clean.\r\n * @return {?string} The data string with sensitive data replaced by 'redacted'.\r\n * @private\r\n */\r\nWebChannelDebug.prototype.maybeRedactPostData_ = function(data) {\r\n  if (!this.redactEnabled_) {\r\n    return data;\r\n  }\r\n\r\n  if (!data) {\r\n    return null;\r\n  }\r\n  var out = '';\r\n  var params = data.split('&');\r\n  for (var i = 0; i < params.length; i++) {\r\n    var param = params[i];\r\n    var keyValue = param.split('=');\r\n    if (keyValue.length > 1) {\r\n      var key = keyValue[0];\r\n      var value = keyValue[1];\r\n\r\n      var keyParts = key.split('_');\r\n      if (keyParts.length >= 2 && keyParts[1] == 'type') {\r\n        out += key + '=' + value + '&';\r\n      } else {\r\n        out += key + '=' +\r\n            'redacted' +\r\n            '&';\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n};\r\n});  // goog.scope\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Static utilities for collecting stats associated with\r\n * ChannelRequest.\r\n */\r\n\r\n\r\ngoog.provide('goog.labs.net.webChannel.requestStats');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.Event');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.ServerReachability');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.ServerReachabilityEvent');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.Stat');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.StatEvent');\r\ngoog.provide('goog.labs.net.webChannel.requestStats.TimingEvent');\r\n\r\ngoog.require('goog.events.Event');\r\ngoog.require('goog.events.EventTarget');\r\n\r\n\r\ngoog.scope(function() {\r\nvar requestStats = goog.labs.net.webChannel.requestStats;\r\n\r\n\r\n/**\r\n * Events fired.\r\n * @const\r\n */\r\nrequestStats.Event = {};\r\n\r\n\r\n/**\r\n * Singleton event target for firing stat events\r\n * @type {goog.events.EventTarget}\r\n * @private\r\n */\r\nrequestStats.statEventTarget_ = new goog.events.EventTarget();\r\n\r\n\r\n/**\r\n * The type of event that occurs every time some information about how reachable\r\n * the server is is discovered.\r\n */\r\nrequestStats.Event.SERVER_REACHABILITY_EVENT = 'serverreachability';\r\n\r\n\r\n/**\r\n * Types of events which reveal information about the reachability of the\r\n * server.\r\n * @enum {number}\r\n */\r\nrequestStats.ServerReachability = {\r\n  REQUEST_MADE: 1,\r\n  REQUEST_SUCCEEDED: 2,\r\n  REQUEST_FAILED: 3,\r\n  BACK_CHANNEL_ACTIVITY: 4  // any response data received\r\n};\r\n\r\n\r\n\r\n/**\r\n * Event class for SERVER_REACHABILITY_EVENT.\r\n *\r\n * @param {goog.events.EventTarget} target The stat event target for\r\n       the channel.\r\n * @param {requestStats.ServerReachability} reachabilityType\r\n *     The reachability event type.\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\nrequestStats.ServerReachabilityEvent = function(target, reachabilityType) {\r\n  goog.events.Event.call(\r\n      this, requestStats.Event.SERVER_REACHABILITY_EVENT, target);\r\n\r\n  /**\r\n   * @type {requestStats.ServerReachability}\r\n   */\r\n  this.reachabilityType = reachabilityType;\r\n};\r\ngoog.inherits(requestStats.ServerReachabilityEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * Notify the channel that a particular fine grained network event has occurred.\r\n * Should be considered package-private.\r\n * @param {requestStats.ServerReachability} reachabilityType\r\n *     The reachability event type.\r\n */\r\nrequestStats.notifyServerReachabilityEvent = function(reachabilityType) {\r\n  var target = requestStats.statEventTarget_;\r\n  target.dispatchEvent(\r\n      new requestStats.ServerReachabilityEvent(target, reachabilityType));\r\n};\r\n\r\n\r\n/**\r\n * Stat Event that fires when things of interest happen that may be useful for\r\n * applications to know about for stats or debugging purposes.\r\n */\r\nrequestStats.Event.STAT_EVENT = 'statevent';\r\n\r\n\r\n/**\r\n * Enum that identifies events for statistics that are interesting to track.\r\n * @enum {number}\r\n */\r\nrequestStats.Stat = {\r\n  /** Event indicating a new connection attempt. */\r\n  CONNECT_ATTEMPT: 0,\r\n\r\n  /** Event indicating a connection error due to a general network problem. */\r\n  ERROR_NETWORK: 1,\r\n\r\n  /**\r\n   * Event indicating a connection error that isn't due to a general network\r\n   * problem.\r\n   */\r\n  ERROR_OTHER: 2,\r\n\r\n  /** Event indicating the start of test stage one. */\r\n  TEST_STAGE_ONE_START: 3,\r\n\r\n  /** Event indicating the start of test stage two. */\r\n  TEST_STAGE_TWO_START: 4,\r\n\r\n  /** Event indicating the first piece of test data was received. */\r\n  TEST_STAGE_TWO_DATA_ONE: 5,\r\n\r\n  /**\r\n   * Event indicating that the second piece of test data was received and it was\r\n   * received separately from the first.\r\n   */\r\n  TEST_STAGE_TWO_DATA_TWO: 6,\r\n\r\n  /** Event indicating both pieces of test data were received simultaneously. */\r\n  TEST_STAGE_TWO_DATA_BOTH: 7,\r\n\r\n  /** Event indicating stage one of the test request failed. */\r\n  TEST_STAGE_ONE_FAILED: 8,\r\n\r\n  /** Event indicating stage two of the test request failed. */\r\n  TEST_STAGE_TWO_FAILED: 9,\r\n\r\n  /**\r\n   * Event indicating that a buffering proxy is likely between the client and\r\n   * the server.\r\n   */\r\n  PROXY: 10,\r\n\r\n  /**\r\n   * Event indicating that no buffering proxy is likely between the client and\r\n   * the server.\r\n   */\r\n  NOPROXY: 11,\r\n\r\n  /** Event indicating an unknown SID error. */\r\n  REQUEST_UNKNOWN_SESSION_ID: 12,\r\n\r\n  /** Event indicating a bad status code was received. */\r\n  REQUEST_BAD_STATUS: 13,\r\n\r\n  /** Event indicating incomplete data was received */\r\n  REQUEST_INCOMPLETE_DATA: 14,\r\n\r\n  /** Event indicating bad data was received */\r\n  REQUEST_BAD_DATA: 15,\r\n\r\n  /** Event indicating no data was received when data was expected. */\r\n  REQUEST_NO_DATA: 16,\r\n\r\n  /** Event indicating a request timeout. */\r\n  REQUEST_TIMEOUT: 17,\r\n\r\n  /**\r\n   * Event indicating that the server never received our hanging GET and so it\r\n   * is being retried.\r\n   */\r\n  BACKCHANNEL_MISSING: 18,\r\n\r\n  /**\r\n   * Event indicating that we have determined that our hanging GET is not\r\n   * receiving data when it should be. Thus it is dead dead and will be retried.\r\n   */\r\n  BACKCHANNEL_DEAD: 19,\r\n\r\n  /**\r\n   * The browser declared itself offline during the lifetime of a request, or\r\n   * was offline when a request was initially made.\r\n   */\r\n  BROWSER_OFFLINE: 20\r\n};\r\n\r\n\r\n\r\n/**\r\n * Event class for STAT_EVENT.\r\n *\r\n * @param {goog.events.EventTarget} eventTarget The stat event target for\r\n       the channel.\r\n * @param {requestStats.Stat} stat The stat.\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\nrequestStats.StatEvent = function(eventTarget, stat) {\r\n  goog.events.Event.call(this, requestStats.Event.STAT_EVENT, eventTarget);\r\n\r\n  /**\r\n   * The stat\r\n   * @type {requestStats.Stat}\r\n   */\r\n  this.stat = stat;\r\n\r\n};\r\ngoog.inherits(requestStats.StatEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * Returns the singleton event target for stat events.\r\n * @return {goog.events.EventTarget} The event target for stat events.\r\n */\r\nrequestStats.getStatEventTarget = function() {\r\n  return requestStats.statEventTarget_;\r\n};\r\n\r\n\r\n/**\r\n * Helper function to call the stat event callback.\r\n * @param {requestStats.Stat} stat The stat.\r\n */\r\nrequestStats.notifyStatEvent = function(stat) {\r\n  var target = requestStats.statEventTarget_;\r\n  target.dispatchEvent(new requestStats.StatEvent(target, stat));\r\n};\r\n\r\n\r\n/**\r\n * An event that fires when POST requests complete successfully, indicating\r\n * the size of the POST and the round trip time.\r\n */\r\nrequestStats.Event.TIMING_EVENT = 'timingevent';\r\n\r\n\r\n\r\n/**\r\n * Event class for requestStats.Event.TIMING_EVENT\r\n *\r\n * @param {goog.events.EventTarget} target The stat event target for\r\n       the channel.\r\n * @param {number} size The number of characters in the POST data.\r\n * @param {number} rtt The total round trip time from POST to response in MS.\r\n * @param {number} retries The number of times the POST had to be retried.\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\nrequestStats.TimingEvent = function(target, size, rtt, retries) {\r\n  goog.events.Event.call(this, requestStats.Event.TIMING_EVENT, target);\r\n\r\n  /**\r\n   * @type {number}\r\n   */\r\n  this.size = size;\r\n\r\n  /**\r\n   * @type {number}\r\n   */\r\n  this.rtt = rtt;\r\n\r\n  /**\r\n   * @type {number}\r\n   */\r\n  this.retries = retries;\r\n\r\n};\r\ngoog.inherits(requestStats.TimingEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * Helper function to notify listeners about POST request performance.\r\n *\r\n * @param {number} size Number of characters in the POST data.\r\n * @param {number} rtt The amount of time from POST start to response.\r\n * @param {number} retries The number of times the POST had to be retried.\r\n */\r\nrequestStats.notifyTimingEvent = function(size, rtt, retries) {\r\n  var target = requestStats.statEventTarget_;\r\n  target.dispatchEvent(\r\n      new requestStats.TimingEvent(target, size, rtt, retries));\r\n};\r\n\r\n\r\n/**\r\n * Allows the application to set an execution hooks for when a channel\r\n * starts processing requests. This is useful to track timing or logging\r\n * special information. The function takes no parameters and return void.\r\n * @param {Function} startHook  The function for the start hook.\r\n */\r\nrequestStats.setStartThreadExecutionHook = function(startHook) {\r\n  requestStats.startExecutionHook_ = startHook;\r\n};\r\n\r\n\r\n/**\r\n * Allows the application to set an execution hooks for when a channel\r\n * stops processing requests. This is useful to track timing or logging\r\n * special information. The function takes no parameters and return void.\r\n * @param {Function} endHook  The function for the end hook.\r\n */\r\nrequestStats.setEndThreadExecutionHook = function(endHook) {\r\n  requestStats.endExecutionHook_ = endHook;\r\n};\r\n\r\n\r\n/**\r\n * Application provided execution hook for the start hook.\r\n *\r\n * @type {Function}\r\n * @private\r\n */\r\nrequestStats.startExecutionHook_ = function() {};\r\n\r\n\r\n/**\r\n * Application provided execution hook for the end hook.\r\n *\r\n * @type {Function}\r\n * @private\r\n */\r\nrequestStats.endExecutionHook_ = function() {};\r\n\r\n\r\n/**\r\n * Helper function to call the start hook\r\n */\r\nrequestStats.onStartExecution = function() {\r\n  requestStats.startExecutionHook_();\r\n};\r\n\r\n\r\n/**\r\n * Helper function to call the end hook\r\n */\r\nrequestStats.onEndExecution = function() {\r\n  requestStats.endExecutionHook_();\r\n};\r\n\r\n\r\n/**\r\n * Wrapper around SafeTimeout which calls the start and end execution hooks\r\n * with a try...finally block.\r\n * @param {Function} fn The callback function.\r\n * @param {number} ms The time in MS for the timer.\r\n * @return {number} The ID of the timer.\r\n */\r\nrequestStats.setTimeout = function(fn, ms) {\r\n  if (!goog.isFunction(fn)) {\r\n    throw new Error('Fn must not be null and must be a function');\r\n  }\r\n  return goog.global.setTimeout(function() {\r\n    requestStats.onStartExecution();\r\n    try {\r\n      fn();\r\n    } finally {\r\n      requestStats.onEndExecution();\r\n    }\r\n  }, ms);\r\n};\r\n});  // goog.scope\r\n","// Copyright 2007 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Error codes shared between goog.net.IframeIo and\r\n * goog.net.XhrIo.\r\n */\r\n\r\ngoog.provide('goog.net.ErrorCode');\r\n\r\n\r\n/**\r\n * Error codes\r\n * @enum {number}\r\n */\r\ngoog.net.ErrorCode = {\r\n\r\n  /**\r\n   * There is no error condition.\r\n   */\r\n  NO_ERROR: 0,\r\n\r\n  /**\r\n   * The most common error from iframeio, unfortunately, is that the browser\r\n   * responded with an error page that is classed as a different domain. The\r\n   * situations, are when a browser error page  is shown -- 404, access denied,\r\n   * DNS failure, connection reset etc.)\r\n   *\r\n   */\r\n  ACCESS_DENIED: 1,\r\n\r\n  /**\r\n   * Currently the only case where file not found will be caused is when the\r\n   * code is running on the local file system and a non-IE browser makes a\r\n   * request to a file that doesn't exist.\r\n   */\r\n  FILE_NOT_FOUND: 2,\r\n\r\n  /**\r\n   * If Firefox shows a browser error page, such as a connection reset by\r\n   * server or access denied, then it will fail silently without the error or\r\n   * load handlers firing.\r\n   */\r\n  FF_SILENT_ERROR: 3,\r\n\r\n  /**\r\n   * Custom error provided by the client through the error check hook.\r\n   */\r\n  CUSTOM_ERROR: 4,\r\n\r\n  /**\r\n   * Exception was thrown while processing the request.\r\n   */\r\n  EXCEPTION: 5,\r\n\r\n  /**\r\n   * The Http response returned a non-successful http status code.\r\n   */\r\n  HTTP_ERROR: 6,\r\n\r\n  /**\r\n   * The request was aborted.\r\n   */\r\n  ABORT: 7,\r\n\r\n  /**\r\n   * The request timed out.\r\n   */\r\n  TIMEOUT: 8,\r\n\r\n  /**\r\n   * The resource is not available offline.\r\n   */\r\n  OFFLINE: 9\r\n};\r\n\r\n\r\n/**\r\n * Returns a friendly error message for an error code. These messages are for\r\n * debugging and are not localized.\r\n * @param {goog.net.ErrorCode} errorCode An error code.\r\n * @return {string} A message for debugging.\r\n */\r\ngoog.net.ErrorCode.getDebugMessage = function(errorCode) {\r\n  switch (errorCode) {\r\n    case goog.net.ErrorCode.NO_ERROR:\r\n      return 'No Error';\r\n\r\n    case goog.net.ErrorCode.ACCESS_DENIED:\r\n      return 'Access denied to content document';\r\n\r\n    case goog.net.ErrorCode.FILE_NOT_FOUND:\r\n      return 'File not found';\r\n\r\n    case goog.net.ErrorCode.FF_SILENT_ERROR:\r\n      return 'Firefox silently errored';\r\n\r\n    case goog.net.ErrorCode.CUSTOM_ERROR:\r\n      return 'Application custom error';\r\n\r\n    case goog.net.ErrorCode.EXCEPTION:\r\n      return 'An exception occurred';\r\n\r\n    case goog.net.ErrorCode.HTTP_ERROR:\r\n      return 'Http response at 400 or 500 level';\r\n\r\n    case goog.net.ErrorCode.ABORT:\r\n      return 'Request was aborted';\r\n\r\n    case goog.net.ErrorCode.TIMEOUT:\r\n      return 'Request timed out';\r\n\r\n    case goog.net.ErrorCode.OFFLINE:\r\n      return 'The resource is not available offline';\r\n\r\n    default:\r\n      return 'Unrecognized error code';\r\n  }\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Common events for the network classes.\r\n */\r\n\r\n\r\ngoog.provide('goog.net.EventType');\r\n\r\n\r\n/**\r\n * Event names for network events\r\n * @enum {string}\r\n */\r\ngoog.net.EventType = {\r\n  COMPLETE: 'complete',\r\n  SUCCESS: 'success',\r\n  ERROR: 'error',\r\n  ABORT: 'abort',\r\n  READY: 'ready',\r\n  READY_STATE_CHANGE: 'readystatechange',\r\n  TIMEOUT: 'timeout',\r\n  INCREMENTAL_DATA: 'incrementaldata',\r\n  PROGRESS: 'progress',\r\n  // DOWNLOAD_PROGRESS and UPLOAD_PROGRESS are special events dispatched by\r\n  // goog.net.XhrIo to allow binding listeners specific to each type of\r\n  // progress.\r\n  DOWNLOAD_PROGRESS: 'downloadprogress',\r\n  UPLOAD_PROGRESS: 'uploadprogress'\r\n};\r\n","// Copyright 2010 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Interface for a factory for creating XMLHttpRequest objects\r\n * and metadata about them.\r\n * @author dbk@google.com (David Barrett-Kahn)\r\n */\r\n\r\ngoog.provide('goog.net.XmlHttpFactory');\r\n\r\n/** @suppress {extraRequire} Typedef. */\r\ngoog.require('goog.net.XhrLike');\r\n\r\n\r\n\r\n/**\r\n * Abstract base class for an XmlHttpRequest factory.\r\n * @constructor\r\n */\r\ngoog.net.XmlHttpFactory = function() {};\r\n\r\n\r\n/**\r\n * Cache of options - we only actually call internalGetOptions once.\r\n * @type {?Object}\r\n * @private\r\n */\r\ngoog.net.XmlHttpFactory.prototype.cachedOptions_ = null;\r\n\r\n\r\n/**\r\n * @return {!goog.net.XhrLike.OrNative} A new XhrLike instance.\r\n */\r\ngoog.net.XmlHttpFactory.prototype.createInstance = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * @return {Object} Options describing how xhr objects obtained from this\r\n *     factory should be used.\r\n */\r\ngoog.net.XmlHttpFactory.prototype.getOptions = function() {\r\n  return this.cachedOptions_ ||\r\n      (this.cachedOptions_ = this.internalGetOptions());\r\n};\r\n\r\n\r\n/**\r\n * Override this method in subclasses to preserve the caching offered by\r\n * getOptions().\r\n * @return {Object} Options describing how xhr objects obtained from this\r\n *     factory should be used.\r\n * @protected\r\n */\r\ngoog.net.XmlHttpFactory.prototype.internalGetOptions = goog.abstractMethod;\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Low level handling of XMLHttpRequest.\r\n * @author arv@google.com (Erik Arvidsson)\r\n * @author dbk@google.com (David Barrett-Kahn)\r\n */\r\n\r\ngoog.provide('goog.net.DefaultXmlHttpFactory');\r\ngoog.provide('goog.net.XmlHttp');\r\ngoog.provide('goog.net.XmlHttp.OptionType');\r\ngoog.provide('goog.net.XmlHttp.ReadyState');\r\ngoog.provide('goog.net.XmlHttpDefines');\r\n\r\ngoog.require('goog.asserts');\r\ngoog.require('goog.net.WrapperXmlHttpFactory');\r\ngoog.require('goog.net.XmlHttpFactory');\r\n\r\n\r\n/**\r\n * Static class for creating XMLHttpRequest objects.\r\n * @return {!goog.net.XhrLike.OrNative} A new XMLHttpRequest object.\r\n */\r\ngoog.net.XmlHttp = function() {\r\n  return goog.net.XmlHttp.factory_.createInstance();\r\n};\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to\r\n *     true bypasses the ActiveX probing code.\r\n * NOTE(ruilopes): Due to the way JSCompiler works, this define *will not* strip\r\n * out the ActiveX probing code from binaries.  To achieve this, use\r\n * `goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR` instead.\r\n * TODO(ruilopes): Collapse both defines.\r\n */\r\ngoog.net.XmlHttp.ASSUME_NATIVE_XHR =\r\n    goog.define('goog.net.XmlHttp.ASSUME_NATIVE_XHR', false);\r\n\r\n\r\n/** @const */\r\ngoog.net.XmlHttpDefines = {};\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to\r\n *     true eliminates the ActiveX probing code.\r\n */\r\ngoog.net.XmlHttpDefines.ASSUME_NATIVE_XHR =\r\n    goog.define('goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR', false);\r\n\r\n\r\n/**\r\n * Gets the options to use with the XMLHttpRequest objects obtained using\r\n * the static methods.\r\n * @return {Object} The options.\r\n */\r\ngoog.net.XmlHttp.getOptions = function() {\r\n  return goog.net.XmlHttp.factory_.getOptions();\r\n};\r\n\r\n\r\n/**\r\n * Type of options that an XmlHttp object can have.\r\n * @enum {number}\r\n */\r\ngoog.net.XmlHttp.OptionType = {\r\n  /**\r\n   * Whether a goog.nullFunction should be used to clear the onreadystatechange\r\n   * handler instead of null.\r\n   */\r\n  USE_NULL_FUNCTION: 0,\r\n\r\n  /**\r\n   * NOTE(user): In IE if send() errors on a *local* request the readystate\r\n   * is still changed to COMPLETE.  We need to ignore it and allow the\r\n   * try/catch around send() to pick up the error.\r\n   */\r\n  LOCAL_REQUEST_ERROR: 1\r\n};\r\n\r\n\r\n/**\r\n * Status constants for XMLHTTP, matches:\r\n * https://msdn.microsoft.com/en-us/library/ms534361(v=vs.85).aspx\r\n * @enum {number}\r\n */\r\ngoog.net.XmlHttp.ReadyState = {\r\n  /**\r\n   * Constant for when xmlhttprequest.readyState is uninitialized\r\n   */\r\n  UNINITIALIZED: 0,\r\n\r\n  /**\r\n   * Constant for when xmlhttprequest.readyState is loading.\r\n   */\r\n  LOADING: 1,\r\n\r\n  /**\r\n   * Constant for when xmlhttprequest.readyState is loaded.\r\n   */\r\n  LOADED: 2,\r\n\r\n  /**\r\n   * Constant for when xmlhttprequest.readyState is in an interactive state.\r\n   */\r\n  INTERACTIVE: 3,\r\n\r\n  /**\r\n   * Constant for when xmlhttprequest.readyState is completed\r\n   */\r\n  COMPLETE: 4\r\n};\r\n\r\n\r\n/**\r\n * The global factory instance for creating XMLHttpRequest objects.\r\n * @type {goog.net.XmlHttpFactory}\r\n * @private\r\n */\r\ngoog.net.XmlHttp.factory_;\r\n\r\n\r\n/**\r\n * Sets the factories for creating XMLHttpRequest objects and their options.\r\n * @param {Function} factory The factory for XMLHttpRequest objects.\r\n * @param {Function} optionsFactory The factory for options.\r\n * @deprecated Use setGlobalFactory instead.\r\n */\r\ngoog.net.XmlHttp.setFactory = function(factory, optionsFactory) {\r\n  goog.net.XmlHttp.setGlobalFactory(\r\n      new goog.net.WrapperXmlHttpFactory(\r\n          goog.asserts.assert(factory), goog.asserts.assert(optionsFactory)));\r\n};\r\n\r\n\r\n/**\r\n * Sets the global factory object.\r\n * @param {!goog.net.XmlHttpFactory} factory New global factory object.\r\n */\r\ngoog.net.XmlHttp.setGlobalFactory = function(factory) {\r\n  goog.net.XmlHttp.factory_ = factory;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Default factory to use when creating xhr objects.  You probably shouldn't be\r\n * instantiating this directly, but rather using it via goog.net.XmlHttp.\r\n * @extends {goog.net.XmlHttpFactory}\r\n * @constructor\r\n */\r\ngoog.net.DefaultXmlHttpFactory = function() {\r\n  goog.net.XmlHttpFactory.call(this);\r\n};\r\ngoog.inherits(goog.net.DefaultXmlHttpFactory, goog.net.XmlHttpFactory);\r\n\r\n\r\n/** @override */\r\ngoog.net.DefaultXmlHttpFactory.prototype.createInstance = function() {\r\n  var progId = this.getProgId_();\r\n  if (progId) {\r\n    return new ActiveXObject(progId);\r\n  } else {\r\n    return new XMLHttpRequest();\r\n  }\r\n};\r\n\r\n\r\n/** @override */\r\ngoog.net.DefaultXmlHttpFactory.prototype.internalGetOptions = function() {\r\n  var progId = this.getProgId_();\r\n  var options = {};\r\n  if (progId) {\r\n    options[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] = true;\r\n    options[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] = true;\r\n  }\r\n  return options;\r\n};\r\n\r\n\r\n/**\r\n * The ActiveX PROG ID string to use to create xhr's in IE. Lazily initialized.\r\n * @type {string|undefined}\r\n * @private\r\n */\r\ngoog.net.DefaultXmlHttpFactory.prototype.ieProgId_;\r\n\r\n\r\n/**\r\n * Initialize the private state used by other functions.\r\n * @return {string} The ActiveX PROG ID string to use to create xhr's in IE.\r\n * @private\r\n */\r\ngoog.net.DefaultXmlHttpFactory.prototype.getProgId_ = function() {\r\n  if (goog.net.XmlHttp.ASSUME_NATIVE_XHR ||\r\n      goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR) {\r\n    return '';\r\n  }\r\n\r\n  // The following blog post describes what PROG IDs to use to create the\r\n  // XMLHTTP object in Internet Explorer:\r\n  // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx\r\n  // However we do not (yet) fully trust that this will be OK for old versions\r\n  // of IE on Win9x so we therefore keep the last 2.\r\n  if (!this.ieProgId_ && typeof XMLHttpRequest == 'undefined' &&\r\n      typeof ActiveXObject != 'undefined') {\r\n    // Candidate Active X types.\r\n    var ACTIVE_X_IDENTS = [\r\n      'MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP',\r\n      'Microsoft.XMLHTTP'\r\n    ];\r\n    for (var i = 0; i < ACTIVE_X_IDENTS.length; i++) {\r\n      var candidate = ACTIVE_X_IDENTS[i];\r\n\r\n      try {\r\n        new ActiveXObject(candidate);\r\n        // NOTE(user): cannot assign progid and return candidate in one line\r\n        // because JSCompiler complaings: BUG 658126\r\n        this.ieProgId_ = candidate;\r\n        return candidate;\r\n      } catch (e) {\r\n        // do nothing; try next choice\r\n      }\r\n    }\r\n\r\n    // couldn't find any matches\r\n    throw new Error(\r\n        'Could not create ActiveXObject. ActiveX might be disabled,' +\r\n        ' or MSXML might not be installed');\r\n  }\r\n\r\n  return /** @type {string} */ (this.ieProgId_);\r\n};\r\n\r\n\r\n// Set the global factory to an instance of the default factory.\r\ngoog.net.XmlHttp.setGlobalFactory(new goog.net.DefaultXmlHttpFactory());\r\n","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview The API spec for the WebChannel messaging library.\r\n *\r\n * Similar to HTML5 WebSocket and Closure BrowserChannel, WebChannel\r\n * offers an abstraction for point-to-point socket-like communication between\r\n * a browser client and a remote origin.\r\n *\r\n * WebChannels are created via <code>WebChannel</code>. Multiple WebChannels\r\n * may be multiplexed over the same WebChannelTransport, which represents\r\n * the underlying physical connectivity over standard wire protocols\r\n * such as HTTP and SPDY.\r\n *\r\n * A WebChannels in turn represents a logical communication channel between\r\n * the client and server end point. A WebChannel remains open for\r\n * as long as the client or server end-point allows.\r\n *\r\n * Messages may be delivered in-order or out-of-order, reliably or unreliably\r\n * over the same WebChannel. Message delivery guarantees of a WebChannel is\r\n * to be specified by the application code; and the choice of the\r\n * underlying wire protocols is completely transparent to the API users.\r\n *\r\n * Client-to-client messaging via WebRTC based transport may also be support\r\n * via the same WebChannel API in future.\r\n *\r\n * Note that we have no immediate plan to move this API out of labs. While\r\n * the implementation is production ready, the API is subject to change\r\n * (addition only):\r\n * 1. Adopt new Web APIs (mainly whatwg streams) and goog.net.streams.\r\n * 2. New programming models for cloud (on the server-side) may require\r\n *    new APIs to be defined.\r\n * 3. WebRTC DataChannel alignment\r\n *\r\n */\r\n\r\ngoog.provide('goog.net.WebChannel');\r\n\r\ngoog.require('goog.events');\r\ngoog.require('goog.events.Event');\r\ngoog.require('goog.events.Listenable');\r\ngoog.require('goog.net.XmlHttpFactory');\r\n\r\n\r\n\r\n/**\r\n * A WebChannel represents a logical bi-directional channel over which the\r\n * client communicates with a remote server that holds the other endpoint\r\n * of the channel. A WebChannel is always created in the context of a shared\r\n * {@link WebChannelTransport} instance. It is up to the underlying client-side\r\n * and server-side implementations to decide how or when multiplexing is\r\n * to be enabled.\r\n *\r\n * @interface\r\n * @extends {EventTarget}\r\n * @extends {goog.events.Listenable}\r\n */\r\ngoog.net.WebChannel = function() {};\r\n\r\n\r\n\r\n/**\r\n * This interface defines a pluggable API to allow WebChannel runtime to support\r\n * customized algorithms in order to recover from transient failures such as\r\n * those failures caused by network or proxies (intermediaries).\r\n *\r\n * The algorithm may also choose to fail-fast, e.g. switch the client to some\r\n * offline mode.\r\n *\r\n * Extra measurements and logging could also be implemented in the custom\r\n * module, which has the full knowledge of all the state transitions\r\n * (due to failures).\r\n *\r\n * A default algorithm will be provided by the webchannel library itself. Custom\r\n * algorithms are expected to be tailored to specific client platforms or\r\n * networking environments, e.g. mobile, cellular network.\r\n *\r\n * @interface\r\n */\r\ngoog.net.WebChannel.FailureRecovery = function() {};\r\n\r\n\r\n/**\r\n * Configuration spec for newly created WebChannel instances.\r\n *\r\n * WebChannels are configured in the context of the containing\r\n * {@link WebChannelTransport}. The configuration parameters are specified\r\n * when a new instance of WebChannel is created via {@link WebChannelTransport}.\r\n *\r\n * messageHeaders: custom headers to be added to every message sent to the\r\n * server. This object is mutable, and custom headers may be changed, removed,\r\n * or added during the runtime after a channel has been opened.\r\n *\r\n * initMessageHeaders: similar to messageHeaders, but any custom headers will\r\n * be sent only once when the channel is opened. Typical usage is to send\r\n * an auth header to the server, which only checks the auth header at the time\r\n * when the channel is opened.\r\n *\r\n * messageContentType: sent as initMessageHeaders via X-WebChannel-Content-Type,\r\n * to inform the server the MIME type of WebChannel messages.\r\n *\r\n * messageUrlParams: custom url query parameters to be added to every message\r\n * sent to the server. This object is mutable, and custom parameters may be\r\n * changed, removed or added during the runtime after a channel has been opened.\r\n *\r\n * clientProtocolHeaderRequired: whether a special header should be added to\r\n * each message so that the server can dispatch webchannel messages without\r\n * knowing the URL path prefix. Defaults to false.\r\n *\r\n * concurrentRequestLimit: the maximum number of in-flight HTTP requests allowed\r\n * when SPDY is enabled. Currently we only detect SPDY in Chrome.\r\n * This parameter defaults to 10. When SPDY is not enabled, this parameter\r\n * will have no effect.\r\n *\r\n * supportsCrossDomainXhr: setting this to true to allow the use of sub-domains\r\n * (as configured by the server) to send XHRs with the CORS withCredentials\r\n * bit set to true.\r\n *\r\n * testUrl: the test URL for detecting connectivity during the initial\r\n * handshake. This parameter defaults to \"/<channel_url>/test\".\r\n *\r\n * sendRawJson: whether to bypass v8 encoding of client-sent messages.\r\n * This defaults to false now due to legacy servers. New applications should\r\n * always configure this option to true.\r\n *\r\n * httpSessionIdParam: the URL parameter name that contains the session id (\r\n * for sticky routing of HTTP requests). When this param is specified, a server\r\n * that supports this option will respond with an opaque session id as part of\r\n * the initial handshake (via the X-HTTP-Session-Id header); and all the\r\n * subsequent requests will contain the httpSessionIdParam. This option will\r\n * take precedence over any duplicated parameter specified with\r\n * messageUrlParams, whose value will be ignored.\r\n *\r\n * httpHeadersOverwriteParam: the URL parameter name to allow custom HTTP\r\n * headers to be overwritten as a URL param to bypass CORS preflight.\r\n * goog.net.rpc.HttpCors is used to encode the HTTP headers.\r\n *\r\n * backgroundChannelTest: whether to run the channel test (detecting networking\r\n * conditions) as a background process so the OPEN event will be fired sooner\r\n * to reduce the initial handshake delay. This option defaults to true.\r\n * The actual background channel test is not fully implemented.\r\n *\r\n * forceLongPolling: whether to force long-polling from client to server.\r\n * This defaults to false. Long-polling may be necessary when a (MITM) proxy\r\n * is buffering data sent by the server.\r\n *\r\n * fastHandshake: enable true 0-RTT message delivery, including\r\n * leveraging QUIC 0-RTT (which requires GET to be used). This option\r\n * defaults to false. Note it is allowed to send messages before Open event is\r\n * received, after a channel has been opened. In order to enable 0-RTT,\r\n * messages will be encoded as part of URL and therefore there needs be a size\r\n * limit for those initial messages that are sent immediately as part of the\r\n * GET handshake request. With sendRawJson=true, this limit is currently set\r\n * to 4K chars and data beyond this limit will be buffered till the handshake\r\n * (1-RTT) finishes. With sendRawJson=false, it's up to the application\r\n * to limit the amount of data that is sent as part of the handshake.\r\n *\r\n * disableRedact: whether to disable logging redact. By default, redact is\r\n * enabled to remove any message payload or user-provided info\r\n * from closure logs.\r\n *\r\n * clientProfile: inform the server about the client profile to enable\r\n * customized configs that are optimized for certain clients or environments.\r\n * Currently this information is sent via X-WebChannel-Client-Profile header.\r\n *\r\n * internalChannelParams: the internal channel parameter name to allow\r\n * experimental channel configurations. Supported options include fastfail,\r\n * baseRetryDelayMs, retryDelaySeedMs, forwardChannelMaxRetries and\r\n * forwardChannelRequestTimeoutMs. Note that these options are subject to\r\n * change.\r\n *\r\n * xmlHttpFactory: allows the caller to override the factory used to create\r\n * XMLHttpRequest objects. This is introduced to disable CORS on firefox OS.\r\n *\r\n * requestRefreshThresholds: client-side thresholds that decide when to refresh\r\n * an underlying HTTP request, to limit memory consumption due to XHR buffering\r\n * or compression context. The client-side thresholds should be signficantly\r\n * smaller than the server-side thresholds. This allows the client to eliminate\r\n * any latency introduced by request refreshing, i.e. an RTT window during which\r\n * messages may be buffered on the server-side. Supported params include\r\n * totalBytesReceived, totalDurationMs.\r\n *\r\n * @typedef {{\r\n *   messageHeaders: (!Object<string, string>|undefined),\r\n *   initMessageHeaders: (!Object<string, string>|undefined),\r\n *   messageContentType: (string|undefined),\r\n *   messageUrlParams: (!Object<string, string>|undefined),\r\n *   clientProtocolHeaderRequired: (boolean|undefined),\r\n *   concurrentRequestLimit: (number|undefined),\r\n *   supportsCrossDomainXhr: (boolean|undefined),\r\n *   testUrl: (string|undefined),\r\n *   sendRawJson: (boolean|undefined),\r\n *   httpSessionIdParam: (string|undefined),\r\n *   httpHeadersOverwriteParam: (string|undefined),\r\n *   backgroundChannelTest: (boolean|undefined),\r\n *   forceLongPolling: (boolean|undefined),\r\n *   fastHandshake: (boolean|undefined),\r\n *   disableRedact: (boolean|undefined),\r\n *   clientProfile: (string|undefined),\r\n *   internalChannelParams: (!Object<string, boolean|number>|undefined),\r\n *   xmlHttpFactory: (!goog.net.XmlHttpFactory|undefined),\r\n *   requestRefreshThresholds: (!Object<string, number>|undefined),\r\n * }}\r\n */\r\ngoog.net.WebChannel.Options;\r\n\r\n\r\n/**\r\n * Types that are allowed as message data.\r\n *\r\n * Note that JS objects (sent by the client) can only have string encoded\r\n * values due to the limitation of the current wire protocol.\r\n *\r\n * Unicode strings (sent by the server) may or may not need be escaped, as\r\n * decided by the server.\r\n *\r\n * @typedef {(!ArrayBuffer|!Blob|!Object<string, !Object|string>|!Array|string)}\r\n */\r\ngoog.net.WebChannel.MessageData;\r\n\r\n\r\n/**\r\n * Open the WebChannel against the URI specified in the constructor.\r\n */\r\ngoog.net.WebChannel.prototype.open = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Close the WebChannel.\r\n *\r\n * This is a full close (shutdown) with no guarantee of FIFO delivery in respect\r\n * to any in-flight messages sent to the server.\r\n *\r\n * If you need such a guarantee, see the Half the halfClose() method.\r\n */\r\ngoog.net.WebChannel.prototype.close = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Half-close the WebChannel.\r\n *\r\n * Half-close semantics:\r\n * 1. delivered as a regular message in FIFO programming order\r\n * 2. the server is expected to return a half-close too (with or without\r\n *    application involved), which will trigger a full close (shutdown)\r\n *    on the client side\r\n * 3. for now, the half-close event defined for server-initiated\r\n *    half-close is not exposed to the client application\r\n * 4. a client-side half-close may be triggered internally when the client\r\n *    receives a half-close from the server; and the client is expected to\r\n *    do a full close after the half-close is acked and delivered\r\n *    on the server-side.\r\n * 5. Full close is always a forced one. See the close() method.\r\n *\r\n * New messages sent after halfClose() will be dropped.\r\n *\r\n * NOTE: This is not yet implemented, and will throw an exception if called.\r\n */\r\ngoog.net.WebChannel.prototype.halfClose = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Sends a message to the server that maintains the other end point of\r\n * the WebChannel.\r\n *\r\n * O-RTT behavior:\r\n * 1. messages sent before open() is called will always be delivered as\r\n *    part of the handshake, i.e. with 0-RTT\r\n * 2. messages sent after open() is called but before the OPEN event\r\n *    is received will be delivered as part of the handshake if\r\n *    send() is called from the same execution context as open().\r\n * 3. otherwise, those messages will be buffered till the handshake\r\n *    is completed (which will fire the OPEN event).\r\n *\r\n * @param {!goog.net.WebChannel.MessageData} message The message to send.\r\n */\r\ngoog.net.WebChannel.prototype.send = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Common events fired by WebChannels.\r\n * @enum {string}\r\n */\r\ngoog.net.WebChannel.EventType = {\r\n  /** Dispatched when the channel is opened. */\r\n  OPEN: goog.events.getUniqueId('open'),\r\n\r\n  /** Dispatched when the channel is closed. */\r\n  CLOSE: goog.events.getUniqueId('close'),\r\n\r\n  /**\r\n   * Dispatched when the channel is aborted due to errors.\r\n   *\r\n   * For backward compatibility reasons, a CLOSE event will also be\r\n   * dispatched, following the ERROR event, which indicates that the channel\r\n   * has been completely shutdown .\r\n   */\r\n  ERROR: goog.events.getUniqueId('error'),\r\n\r\n  /** Dispatched when the channel has received a new message. */\r\n  MESSAGE: goog.events.getUniqueId('message')\r\n};\r\n\r\n\r\n\r\n/**\r\n * The event interface for the MESSAGE event.\r\n *\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\ngoog.net.WebChannel.MessageEvent = function() {\r\n  goog.net.WebChannel.MessageEvent.base(\r\n      this, 'constructor', goog.net.WebChannel.EventType.MESSAGE);\r\n};\r\ngoog.inherits(goog.net.WebChannel.MessageEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * The content of the message received from the server.\r\n *\r\n * @type {!goog.net.WebChannel.MessageData}\r\n */\r\ngoog.net.WebChannel.MessageEvent.prototype.data;\r\n\r\n\r\n/**\r\n * The metadata key when the MESSAGE event represents a metadata message.\r\n *\r\n * @type {string|undefined}\r\n */\r\ngoog.net.WebChannel.MessageEvent.prototype.metadataKey;\r\n\r\n\r\n/**\r\n * WebChannel level error conditions.\r\n *\r\n * Summary of error debugging and reporting in WebChannel:\r\n *\r\n * Network Error\r\n * 1. By default the webchannel library will set the error status to\r\n *    NETWORK_ERROR when a channel has to be aborted or closed. NETWORK_ERROR\r\n *    may be recovered by the application by retrying and opening a new channel.\r\n * 2. There may be lost messages (not acked by the server) when a channel is\r\n *    aborted. Currently we don't have a public API to retrieve messages that\r\n *    are waiting to be acked on the client side. File a bug if you think it\r\n *    is useful to expose such an API.\r\n * 3. Details of why a channel fails are available via closure debug logs,\r\n *    and stats events (see webchannel/requeststats.js). Those are internal\r\n *    stats and are subject to change. File a bug if you think it's useful to\r\n *    version and expose such stats as part of the WebChannel API.\r\n *\r\n * Server Error\r\n * 1. SERVER_ERROR is intended to indicate a non-recoverable condition, e.g.\r\n *    when auth fails.\r\n * 2. We don't currently generate any such errors, because most of the time\r\n *    it's the responsibility of upper-layer frameworks or the application\r\n *    itself to indicate to the client why a webchannel has been failed\r\n *    by the server.\r\n * 3. When a channel is failed by the server explicitly, we still signal\r\n *    NETWORK_ERROR to the client. Explicit server failure may happen when the\r\n *    server does a fail-over, or becomes overloaded, or conducts a forced\r\n *    shutdown etc.\r\n * 4. We use some heuristic to decide if the network (aka cloud) is down\r\n *    v.s. the actual server is down.\r\n *\r\n *  RuntimeProperties.getLastStatusCode is a useful state that we expose to\r\n *  the client to indicate the HTTP response status code of the last HTTP\r\n *  request initiated by the WebChannel client library, for debugging\r\n *  purposes only.\r\n *\r\n *  See WebChannel.Options.backChannelFailureRecovery and\r\n *  WebChannel.FailureRecovery to install a custom failure-recovery algorithm.\r\n *\r\n * @enum {number}\r\n */\r\ngoog.net.WebChannel.ErrorStatus = {\r\n  /** No error has occurred. */\r\n  OK: 0,\r\n\r\n  /** Communication to the server has failed. */\r\n  NETWORK_ERROR: 1,\r\n\r\n  /** The server fails to accept or process the WebChannel. */\r\n  SERVER_ERROR: 2\r\n};\r\n\r\n\r\n\r\n/**\r\n * The event interface for the ERROR event.\r\n *\r\n * @constructor\r\n * @extends {goog.events.Event}\r\n */\r\ngoog.net.WebChannel.ErrorEvent = function() {\r\n  goog.net.WebChannel.ErrorEvent.base(\r\n      this, 'constructor', goog.net.WebChannel.EventType.ERROR);\r\n};\r\ngoog.inherits(goog.net.WebChannel.ErrorEvent, goog.events.Event);\r\n\r\n\r\n/**\r\n * The error status.\r\n *\r\n * @type {!goog.net.WebChannel.ErrorStatus}\r\n */\r\ngoog.net.WebChannel.ErrorEvent.prototype.status;\r\n\r\n\r\n/**\r\n * @return {!goog.net.WebChannel.RuntimeProperties} The runtime properties\r\n * of the WebChannel instance.\r\n */\r\ngoog.net.WebChannel.prototype.getRuntimeProperties = goog.abstractMethod;\r\n\r\n\r\n\r\n/**\r\n * The runtime properties of the WebChannel instance.\r\n *\r\n * This class is defined for debugging and monitoring purposes, as well as for\r\n * runtime functions that the application may choose to manage by itself.\r\n *\r\n * @interface\r\n */\r\ngoog.net.WebChannel.RuntimeProperties = function() {};\r\n\r\n\r\n/**\r\n * @return {number} The effective limit for the number of concurrent HTTP\r\n * requests that are allowed to be made for sending messages from the client\r\n * to the server. When SPDY is not enabled, this limit will be one.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.getConcurrentRequestLimit =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * For applications that need support multiple channels (e.g. from\r\n * different tabs) to the same origin, use this method to decide if SPDY is\r\n * enabled and therefore it is safe to open multiple channels.\r\n *\r\n * If SPDY is disabled, the application may choose to limit the number of active\r\n * channels to one or use other means such as sub-domains to work around\r\n * the browser connection limit.\r\n *\r\n * @return {boolean} Whether SPDY is enabled for the origin against which\r\n * the channel is created.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.isSpdyEnabled =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * @return {number} The number of requests (for sending messages to the server)\r\n * that are pending. If this number is approaching the value of\r\n * getConcurrentRequestLimit(), client-to-server message delivery may experience\r\n * a higher latency.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.getPendingRequestCount =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * For applications to query the current HTTP session id, sent by the server\r\n * during the initial handshake.\r\n *\r\n * @return {?string} the HTTP session id or null if no HTTP session is in use.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.getHttpSessionId =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Experimental API.\r\n *\r\n * This method generates an in-band commit request to the server, which will\r\n * ack the commit request as soon as all messages sent prior to this commit\r\n * request have been committed by the application.\r\n *\r\n * Committing a message has a stronger semantics than delivering a message\r\n * to the application. Detail spec:\r\n * https://github.com/bidiweb/webchannel/blob/master/commit.md\r\n *\r\n * Timeout or cancellation is not supported and the application is expected to\r\n * abort the channel if the commit-ack fails to arrive in time.\r\n *\r\n * ===\r\n *\r\n * This is currently implemented only in the client layer and the commit\r\n * callback will be invoked after all the pending client-sent messages have been\r\n * delivered by the server-side webchannel end-point. This semantics is\r\n * different and weaker than what's required for end-to-end ack which requires\r\n * the server application to ack the in-order delivery of messages that are sent\r\n * before the commit request is issued.\r\n *\r\n * Commit should only be called after the channel open event is received.\r\n * Duplicated commits are allowed and only the last callback is guaranteed.\r\n * Commit called after the channel has been closed will be ignored.\r\n *\r\n * @param {function()} callback The callback will be invoked once an\r\n * ack has been received for the current commit or any newly issued commit.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.commit = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * This method may be used by the application to recover from a peer failure\r\n * or to enable sender-initiated flow-control.\r\n *\r\n * Detail spec: https://github.com/bidiweb/webchannel/blob/master/commit.md\r\n *\r\n * This is not yet implemented.\r\n *\r\n * @return {number} The total number of messages that have not received\r\n * commit-ack from the server; or if no commit has been issued, the number\r\n * of messages that have not been delivered to the server application.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.getNonAckedMessageCount =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * A low water-mark message count to notify the application when the\r\n * flow-control condition is cleared, that is, when the application is\r\n * able to send more messages.\r\n *\r\n * We expect the application to configure a high water-mark message count,\r\n * which is checked via getNonAckedMessageCount(). When the high water-mark\r\n * is exceeded, the application should install a callback via this method\r\n * to be notified when to start to send new messages.\r\n *\r\n * This is not yet implemented.\r\n *\r\n * @param {number} count The low water-mark count. It is an error to pass\r\n * a non-positive value.\r\n * @param {function()} callback The call back to notify the application\r\n * when NonAckedMessageCount is below the specified low water-mark count.\r\n * Any previously registered callback is cleared. This new callback will\r\n * be cleared once it has been fired, or when the channel is closed or aborted.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.notifyNonAckedMessageCount =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Experimental API.\r\n *\r\n * This method registers a callback to handle the commit request sent\r\n * by the server. Commit protocol spec:\r\n * https://github.com/bidiweb/webchannel/blob/master/commit.md\r\n *\r\n * This is not yet implemented.\r\n *\r\n * @param {function(!Object)} callback The callback will take an opaque\r\n * commitId which needs be passed back to the server when an ack-commit\r\n * response is generated by the client application, via ackCommit().\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.onCommit = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Experimental API.\r\n *\r\n * This method is used by the application to generate an ack-commit response\r\n * for the given commitId. Commit protocol spec:\r\n * https://github.com/bidiweb/webchannel/blob/master/commit.md\r\n *\r\n * This is not yet implemented.\r\n *\r\n * @param {!Object} commitId The commitId which denotes the commit request\r\n * from the server that needs be ack'ed.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.ackCommit = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * @return {number} The last HTTP status code received by the channel.\r\n */\r\ngoog.net.WebChannel.RuntimeProperties.prototype.getLastStatusCode =\r\n    goog.abstractMethod;\r\n\r\n\r\n/**\r\n * Enum to indicate the current recovery state.\r\n *\r\n * @enum {string}\r\n */\r\ngoog.net.WebChannel.FailureRecovery.State = {\r\n  /** Initial state. */\r\n  INIT: 'init',\r\n\r\n  /** Once a failure has been detected. */\r\n  FAILED: 'failed',\r\n\r\n  /**\r\n   * Once a recovery operation has been issued, e.g. a new request to resume\r\n   * communication.\r\n   */\r\n  RECOVERING: 'recovering',\r\n\r\n  /** The channel has been closed.  */\r\n  CLOSED: 'closed'\r\n};\r\n\r\n\r\n/**\r\n * Enum to indicate different failure conditions as detected by the webchannel\r\n * runtime.\r\n *\r\n * This enum is to be used only between the runtime and FailureRecovery module,\r\n * and new states are expected to be introduced in future.\r\n *\r\n * @enum {string}\r\n */\r\ngoog.net.WebChannel.FailureRecovery.FailureCondition = {\r\n  /**\r\n   * The HTTP response returned a non-successful http status code.\r\n   */\r\n  HTTP_ERROR: 'http_error',\r\n\r\n  /**\r\n   * The request was aborted.\r\n   */\r\n  ABORT: 'abort',\r\n\r\n  /**\r\n   * The request timed out.\r\n   */\r\n  TIMEOUT: 'timeout',\r\n\r\n  /**\r\n   * Exception was thrown while processing the request/response.\r\n   */\r\n  EXCEPTION: 'exception'\r\n};\r\n\r\n\r\n/**\r\n * @return {!goog.net.WebChannel.FailureRecovery.State} the current state,\r\n * mainly for debugging use.\r\n */\r\ngoog.net.WebChannel.FailureRecovery.prototype.getState = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * This method is for WebChannel runtime to set the current failure condition\r\n * and to provide a callback for the algorithm to signal to the runtime\r\n * when it is time to issue a recovery operation, e.g. a new request to the\r\n * server.\r\n *\r\n * Supported transitions include:\r\n *   INIT->FAILED\r\n *   FAILED->FAILED (re-entry ok)\r\n *   RECOVERY->FAILED.\r\n *\r\n * Ignored if state == CLOSED.\r\n *\r\n * Advanced implementations are expected to track all the state transitions\r\n * and their timestamps for monitoring purposes.\r\n *\r\n * @param {!goog.net.WebChannel.FailureRecovery.FailureCondition} failure The\r\n * new failure condition generated by the WebChannel runtime.\r\n * @param {!Function} operation The callback function to the WebChannel\r\n * runtime to issue a recovery operation, e.g. a new request. E.g. the default\r\n * recovery algorithm will issue timeout-based recovery operations.\r\n * Post-condition for the callback: state transition to RECOVERING.\r\n *\r\n * @return {!goog.net.WebChannel.FailureRecovery.State} The updated state\r\n * as decided by the failure recovery module. Upon a recoverable failure event,\r\n * the state is transitioned to RECOVERING; or the state is transitioned to\r\n * FAILED which indicates a fail-fast decision for the runtime to execute.\r\n */\r\ngoog.net.WebChannel.FailureRecovery.prototype.setFailure = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * The Webchannel runtime needs call this method when webchannel is closed or\r\n * aborted.\r\n *\r\n * Once the instance is closed, any access to the instance will be a no-op.\r\n */\r\ngoog.net.WebChannel.FailureRecovery.prototype.close = goog.abstractMethod;\r\n\r\n\r\n/**\r\n * A request header to indicate to the server the messaging protocol\r\n * each HTTP message is speaking.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_CLIENT_PROTOCOL = 'X-Client-Protocol';\r\n\r\n\r\n/**\r\n * The value for x-client-protocol when the messaging protocol is WebChannel.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_CLIENT_PROTOCOL_WEB_CHANNEL = 'webchannel';\r\n\r\n\r\n/**\r\n * A response header for the server to signal the wire-protocol that\r\n * the browser establishes with the server (or proxy), e.g. \"spdy\" (aka http/2)\r\n * \"quic\". This information avoids the need to use private APIs to decide if\r\n * HTTP requests are multiplexed etc.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_CLIENT_WIRE_PROTOCOL = 'X-Client-Wire-Protocol';\r\n\r\n\r\n/**\r\n * A response header for the server to send back the HTTP session id as part of\r\n * the initial handshake. The value of the HTTP session id is opaque to the\r\n * WebChannel protocol.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_HTTP_SESSION_ID = 'X-HTTP-Session-Id';\r\n\r\n\r\n/**\r\n * A response header for the server to send back any initial response data as a\r\n * header to avoid any possible buffering by an intermediary, which may\r\n * be undesired during the handshake.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_HTTP_INITIAL_RESPONSE = 'X-HTTP-Initial-Response';\r\n\r\n\r\n/**\r\n * A request header for specifying the content-type of WebChannel messages,\r\n * e.g. application-defined JSON encoding styles. Currently this header\r\n * is sent by the client via initMessageHeaders when the channel is opened.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_WEBCHANNEL_CONTENT_TYPE = 'X-WebChannel-Content-Type';\r\n\r\n\r\n/**\r\n * A request header for specifying the client profile in order to apply\r\n * customized config params on the server side, e.g. timeouts.\r\n *\r\n * @type {string}\r\n */\r\ngoog.net.WebChannel.X_WEBCHANNEL_CLIENT_PROFILE = 'X-WebChannel-Client-Profile';\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Definition of the ChannelRequest class. The request\r\n * object encapsulates the logic for making a single request, either for the\r\n * forward channel, back channel, or test channel, to the server. It contains\r\n * the logic for the two types of transports we use:\r\n * XMLHTTP and Image request. It provides timeout detection. More transports\r\n * to be added in future, such as Fetch, WebSocket.\r\n */\r\n\r\n\r\ngoog.provide('goog.labs.net.webChannel.ChannelRequest');\r\n\r\ngoog.require('goog.Timer');\r\ngoog.require('goog.async.Throttle');\r\ngoog.require('goog.events.EventHandler');\r\ngoog.require('goog.labs.net.webChannel.Channel');\r\ngoog.require('goog.labs.net.webChannel.WebChannelDebug');\r\ngoog.require('goog.labs.net.webChannel.environment');\r\ngoog.require('goog.labs.net.webChannel.requestStats');\r\ngoog.require('goog.net.ErrorCode');\r\ngoog.require('goog.net.EventType');\r\ngoog.require('goog.net.WebChannel');\r\ngoog.require('goog.net.XmlHttp');\r\ngoog.require('goog.object');\r\ngoog.require('goog.string');\r\ngoog.require('goog.userAgent');\r\n\r\ngoog.forwardDeclare('goog.Uri');\r\ngoog.forwardDeclare('goog.net.XhrIo');\r\n\r\n\r\n\r\n/**\r\n * A new ChannelRequest is created for each request to the server.\r\n *\r\n * @param {goog.labs.net.webChannel.Channel} channel\r\n *     The channel that owns this request.\r\n * @param {goog.labs.net.webChannel.WebChannelDebug} channelDebug A\r\n *     WebChannelDebug to use for logging.\r\n * @param {string=} opt_sessionId The session id for the channel.\r\n * @param {string|number=} opt_requestId The request id for this request.\r\n * @param {number=} opt_retryId The retry id for this request.\r\n * @constructor\r\n * @struct\r\n * @final\r\n */\r\ngoog.labs.net.webChannel.ChannelRequest = function(\r\n    channel, channelDebug, opt_sessionId, opt_requestId, opt_retryId) {\r\n  /**\r\n   * The channel object that owns the request.\r\n   * @private {goog.labs.net.webChannel.Channel}\r\n   */\r\n  this.channel_ = channel;\r\n\r\n  /**\r\n   * The channel debug to use for logging\r\n   * @private {goog.labs.net.webChannel.WebChannelDebug}\r\n   */\r\n  this.channelDebug_ = channelDebug;\r\n\r\n  /**\r\n   * The Session ID for the channel.\r\n   * @private {string|undefined}\r\n   */\r\n  this.sid_ = opt_sessionId;\r\n\r\n  /**\r\n   * The RID (request ID) for the request.\r\n   * @private {string|number|undefined}\r\n   */\r\n  this.rid_ = opt_requestId;\r\n\r\n  /**\r\n   * The attempt number of the current request.\r\n   * @private {number}\r\n   */\r\n  this.retryId_ = opt_retryId || 1;\r\n\r\n  /**\r\n   * An object to keep track of the channel request event listeners.\r\n   * @private {!goog.events.EventHandler<\r\n   *     !goog.labs.net.webChannel.ChannelRequest>}\r\n   */\r\n  this.eventHandler_ = new goog.events.EventHandler(this);\r\n\r\n  /**\r\n   * The timeout in ms before failing the request.\r\n   * @private {number}\r\n   */\r\n  this.timeout_ = goog.labs.net.webChannel.ChannelRequest.TIMEOUT_MS_;\r\n\r\n  /**\r\n   * A timer for polling responseText in browsers that don't fire\r\n   * onreadystatechange during incremental loading of responseText.\r\n   * @private {goog.Timer}\r\n   */\r\n  this.pollingTimer_ =\r\n      new goog.Timer(goog.labs.net.webChannel.environment.getPollingInterval());\r\n\r\n  /**\r\n   * Extra HTTP headers to add to all the requests sent to the server.\r\n   * @private {Object}\r\n   */\r\n  this.extraHeaders_ = null;\r\n\r\n\r\n  /**\r\n   * Whether the request was successful. This is only set to true after the\r\n   * request successfully completes.\r\n   * @private {boolean}\r\n   */\r\n  this.successful_ = false;\r\n\r\n\r\n  /**\r\n   * The TimerID of the timer used to detect if the request has timed-out.\r\n   * @type {?number}\r\n   * @private\r\n   */\r\n  this.watchDogTimerId_ = null;\r\n\r\n  /**\r\n   * The time in the future when the request will timeout.\r\n   * @private {?number}\r\n   */\r\n  this.watchDogTimeoutTime_ = null;\r\n\r\n  /**\r\n   * The time the request started.\r\n   * @private {?number}\r\n   */\r\n  this.requestStartTime_ = null;\r\n\r\n  /**\r\n   * The type of request (XMLHTTP, IMG)\r\n   * @private {?number}\r\n   */\r\n  this.type_ = null;\r\n\r\n  /**\r\n   * The base Uri for the request. The includes all the parameters except the\r\n   * one that indicates the retry number.\r\n   * @private {goog.Uri}\r\n   */\r\n  this.baseUri_ = null;\r\n\r\n  /**\r\n   * The request Uri that was actually used for the most recent request attempt.\r\n   * @private {goog.Uri}\r\n   */\r\n  this.requestUri_ = null;\r\n\r\n  /**\r\n   * The post data, if the request is a post.\r\n   * @private {?string}\r\n   */\r\n  this.postData_ = null;\r\n\r\n  /**\r\n   * An array of pending messages that we have either received a non-successful\r\n   * response for, or no response at all, and which therefore may or may not\r\n   * have been received by the server.\r\n   * @private {!Array<goog.labs.net.webChannel.Wire.QueuedMap>}\r\n   */\r\n  this.pendingMessages_ = [];\r\n\r\n  /**\r\n   * The XhrLte request if the request is using XMLHTTP\r\n   * @private {goog.net.XhrIo}\r\n   */\r\n  this.xmlHttp_ = null;\r\n\r\n  /**\r\n   * The position of where the next unprocessed chunk starts in the response\r\n   * text.\r\n   * @private {number}\r\n   */\r\n  this.xmlHttpChunkStart_ = 0;\r\n\r\n  /**\r\n   * The verb (Get or Post) for the request.\r\n   * @private {?string}\r\n   */\r\n  this.verb_ = null;\r\n\r\n  /**\r\n   * The last error if the request failed.\r\n   * @private {?goog.labs.net.webChannel.ChannelRequest.Error}\r\n   */\r\n  this.lastError_ = null;\r\n\r\n  /**\r\n   * The last status code received.\r\n   * @private {number}\r\n   */\r\n  this.lastStatusCode_ = -1;\r\n\r\n  /**\r\n   * Whether the request has been cancelled due to a call to cancel.\r\n   * @private {boolean}\r\n   */\r\n  this.cancelled_ = false;\r\n\r\n  /**\r\n   * A throttle time in ms for readystatechange events for the backchannel.\r\n   * Useful for throttling when ready state is INTERACTIVE (partial data).\r\n   * If set to zero no throttle is used.\r\n   *\r\n   * See WebChannelBase.prototype.readyStateChangeThrottleMs_\r\n   *\r\n   * @private {number}\r\n   */\r\n  this.readyStateChangeThrottleMs_ = 0;\r\n\r\n  /**\r\n   * The throttle for readystatechange events for the current request, or null\r\n   * if there is none.\r\n   * @private {goog.async.Throttle}\r\n   */\r\n  this.readyStateChangeThrottle_ = null;\r\n\r\n  /**\r\n   * Whether to the result is expected to be encoded for chunking and thus\r\n   * requires decoding.\r\n   * @private {boolean}\r\n   */\r\n  this.decodeChunks_ = false;\r\n\r\n  /**\r\n   * Whether to decode x-http-initial-response.\r\n   * @private {boolean}\r\n   */\r\n  this.decodeInitialResponse_ = false;\r\n\r\n  /**\r\n   * Whether x-http-initial-response has been decoded (dispatched).\r\n   * @private {boolean}\r\n   */\r\n  this.initialResponseDecoded_ = false;\r\n};\r\n\r\n\r\ngoog.scope(function() {\r\nvar WebChannel = goog.net.WebChannel;\r\nvar Channel = goog.labs.net.webChannel.Channel;\r\nvar ChannelRequest = goog.labs.net.webChannel.ChannelRequest;\r\nvar requestStats = goog.labs.net.webChannel.requestStats;\r\nvar WebChannelDebug = goog.labs.net.webChannel.WebChannelDebug;\r\nvar environment = goog.labs.net.webChannel.environment;\r\n\r\n\r\n/**\r\n * Default timeout in MS for a request. The server must return data within this\r\n * time limit for the request to not timeout.\r\n * @private {number}\r\n */\r\nChannelRequest.TIMEOUT_MS_ = 45 * 1000;\r\n\r\n\r\n/**\r\n * Enum for channel requests type\r\n * @enum {number}\r\n * @private\r\n */\r\nChannelRequest.Type_ = {\r\n  /**\r\n   * XMLHTTP requests.\r\n   */\r\n  XML_HTTP: 1,\r\n\r\n  /**\r\n   * IMG requests.\r\n   */\r\n  CLOSE_REQUEST: 2\r\n};\r\n\r\n\r\n/**\r\n * Enum type for identifying an error.\r\n * @enum {number}\r\n */\r\nChannelRequest.Error = {\r\n  /**\r\n   * Errors due to a non-200 status code.\r\n   */\r\n  STATUS: 0,\r\n\r\n  /**\r\n   * Errors due to no data being returned.\r\n   */\r\n  NO_DATA: 1,\r\n\r\n  /**\r\n   * Errors due to a timeout.\r\n   */\r\n  TIMEOUT: 2,\r\n\r\n  /**\r\n   * Errors due to the server returning an unknown.\r\n   */\r\n  UNKNOWN_SESSION_ID: 3,\r\n\r\n  /**\r\n   * Errors due to bad data being received.\r\n   */\r\n  BAD_DATA: 4,\r\n\r\n  /**\r\n   * Errors due to the handler throwing an exception.\r\n   */\r\n  HANDLER_EXCEPTION: 5,\r\n\r\n  /**\r\n   * The browser declared itself offline during the request.\r\n   */\r\n  BROWSER_OFFLINE: 6\r\n};\r\n\r\n\r\n/**\r\n * Returns a useful error string for debugging based on the specified error\r\n * code.\r\n * @param {?ChannelRequest.Error} errorCode The error code.\r\n * @param {number} statusCode The HTTP status code.\r\n * @return {string} The error string for the given code combination.\r\n */\r\nChannelRequest.errorStringFromCode = function(errorCode, statusCode) {\r\n  switch (errorCode) {\r\n    case ChannelRequest.Error.STATUS:\r\n      return 'Non-200 return code (' + statusCode + ')';\r\n    case ChannelRequest.Error.NO_DATA:\r\n      return 'XMLHTTP failure (no data)';\r\n    case ChannelRequest.Error.TIMEOUT:\r\n      return 'HttpConnection timeout';\r\n    default:\r\n      return 'Unknown error';\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Sentinel value used to indicate an invalid chunk in a multi-chunk response.\r\n * @private {Object}\r\n */\r\nChannelRequest.INVALID_CHUNK_ = {};\r\n\r\n\r\n/**\r\n * Sentinel value used to indicate an incomplete chunk in a multi-chunk\r\n * response.\r\n * @private {Object}\r\n */\r\nChannelRequest.INCOMPLETE_CHUNK_ = {};\r\n\r\n\r\n/**\r\n * Returns whether XHR streaming is supported on this browser.\r\n *\r\n * @return {boolean} Whether XHR streaming is supported.\r\n * @see http://code.google.com/p/closure-library/issues/detail?id=346\r\n */\r\nChannelRequest.supportsXhrStreaming = function() {\r\n  return !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(10);\r\n};\r\n\r\n\r\n/**\r\n * Sets extra HTTP headers to add to all the requests sent to the server.\r\n *\r\n * @param {Object} extraHeaders The HTTP headers.\r\n */\r\nChannelRequest.prototype.setExtraHeaders = function(extraHeaders) {\r\n  this.extraHeaders_ = extraHeaders;\r\n};\r\n\r\n\r\n/**\r\n * Overrides the default HTTP method.\r\n *\r\n * @param {string} verb The HTTP method\r\n */\r\nChannelRequest.prototype.setVerb = function(verb) {\r\n  this.verb_ = verb;\r\n};\r\n\r\n\r\n/**\r\n * Sets the timeout for a request\r\n *\r\n * @param {number} timeout   The timeout in MS for when we fail the request.\r\n */\r\nChannelRequest.prototype.setTimeout = function(timeout) {\r\n  this.timeout_ = timeout;\r\n};\r\n\r\n\r\n/**\r\n * Sets the throttle for handling onreadystatechange events for the request.\r\n *\r\n * @param {number} throttle The throttle in ms.  A value of zero indicates\r\n *     no throttle.\r\n */\r\nChannelRequest.prototype.setReadyStateChangeThrottle = function(throttle) {\r\n  this.readyStateChangeThrottleMs_ = throttle;\r\n};\r\n\r\n\r\n/**\r\n * Sets the pending messages that this request is handling.\r\n *\r\n * @param {!Array<goog.labs.net.webChannel.Wire.QueuedMap>} pendingMessages\r\n *     The pending messages for this request.\r\n */\r\nChannelRequest.prototype.setPendingMessages = function(pendingMessages) {\r\n  this.pendingMessages_ = pendingMessages;\r\n};\r\n\r\n\r\n/**\r\n * Gets the pending messages that this request is handling, in case of a retry.\r\n *\r\n * @return {!Array<goog.labs.net.webChannel.Wire.QueuedMap>} The pending\r\n *     messages for this request.\r\n */\r\nChannelRequest.prototype.getPendingMessages = function() {\r\n  return this.pendingMessages_;\r\n};\r\n\r\n\r\n/**\r\n * Uses XMLHTTP to send an HTTP POST to the server.\r\n *\r\n * @param {goog.Uri} uri  The uri of the request.\r\n * @param {?string} postData  The data for the post body.\r\n * @param {boolean} decodeChunks  Whether to the result is expected to be\r\n *     encoded for chunking and thus requires decoding.\r\n */\r\nChannelRequest.prototype.xmlHttpPost = function(uri, postData, decodeChunks) {\r\n  this.type_ = ChannelRequest.Type_.XML_HTTP;\r\n  this.baseUri_ = uri.clone().makeUnique();\r\n  this.postData_ = postData;\r\n  this.decodeChunks_ = decodeChunks;\r\n  this.sendXmlHttp_(null /* hostPrefix */);\r\n};\r\n\r\n\r\n/**\r\n * Uses XMLHTTP to send an HTTP GET to the server.\r\n *\r\n * @param {goog.Uri} uri  The uri of the request.\r\n * @param {boolean} decodeChunks  Whether to the result is expected to be\r\n *     encoded for chunking and thus requires decoding.\r\n * @param {?string} hostPrefix  The host prefix, if we might be using a\r\n *     secondary domain.  Note that it should also be in the URL, adding this\r\n *     won't cause it to be added to the URL.\r\n */\r\nChannelRequest.prototype.xmlHttpGet = function(uri, decodeChunks, hostPrefix) {\r\n  this.type_ = ChannelRequest.Type_.XML_HTTP;\r\n  this.baseUri_ = uri.clone().makeUnique();\r\n  this.postData_ = null;\r\n  this.decodeChunks_ = decodeChunks;\r\n\r\n  this.sendXmlHttp_(hostPrefix);\r\n};\r\n\r\n\r\n/**\r\n * Sends a request via XMLHTTP according to the current state of the request\r\n * object.\r\n *\r\n * @param {?string} hostPrefix The host prefix, if we might be using a secondary\r\n *     domain.\r\n * @private\r\n */\r\nChannelRequest.prototype.sendXmlHttp_ = function(hostPrefix) {\r\n  this.requestStartTime_ = goog.now();\r\n  this.ensureWatchDogTimer_();\r\n\r\n  // clone the base URI to create the request URI. The request uri has the\r\n  // attempt number as a parameter which helps in debugging.\r\n  this.requestUri_ = this.baseUri_.clone();\r\n  this.requestUri_.setParameterValues('t', this.retryId_);\r\n\r\n  // send the request either as a POST or GET\r\n  this.xmlHttpChunkStart_ = 0;\r\n  var useSecondaryDomains = this.channel_.shouldUseSecondaryDomains();\r\n  this.xmlHttp_ =\r\n      this.channel_.createXhrIo(useSecondaryDomains ? hostPrefix : null);\r\n\r\n  if (this.readyStateChangeThrottleMs_ > 0) {\r\n    this.readyStateChangeThrottle_ = new goog.async.Throttle(\r\n        goog.bind(this.xmlHttpHandler_, this, this.xmlHttp_),\r\n        this.readyStateChangeThrottleMs_);\r\n  }\r\n\r\n  this.eventHandler_.listen(\r\n      this.xmlHttp_, goog.net.EventType.READY_STATE_CHANGE,\r\n      this.readyStateChangeHandler_);\r\n\r\n  var headers = this.extraHeaders_ ? goog.object.clone(this.extraHeaders_) : {};\r\n  if (this.postData_) {\r\n    if (!this.verb_) {\r\n      this.verb_ = 'POST';\r\n    }\r\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n    this.xmlHttp_.send(this.requestUri_, this.verb_, this.postData_, headers);\r\n  } else {\r\n    this.verb_ = 'GET';\r\n    this.xmlHttp_.send(this.requestUri_, this.verb_, null, headers);\r\n  }\r\n  requestStats.notifyServerReachabilityEvent(\r\n      requestStats.ServerReachability.REQUEST_MADE);\r\n  this.channelDebug_.xmlHttpChannelRequest(\r\n      this.verb_, this.requestUri_, this.rid_, this.retryId_, this.postData_);\r\n};\r\n\r\n\r\n/**\r\n * Handles a readystatechange event.\r\n * @param {goog.events.Event} evt The event.\r\n * @private\r\n */\r\nChannelRequest.prototype.readyStateChangeHandler_ = function(evt) {\r\n  var xhr = /** @type {goog.net.XhrIo} */ (evt.target);\r\n  var throttle = this.readyStateChangeThrottle_;\r\n  if (throttle &&\r\n      xhr.getReadyState() == goog.net.XmlHttp.ReadyState.INTERACTIVE) {\r\n    // Only throttle in the partial data case.\r\n    this.channelDebug_.debug('Throttling readystatechange.');\r\n    throttle.fire();\r\n  } else {\r\n    // If we haven't throttled, just handle response directly.\r\n    this.xmlHttpHandler_(xhr);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * XmlHttp handler\r\n * @param {goog.net.XhrIo} xmlhttp The XhrIo object for the current request.\r\n * @private\r\n */\r\nChannelRequest.prototype.xmlHttpHandler_ = function(xmlhttp) {\r\n  requestStats.onStartExecution();\r\n\r\n\r\n  try {\r\n    if (xmlhttp == this.xmlHttp_) {\r\n      this.onXmlHttpReadyStateChanged_();\r\n    } else {\r\n      this.channelDebug_.warning(\r\n          'Called back with an ' +\r\n          'unexpected xmlhttp');\r\n    }\r\n  } catch (ex) {\r\n    this.channelDebug_.debug('Failed call to OnXmlHttpReadyStateChanged_');\r\n    if (this.xmlHttp_ && this.xmlHttp_.getResponseText()) {\r\n      var channelRequest = this;\r\n      this.channelDebug_.dumpException(ex, function() {\r\n        return 'ResponseText: ' + channelRequest.xmlHttp_.getResponseText();\r\n      });\r\n    } else {\r\n      this.channelDebug_.dumpException(ex, 'No response text');\r\n    }\r\n  } finally {\r\n    requestStats.onEndExecution();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called by the readystate handler for XMLHTTP requests.\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.onXmlHttpReadyStateChanged_ = function() {\r\n  var readyState = this.xmlHttp_.getReadyState();\r\n  var errorCode = this.xmlHttp_.getLastErrorCode();\r\n  var statusCode = this.xmlHttp_.getStatus();\r\n\r\n  // we get partial results in browsers that support ready state interactive.\r\n  // We also make sure that getResponseText is not null in interactive mode\r\n  // before we continue.\r\n  if (readyState < goog.net.XmlHttp.ReadyState.INTERACTIVE ||\r\n      (readyState == goog.net.XmlHttp.ReadyState.INTERACTIVE &&\r\n       !environment.isPollingRequired() &&  // otherwise, go on to startPolling\r\n       !this.xmlHttp_.getResponseText())) {\r\n    return;  // not yet ready\r\n  }\r\n\r\n  // Dispatch any appropriate network events.\r\n  if (!this.cancelled_ && readyState == goog.net.XmlHttp.ReadyState.COMPLETE &&\r\n      errorCode != goog.net.ErrorCode.ABORT) {\r\n    // Pretty conservative, these are the only known scenarios which we'd\r\n    // consider indicative of a truly non-functional network connection.\r\n    if (errorCode == goog.net.ErrorCode.TIMEOUT || statusCode <= 0) {\r\n      requestStats.notifyServerReachabilityEvent(\r\n          requestStats.ServerReachability.REQUEST_FAILED);\r\n    } else {\r\n      requestStats.notifyServerReachabilityEvent(\r\n          requestStats.ServerReachability.REQUEST_SUCCEEDED);\r\n    }\r\n  }\r\n\r\n  // got some data so cancel the watchdog timer\r\n  this.cancelWatchDogTimer_();\r\n\r\n  var status = this.xmlHttp_.getStatus();\r\n  this.lastStatusCode_ = status;\r\n  var responseText = this.xmlHttp_.getResponseText();\r\n  if (!responseText) {\r\n    var channelRequest = this;\r\n    this.channelDebug_.debug(function() {\r\n      return 'No response text for uri ' + channelRequest.requestUri_ +\r\n          ' status ' + status;\r\n    });\r\n  }\r\n  this.successful_ = (status == 200);\r\n\r\n  this.channelDebug_.xmlHttpChannelResponseMetaData(\r\n      /** @type {string} */ (this.verb_), this.requestUri_, this.rid_,\r\n      this.retryId_, readyState, status);\r\n\r\n  if (!this.successful_) {\r\n    if (status == 400 && responseText.indexOf('Unknown SID') > 0) {\r\n      // the server error string will include 'Unknown SID' which indicates the\r\n      // server doesn't know about the session (maybe it got restarted, maybe\r\n      // the user got moved to another server, etc.,). Handlers can special\r\n      // case this error\r\n      this.lastError_ = ChannelRequest.Error.UNKNOWN_SESSION_ID;\r\n      requestStats.notifyStatEvent(\r\n          requestStats.Stat.REQUEST_UNKNOWN_SESSION_ID);\r\n      this.channelDebug_.warning('XMLHTTP Unknown SID (' + this.rid_ + ')');\r\n    } else {\r\n      this.lastError_ = ChannelRequest.Error.STATUS;\r\n      requestStats.notifyStatEvent(requestStats.Stat.REQUEST_BAD_STATUS);\r\n      this.channelDebug_.warning(\r\n          'XMLHTTP Bad status ' + status + ' (' + this.rid_ + ')');\r\n    }\r\n    this.cleanup_();\r\n    this.dispatchFailure_();\r\n    return;\r\n  }\r\n\r\n  if (this.shouldCheckInitialResponse_()) {\r\n    var initialResponse = this.getInitialResponse_();\r\n    if (initialResponse) {\r\n      this.channelDebug_.xmlHttpChannelResponseText(\r\n          this.rid_, initialResponse,\r\n          'Initial handshake response via ' +\r\n              WebChannel.X_HTTP_INITIAL_RESPONSE);\r\n      this.initialResponseDecoded_ = true;\r\n      this.safeOnRequestData_(initialResponse);\r\n    } else {\r\n      this.successful_ = false;\r\n      this.lastError_ = ChannelRequest.Error.UNKNOWN_SESSION_ID;  // fail-fast\r\n      requestStats.notifyStatEvent(\r\n          requestStats.Stat.REQUEST_UNKNOWN_SESSION_ID);\r\n      this.channelDebug_.warning(\r\n          'XMLHTTP Missing X_HTTP_INITIAL_RESPONSE' +\r\n          ' (' + this.rid_ + ')');\r\n      this.cleanup_();\r\n      this.dispatchFailure_();\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (this.decodeChunks_) {\r\n    this.decodeNextChunks_(readyState, responseText);\r\n    if (environment.isPollingRequired() && this.successful_ &&\r\n        readyState == goog.net.XmlHttp.ReadyState.INTERACTIVE) {\r\n      this.startPolling_();\r\n    }\r\n  } else {\r\n    this.channelDebug_.xmlHttpChannelResponseText(\r\n        this.rid_, responseText, null);\r\n    this.safeOnRequestData_(responseText);\r\n  }\r\n\r\n  if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {\r\n    this.cleanup_();\r\n  }\r\n\r\n  if (!this.successful_) {\r\n    return;\r\n  }\r\n\r\n  if (!this.cancelled_) {\r\n    if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {\r\n      this.channel_.onRequestComplete(this);\r\n    } else {\r\n      // The default is false, the result from this callback shouldn't carry\r\n      // over to the next callback, otherwise the request looks successful if\r\n      // the watchdog timer gets called\r\n      this.successful_ = false;\r\n      this.ensureWatchDogTimer_();\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Whether we need check the initial-response header that is sent during the\r\n * fast handshake.\r\n *\r\n * @return {boolean} true if the initial-response header is yet to be processed.\r\n * @private\r\n */\r\nChannelRequest.prototype.shouldCheckInitialResponse_ = function() {\r\n  return this.decodeInitialResponse_ && !this.initialResponseDecoded_;\r\n};\r\n\r\n\r\n/**\r\n * Queries the initial response header that is sent during the handshake.\r\n *\r\n * @return {?string} The non-empty header value or null.\r\n * @private\r\n */\r\nChannelRequest.prototype.getInitialResponse_ = function() {\r\n  if (this.xmlHttp_) {\r\n    var value = this.xmlHttp_.getStreamingResponseHeader(\r\n        WebChannel.X_HTTP_INITIAL_RESPONSE);\r\n    if (value && !goog.string.isEmptyOrWhitespace(value)) {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n\r\n/**\r\n * Check if the initial response header has been handled.\r\n *\r\n * @return {boolean} true if X_HTTP_INITIAL_RESPONSE has been handled.\r\n */\r\nChannelRequest.prototype.isInitialResponseDecoded = function() {\r\n  return this.initialResponseDecoded_;\r\n};\r\n\r\n\r\n/**\r\n * Decodes X_HTTP_INITIAL_RESPONSE if present.\r\n */\r\nChannelRequest.prototype.setDecodeInitialResponse = function() {\r\n  this.decodeInitialResponse_ = true;\r\n};\r\n\r\n\r\n/**\r\n * Decodes the next set of available chunks in the response.\r\n * @param {number} readyState The value of readyState.\r\n * @param {string} responseText The value of responseText.\r\n * @private\r\n */\r\nChannelRequest.prototype.decodeNextChunks_ = function(\r\n    readyState, responseText) {\r\n  var decodeNextChunksSuccessful = true;\r\n  while (!this.cancelled_ && this.xmlHttpChunkStart_ < responseText.length) {\r\n    var chunkText = this.getNextChunk_(responseText);\r\n    if (chunkText == ChannelRequest.INCOMPLETE_CHUNK_) {\r\n      if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE) {\r\n        // should have consumed entire response when the request is done\r\n        this.lastError_ = ChannelRequest.Error.BAD_DATA;\r\n        requestStats.notifyStatEvent(requestStats.Stat.REQUEST_INCOMPLETE_DATA);\r\n        decodeNextChunksSuccessful = false;\r\n      }\r\n      this.channelDebug_.xmlHttpChannelResponseText(\r\n          this.rid_, null, '[Incomplete Response]');\r\n      break;\r\n    } else if (chunkText == ChannelRequest.INVALID_CHUNK_) {\r\n      this.lastError_ = ChannelRequest.Error.BAD_DATA;\r\n      requestStats.notifyStatEvent(requestStats.Stat.REQUEST_BAD_DATA);\r\n      this.channelDebug_.xmlHttpChannelResponseText(\r\n          this.rid_, responseText, '[Invalid Chunk]');\r\n      decodeNextChunksSuccessful = false;\r\n      break;\r\n    } else {\r\n      this.channelDebug_.xmlHttpChannelResponseText(\r\n          this.rid_, /** @type {string} */ (chunkText), null);\r\n      this.safeOnRequestData_(/** @type {string} */ (chunkText));\r\n    }\r\n  }\r\n  if (readyState == goog.net.XmlHttp.ReadyState.COMPLETE &&\r\n      responseText.length == 0) {\r\n    // also an error if we didn't get any response\r\n    this.lastError_ = ChannelRequest.Error.NO_DATA;\r\n    requestStats.notifyStatEvent(requestStats.Stat.REQUEST_NO_DATA);\r\n    decodeNextChunksSuccessful = false;\r\n  }\r\n  this.successful_ = this.successful_ && decodeNextChunksSuccessful;\r\n  if (!decodeNextChunksSuccessful) {\r\n    // malformed response - we make this trigger retry logic\r\n    this.channelDebug_.xmlHttpChannelResponseText(\r\n        this.rid_, responseText, '[Invalid Chunked Response]');\r\n    this.cleanup_();\r\n    this.dispatchFailure_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Polls the response for new data.\r\n * @private\r\n */\r\nChannelRequest.prototype.pollResponse_ = function() {\r\n  if (!this.xmlHttp_) {\r\n    return;  // already closed\r\n  }\r\n  var readyState = this.xmlHttp_.getReadyState();\r\n  var responseText = this.xmlHttp_.getResponseText();\r\n  if (this.xmlHttpChunkStart_ < responseText.length) {\r\n    this.cancelWatchDogTimer_();\r\n    this.decodeNextChunks_(readyState, responseText);\r\n    if (this.successful_ &&\r\n        readyState != goog.net.XmlHttp.ReadyState.COMPLETE) {\r\n      this.ensureWatchDogTimer_();\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Starts a polling interval for changes to responseText of the\r\n * XMLHttpRequest, for browsers that don't fire onreadystatechange\r\n * as data comes in incrementally.  This timer is disabled in\r\n * cleanup_().\r\n * @private\r\n */\r\nChannelRequest.prototype.startPolling_ = function() {\r\n  this.eventHandler_.listen(\r\n      this.pollingTimer_, goog.Timer.TICK, this.pollResponse_);\r\n  this.pollingTimer_.start();\r\n};\r\n\r\n\r\n/**\r\n * Returns the next chunk of a chunk-encoded response. This is not standard\r\n * HTTP chunked encoding because browsers don't expose the chunk boundaries to\r\n * the application through XMLHTTP. So we have an additional chunk encoding at\r\n * the application level that lets us tell where the beginning and end of\r\n * individual responses are so that we can only try to eval a complete JS array.\r\n *\r\n * The encoding is the size of the chunk encoded as a decimal string followed\r\n * by a newline followed by the data.\r\n *\r\n * @param {string} responseText The response text from the XMLHTTP response.\r\n * @return {string|Object} The next chunk string or a sentinel object\r\n *                         indicating a special condition.\r\n * @private\r\n */\r\nChannelRequest.prototype.getNextChunk_ = function(responseText) {\r\n  var sizeStartIndex = this.xmlHttpChunkStart_;\r\n  var sizeEndIndex = responseText.indexOf('\\n', sizeStartIndex);\r\n  if (sizeEndIndex == -1) {\r\n    return ChannelRequest.INCOMPLETE_CHUNK_;\r\n  }\r\n\r\n  var sizeAsString = responseText.substring(sizeStartIndex, sizeEndIndex);\r\n  var size = Number(sizeAsString);\r\n  if (isNaN(size)) {\r\n    return ChannelRequest.INVALID_CHUNK_;\r\n  }\r\n\r\n  var chunkStartIndex = sizeEndIndex + 1;\r\n  if (chunkStartIndex + size > responseText.length) {\r\n    return ChannelRequest.INCOMPLETE_CHUNK_;\r\n  }\r\n\r\n  var chunkText = responseText.substr(chunkStartIndex, size);\r\n  this.xmlHttpChunkStart_ = chunkStartIndex + size;\r\n  return chunkText;\r\n};\r\n\r\n\r\n/**\r\n * Uses an IMG tag or navigator.sendBeacon to send an HTTP get to the server.\r\n *\r\n * This is only currently used to terminate the connection, as an IMG tag is\r\n * the most reliable way to send something to the server while the page\r\n * is getting torn down.\r\n *\r\n * Navigator.sendBeacon is available on Chrome and Firefox as a formal\r\n * solution to ensure delivery without blocking window close. See\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\r\n *\r\n * For Chrome Apps, sendBeacon is always necessary due to Content Security\r\n * Policy (CSP) violation of using an IMG tag.\r\n *\r\n * For react-native, we use xhr to send the actual close request, and assume\r\n * there is no page-close issue with react-native.\r\n *\r\n * @param {goog.Uri} uri The uri to send a request to.\r\n */\r\nChannelRequest.prototype.sendCloseRequest = function(uri) {\r\n  this.type_ = ChannelRequest.Type_.CLOSE_REQUEST;\r\n  this.baseUri_ = uri.clone().makeUnique();\r\n\r\n  var requestSent = false;\r\n\r\n  if (goog.global.navigator && goog.global.navigator.sendBeacon) {\r\n    // empty string body to avoid 413 error on chrome < 41\r\n    requestSent =\r\n        goog.global.navigator.sendBeacon(this.baseUri_.toString(), '');\r\n  }\r\n\r\n  if (!requestSent && goog.global.Image) {\r\n    var eltImg = new Image();\r\n    eltImg.src = this.baseUri_;\r\n    requestSent = true;\r\n  }\r\n\r\n  if (!requestSent) {\r\n    // no handler is set to match the sendBeacon/Image behavior\r\n    this.xmlHttp_ = this.channel_.createXhrIo(null);\r\n    this.xmlHttp_.send(this.baseUri_);\r\n  }\r\n\r\n  this.requestStartTime_ = goog.now();\r\n  this.ensureWatchDogTimer_();\r\n};\r\n\r\n\r\n/**\r\n * Cancels the request no matter what the underlying transport is.\r\n */\r\nChannelRequest.prototype.cancel = function() {\r\n  this.cancelled_ = true;\r\n  this.cleanup_();\r\n};\r\n\r\n\r\n/**\r\n * Resets the timeout.\r\n *\r\n * @param {number=} opt_timeout The new timeout\r\n */\r\nChannelRequest.prototype.resetTimeout = function(opt_timeout) {\r\n  if (opt_timeout) {\r\n    this.setTimeout(opt_timeout);\r\n  }\r\n  // restart only if a timer is currently set\r\n  if (this.watchDogTimerId_) {\r\n    this.cancelWatchDogTimer_();\r\n    this.ensureWatchDogTimer_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Ensures that there is watchdog timeout which is used to ensure that\r\n * the connection completes in time.\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.ensureWatchDogTimer_ = function() {\r\n  this.watchDogTimeoutTime_ = goog.now() + this.timeout_;\r\n  this.startWatchDogTimer_(this.timeout_);\r\n};\r\n\r\n\r\n/**\r\n * Starts the watchdog timer which is used to ensure that the connection\r\n * completes in time.\r\n * @param {number} time The number of milliseconds to wait.\r\n * @private\r\n */\r\nChannelRequest.prototype.startWatchDogTimer_ = function(time) {\r\n  if (this.watchDogTimerId_ != null) {\r\n    // assertion\r\n    throw new Error('WatchDog timer not null');\r\n  }\r\n  this.watchDogTimerId_ =\r\n      requestStats.setTimeout(goog.bind(this.onWatchDogTimeout_, this), time);\r\n};\r\n\r\n\r\n/**\r\n * Cancels the watchdog timer if it has been started.\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.cancelWatchDogTimer_ = function() {\r\n  if (this.watchDogTimerId_) {\r\n    goog.global.clearTimeout(this.watchDogTimerId_);\r\n    this.watchDogTimerId_ = null;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called when the watchdog timer is triggered. It also handles a case where it\r\n * is called too early which we suspect may be happening sometimes\r\n * (not sure why)\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.onWatchDogTimeout_ = function() {\r\n  this.watchDogTimerId_ = null;\r\n  var now = goog.now();\r\n  if (now - this.watchDogTimeoutTime_ >= 0) {\r\n    this.handleTimeout_();\r\n  } else {\r\n    // got called too early for some reason\r\n    this.channelDebug_.warning('WatchDog timer called too early');\r\n    this.startWatchDogTimer_(this.watchDogTimeoutTime_ - now);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called when the request has actually timed out. Will cleanup and notify the\r\n * channel of the failure.\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.handleTimeout_ = function() {\r\n  if (this.successful_) {\r\n    // Should never happen.\r\n    this.channelDebug_.severe(\r\n        'Received watchdog timeout even though request loaded successfully');\r\n  }\r\n\r\n  this.channelDebug_.timeoutResponse(this.requestUri_);\r\n\r\n  // IMG or SendBeacon requests never notice if they were successful,\r\n  // and always 'time out'. This fact says nothing about reachability.\r\n  if (this.type_ != ChannelRequest.Type_.CLOSE_REQUEST) {\r\n    requestStats.notifyServerReachabilityEvent(\r\n        requestStats.ServerReachability.REQUEST_FAILED);\r\n    requestStats.notifyStatEvent(requestStats.Stat.REQUEST_TIMEOUT);\r\n  }\r\n\r\n  this.cleanup_();\r\n\r\n  // Set error and dispatch failure.\r\n  // This is called for CLOSE_REQUEST too to ensure channel_.onRequestComplete.\r\n  this.lastError_ = ChannelRequest.Error.TIMEOUT;\r\n  this.dispatchFailure_();\r\n};\r\n\r\n\r\n/**\r\n * Notifies the channel that this request failed.\r\n * @private\r\n */\r\nChannelRequest.prototype.dispatchFailure_ = function() {\r\n  if (this.channel_.isClosed() || this.cancelled_) {\r\n    return;\r\n  }\r\n\r\n  this.channel_.onRequestComplete(this);\r\n};\r\n\r\n\r\n/**\r\n * Cleans up the objects used to make the request. This function is\r\n * idempotent.\r\n *\r\n * @private\r\n */\r\nChannelRequest.prototype.cleanup_ = function() {\r\n  this.cancelWatchDogTimer_();\r\n\r\n  goog.dispose(this.readyStateChangeThrottle_);\r\n  this.readyStateChangeThrottle_ = null;\r\n\r\n  // Stop the polling timer, if necessary.\r\n  this.pollingTimer_.stop();\r\n\r\n  // Unhook all event handlers.\r\n  this.eventHandler_.removeAll();\r\n\r\n  if (this.xmlHttp_) {\r\n    // clear out this.xmlHttp_ before aborting so we handle getting reentered\r\n    // inside abort\r\n    var xmlhttp = this.xmlHttp_;\r\n    this.xmlHttp_ = null;\r\n    xmlhttp.abort();\r\n    xmlhttp.dispose();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Indicates whether the request was successful. Only valid after the handler\r\n * is called to indicate completion of the request.\r\n *\r\n * @return {boolean} True if the request succeeded.\r\n */\r\nChannelRequest.prototype.getSuccess = function() {\r\n  return this.successful_;\r\n};\r\n\r\n\r\n/**\r\n * If the request was not successful, returns the reason.\r\n *\r\n * @return {?ChannelRequest.Error}  The last error.\r\n */\r\nChannelRequest.prototype.getLastError = function() {\r\n  return this.lastError_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the status code of the last request.\r\n * @return {number} The status code of the last request.\r\n */\r\nChannelRequest.prototype.getLastStatusCode = function() {\r\n  return this.lastStatusCode_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the session id for this channel.\r\n *\r\n * @return {string|undefined} The session ID.\r\n */\r\nChannelRequest.prototype.getSessionId = function() {\r\n  return this.sid_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the request id for this request. Each request has a unique request\r\n * id and the request IDs are a sequential increasing count.\r\n *\r\n * @return {string|number|undefined} The request ID.\r\n */\r\nChannelRequest.prototype.getRequestId = function() {\r\n  return this.rid_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the data for a post, if this request is a post.\r\n *\r\n * @return {?string} The POST data provided by the request initiator.\r\n */\r\nChannelRequest.prototype.getPostData = function() {\r\n  return this.postData_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the XhrIo request object.\r\n *\r\n * @return {?goog.net.XhrIo} Any XhrIo request created for this object.\r\n */\r\nChannelRequest.prototype.getXhr = function() {\r\n  return this.xmlHttp_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the time that the request started, if it has started.\r\n *\r\n * @return {?number} The time the request started, as returned by goog.now().\r\n */\r\nChannelRequest.prototype.getRequestStartTime = function() {\r\n  return this.requestStartTime_;\r\n};\r\n\r\n\r\n/**\r\n * Helper to call the callback's onRequestData, which catches any\r\n * exception.\r\n * @param {string} data The request data.\r\n * @private\r\n */\r\nChannelRequest.prototype.safeOnRequestData_ = function(data) {\r\n  try {\r\n    this.channel_.onRequestData(this, data);\r\n    var stats = requestStats.ServerReachability;\r\n    requestStats.notifyServerReachabilityEvent(stats.BACK_CHANNEL_ACTIVITY);\r\n  } catch (e) {\r\n    // Dump debug info, but keep going without closing the channel.\r\n    this.channelDebug_.dumpException(e, 'Error in httprequest callback');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Convenience factory method.\r\n *\r\n * @param {Channel} channel The channel object that owns this request.\r\n * @param {WebChannelDebug} channelDebug A WebChannelDebug to use for logging.\r\n * @param {string=} opt_sessionId  The session id for the channel.\r\n * @param {string|number=} opt_requestId  The request id for this request.\r\n * @param {number=} opt_retryId  The retry id for this request.\r\n * @return {!ChannelRequest} The created channel request.\r\n */\r\nChannelRequest.createChannelRequest = function(\r\n    channel, channelDebug, opt_sessionId, opt_requestId, opt_retryId) {\r\n  return new ChannelRequest(\r\n      channel, channelDebug, opt_sessionId, opt_requestId, opt_retryId);\r\n};\r\n});  // goog.scope\r\n","// Copyright 2018 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview A single module to define user-agent specific environment\r\n * details.\r\n */\r\n\r\ngoog.module('goog.labs.net.webChannel.environment');\r\n\r\ngoog.module.declareLegacyNamespace();\r\n\r\nvar userAgent = goog.require('goog.userAgent');\r\n\r\n\r\n/**\r\n * The default polling interval in millis for Edge.\r\n *\r\n * Currently on edge, new-chunk events may be not be fired (at all) if a new\r\n * chunk arrives within 50ms following the previous chunk. This may be fixed\r\n * in future, which requires changes to the whatwg spec too.\r\n *\r\n * @private @const {number}\r\n */\r\nvar EDGE_POLLING_INTERVAL_ = 125;\r\n\r\n\r\n/**\r\n * History:\r\n *\r\n * IE11 is still using Trident, the traditional engine for IE.\r\n * Edge is using EdgeHTML, a fork of Trident. We are seeing the same issue\r\n * on IE-11 (reported in 2017), so treat IE the same as Edge for now.\r\n *\r\n * We used to do polling for Opera (only) with an 250ms interval, because Opera\r\n * only fires readyState == INTERACTIVE once. Opera switched to WebKit in 2013,\r\n * and then to Blink (chrome).\r\n *\r\n * TODO(user): check the raw UA string to keep polling for old, mobile operas\r\n * that may still be affected. For old Opera, double the polling interval\r\n * to 250ms.\r\n *\r\n * @return {boolean} True if polling is required with XHR.\r\n */\r\nexports.isPollingRequired = function() {\r\n  return userAgent.EDGE_OR_IE;\r\n};\r\n\r\n\r\n/**\r\n * How often to poll (in MS) for changes to responseText in browsers that don't\r\n * fire onreadystatechange during incremental loading of the response body.\r\n *\r\n * @return {number|undefined} The polling interval (MS) for the current U-A;\r\n * or undefined if polling is not supposed to be enabled.\r\n */\r\nexports.getPollingInterval = function() {\r\n  if (userAgent.EDGE_OR_IE) {\r\n    return EDGE_POLLING_INTERVAL_;\r\n  }\r\n\r\n  return undefined;\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Base WebChannel implementation.\r\n *\r\n */\r\n\r\n\r\ngoog.provide('goog.labs.net.webChannel.WebChannelBase');\r\n\r\ngoog.require('goog.Uri');\r\ngoog.require('goog.array');\r\ngoog.require('goog.asserts');\r\ngoog.require('goog.async.run');\r\ngoog.require('goog.debug.TextFormatter');\r\ngoog.require('goog.json');\r\ngoog.require('goog.labs.net.webChannel.BaseTestChannel');\r\ngoog.require('goog.labs.net.webChannel.Channel');\r\ngoog.require('goog.labs.net.webChannel.ChannelRequest');\r\ngoog.require('goog.labs.net.webChannel.ConnectionState');\r\ngoog.require('goog.labs.net.webChannel.ForwardChannelRequestPool');\r\ngoog.require('goog.labs.net.webChannel.WebChannelDebug');\r\ngoog.require('goog.labs.net.webChannel.Wire');\r\ngoog.require('goog.labs.net.webChannel.WireV8');\r\ngoog.require('goog.labs.net.webChannel.netUtils');\r\ngoog.require('goog.labs.net.webChannel.requestStats');\r\ngoog.require('goog.log');\r\ngoog.require('goog.net.WebChannel');\r\ngoog.require('goog.net.XhrIo');\r\ngoog.require('goog.net.XmlHttpFactory');\r\ngoog.require('goog.net.rpc.HttpCors');\r\ngoog.require('goog.object');\r\ngoog.require('goog.string');\r\ngoog.require('goog.structs');\r\ngoog.require('goog.structs.CircularBuffer');\r\n\r\ngoog.scope(function() {\r\nvar WebChannel = goog.net.WebChannel;\r\nvar BaseTestChannel = goog.labs.net.webChannel.BaseTestChannel;\r\nvar ChannelRequest = goog.labs.net.webChannel.ChannelRequest;\r\nvar ConnectionState = goog.labs.net.webChannel.ConnectionState;\r\nvar ForwardChannelRequestPool =\r\n    goog.labs.net.webChannel.ForwardChannelRequestPool;\r\nvar WebChannelDebug = goog.labs.net.webChannel.WebChannelDebug;\r\nvar Wire = goog.labs.net.webChannel.Wire;\r\nvar WireV8 = goog.labs.net.webChannel.WireV8;\r\nvar netUtils = goog.labs.net.webChannel.netUtils;\r\nvar requestStats = goog.labs.net.webChannel.requestStats;\r\n\r\nvar httpCors = goog.module.get('goog.net.rpc.HttpCors');\r\n\r\n\r\n/**\r\n * This WebChannel implementation is branched off goog.net.BrowserChannel\r\n * for now. Ongoing changes to goog.net.BrowserChannel will be back\r\n * ported to this implementation as needed.\r\n *\r\n * @param {!goog.net.WebChannel.Options=} opt_options Configuration for the\r\n *        WebChannel instance.\r\n * @param {number=} opt_clientVersion An application-specific version number\r\n *        that is sent to the server when connected.\r\n * @param {!ConnectionState=} opt_conn Previously determined connection\r\n *        conditions.\r\n * @constructor\r\n * @struct\r\n * @implements {goog.labs.net.webChannel.Channel}\r\n */\r\ngoog.labs.net.webChannel.WebChannelBase = function(\r\n    opt_options, opt_clientVersion, opt_conn) {\r\n  /**\r\n   * The client library version (capabilities).\r\n   * @private {number}\r\n   */\r\n  this.clientVersion_ = opt_clientVersion || 0;\r\n\r\n  /**\r\n   * The server library version (capabilities).\r\n   * @private {number}\r\n   */\r\n  this.serverVersion_ = 0;\r\n\r\n\r\n  /**\r\n   * An array of queued maps that need to be sent to the server.\r\n   * @private {!Array<Wire.QueuedMap>}\r\n   */\r\n  this.outgoingMaps_ = [];\r\n\r\n  /**\r\n   * The channel debug used for logging\r\n   * @private {!WebChannelDebug}\r\n   */\r\n  this.channelDebug_ = new WebChannelDebug();\r\n\r\n  /**\r\n   * Previous connectivity test results.\r\n   * @private {!ConnectionState}\r\n   */\r\n  this.connState_ = opt_conn || new ConnectionState();\r\n\r\n  /**\r\n   * Extra HTTP headers to add to all the requests sent to the server.\r\n   * @private {Object}\r\n   */\r\n  this.extraHeaders_ = null;\r\n\r\n  /**\r\n   * Extra HTTP headers to add to the init request(s) sent to the server.\r\n   * @private {Object}\r\n   */\r\n  this.initHeaders_ = null;\r\n\r\n  /**\r\n   * @private {?string} The URL param name to overwrite custom HTTP headers\r\n   * to bypass CORS preflight.\r\n   */\r\n  this.httpHeadersOverwriteParam_ = null;\r\n\r\n  /**\r\n   * Extra parameters to add to all the requests sent to the server.\r\n   * @private {Object}\r\n   */\r\n  this.extraParams_ = null;\r\n\r\n  /**\r\n   * Parameter name for the http session id.\r\n   * @private {?string}\r\n   */\r\n  this.httpSessionIdParam_ = null;\r\n\r\n  /**\r\n   * The http session id, to be sent with httpSessionIdParam_ with each\r\n   * request after the initial handshake.\r\n   * @private {?string}\r\n   */\r\n  this.httpSessionId_ = null;\r\n\r\n  /**\r\n   * The ChannelRequest object for the backchannel.\r\n   * @private {ChannelRequest}\r\n   */\r\n  this.backChannelRequest_ = null;\r\n\r\n  /**\r\n   * The relative path (in the context of the the page hosting the browser\r\n   * channel) for making requests to the server.\r\n   * @private {?string}\r\n   */\r\n  this.path_ = null;\r\n\r\n  /**\r\n   * The absolute URI for the forwardchannel request.\r\n   * @private {goog.Uri}\r\n   */\r\n  this.forwardChannelUri_ = null;\r\n\r\n  /**\r\n   * The absolute URI for the backchannel request.\r\n   * @private {goog.Uri}\r\n   */\r\n  this.backChannelUri_ = null;\r\n\r\n  /**\r\n   * A subdomain prefix for using a subdomain in IE for the backchannel\r\n   * requests.\r\n   * @private {?string}\r\n   */\r\n  this.hostPrefix_ = null;\r\n\r\n  /**\r\n   * Whether we allow the use of a subdomain in IE for the backchannel requests.\r\n   * @private {boolean}\r\n   */\r\n  this.allowHostPrefix_ = true;\r\n\r\n  /**\r\n   * The next id to use for the RID (request identifier) parameter. This\r\n   * identifier uniquely identifies the forward channel request.\r\n   * @private {number}\r\n   */\r\n  this.nextRid_ = 0;\r\n\r\n  /**\r\n   * The id to use for the next outgoing map. This identifier uniquely\r\n   * identifies a sent map.\r\n   * @private {number}\r\n   */\r\n  this.nextMapId_ = 0;\r\n\r\n  /**\r\n   * Whether to fail forward-channel requests after one try or a few tries.\r\n   * @private {boolean}\r\n   */\r\n  this.failFast_ =\r\n      !!goog.getObjectByName('internalChannelParams.failFast', opt_options);\r\n\r\n  /**\r\n   * The handler that receive callbacks for state changes and data.\r\n   * @private {goog.labs.net.webChannel.WebChannelBase.Handler}\r\n   */\r\n  this.handler_ = null;\r\n\r\n  /**\r\n   * Timer identifier for asynchronously making a forward channel request.\r\n   * This is set to true if the func is scheduled with async.run, which\r\n   * is equivalent to setTimeout(0).\r\n   * @private {?number|?boolean}\r\n   */\r\n  this.forwardChannelTimerId_ = null;\r\n\r\n  /**\r\n   * Timer identifier for asynchronously making a back channel request.\r\n   * @private {?number}\r\n   */\r\n  this.backChannelTimerId_ = null;\r\n\r\n  /**\r\n   * Timer identifier for the timer that waits for us to retry the backchannel\r\n   * in the case where it is dead and no longer receiving data.\r\n   * @private {?number}\r\n   */\r\n  this.deadBackChannelTimerId_ = null;\r\n\r\n  /**\r\n   * The TestChannel object which encapsulates the logic for determining\r\n   * interesting network conditions about the client.\r\n   * @private {BaseTestChannel}\r\n   */\r\n  this.connectionTest_ = null;\r\n\r\n  /**\r\n   * Whether the client's network conditions can support chunked responses.\r\n   * @private {?boolean}\r\n   */\r\n  this.useChunked_ = null;\r\n\r\n  /**\r\n   * Whether chunked mode is allowed. In certain debugging situations, it's\r\n   * useful to disable this.\r\n   * @private {boolean}\r\n   */\r\n  this.allowChunkedMode_ = true;\r\n\r\n  /**\r\n   * The array identifier of the last array received from the server for the\r\n   * backchannel request.\r\n   * @private {number}\r\n   */\r\n  this.lastArrayId_ = -1;\r\n\r\n  /**\r\n   * The array id of the last array sent by the server that we know about.\r\n   * @private {number}\r\n   */\r\n  this.lastPostResponseArrayId_ = -1;\r\n\r\n  /**\r\n   * The last status code received.\r\n   * @private {number}\r\n   */\r\n  this.lastStatusCode_ = -1;\r\n\r\n  /**\r\n   * Number of times we have retried the current forward channel request.\r\n   * @private {number}\r\n   */\r\n  this.forwardChannelRetryCount_ = 0;\r\n\r\n  /**\r\n   * Number of times in a row that we have retried the current back channel\r\n   * request and received no data.\r\n   * @private {number}\r\n   */\r\n  this.backChannelRetryCount_ = 0;\r\n\r\n  /**\r\n   * The attempt id for the current back channel request. Starts at 1 and\r\n   * increments for each reconnect. The server uses this to log if our\r\n   * connection is flaky or not.\r\n   * @private {number}\r\n   */\r\n  this.backChannelAttemptId_ = 0;\r\n\r\n  /**\r\n   * The base part of the time before firing next retry request. Default is 5\r\n   * seconds. Note that a random delay is added (see {@link retryDelaySeedMs_})\r\n   * for all retries, and linear backoff is applied to the sum for subsequent\r\n   * retries.\r\n   * @private {number}\r\n   */\r\n  this.baseRetryDelayMs_ =\r\n      goog.getObjectByName(\r\n          'internalChannelParams.baseRetryDelayMs', opt_options) ||\r\n      5 * 1000;\r\n\r\n  /**\r\n   * A random time between 0 and this number of MS is added to the\r\n   * {@link baseRetryDelayMs_}. Default is 10 seconds.\r\n   * @private {number}\r\n   */\r\n  this.retryDelaySeedMs_ =\r\n      goog.getObjectByName(\r\n          'internalChannelParams.retryDelaySeedMs', opt_options) ||\r\n      10 * 1000;\r\n\r\n  /**\r\n   * Maximum number of attempts to connect to the server for forward channel\r\n   * requests. Defaults to 2.\r\n   * @private {number}\r\n   */\r\n  this.forwardChannelMaxRetries_ =\r\n      goog.getObjectByName(\r\n          'internalChannelParams.forwardChannelMaxRetries', opt_options) ||\r\n      2;\r\n\r\n  /**\r\n   * The timeout in milliseconds for a forward channel request. Defaults to 20\r\n   * seconds. Note that part of this timeout can be randomized.\r\n   * @private {number}\r\n   */\r\n  this.forwardChannelRequestTimeoutMs_ =\r\n      goog.getObjectByName(\r\n          'internalChannelParams.forwardChannelRequestTimeoutMs',\r\n          opt_options) ||\r\n      20 * 1000;\r\n\r\n  /**\r\n   * The custom factory used to create XMLHttpRequest objects.\r\n   * @private {!goog.net.XmlHttpFactory | undefined}\r\n   */\r\n  this.xmlHttpFactory_ =\r\n      (opt_options && opt_options.xmlHttpFactory) || undefined;\r\n\r\n  /**\r\n   * The timeout in milliseconds for a back channel request. Defaults to using\r\n   * the timeout configured in ChannelRequest (45s). If server-side\r\n   * keepaliveInterval is known to the client, set the backchannel request\r\n   * timeout to 1.5 * keepaliveInterval (ms).\r\n   *\r\n   * @private {number|undefined}\r\n   */\r\n  this.backChannelRequestTimeoutMs_ = undefined;\r\n\r\n  /**\r\n   * A throttle time in ms for readystatechange events for the backchannel.\r\n   * Useful for throttling when ready state is INTERACTIVE (partial data).\r\n   *\r\n   * This throttle is useful if the server sends large data chunks down the\r\n   * backchannel.  It prevents examining XHR partial data on every readystate\r\n   * change event.  This is useful because large chunks can trigger hundreds\r\n   * of readystatechange events, each of which takes ~5ms or so to handle,\r\n   * in turn making the UI unresponsive for a significant period.\r\n   *\r\n   * If set to zero no throttle is used.\r\n   * @private {number}\r\n   */\r\n  this.readyStateChangeThrottleMs_ = 0;\r\n\r\n  /**\r\n   * Whether cross origin requests are supported for the channel.\r\n   *\r\n   * See {@link goog.net.XhrIo#setWithCredentials}.\r\n   * @private {boolean}\r\n   */\r\n  this.supportsCrossDomainXhrs_ =\r\n      (opt_options && opt_options.supportsCrossDomainXhr) || false;\r\n\r\n  /**\r\n   * The current session id.\r\n   * @private {string}\r\n   */\r\n  this.sid_ = '';\r\n\r\n  /**\r\n   * The current ChannelRequest pool for the forward channel.\r\n   * @private {!ForwardChannelRequestPool}\r\n   */\r\n  this.forwardChannelRequestPool_ = new ForwardChannelRequestPool(\r\n      opt_options && opt_options.concurrentRequestLimit);\r\n\r\n  /**\r\n   * The V8 codec.\r\n   * @private {!WireV8}\r\n   */\r\n  this.wireCodec_ = new WireV8();\r\n\r\n  /**\r\n   * Whether to run the channel test as a background process to not block\r\n   * the OPEN event.\r\n   *\r\n   * @private {boolean}\r\n   */\r\n  this.backgroundChannelTest_ =\r\n      opt_options && goog.isDef(opt_options.backgroundChannelTest) ?\r\n      opt_options.backgroundChannelTest :\r\n      true;\r\n\r\n  /**\r\n   * Whether to turn on the fast handshake behavior.\r\n   *\r\n   * @private {boolean}\r\n   */\r\n  this.fastHandshake_ = (opt_options && opt_options.fastHandshake) || false;\r\n\r\n  if (this.fastHandshake_ && !this.backgroundChannelTest_) {\r\n    this.channelDebug_.warning(\r\n        'Force backgroundChannelTest when fastHandshake is enabled.');\r\n    this.backgroundChannelTest_ = true;\r\n  }\r\n\r\n  if (opt_options && opt_options.disableRedact) {\r\n    this.channelDebug_.disableRedact();\r\n  }\r\n\r\n  if (opt_options && opt_options.forceLongPolling) {\r\n    this.allowChunkedMode_ = false;\r\n  }\r\n\r\n  /**\r\n   * Callback when all the pending client-sent messages have been flushed.\r\n   *\r\n   * @private {function()|undefined}\r\n   */\r\n  this.forwardChannelFlushedCallback_ = undefined;\r\n};\r\n\r\nvar WebChannelBase = goog.labs.net.webChannel.WebChannelBase;\r\n\r\n\r\n/**\r\n * The channel version that we negotiated with the server for this session.\r\n * Starts out as the version we request, and then is changed to the negotiated\r\n * version after the initial open.\r\n * @private {number}\r\n */\r\nWebChannelBase.prototype.channelVersion_ = Wire.LATEST_CHANNEL_VERSION;\r\n\r\n\r\n/**\r\n * Enum type for the channel state machine.\r\n * @enum {number}\r\n */\r\nWebChannelBase.State = {\r\n  /** The channel is closed. */\r\n  CLOSED: 0,\r\n\r\n  /** The channel has been initialized but hasn't yet initiated a connection. */\r\n  INIT: 1,\r\n\r\n  /** The channel is in the process of opening a connection to the server. */\r\n  OPENING: 2,\r\n\r\n  /** The channel is open. */\r\n  OPENED: 3\r\n};\r\n\r\n\r\n/**\r\n * The current state of the WebChannel.\r\n * @private {!WebChannelBase.State}\r\n */\r\nWebChannelBase.prototype.state_ = WebChannelBase.State.INIT;\r\n\r\n\r\n/**\r\n * The timeout in milliseconds for a forward channel request.\r\n * @type {number}\r\n */\r\nWebChannelBase.FORWARD_CHANNEL_RETRY_TIMEOUT = 20 * 1000;\r\n\r\n\r\n/**\r\n * Maximum number of attempts to connect to the server for back channel\r\n * requests.\r\n * @type {number}\r\n */\r\nWebChannelBase.BACK_CHANNEL_MAX_RETRIES = 3;\r\n\r\n\r\n/**\r\n * A number in MS of how long we guess the maxmium amount of time a round trip\r\n * to the server should take. In the future this could be substituted with a\r\n * real measurement of the RTT.\r\n * @type {number}\r\n */\r\nWebChannelBase.RTT_ESTIMATE = 3 * 1000;\r\n\r\n\r\n/**\r\n * When retrying for an inactive channel, we will multiply the total delay by\r\n * this number.\r\n * @type {number}\r\n */\r\nWebChannelBase.INACTIVE_CHANNEL_RETRY_FACTOR = 2;\r\n\r\n\r\n/**\r\n * Enum type for identifying an error.\r\n * @enum {number}\r\n */\r\nWebChannelBase.Error = {\r\n  /** Value that indicates no error has occurred. */\r\n  OK: 0,\r\n\r\n  /** An error due to a request failing. */\r\n  REQUEST_FAILED: 2,\r\n\r\n  /** An error due to the user being logged out. */\r\n  LOGGED_OUT: 4,\r\n\r\n  /** An error due to server response which contains no data. */\r\n  NO_DATA: 5,\r\n\r\n  /** An error due to a server response indicating an unknown session id */\r\n  UNKNOWN_SESSION_ID: 6,\r\n\r\n  /** An error due to a server response requesting to stop the channel. */\r\n  STOP: 7,\r\n\r\n  /** A general network error. */\r\n  NETWORK: 8,\r\n\r\n  /** An error due to bad data being returned from the server. */\r\n  BAD_DATA: 10,\r\n\r\n  /** An error due to a response that is not parsable. */\r\n  BAD_RESPONSE: 11\r\n};\r\n\r\n\r\n/**\r\n * Internal enum type for the two channel types.\r\n * @enum {number}\r\n * @private\r\n */\r\nWebChannelBase.ChannelType_ = {\r\n  FORWARD_CHANNEL: 1,\r\n\r\n  BACK_CHANNEL: 2\r\n};\r\n\r\n\r\n/**\r\n * The maximum number of maps that can be sent in one POST. Should match\r\n * MAX_MAPS_PER_REQUEST on the server code.\r\n * @type {number}\r\n * @private\r\n */\r\nWebChannelBase.MAX_MAPS_PER_REQUEST_ = 1000;\r\n\r\n\r\n/**\r\n * The maximum number of utf-8 chars that can be sent in one GET to enable 0-RTT\r\n * handshake.\r\n *\r\n *  @const @private {number}\r\n */\r\nWebChannelBase.MAX_CHARS_PER_GET_ = 4 * 1024;\r\n\r\n\r\n/**\r\n * A guess at a cutoff at which to no longer assume the backchannel is dead\r\n * when we are slow to receive data. Number in bytes.\r\n *\r\n * Assumption: The worst bandwidth we work on is 50 kilobits/sec\r\n * 50kbits/sec * (1 byte / 8 bits) * 6 sec dead backchannel timeout\r\n * @type {number}\r\n */\r\nWebChannelBase.OUTSTANDING_DATA_BACKCHANNEL_RETRY_CUTOFF = 37500;\r\n\r\n\r\n/**\r\n * @return {number} The server version or 0 if undefined\r\n */\r\nWebChannelBase.prototype.getServerVersion = function() {\r\n  return this.serverVersion_;\r\n};\r\n\r\n\r\n/**\r\n * @return {!ForwardChannelRequestPool} The forward channel request pool.\r\n */\r\nWebChannelBase.prototype.getForwardChannelRequestPool = function() {\r\n  return this.forwardChannelRequestPool_;\r\n};\r\n\r\n\r\n/**\r\n * @return {!Object} The codec object, to be used for the test channel.\r\n */\r\nWebChannelBase.prototype.getWireCodec = function() {\r\n  return this.wireCodec_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the logger.\r\n *\r\n * @return {!WebChannelDebug} The channel debug object.\r\n */\r\nWebChannelBase.prototype.getChannelDebug = function() {\r\n  return this.channelDebug_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the logger.\r\n *\r\n * @param {!WebChannelDebug} channelDebug The channel debug object.\r\n */\r\nWebChannelBase.prototype.setChannelDebug = function(channelDebug) {\r\n  this.channelDebug_ = channelDebug;\r\n};\r\n\r\n\r\n/**\r\n * Starts the channel. This initiates connections to the server.\r\n *\r\n * @param {string} testPath  The path for the test connection.\r\n * @param {string} channelPath  The path for the channel connection.\r\n * @param {!Object=} opt_extraParams Extra parameter keys and values to add to\r\n *     the requests.\r\n * @param {string=} opt_oldSessionId  Session ID from a previous session.\r\n * @param {number=} opt_oldArrayId  The last array ID from a previous session.\r\n */\r\nWebChannelBase.prototype.connect = function(\r\n    testPath, channelPath, opt_extraParams, opt_oldSessionId, opt_oldArrayId) {\r\n  this.channelDebug_.debug('connect()');\r\n\r\n  requestStats.notifyStatEvent(requestStats.Stat.CONNECT_ATTEMPT);\r\n\r\n  this.path_ = channelPath;\r\n  this.extraParams_ = opt_extraParams || {};\r\n\r\n  // Attach parameters about the previous session if reconnecting.\r\n  if (opt_oldSessionId && goog.isDef(opt_oldArrayId)) {\r\n    this.extraParams_['OSID'] = opt_oldSessionId;\r\n    this.extraParams_['OAID'] = opt_oldArrayId;\r\n  }\r\n\r\n  if (this.backgroundChannelTest_) {\r\n    this.channelDebug_.debug('connect() bypassed channel-test.');\r\n    this.connState_.handshakeResult = [];\r\n    this.connState_.bufferingProxyResult = false;\r\n\r\n    // TODO(user): merge states with background channel test\r\n    // requestStats.setTimeout(goog.bind(this.connectTest_, this, testPath), 0);\r\n    //     this.connectChannel_();\r\n  }\r\n\r\n  this.connectTest_(testPath);\r\n};\r\n\r\n\r\n/**\r\n * Disconnects and closes the channel.\r\n */\r\nWebChannelBase.prototype.disconnect = function() {\r\n  this.channelDebug_.debug('disconnect()');\r\n\r\n  this.cancelRequests_();\r\n\r\n  if (this.state_ == WebChannelBase.State.OPENED) {\r\n    var rid = this.nextRid_++;\r\n    var uri = this.forwardChannelUri_.clone();\r\n    uri.setParameterValue('SID', this.sid_);\r\n    uri.setParameterValue('RID', rid);\r\n    uri.setParameterValue('TYPE', 'terminate');\r\n\r\n    // Add the reconnect parameters.\r\n    this.addAdditionalParams_(uri);\r\n\r\n    var request = ChannelRequest.createChannelRequest(\r\n        this, this.channelDebug_, this.sid_, rid);\r\n    request.sendCloseRequest(uri);\r\n  }\r\n\r\n  this.onClose_();\r\n};\r\n\r\n\r\n/**\r\n * Returns the session id of the channel. Only available after the\r\n * channel has been opened.\r\n * @return {string} Session ID.\r\n */\r\nWebChannelBase.prototype.getSessionId = function() {\r\n  return this.sid_;\r\n};\r\n\r\n\r\n/**\r\n * Starts the test channel to determine network conditions.\r\n *\r\n * @param {string} testPath  The relative PATH for the test connection.\r\n * @private\r\n */\r\nWebChannelBase.prototype.connectTest_ = function(testPath) {\r\n  this.channelDebug_.debug('connectTest_()');\r\n  if (!this.okToMakeRequest_()) {\r\n    return;  // channel is cancelled\r\n  }\r\n  this.connectionTest_ = new BaseTestChannel(this, this.channelDebug_);\r\n\r\n  if (this.httpHeadersOverwriteParam_ === null) {\r\n    this.connectionTest_.setExtraHeaders(this.extraHeaders_);\r\n  }\r\n\r\n  var urlPath = testPath;\r\n  if (this.httpHeadersOverwriteParam_ && this.extraHeaders_) {\r\n    urlPath = httpCors.setHttpHeadersWithOverwriteParam(\r\n        testPath, this.httpHeadersOverwriteParam_, this.extraHeaders_);\r\n  }\r\n\r\n  this.connectionTest_.connect(/** @type {string} */ (urlPath));\r\n};\r\n\r\n\r\n/**\r\n * Starts the regular channel which is run after the test channel is complete.\r\n * @private\r\n */\r\nWebChannelBase.prototype.connectChannel_ = function() {\r\n  this.channelDebug_.debug('connectChannel_()');\r\n  this.ensureInState_(WebChannelBase.State.INIT, WebChannelBase.State.CLOSED);\r\n  this.forwardChannelUri_ =\r\n      this.getForwardChannelUri(/** @type {string} */ (this.path_));\r\n  this.ensureForwardChannel_();\r\n};\r\n\r\n\r\n/**\r\n * Cancels all outstanding requests.\r\n * @private\r\n */\r\nWebChannelBase.prototype.cancelRequests_ = function() {\r\n  if (this.connectionTest_) {\r\n    this.connectionTest_.abort();\r\n    this.connectionTest_ = null;\r\n  }\r\n\r\n  if (this.backChannelRequest_) {\r\n    this.backChannelRequest_.cancel();\r\n    this.backChannelRequest_ = null;\r\n  }\r\n\r\n  if (this.backChannelTimerId_) {\r\n    goog.global.clearTimeout(this.backChannelTimerId_);\r\n    this.backChannelTimerId_ = null;\r\n  }\r\n\r\n  this.clearDeadBackchannelTimer_();\r\n\r\n  this.forwardChannelRequestPool_.cancel();\r\n\r\n  if (this.forwardChannelTimerId_) {\r\n    this.clearForwardChannelTimer_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clears the forward channel timer.\r\n * @private\r\n */\r\nWebChannelBase.prototype.clearForwardChannelTimer_ = function() {\r\n  if (goog.isNumber(this.forwardChannelTimerId_)) {\r\n    goog.global.clearTimeout(this.forwardChannelTimerId_);\r\n  }\r\n\r\n  this.forwardChannelTimerId_ = null;\r\n};\r\n\r\n\r\n/**\r\n * Returns the extra HTTP headers to add to all the requests sent to the server.\r\n *\r\n * @return {Object} The HTTP headers, or null.\r\n */\r\nWebChannelBase.prototype.getExtraHeaders = function() {\r\n  return this.extraHeaders_;\r\n};\r\n\r\n\r\n/**\r\n * Sets extra HTTP headers to add to all the requests sent to the server.\r\n *\r\n * @param {Object} extraHeaders The HTTP headers, or null.\r\n */\r\nWebChannelBase.prototype.setExtraHeaders = function(extraHeaders) {\r\n  this.extraHeaders_ = extraHeaders;\r\n};\r\n\r\n\r\n/**\r\n * Returns the extra HTTP headers to add to the init requests\r\n * sent to the server.\r\n *\r\n * @return {Object} The HTTP headers, or null.\r\n */\r\nWebChannelBase.prototype.getInitHeaders = function() {\r\n  return this.initHeaders_;\r\n};\r\n\r\n\r\n/**\r\n * Sets extra HTTP headers to add to the init requests sent to the server.\r\n *\r\n * @param {Object} initHeaders The HTTP headers, or null.\r\n */\r\nWebChannelBase.prototype.setInitHeaders = function(initHeaders) {\r\n  this.initHeaders_ = initHeaders;\r\n};\r\n\r\n\r\n/**\r\n * Sets the URL param name to overwrite custom HTTP headers.\r\n *\r\n * @param {string} httpHeadersOverwriteParam The URL param name.\r\n */\r\nWebChannelBase.prototype.setHttpHeadersOverwriteParam = function(\r\n    httpHeadersOverwriteParam) {\r\n  this.httpHeadersOverwriteParam_ = httpHeadersOverwriteParam;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.setHttpSessionIdParam = function(httpSessionIdParam) {\r\n  this.httpSessionIdParam_ = httpSessionIdParam;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getHttpSessionIdParam = function() {\r\n  return this.httpSessionIdParam_;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.setHttpSessionId = function(httpSessionId) {\r\n  this.httpSessionId_ = httpSessionId;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getHttpSessionId = function() {\r\n  return this.httpSessionId_;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getBackgroundChannelTest = function() {\r\n  return this.backgroundChannelTest_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the throttle for handling onreadystatechange events for the request.\r\n *\r\n * @param {number} throttle The throttle in ms.  A value of zero indicates\r\n *     no throttle.\r\n */\r\nWebChannelBase.prototype.setReadyStateChangeThrottle = function(throttle) {\r\n  this.readyStateChangeThrottleMs_ = throttle;\r\n};\r\n\r\n\r\n/**\r\n * Sets whether cross origin requests are supported for the channel.\r\n *\r\n * Setting this allows the creation of requests to secondary domains and\r\n * sends XHRs with the CORS withCredentials bit set to true.\r\n *\r\n * In order for cross-origin requests to work, the server will also need to set\r\n * CORS response headers as per:\r\n * https://developer.mozilla.org/en-US/docs/HTTP_access_control\r\n *\r\n * See {@link goog.net.XhrIo#setWithCredentials}.\r\n * @param {boolean} supportCrossDomain Whether cross domain XHRs are supported.\r\n */\r\nWebChannelBase.prototype.setSupportsCrossDomainXhrs = function(\r\n    supportCrossDomain) {\r\n  this.supportsCrossDomainXhrs_ = supportCrossDomain;\r\n};\r\n\r\n\r\n/**\r\n * Returns the handler used for channel callback events.\r\n *\r\n * @return {WebChannelBase.Handler} The handler.\r\n */\r\nWebChannelBase.prototype.getHandler = function() {\r\n  return this.handler_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the handler used for channel callback events.\r\n * @param {WebChannelBase.Handler} handler The handler to set.\r\n */\r\nWebChannelBase.prototype.setHandler = function(handler) {\r\n  this.handler_ = handler;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether the channel allows the use of a subdomain. There may be\r\n * cases where this isn't allowed.\r\n * @return {boolean} Whether a host prefix is allowed.\r\n */\r\nWebChannelBase.prototype.getAllowHostPrefix = function() {\r\n  return this.allowHostPrefix_;\r\n};\r\n\r\n\r\n/**\r\n * Sets whether the channel allows the use of a subdomain. There may be cases\r\n * where this isn't allowed, for example, logging in with troutboard where\r\n * using a subdomain causes Apache to force the user to authenticate twice.\r\n * @param {boolean} allowHostPrefix Whether a host prefix is allowed.\r\n */\r\nWebChannelBase.prototype.setAllowHostPrefix = function(allowHostPrefix) {\r\n  this.allowHostPrefix_ = allowHostPrefix;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether the channel is buffered or not. This state is valid for\r\n * querying only after the test connection has completed. This may be\r\n * queried in the WebChannelBase.okToMakeRequest() callback.\r\n * A channel may be buffered if the test connection determines that\r\n * a chunked response could not be sent down within a suitable time.\r\n * @return {boolean} Whether the channel is buffered.\r\n */\r\nWebChannelBase.prototype.isBuffered = function() {\r\n  return !this.useChunked_;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether chunked mode is allowed. In certain debugging situations,\r\n * it's useful for the application to have a way to disable chunked mode for a\r\n * user.\r\n\r\n * @return {boolean} Whether chunked mode is allowed.\r\n */\r\nWebChannelBase.prototype.getAllowChunkedMode = function() {\r\n  return this.allowChunkedMode_;\r\n};\r\n\r\n\r\n/**\r\n * Sets whether chunked mode is allowed. In certain debugging situations, it's\r\n * useful for the application to have a way to disable chunked mode for a user.\r\n * @param {boolean} allowChunkedMode  Whether chunked mode is allowed.\r\n */\r\nWebChannelBase.prototype.setAllowChunkedMode = function(allowChunkedMode) {\r\n  this.allowChunkedMode_ = allowChunkedMode;\r\n};\r\n\r\n\r\n/**\r\n * Sends a request to the server. The format of the request is a Map data\r\n * structure of key/value pairs. These maps are then encoded in a format\r\n * suitable for the wire and then reconstituted as a Map data structure that\r\n * the server can process.\r\n * @param {!Object|!goog.structs.Map} map The map to send.\r\n * @param {!Object=} opt_context The context associated with the map.\r\n */\r\nWebChannelBase.prototype.sendMap = function(map, opt_context) {\r\n  goog.asserts.assert(\r\n      this.state_ != WebChannelBase.State.CLOSED,\r\n      'Invalid operation: sending map when state is closed');\r\n\r\n  // We can only send 1000 maps per POST, but typically we should never have\r\n  // that much to send, so warn if we exceed that (we still send all the maps).\r\n  if (this.outgoingMaps_.length == WebChannelBase.MAX_MAPS_PER_REQUEST_) {\r\n    // severe() is temporary so that we get these uploaded and can figure out\r\n    // what's causing them. Afterwards can change to warning().\r\n    this.channelDebug_.severe(function() {\r\n      return 'Already have ' + WebChannelBase.MAX_MAPS_PER_REQUEST_ +\r\n          ' queued maps upon queueing ' + goog.json.serialize(map);\r\n    });\r\n  }\r\n\r\n  this.outgoingMaps_.push(\r\n      new Wire.QueuedMap(this.nextMapId_++, map, opt_context));\r\n\r\n  // Messages need be buffered during OPENING to avoid server-side race\r\n  if (this.state_ == WebChannelBase.State.OPENED) {\r\n    this.ensureForwardChannel_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * When set to true, this changes the behavior of the forward channel so it\r\n * will not retry requests; it will fail after one network failure, and if\r\n * there was already one network failure, the request will fail immediately.\r\n * @param {boolean} failFast  Whether or not to fail fast.\r\n */\r\nWebChannelBase.prototype.setFailFast = function(failFast) {\r\n  this.failFast_ = failFast;\r\n  this.channelDebug_.info('setFailFast: ' + failFast);\r\n  if ((this.forwardChannelRequestPool_.hasPendingRequest() ||\r\n       this.forwardChannelTimerId_) &&\r\n      this.forwardChannelRetryCount_ > this.getForwardChannelMaxRetries()) {\r\n    var self = this;\r\n    this.channelDebug_.info(function() {\r\n      return 'Retry count ' + self.forwardChannelRetryCount_ +\r\n          ' > new maxRetries ' + self.getForwardChannelMaxRetries() +\r\n          '. Fail immediately!';\r\n    });\r\n\r\n    if (!this.forwardChannelRequestPool_.forceComplete(\r\n            goog.bind(this.onRequestComplete, this))) {\r\n      // i.e., this.forwardChannelTimerId_\r\n      this.clearForwardChannelTimer_();\r\n      // The error code from the last failed request is gone, so just use a\r\n      // generic one.\r\n      this.signalError_(WebChannelBase.Error.REQUEST_FAILED);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The max number of forward-channel retries, which will be 0\r\n * in fail-fast mode.\r\n */\r\nWebChannelBase.prototype.getForwardChannelMaxRetries = function() {\r\n  return this.failFast_ ? 0 : this.forwardChannelMaxRetries_;\r\n};\r\n\r\n\r\n/**\r\n * Sets the maximum number of attempts to connect to the server for forward\r\n * channel requests.\r\n * @param {number} retries The maximum number of attempts.\r\n */\r\nWebChannelBase.prototype.setForwardChannelMaxRetries = function(retries) {\r\n  this.forwardChannelMaxRetries_ = retries;\r\n};\r\n\r\n\r\n/**\r\n * Sets the timeout for a forward channel request.\r\n * @param {number} timeoutMs The timeout in milliseconds.\r\n */\r\nWebChannelBase.prototype.setForwardChannelRequestTimeout = function(timeoutMs) {\r\n  this.forwardChannelRequestTimeoutMs_ = timeoutMs;\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The max number of back-channel retries, which is a constant.\r\n */\r\nWebChannelBase.prototype.getBackChannelMaxRetries = function() {\r\n  // Back-channel retries is a constant.\r\n  return WebChannelBase.BACK_CHANNEL_MAX_RETRIES;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.isClosed = function() {\r\n  return this.state_ == WebChannelBase.State.CLOSED;\r\n};\r\n\r\n\r\n/**\r\n * Returns the channel state.\r\n * @return {WebChannelBase.State} The current state of the channel.\r\n */\r\nWebChannelBase.prototype.getState = function() {\r\n  return this.state_;\r\n};\r\n\r\n\r\n/**\r\n * Return the last status code received for a request.\r\n * @return {number} The last status code received for a request.\r\n */\r\nWebChannelBase.prototype.getLastStatusCode = function() {\r\n  return this.lastStatusCode_;\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The last array id received.\r\n */\r\nWebChannelBase.prototype.getLastArrayId = function() {\r\n  return this.lastArrayId_;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether there are outstanding requests servicing the channel.\r\n * @return {boolean} true if there are outstanding requests.\r\n */\r\nWebChannelBase.prototype.hasOutstandingRequests = function() {\r\n  return this.getOutstandingRequests_() != 0;\r\n};\r\n\r\n\r\n/**\r\n * Returns the number of outstanding requests.\r\n * @return {number} The number of outstanding requests to the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.getOutstandingRequests_ = function() {\r\n  var count = 0;\r\n  if (this.backChannelRequest_) {\r\n    count++;\r\n  }\r\n  count += this.forwardChannelRequestPool_.getRequestCount();\r\n  return count;\r\n};\r\n\r\n\r\n/**\r\n * Ensures that a forward channel request is scheduled.\r\n * @private\r\n */\r\nWebChannelBase.prototype.ensureForwardChannel_ = function() {\r\n  if (this.forwardChannelRequestPool_.isFull()) {\r\n    // enough connection in process - no need to start a new request\r\n    return;\r\n  }\r\n\r\n  if (this.forwardChannelTimerId_) {\r\n    // no need to start a new request - one is already scheduled\r\n    return;\r\n  }\r\n\r\n  // Use async.run instead of setTimeout(0) to avoid the 1s message delay\r\n  // from chrome/firefox background tabs\r\n  this.forwardChannelTimerId_ = true;\r\n  goog.async.run(this.onStartForwardChannelTimer_, this);\r\n\r\n  this.forwardChannelRetryCount_ = 0;\r\n};\r\n\r\n\r\n/**\r\n * Schedules a forward-channel retry for the specified request, unless the max\r\n * retries has been reached.\r\n * @param {!ChannelRequest} request The failed request to retry.\r\n * @return {boolean} true iff a retry was scheduled.\r\n * @private\r\n */\r\nWebChannelBase.prototype.maybeRetryForwardChannel_ = function(request) {\r\n  if (this.forwardChannelRequestPool_.getRequestCount() >=\r\n      this.forwardChannelRequestPool_.getMaxSize() -\r\n          (this.forwardChannelTimerId_ ? 1 : 0)) {\r\n    // Should be impossible to be called in this state.\r\n    this.channelDebug_.severe('Unexpected retry request is scheduled.');\r\n    return false;\r\n  }\r\n\r\n  if (this.forwardChannelTimerId_) {\r\n    this.channelDebug_.debug(\r\n        'Use the retry request that is already scheduled.');\r\n    this.outgoingMaps_ =\r\n        request.getPendingMessages().concat(this.outgoingMaps_);\r\n    return true;\r\n  }\r\n\r\n  // No retry for open_() and fail-fast\r\n  if (this.state_ == WebChannelBase.State.INIT ||\r\n      this.state_ == WebChannelBase.State.OPENING ||\r\n      (this.forwardChannelRetryCount_ >= this.getForwardChannelMaxRetries())) {\r\n    return false;\r\n  }\r\n\r\n  this.channelDebug_.debug('Going to retry POST');\r\n\r\n  this.forwardChannelTimerId_ = requestStats.setTimeout(\r\n      goog.bind(this.onStartForwardChannelTimer_, this, request),\r\n      this.getRetryTime_(this.forwardChannelRetryCount_));\r\n  this.forwardChannelRetryCount_++;\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Timer callback for ensureForwardChannel\r\n * @param {ChannelRequest=} opt_retryRequest A failed request\r\n * to retry.\r\n * @private\r\n */\r\nWebChannelBase.prototype.onStartForwardChannelTimer_ = function(\r\n    opt_retryRequest) {\r\n  // null is possible if scheduled with async.run\r\n  if (this.forwardChannelTimerId_) {\r\n    this.forwardChannelTimerId_ = null;\r\n    this.startForwardChannel_(opt_retryRequest);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Begins a new forward channel operation to the server.\r\n * @param {ChannelRequest=} opt_retryRequest A failed request to retry.\r\n * @private\r\n */\r\nWebChannelBase.prototype.startForwardChannel_ = function(opt_retryRequest) {\r\n  this.channelDebug_.debug('startForwardChannel_');\r\n  if (!this.okToMakeRequest_()) {\r\n    return;  // channel is cancelled\r\n  } else if (this.state_ == WebChannelBase.State.INIT) {\r\n    if (opt_retryRequest) {\r\n      this.channelDebug_.severe('Not supposed to retry the open');\r\n      return;\r\n    }\r\n    this.open_();\r\n    this.state_ = WebChannelBase.State.OPENING;\r\n  } else if (this.state_ == WebChannelBase.State.OPENED) {\r\n    if (opt_retryRequest) {\r\n      this.makeForwardChannelRequest_(opt_retryRequest);\r\n      return;\r\n    }\r\n\r\n    if (this.outgoingMaps_.length == 0) {\r\n      this.channelDebug_.debug(\r\n          'startForwardChannel_ returned: ' +\r\n          'nothing to send');\r\n      // no need to start a new forward channel request\r\n      return;\r\n    }\r\n\r\n    if (this.forwardChannelRequestPool_.isFull()) {\r\n      // Should be impossible to be called in this state.\r\n      this.channelDebug_.severe(\r\n          'startForwardChannel_ returned: ' +\r\n          'connection already in progress');\r\n      return;\r\n    }\r\n\r\n    this.makeForwardChannelRequest_();\r\n    this.channelDebug_.debug('startForwardChannel_ finished, sent request');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Establishes a new channel session with the the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.open_ = function() {\r\n  this.channelDebug_.debug('open_()');\r\n  this.nextRid_ = Math.floor(Math.random() * 100000);\r\n\r\n  var rid = this.nextRid_++;\r\n  var request =\r\n      ChannelRequest.createChannelRequest(this, this.channelDebug_, '', rid);\r\n\r\n  // mix the init headers\r\n  var extraHeaders = this.extraHeaders_;\r\n  if (this.initHeaders_) {\r\n    if (extraHeaders) {\r\n      extraHeaders = goog.object.clone(extraHeaders);\r\n      goog.object.extend(extraHeaders, this.initHeaders_);\r\n    } else {\r\n      extraHeaders = this.initHeaders_;\r\n    }\r\n  }\r\n\r\n  if (this.httpHeadersOverwriteParam_ === null) {\r\n    request.setExtraHeaders(extraHeaders);\r\n  }\r\n\r\n  var requestText = this.dequeueOutgoingMaps_(\r\n      request,\r\n      this.fastHandshake_ ? this.getMaxNumMessagesForFastHandshake_() :\r\n                            WebChannelBase.MAX_MAPS_PER_REQUEST_);\r\n\r\n  var uri = this.forwardChannelUri_.clone();\r\n  uri.setParameterValue('RID', rid);\r\n\r\n  if (this.clientVersion_ > 0) {\r\n    uri.setParameterValue('CVER', this.clientVersion_);\r\n  }\r\n\r\n  // http-session-id to be generated as the response\r\n  if (this.getBackgroundChannelTest() && this.getHttpSessionIdParam()) {\r\n    uri.setParameterValue(\r\n        WebChannel.X_HTTP_SESSION_ID, this.getHttpSessionIdParam());\r\n  }\r\n\r\n  // Add the reconnect parameters.\r\n  this.addAdditionalParams_(uri);\r\n\r\n  if (this.httpHeadersOverwriteParam_ && extraHeaders) {\r\n    httpCors.setHttpHeadersWithOverwriteParam(\r\n        uri, this.httpHeadersOverwriteParam_, extraHeaders);\r\n  }\r\n\r\n  this.forwardChannelRequestPool_.addRequest(request);\r\n\r\n  // Check the option and use GET to enable QUIC 0-RTT\r\n  if (this.fastHandshake_) {\r\n    uri.setParameterValue('$req', requestText);\r\n\r\n    // enable handshake upgrade\r\n    uri.setParameterValue('SID', 'null');\r\n    request.setDecodeInitialResponse();\r\n\r\n    request.xmlHttpPost(uri, null, true);  // Send as a GET\r\n  } else {\r\n    request.xmlHttpPost(uri, requestText, true);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The number of raw JSON messages to be encoded\r\n * with the fast-handshake (GET) request, including zero. If messages are not\r\n * encoded as raw JSON data, return WebChannelBase.MAX_MAPS_PER_REQUEST_\r\n * @private\r\n */\r\nWebChannelBase.prototype.getMaxNumMessagesForFastHandshake_ = function() {\r\n  var total = 0;\r\n  for (var i = 0; i < this.outgoingMaps_.length; i++) {\r\n    var map = this.outgoingMaps_[i];\r\n    var size = map.getRawDataSize();\r\n    if (size === undefined) {\r\n      break;\r\n    }\r\n    total += size;\r\n\r\n    if (total > WebChannelBase.MAX_CHARS_PER_GET_) {\r\n      return i;\r\n    }\r\n\r\n    if (total === WebChannelBase.MAX_CHARS_PER_GET_ ||\r\n        i === this.outgoingMaps_.length - 1) {\r\n      return i + 1;\r\n    }\r\n  }\r\n\r\n  return WebChannelBase.MAX_MAPS_PER_REQUEST_;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Makes a forward channel request using XMLHTTP.\r\n * @param {!ChannelRequest=} opt_retryRequest A failed request to retry.\r\n * @private\r\n */\r\nWebChannelBase.prototype.makeForwardChannelRequest_ = function(\r\n    opt_retryRequest) {\r\n  var rid;\r\n  if (opt_retryRequest) {\r\n    rid = opt_retryRequest.getRequestId();  // Reuse the same RID for a retry\r\n  } else {\r\n    rid = this.nextRid_++;\r\n  }\r\n\r\n  var uri = this.forwardChannelUri_.clone();\r\n  uri.setParameterValue('SID', this.sid_);\r\n  uri.setParameterValue('RID', rid);\r\n  uri.setParameterValue('AID', this.lastArrayId_);\r\n  // Add the additional reconnect parameters.\r\n  this.addAdditionalParams_(uri);\r\n\r\n  if (this.httpHeadersOverwriteParam_ && this.extraHeaders_) {\r\n    httpCors.setHttpHeadersWithOverwriteParam(\r\n        uri, this.httpHeadersOverwriteParam_, this.extraHeaders_);\r\n  }\r\n\r\n  var request = ChannelRequest.createChannelRequest(\r\n      this, this.channelDebug_, this.sid_, rid,\r\n      this.forwardChannelRetryCount_ + 1);\r\n\r\n  if (this.httpHeadersOverwriteParam_ === null) {\r\n    request.setExtraHeaders(this.extraHeaders_);\r\n  }\r\n\r\n  var requestText;\r\n  if (opt_retryRequest) {\r\n    this.requeuePendingMaps_(opt_retryRequest);\r\n  }\r\n  requestText =\r\n      this.dequeueOutgoingMaps_(request, WebChannelBase.MAX_MAPS_PER_REQUEST_);\r\n\r\n  // Randomize from 50%-100% of the forward channel timeout to avoid\r\n  // a big hit if servers happen to die at once.\r\n  request.setTimeout(\r\n      Math.round(this.forwardChannelRequestTimeoutMs_ * 0.50) +\r\n      Math.round(this.forwardChannelRequestTimeoutMs_ * 0.50 * Math.random()));\r\n  this.forwardChannelRequestPool_.addRequest(request);\r\n  request.xmlHttpPost(uri, requestText, true);\r\n};\r\n\r\n\r\n/**\r\n * Adds the additional parameters from the handler to the given URI.\r\n * @param {!goog.Uri} uri The URI to add the parameters to.\r\n * @private\r\n */\r\nWebChannelBase.prototype.addAdditionalParams_ = function(uri) {\r\n  // Add the additional reconnect parameters as needed.\r\n  if (this.handler_) {\r\n    var params = this.handler_.getAdditionalParams(this);\r\n    if (params) {\r\n      goog.structs.forEach(params, function(value, key, coll) {\r\n        uri.setParameterValue(key, value);\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns the request text from the outgoing maps and resets it.\r\n * @param {!ChannelRequest} request The new request for sending the messages.\r\n * @param {number} maxNum The maximum number of messages to be encoded\r\n * @return {string} The encoded request text created from all the currently\r\n *                  queued outgoing maps.\r\n * @private\r\n */\r\nWebChannelBase.prototype.dequeueOutgoingMaps_ = function(request, maxNum) {\r\n  var count = Math.min(this.outgoingMaps_.length, maxNum);\r\n\r\n  var badMapHandler = this.handler_ ?\r\n      goog.bind(this.handler_.badMapError, this.handler_, this) :\r\n      null;\r\n  var result = this.wireCodec_.encodeMessageQueue(\r\n      this.outgoingMaps_, count, badMapHandler);\r\n\r\n  request.setPendingMessages(this.outgoingMaps_.splice(0, count));\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Requeues unacknowledged sent arrays for retransmission in the next forward\r\n * channel request.\r\n * @param {!ChannelRequest} retryRequest A failed request to retry.\r\n * @private\r\n */\r\nWebChannelBase.prototype.requeuePendingMaps_ = function(retryRequest) {\r\n  this.outgoingMaps_ =\r\n      retryRequest.getPendingMessages().concat(this.outgoingMaps_);\r\n};\r\n\r\n\r\n/**\r\n * Ensures there is a backchannel request for receiving data from the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.ensureBackChannel_ = function() {\r\n  if (this.backChannelRequest_) {\r\n    // already have one\r\n    return;\r\n  }\r\n\r\n  if (this.backChannelTimerId_) {\r\n    // no need to start a new request - one is already scheduled\r\n    return;\r\n  }\r\n\r\n  this.backChannelAttemptId_ = 1;\r\n\r\n  // Use async.run instead of setTimeout(0) to avoid the 1s message delay\r\n  // from chrome/firefox background tabs\r\n  // backChannelTimerId_ stays unset, as with setTimeout(0)\r\n  goog.async.run(this.onStartBackChannelTimer_, this);\r\n\r\n  this.backChannelRetryCount_ = 0;\r\n};\r\n\r\n\r\n/**\r\n * Schedules a back-channel retry, unless the max retries has been reached.\r\n * @return {boolean} true iff a retry was scheduled.\r\n * @private\r\n */\r\nWebChannelBase.prototype.maybeRetryBackChannel_ = function() {\r\n  if (this.backChannelRequest_ || this.backChannelTimerId_) {\r\n    // Should be impossible to be called in this state.\r\n    this.channelDebug_.severe('Request already in progress');\r\n    return false;\r\n  }\r\n\r\n  if (this.backChannelRetryCount_ >= this.getBackChannelMaxRetries()) {\r\n    return false;\r\n  }\r\n\r\n  this.channelDebug_.debug('Going to retry GET');\r\n\r\n  this.backChannelAttemptId_++;\r\n  this.backChannelTimerId_ = requestStats.setTimeout(\r\n      goog.bind(this.onStartBackChannelTimer_, this),\r\n      this.getRetryTime_(this.backChannelRetryCount_));\r\n  this.backChannelRetryCount_++;\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Timer callback for ensureBackChannel_.\r\n * @private\r\n */\r\nWebChannelBase.prototype.onStartBackChannelTimer_ = function() {\r\n  this.backChannelTimerId_ = null;\r\n  this.startBackChannel_();\r\n};\r\n\r\n\r\n/**\r\n * Begins a new back channel operation to the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.startBackChannel_ = function() {\r\n  if (!this.okToMakeRequest_()) {\r\n    // channel is cancelled\r\n    return;\r\n  }\r\n\r\n  this.channelDebug_.debug('Creating new HttpRequest');\r\n  this.backChannelRequest_ = ChannelRequest.createChannelRequest(\r\n      this, this.channelDebug_, this.sid_, 'rpc', this.backChannelAttemptId_);\r\n\r\n  if (this.httpHeadersOverwriteParam_ === null) {\r\n    this.backChannelRequest_.setExtraHeaders(this.extraHeaders_);\r\n  }\r\n\r\n  this.backChannelRequest_.setReadyStateChangeThrottle(\r\n      this.readyStateChangeThrottleMs_);\r\n  var uri = this.backChannelUri_.clone();\r\n  uri.setParameterValue('RID', 'rpc');\r\n  uri.setParameterValue('SID', this.sid_);\r\n  uri.setParameterValue('CI', this.useChunked_ ? '0' : '1');\r\n  uri.setParameterValue('AID', this.lastArrayId_);\r\n\r\n  // Add the reconnect parameters.\r\n  this.addAdditionalParams_(uri);\r\n\r\n  uri.setParameterValue('TYPE', 'xmlhttp');\r\n\r\n  if (this.httpHeadersOverwriteParam_ && this.extraHeaders_) {\r\n    httpCors.setHttpHeadersWithOverwriteParam(\r\n        uri, this.httpHeadersOverwriteParam_, this.extraHeaders_);\r\n  }\r\n\r\n  if (this.backChannelRequestTimeoutMs_) {\r\n    this.backChannelRequest_.setTimeout(this.backChannelRequestTimeoutMs_);\r\n  }\r\n\r\n  this.backChannelRequest_.xmlHttpGet(\r\n      uri, true /* decodeChunks */, this.hostPrefix_);\r\n\r\n  this.channelDebug_.debug('New Request created');\r\n};\r\n\r\n\r\n/**\r\n * Gives the handler a chance to return an error code and stop channel\r\n * execution. A handler might want to do this to check that the user is still\r\n * logged in, for example.\r\n * @private\r\n * @return {boolean} If it's OK to make a request.\r\n */\r\nWebChannelBase.prototype.okToMakeRequest_ = function() {\r\n  if (this.handler_) {\r\n    var result = this.handler_.okToMakeRequest(this);\r\n    if (result != WebChannelBase.Error.OK) {\r\n      this.channelDebug_.debug(\r\n          'Handler returned error code from okToMakeRequest');\r\n      this.signalError_(result);\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.testConnectionFinished = function(\r\n    testChannel, useChunked) {\r\n  this.channelDebug_.debug('Test Connection Finished');\r\n\r\n  // Forward channel will not be used prior to this method is called\r\n  var clientProtocol = testChannel.getClientProtocol();\r\n  if (clientProtocol) {\r\n    this.forwardChannelRequestPool_.applyClientProtocol(clientProtocol);\r\n  }\r\n\r\n  this.useChunked_ = this.allowChunkedMode_ && useChunked;\r\n  this.lastStatusCode_ = testChannel.getLastStatusCode();\r\n\r\n  this.connectChannel_();\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.testConnectionFailure = function(\r\n    testChannel, errorCode) {\r\n  this.channelDebug_.debug('Test Connection Failed');\r\n  this.lastStatusCode_ = testChannel.getLastStatusCode();\r\n  this.signalError_(WebChannelBase.Error.REQUEST_FAILED);\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.onRequestData = function(request, responseText) {\r\n  if (this.state_ == WebChannelBase.State.CLOSED ||\r\n      (this.backChannelRequest_ != request &&\r\n       !this.forwardChannelRequestPool_.hasRequest(request))) {\r\n    // either CLOSED or a request we don't know about (perhaps an old request)\r\n    return;\r\n  }\r\n  this.lastStatusCode_ = request.getLastStatusCode();\r\n\r\n  // first to check if request has been upgraded to backchannel\r\n  if (!request.isInitialResponseDecoded() &&\r\n      this.forwardChannelRequestPool_.hasRequest(request) &&\r\n      this.state_ == WebChannelBase.State.OPENED) {\r\n    var response;\r\n    try {\r\n      response = this.wireCodec_.decodeMessage(responseText);\r\n    } catch (ex) {\r\n      response = null;\r\n    }\r\n    if (goog.isArray(response) && response.length == 3) {\r\n      this.handlePostResponse_(/** @type {!Array<?>} */ (response), request);\r\n      this.onForwardChannelFlushed_();\r\n    } else {\r\n      this.channelDebug_.debug('Bad POST response data returned');\r\n      this.signalError_(WebChannelBase.Error.BAD_RESPONSE);\r\n    }\r\n  } else {\r\n    if (request.isInitialResponseDecoded() ||\r\n        this.backChannelRequest_ == request) {\r\n      this.clearDeadBackchannelTimer_();\r\n    }\r\n    if (!goog.string.isEmptyOrWhitespace(responseText)) {\r\n      var response = this.wireCodec_.decodeMessage(responseText);\r\n      this.onInput_(/** @type {!Array<?>} */ (response), request);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Checks if we need call the flush callback.\r\n *\r\n * @private\r\n */\r\nWebChannelBase.prototype.onForwardChannelFlushed_ = function() {\r\n  if (this.forwardChannelRequestPool_.getRequestCount() <= 1) {\r\n    if (this.forwardChannelFlushedCallback_) {\r\n      try {\r\n        this.forwardChannelFlushedCallback_();\r\n      } catch (ex) {\r\n        this.channelDebug_.dumpException(\r\n            ex, 'Exception from forwardChannelFlushedCallback_ ');\r\n      }\r\n      // reset\r\n      this.forwardChannelFlushedCallback_ = undefined;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Handles a POST response from the server.\r\n * @param {Array<number>} responseValues The key value pairs in\r\n *     the POST response.\r\n * @param {!ChannelRequest} forwardReq The forward channel request that\r\n * triggers this function call.\r\n * @private\r\n */\r\nWebChannelBase.prototype.handlePostResponse_ = function(\r\n    responseValues, forwardReq) {\r\n  // The first response value is set to 0 if server is missing backchannel.\r\n  if (responseValues[0] == 0) {\r\n    this.handleBackchannelMissing_(forwardReq);\r\n    return;\r\n  }\r\n  this.lastPostResponseArrayId_ = responseValues[1];\r\n  var outstandingArrays = this.lastPostResponseArrayId_ - this.lastArrayId_;\r\n  if (0 < outstandingArrays) {\r\n    var numOutstandingBackchannelBytes = responseValues[2];\r\n    this.channelDebug_.debug(\r\n        numOutstandingBackchannelBytes + ' bytes (in ' + outstandingArrays +\r\n        ' arrays) are outstanding on the BackChannel');\r\n    if (!this.shouldRetryBackChannel_(numOutstandingBackchannelBytes)) {\r\n      return;\r\n    }\r\n    if (!this.deadBackChannelTimerId_) {\r\n      // We expect to receive data within 2 RTTs or we retry the backchannel.\r\n      this.deadBackChannelTimerId_ = requestStats.setTimeout(\r\n          goog.bind(this.onBackChannelDead_, this),\r\n          2 * WebChannelBase.RTT_ESTIMATE);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Handles a POST response from the server telling us that it has detected that\r\n * we have no hanging GET connection.\r\n * @param {!ChannelRequest} forwardReq The forward channel request that\r\n * triggers this function call.\r\n * @private\r\n */\r\nWebChannelBase.prototype.handleBackchannelMissing_ = function(forwardReq) {\r\n  // As long as the back channel was started before the POST was sent,\r\n  // we should retry the backchannel. We give a slight buffer of RTT_ESTIMATE\r\n  // so as not to excessively retry the backchannel\r\n  this.channelDebug_.debug('Server claims our backchannel is missing.');\r\n  if (this.backChannelTimerId_) {\r\n    this.channelDebug_.debug('But we are currently starting the request.');\r\n    return;\r\n  } else if (!this.backChannelRequest_) {\r\n    this.channelDebug_.warning('We do not have a BackChannel established');\r\n  } else if (\r\n      this.backChannelRequest_.getRequestStartTime() +\r\n          WebChannelBase.RTT_ESTIMATE <\r\n      forwardReq.getRequestStartTime()) {\r\n    this.clearDeadBackchannelTimer_();\r\n    this.backChannelRequest_.cancel();\r\n    this.backChannelRequest_ = null;\r\n  } else {\r\n    return;\r\n  }\r\n  this.maybeRetryBackChannel_();\r\n  requestStats.notifyStatEvent(requestStats.Stat.BACKCHANNEL_MISSING);\r\n};\r\n\r\n\r\n/**\r\n * Determines whether we should start the process of retrying a possibly\r\n * dead backchannel.\r\n * @param {number} outstandingBytes The number of bytes for which the server has\r\n *     not yet received acknowledgement.\r\n * @return {boolean} Whether to start the backchannel retry timer.\r\n * @private\r\n */\r\nWebChannelBase.prototype.shouldRetryBackChannel_ = function(outstandingBytes) {\r\n  // Not too many outstanding bytes, not buffered and not after a retry.\r\n  return outstandingBytes <\r\n      WebChannelBase.OUTSTANDING_DATA_BACKCHANNEL_RETRY_CUTOFF &&\r\n      !this.isBuffered() && this.backChannelRetryCount_ == 0;\r\n};\r\n\r\n\r\n/**\r\n * Decides which host prefix should be used, if any.  If there is a handler,\r\n * allows the handler to validate a host prefix provided by the server, and\r\n * optionally override it.\r\n * @param {?string} serverHostPrefix The host prefix provided by the server.\r\n * @return {?string} The host prefix to actually use, if any. Will return null\r\n *     if the use of host prefixes was disabled via setAllowHostPrefix().\r\n * @override\r\n */\r\nWebChannelBase.prototype.correctHostPrefix = function(serverHostPrefix) {\r\n  if (this.allowHostPrefix_) {\r\n    if (this.handler_) {\r\n      return this.handler_.correctHostPrefix(serverHostPrefix);\r\n    }\r\n    return serverHostPrefix;\r\n  }\r\n  return null;\r\n};\r\n\r\n\r\n/**\r\n * Handles the timer that indicates that our backchannel is no longer able to\r\n * successfully receive data from the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.onBackChannelDead_ = function() {\r\n  if (goog.isDefAndNotNull(this.deadBackChannelTimerId_)) {\r\n    this.deadBackChannelTimerId_ = null;\r\n    this.backChannelRequest_.cancel();\r\n    this.backChannelRequest_ = null;\r\n    this.maybeRetryBackChannel_();\r\n    requestStats.notifyStatEvent(requestStats.Stat.BACKCHANNEL_DEAD);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clears the timer that indicates that our backchannel is no longer able to\r\n * successfully receive data from the server.\r\n * @private\r\n */\r\nWebChannelBase.prototype.clearDeadBackchannelTimer_ = function() {\r\n  if (goog.isDefAndNotNull(this.deadBackChannelTimerId_)) {\r\n    goog.global.clearTimeout(this.deadBackChannelTimerId_);\r\n    this.deadBackChannelTimerId_ = null;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns whether or not the given error/status combination is fatal or not.\r\n * On fatal errors we immediately close the session rather than retrying the\r\n * failed request.\r\n * @param {?ChannelRequest.Error} error The error code for the\r\n * failed request.\r\n * @param {number} statusCode The last HTTP status code.\r\n * @return {boolean} Whether or not the error is fatal.\r\n * @private\r\n */\r\nWebChannelBase.isFatalError_ = function(error, statusCode) {\r\n  return error == ChannelRequest.Error.UNKNOWN_SESSION_ID ||\r\n      (error == ChannelRequest.Error.STATUS && statusCode > 0);\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.onRequestComplete = function(request) {\r\n  this.channelDebug_.debug('Request complete');\r\n  var type;\r\n  var pendingMessages = null;\r\n  if (this.backChannelRequest_ == request) {\r\n    this.clearDeadBackchannelTimer_();\r\n    this.backChannelRequest_ = null;\r\n    type = WebChannelBase.ChannelType_.BACK_CHANNEL;\r\n  } else if (this.forwardChannelRequestPool_.hasRequest(request)) {\r\n    pendingMessages = request.getPendingMessages();\r\n    this.forwardChannelRequestPool_.removeRequest(request);\r\n    type = WebChannelBase.ChannelType_.FORWARD_CHANNEL;\r\n  } else {\r\n    // return if it was an old request from a previous session\r\n    return;\r\n  }\r\n\r\n  this.lastStatusCode_ = request.getLastStatusCode();\r\n\r\n  if (this.state_ == WebChannelBase.State.CLOSED) {\r\n    return;\r\n  }\r\n\r\n  if (request.getSuccess()) {\r\n    // Yay!\r\n    if (type == WebChannelBase.ChannelType_.FORWARD_CHANNEL) {\r\n      var size = request.getPostData() ? request.getPostData().length : 0;\r\n      requestStats.notifyTimingEvent(\r\n          size, goog.now() - request.getRequestStartTime(),\r\n          this.forwardChannelRetryCount_);\r\n      this.ensureForwardChannel_();\r\n      this.onSuccess_(request);\r\n    } else {  // i.e., back-channel\r\n      this.ensureBackChannel_();\r\n    }\r\n    return;\r\n  }\r\n  // Else unsuccessful. Fall through.\r\n\r\n  var lastError = request.getLastError();\r\n  if (!WebChannelBase.isFatalError_(lastError, this.lastStatusCode_)) {\r\n    // Maybe retry.\r\n    var self = this;\r\n    this.channelDebug_.debug(function() {\r\n      return 'Maybe retrying, last error: ' +\r\n          ChannelRequest.errorStringFromCode(lastError, self.lastStatusCode_);\r\n    });\r\n    if (type == WebChannelBase.ChannelType_.FORWARD_CHANNEL) {\r\n      if (this.maybeRetryForwardChannel_(request)) {\r\n        return;\r\n      }\r\n    }\r\n    if (type == WebChannelBase.ChannelType_.BACK_CHANNEL) {\r\n      if (this.maybeRetryBackChannel_()) {\r\n        return;\r\n      }\r\n    }\r\n    // Else exceeded max retries. Fall through.\r\n    this.channelDebug_.debug('Exceeded max number of retries');\r\n  } else {\r\n    // Else fatal error. Fall through and mark the pending maps as failed.\r\n    this.channelDebug_.debug('Not retrying due to error type');\r\n  }\r\n\r\n\r\n  // Abort the channel now\r\n\r\n  // Record pending messages from the failed request\r\n  if (pendingMessages && pendingMessages.length > 0) {\r\n    this.forwardChannelRequestPool_.addPendingMessages(pendingMessages);\r\n  }\r\n\r\n  this.channelDebug_.debug('Error: HTTP request failed');\r\n  switch (lastError) {\r\n    case ChannelRequest.Error.NO_DATA:\r\n      this.signalError_(WebChannelBase.Error.NO_DATA);\r\n      break;\r\n    case ChannelRequest.Error.BAD_DATA:\r\n      this.signalError_(WebChannelBase.Error.BAD_DATA);\r\n      break;\r\n    case ChannelRequest.Error.UNKNOWN_SESSION_ID:\r\n      this.signalError_(WebChannelBase.Error.UNKNOWN_SESSION_ID);\r\n      break;\r\n    default:\r\n      this.signalError_(WebChannelBase.Error.REQUEST_FAILED);\r\n      break;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @param {number} retryCount Number of retries so far.\r\n * @return {number} Time in ms before firing next retry request.\r\n * @private\r\n */\r\nWebChannelBase.prototype.getRetryTime_ = function(retryCount) {\r\n  var retryTime = this.baseRetryDelayMs_ +\r\n      Math.floor(Math.random() * this.retryDelaySeedMs_);\r\n  if (!this.isActive()) {\r\n    this.channelDebug_.debug('Inactive channel');\r\n    retryTime = retryTime * WebChannelBase.INACTIVE_CHANNEL_RETRY_FACTOR;\r\n  }\r\n  // Backoff for subsequent retries\r\n  retryTime *= retryCount;\r\n  return retryTime;\r\n};\r\n\r\n\r\n/**\r\n * @param {number} baseDelayMs The base part of the retry delay, in ms.\r\n * @param {number} delaySeedMs A random delay between 0 and this is added to\r\n *     the base part.\r\n */\r\nWebChannelBase.prototype.setRetryDelay = function(baseDelayMs, delaySeedMs) {\r\n  this.baseRetryDelayMs_ = baseDelayMs;\r\n  this.retryDelaySeedMs_ = delaySeedMs;\r\n};\r\n\r\n\r\n/**\r\n * Apply any handshake control headers.\r\n * @param {!ChannelRequest} request The underlying request object\r\n * @private\r\n */\r\nWebChannelBase.prototype.applyControlHeaders_ = function(request) {\r\n  if (!this.backgroundChannelTest_) {\r\n    return;\r\n  }\r\n\r\n  var xhr = request.getXhr();\r\n  if (xhr) {\r\n    var clientProtocol =\r\n        xhr.getStreamingResponseHeader(WebChannel.X_CLIENT_WIRE_PROTOCOL);\r\n    if (clientProtocol) {\r\n      this.forwardChannelRequestPool_.applyClientProtocol(clientProtocol);\r\n    }\r\n\r\n    if (this.getHttpSessionIdParam()) {\r\n      var httpSessionIdHeader =\r\n          xhr.getStreamingResponseHeader(WebChannel.X_HTTP_SESSION_ID);\r\n      if (httpSessionIdHeader) {\r\n        this.setHttpSessionId(httpSessionIdHeader);\r\n        // update the cached uri\r\n        var httpSessionIdParam = this.getHttpSessionIdParam();\r\n\r\n        this.forwardChannelUri_.setParameterValue(\r\n            /** @type {string} */ (httpSessionIdParam),  // never null\r\n            httpSessionIdHeader);\r\n      } else {\r\n        this.channelDebug_.warning(\r\n            'Missing X_HTTP_SESSION_ID in the handshake response');\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Processes the data returned by the server.\r\n * @param {!Array<!Array<?>>} respArray The response array returned\r\n *     by the server.\r\n * @param {!ChannelRequest} request The underlying request object\r\n * @private\r\n */\r\nWebChannelBase.prototype.onInput_ = function(respArray, request) {\r\n  var batch =\r\n      this.handler_ && this.handler_.channelHandleMultipleArrays ? [] : null;\r\n  for (var i = 0; i < respArray.length; i++) {\r\n    var nextArray = respArray[i];\r\n    this.lastArrayId_ = nextArray[0];\r\n    nextArray = nextArray[1];\r\n    if (this.state_ == WebChannelBase.State.OPENING) {\r\n      if (nextArray[0] == 'c') {\r\n        this.sid_ = nextArray[1];\r\n        this.hostPrefix_ = this.correctHostPrefix(nextArray[2]);\r\n\r\n        var negotiatedVersion = nextArray[3];\r\n        if (goog.isDefAndNotNull(negotiatedVersion)) {\r\n          this.channelVersion_ = negotiatedVersion;\r\n          this.channelDebug_.info('VER=' + this.channelVersion_);\r\n        }\r\n\r\n        var negotiatedServerVersion = nextArray[4];\r\n        if (goog.isDefAndNotNull(negotiatedServerVersion)) {\r\n          this.serverVersion_ = negotiatedServerVersion;\r\n          this.channelDebug_.info('SVER=' + this.serverVersion_);\r\n        }\r\n\r\n        // CVER=22\r\n        var serverKeepaliveMs = nextArray[5];\r\n        if (goog.isDefAndNotNull(serverKeepaliveMs) &&\r\n            goog.isNumber(serverKeepaliveMs) && serverKeepaliveMs > 0) {\r\n          var timeout = 1.5 * serverKeepaliveMs;\r\n          this.backChannelRequestTimeoutMs_ = timeout;\r\n          this.channelDebug_.info('backChannelRequestTimeoutMs_=' + timeout);\r\n        }\r\n\r\n        this.applyControlHeaders_(request);\r\n\r\n        this.state_ = WebChannelBase.State.OPENED;\r\n        if (this.handler_) {\r\n          this.handler_.channelOpened(this);\r\n        }\r\n\r\n        this.startBackchannelAfterHandshake_(request);\r\n\r\n        if (this.outgoingMaps_.length > 0) {\r\n          this.ensureForwardChannel_();\r\n        }\r\n      } else if (nextArray[0] == 'stop' || nextArray[0] == 'close') {\r\n        // treat close also as an abort\r\n        this.signalError_(WebChannelBase.Error.STOP);\r\n      }\r\n    } else if (this.state_ == WebChannelBase.State.OPENED) {\r\n      if (nextArray[0] == 'stop' || nextArray[0] == 'close') {\r\n        if (batch && !goog.array.isEmpty(batch)) {\r\n          this.handler_.channelHandleMultipleArrays(this, batch);\r\n          batch.length = 0;\r\n        }\r\n        if (nextArray[0] == 'stop') {\r\n          this.signalError_(WebChannelBase.Error.STOP);\r\n        } else {\r\n          this.disconnect();\r\n        }\r\n      } else if (nextArray[0] == 'noop') {\r\n        // ignore - noop to keep connection happy\r\n      } else {\r\n        if (batch) {\r\n          batch.push(nextArray);\r\n        } else if (this.handler_) {\r\n          this.handler_.channelHandleArray(this, nextArray);\r\n        }\r\n      }\r\n      // We have received useful data on the back-channel, so clear its retry\r\n      // count. We do this because back-channels by design do not complete\r\n      // quickly, so on a flaky connection we could have many fail to complete\r\n      // fully but still deliver a lot of data before they fail. We don't want\r\n      // to count such failures towards the retry limit, because we don't want\r\n      // to give up on a session if we can still receive data.\r\n      this.backChannelRetryCount_ = 0;\r\n    }\r\n  }\r\n  if (batch && !goog.array.isEmpty(batch)) {\r\n    this.handler_.channelHandleMultipleArrays(this, batch);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Starts the backchannel after the handshake.\r\n *\r\n * @param {!ChannelRequest} request The underlying request object\r\n * @private\r\n */\r\nWebChannelBase.prototype.startBackchannelAfterHandshake_ = function(request) {\r\n  this.backChannelUri_ = this.getBackChannelUri(\r\n      this.hostPrefix_, /** @type {string} */ (this.path_));\r\n\r\n  if (request.isInitialResponseDecoded()) {\r\n    this.channelDebug_.debug('Upgrade the handshake request to a backchannel.');\r\n    this.forwardChannelRequestPool_.removeRequest(request);\r\n    request.resetTimeout(this.backChannelRequestTimeoutMs_);\r\n    this.backChannelRequest_ = request;\r\n  } else {\r\n    // Open connection to receive data\r\n    this.ensureBackChannel_();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Helper to ensure the channel is in the expected state.\r\n * @param {...number} var_args The channel must be in one of the indicated\r\n *     states.\r\n * @private\r\n */\r\nWebChannelBase.prototype.ensureInState_ = function(var_args) {\r\n  goog.asserts.assert(\r\n      goog.array.contains(arguments, this.state_),\r\n      'Unexpected channel state: %s', this.state_);\r\n};\r\n\r\n\r\n/**\r\n * Signals an error has occurred.\r\n * @param {WebChannelBase.Error} error The error code for the failure.\r\n * @private\r\n */\r\nWebChannelBase.prototype.signalError_ = function(error) {\r\n  this.channelDebug_.info('Error code ' + error);\r\n  if (error == WebChannelBase.Error.REQUEST_FAILED) {\r\n    // Create a separate Internet connection to check\r\n    // if it's a server error or user's network error.\r\n    var imageUri = null;\r\n    if (this.handler_) {\r\n      imageUri = this.handler_.getNetworkTestImageUri(this);\r\n    }\r\n    netUtils.testNetwork(goog.bind(this.testNetworkCallback_, this), imageUri);\r\n  } else {\r\n    requestStats.notifyStatEvent(requestStats.Stat.ERROR_OTHER);\r\n  }\r\n  this.onError_(error);\r\n};\r\n\r\n\r\n/**\r\n * Callback for netUtils.testNetwork during error handling.\r\n * @param {boolean} networkUp Whether the network is up.\r\n * @private\r\n */\r\nWebChannelBase.prototype.testNetworkCallback_ = function(networkUp) {\r\n  if (networkUp) {\r\n    this.channelDebug_.info('Successfully pinged google.com');\r\n    requestStats.notifyStatEvent(requestStats.Stat.ERROR_OTHER);\r\n  } else {\r\n    this.channelDebug_.info('Failed to ping google.com');\r\n    requestStats.notifyStatEvent(requestStats.Stat.ERROR_NETWORK);\r\n    // Do not call onError_ again to eliminate duplicated Error events.\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called when messages have been successfully sent from the queue.\r\n * @param {!ChannelRequest} request The request object\r\n * @private\r\n */\r\nWebChannelBase.prototype.onSuccess_ = function(request) {\r\n  if (this.handler_) {\r\n    this.handler_.channelSuccess(this, request);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called when we've determined the final error for a channel. It closes the\r\n * notifiers the handler of the error and closes the channel.\r\n * @param {WebChannelBase.Error} error  The error code for the failure.\r\n * @private\r\n */\r\nWebChannelBase.prototype.onError_ = function(error) {\r\n  this.channelDebug_.debug('HttpChannel: error - ' + error);\r\n  this.state_ = WebChannelBase.State.CLOSED;\r\n  if (this.handler_) {\r\n    this.handler_.channelError(this, error);\r\n  }\r\n  this.onClose_();\r\n  this.cancelRequests_();\r\n};\r\n\r\n\r\n/**\r\n * Called when the channel has been closed. It notifiers the handler of the\r\n * event, and reports any pending or undelivered maps.\r\n * @private\r\n */\r\nWebChannelBase.prototype.onClose_ = function() {\r\n  this.state_ = WebChannelBase.State.CLOSED;\r\n  this.lastStatusCode_ = -1;\r\n  if (this.handler_) {\r\n    var pendingMessages = this.forwardChannelRequestPool_.getPendingMessages();\r\n\r\n    if (pendingMessages.length == 0 && this.outgoingMaps_.length == 0) {\r\n      this.handler_.channelClosed(this);\r\n    } else {\r\n      var self = this;\r\n      this.channelDebug_.debug(function() {\r\n        return 'Number of undelivered maps' +\r\n            ', pending: ' + pendingMessages.length +\r\n            ', outgoing: ' + self.outgoingMaps_.length;\r\n      });\r\n\r\n      this.forwardChannelRequestPool_.clearPendingMessages();\r\n\r\n      var copyOfUndeliveredMaps = goog.array.clone(this.outgoingMaps_);\r\n      this.outgoingMaps_.length = 0;\r\n\r\n      this.handler_.channelClosed(this, pendingMessages, copyOfUndeliveredMaps);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getForwardChannelUri = function(path) {\r\n  var uri = this.createDataUri(null, path);\r\n  this.channelDebug_.debug('GetForwardChannelUri: ' + uri);\r\n  return uri;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getConnectionState = function() {\r\n  return this.connState_;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.getBackChannelUri = function(hostPrefix, path) {\r\n  var uri = this.createDataUri(\r\n      this.shouldUseSecondaryDomains() ? hostPrefix : null, path);\r\n  this.channelDebug_.debug('GetBackChannelUri: ' + uri);\r\n  return uri;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.createDataUri = function(\r\n    hostPrefix, path, opt_overridePort) {\r\n  var uri = goog.Uri.parse(path);\r\n  var uriAbsolute = (uri.getDomain() != '');\r\n  if (uriAbsolute) {\r\n    if (hostPrefix) {\r\n      uri.setDomain(hostPrefix + '.' + uri.getDomain());\r\n    }\r\n\r\n    uri.setPort(opt_overridePort || uri.getPort());\r\n  } else {\r\n    var locationPage = goog.global.location;\r\n    var hostName;\r\n    if (hostPrefix) {\r\n      hostName = hostPrefix + '.' + locationPage.hostname;\r\n    } else {\r\n      hostName = locationPage.hostname;\r\n    }\r\n\r\n    var port = opt_overridePort || +locationPage.port;\r\n\r\n    uri = goog.Uri.create(locationPage.protocol, null, hostName, port, path);\r\n  }\r\n\r\n  if (this.extraParams_) {\r\n    goog.object.forEach(this.extraParams_, function(value, key) {\r\n      uri.setParameterValue(key, value);\r\n    });\r\n  }\r\n\r\n  var param = this.getHttpSessionIdParam();\r\n  var value = this.getHttpSessionId();\r\n  if (param && value) {\r\n    uri.setParameterValue(param, value);\r\n  }\r\n\r\n  // Add the protocol version to the URI.\r\n  uri.setParameterValue('VER', this.channelVersion_);\r\n\r\n  // Add the reconnect parameters.\r\n  this.addAdditionalParams_(uri);\r\n\r\n  return uri;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.createXhrIo = function(hostPrefix) {\r\n  if (hostPrefix && !this.supportsCrossDomainXhrs_) {\r\n    throw new Error('Can\\'t create secondary domain capable XhrIo object.');\r\n  }\r\n  var xhr = new goog.net.XhrIo(this.xmlHttpFactory_);\r\n  xhr.setWithCredentials(this.supportsCrossDomainXhrs_);\r\n  return xhr;\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.isActive = function() {\r\n  return !!this.handler_ && this.handler_.isActive(this);\r\n};\r\n\r\n\r\n/**\r\n * @override\r\n */\r\nWebChannelBase.prototype.shouldUseSecondaryDomains = function() {\r\n  return this.supportsCrossDomainXhrs_;\r\n};\r\n\r\n\r\n/**\r\n * Sets (overwrites) the forward channel flush callback.\r\n *\r\n * @param {function()} callback The callback to be invoked.\r\n */\r\nWebChannelBase.prototype.setForwardChannelFlushCallback = function(callback) {\r\n  this.forwardChannelFlushedCallback_ = callback;\r\n};\r\n\r\n\r\n/**\r\n * A LogSaver that can be used to accumulate all the debug logs so they\r\n * can be sent to the server when a problem is detected.\r\n * @const\r\n */\r\nWebChannelBase.LogSaver = {};\r\n\r\n\r\n/**\r\n * Buffer for accumulating the debug log\r\n * @type {goog.structs.CircularBuffer}\r\n * @private\r\n */\r\nWebChannelBase.LogSaver.buffer_ = new goog.structs.CircularBuffer(1000);\r\n\r\n\r\n/**\r\n * Whether we're currently accumulating the debug log.\r\n * @type {boolean}\r\n * @private\r\n */\r\nWebChannelBase.LogSaver.enabled_ = false;\r\n\r\n\r\n/**\r\n * Formatter for saving logs.\r\n * @type {goog.debug.Formatter}\r\n * @private\r\n */\r\nWebChannelBase.LogSaver.formatter_ = new goog.debug.TextFormatter();\r\n\r\n\r\n/**\r\n * Returns whether the LogSaver is enabled.\r\n * @return {boolean} Whether saving is enabled or disabled.\r\n */\r\nWebChannelBase.LogSaver.isEnabled = function() {\r\n  return WebChannelBase.LogSaver.enabled_;\r\n};\r\n\r\n\r\n/**\r\n * Enables of disables the LogSaver.\r\n * @param {boolean} enable Whether to enable or disable saving.\r\n */\r\nWebChannelBase.LogSaver.setEnabled = function(enable) {\r\n  if (enable == WebChannelBase.LogSaver.enabled_) {\r\n    return;\r\n  }\r\n\r\n  var fn = WebChannelBase.LogSaver.addLogRecord;\r\n  var logger = goog.log.getLogger('goog.net');\r\n  if (enable) {\r\n    goog.log.addHandler(logger, fn);\r\n  } else {\r\n    goog.log.removeHandler(logger, fn);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Adds a log record.\r\n * @param {goog.log.LogRecord} logRecord the LogRecord.\r\n */\r\nWebChannelBase.LogSaver.addLogRecord = function(logRecord) {\r\n  WebChannelBase.LogSaver.buffer_.add(\r\n      WebChannelBase.LogSaver.formatter_.formatRecord(logRecord));\r\n};\r\n\r\n\r\n/**\r\n * Returns the log as a single string.\r\n * @return {string} The log as a single string.\r\n */\r\nWebChannelBase.LogSaver.getBuffer = function() {\r\n  return WebChannelBase.LogSaver.buffer_.getValues().join('');\r\n};\r\n\r\n\r\n/**\r\n * Clears the buffer\r\n */\r\nWebChannelBase.LogSaver.clearBuffer = function() {\r\n  WebChannelBase.LogSaver.buffer_.clear();\r\n};\r\n\r\n\r\n\r\n/**\r\n * Abstract base class for the channel handler\r\n * @constructor\r\n * @struct\r\n */\r\nWebChannelBase.Handler = function() {};\r\n\r\n\r\n/**\r\n * Callback handler for when a batch of response arrays is received from the\r\n * server. When null, batched dispatching is disabled.\r\n * @type {?function(!WebChannelBase, !Array<!Array<?>>)}\r\n */\r\nWebChannelBase.Handler.prototype.channelHandleMultipleArrays = null;\r\n\r\n\r\n/**\r\n * Whether it's okay to make a request to the server. A handler can return\r\n * false if the channel should fail. For example, if the user has logged out,\r\n * the handler may want all requests to fail immediately.\r\n * @param {WebChannelBase} channel The channel.\r\n * @return {WebChannelBase.Error} An error code. The code should\r\n * return WebChannelBase.Error.OK to indicate it's okay. Any other\r\n * error code will cause a failure.\r\n */\r\nWebChannelBase.Handler.prototype.okToMakeRequest = function(channel) {\r\n  return WebChannelBase.Error.OK;\r\n};\r\n\r\n\r\n/**\r\n * Indicates the WebChannel has successfully negotiated with the server\r\n * and can now send and receive data.\r\n * @param {WebChannelBase} channel The channel.\r\n */\r\nWebChannelBase.Handler.prototype.channelOpened = function(channel) {};\r\n\r\n\r\n/**\r\n * New input is available for the application to process.\r\n *\r\n * @param {WebChannelBase} channel The channel.\r\n * @param {Array<?>} array The data array.\r\n */\r\nWebChannelBase.Handler.prototype.channelHandleArray = function(\r\n    channel, array) {};\r\n\r\n\r\n/**\r\n * Indicates messages that have been successfully sent on the channel.\r\n *\r\n * @param {WebChannelBase} channel The channel.\r\n * @param {!ChannelRequest} request The request object that contains\r\n *     the pending messages that have been successfully delivered to the server.\r\n */\r\nWebChannelBase.Handler.prototype.channelSuccess = function(channel, request) {};\r\n\r\n\r\n/**\r\n * Indicates an error occurred on the WebChannel.\r\n *\r\n * @param {WebChannelBase} channel The channel.\r\n * @param {WebChannelBase.Error} error The error code.\r\n */\r\nWebChannelBase.Handler.prototype.channelError = function(channel, error) {};\r\n\r\n\r\n/**\r\n * Indicates the WebChannel is closed. Also notifies about which maps,\r\n * if any, that may not have been delivered to the server.\r\n * @param {WebChannelBase} channel The channel.\r\n * @param {Array<Wire.QueuedMap>=} opt_pendingMaps The\r\n *     array of pending maps, which may or may not have been delivered to the\r\n *     server.\r\n * @param {Array<Wire.QueuedMap>=} opt_undeliveredMaps\r\n *     The array of undelivered maps, which have definitely not been delivered\r\n *     to the server.\r\n */\r\nWebChannelBase.Handler.prototype.channelClosed = function(\r\n    channel, opt_pendingMaps, opt_undeliveredMaps) {};\r\n\r\n\r\n/**\r\n * Gets any parameters that should be added at the time another connection is\r\n * made to the server.\r\n * @param {WebChannelBase} channel The channel.\r\n * @return {!Object} Extra parameter keys and values to add to the requests.\r\n */\r\nWebChannelBase.Handler.prototype.getAdditionalParams = function(channel) {\r\n  return {};\r\n};\r\n\r\n\r\n/**\r\n * Gets the URI of an image that can be used to test network connectivity.\r\n * @param {WebChannelBase} channel The channel.\r\n * @return {goog.Uri?} A custom URI to load for the network test.\r\n */\r\nWebChannelBase.Handler.prototype.getNetworkTestImageUri = function(channel) {\r\n  return null;\r\n};\r\n\r\n\r\n/**\r\n * Gets whether this channel is currently active. This is used to determine the\r\n * length of time to wait before retrying.\r\n * @param {WebChannelBase} channel The channel.\r\n * @return {boolean} Whether the channel is currently active.\r\n */\r\nWebChannelBase.Handler.prototype.isActive = function(channel) {\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Called by the channel if enumeration of the map throws an exception.\r\n * @param {WebChannelBase} channel The channel.\r\n * @param {Object} map The map that can't be enumerated.\r\n */\r\nWebChannelBase.Handler.prototype.badMapError = function(channel, map) {};\r\n\r\n\r\n/**\r\n * Allows the handler to override a host prefix provided by the server. Will\r\n * be called whenever the channel has received such a prefix and is considering\r\n * its use.\r\n * @param {?string} serverHostPrefix The host prefix provided by the server.\r\n * @return {?string} The host prefix the client should use.\r\n */\r\nWebChannelBase.Handler.prototype.correctHostPrefix = function(\r\n    serverHostPrefix) {\r\n  return serverHostPrefix;\r\n};\r\n});  // goog.scope\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Generics method for collection-like classes and objects.\r\n *\r\n * @author arv@google.com (Erik Arvidsson)\r\n *\r\n * This file contains functions to work with collections. It supports using\r\n * Map, Set, Array and Object and other classes that implement collection-like\r\n * methods.\r\n * @suppress {strictMissingProperties}\r\n */\r\n\r\n\r\ngoog.provide('goog.structs');\r\n\r\ngoog.require('goog.array');\r\ngoog.require('goog.object');\r\n\r\n\r\n// We treat an object as a dictionary if it has getKeys or it is an object that\r\n// isn't arrayLike.\r\n\r\n\r\n/**\r\n * Returns the number of values in the collection-like object.\r\n * @param {Object} col The collection-like object.\r\n * @return {number} The number of values in the collection-like object.\r\n */\r\ngoog.structs.getCount = function(col) {\r\n  if (col.getCount && typeof col.getCount == 'function') {\r\n    return col.getCount();\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return col.length;\r\n  }\r\n  return goog.object.getCount(col);\r\n};\r\n\r\n\r\n/**\r\n * Returns the values of the collection-like object.\r\n * @param {Object} col The collection-like object.\r\n * @return {!Array<?>} The values in the collection-like object.\r\n */\r\ngoog.structs.getValues = function(col) {\r\n  if (col.getValues && typeof col.getValues == 'function') {\r\n    return col.getValues();\r\n  }\r\n  if (goog.isString(col)) {\r\n    return col.split('');\r\n  }\r\n  if (goog.isArrayLike(col)) {\r\n    var rv = [];\r\n    var l = col.length;\r\n    for (var i = 0; i < l; i++) {\r\n      rv.push(col[i]);\r\n    }\r\n    return rv;\r\n  }\r\n  return goog.object.getValues(col);\r\n};\r\n\r\n\r\n/**\r\n * Returns the keys of the collection. Some collections have no notion of\r\n * keys/indexes and this function will return undefined in those cases.\r\n * @param {Object} col The collection-like object.\r\n * @return {!Array|undefined} The keys in the collection.\r\n */\r\ngoog.structs.getKeys = function(col) {\r\n  if (col.getKeys && typeof col.getKeys == 'function') {\r\n    return col.getKeys();\r\n  }\r\n  // if we have getValues but no getKeys we know this is a key-less collection\r\n  if (col.getValues && typeof col.getValues == 'function') {\r\n    return undefined;\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    var rv = [];\r\n    var l = col.length;\r\n    for (var i = 0; i < l; i++) {\r\n      rv.push(i);\r\n    }\r\n    return rv;\r\n  }\r\n\r\n  return goog.object.getKeys(col);\r\n};\r\n\r\n\r\n/**\r\n * Whether the collection contains the given value. This is O(n) and uses\r\n * equals (==) to test the existence.\r\n * @param {Object} col The collection-like object.\r\n * @param {*} val The value to check for.\r\n * @return {boolean} True if the map contains the value.\r\n */\r\ngoog.structs.contains = function(col, val) {\r\n  if (col.contains && typeof col.contains == 'function') {\r\n    return col.contains(val);\r\n  }\r\n  if (col.containsValue && typeof col.containsValue == 'function') {\r\n    return col.containsValue(val);\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.contains(/** @type {!Array<?>} */ (col), val);\r\n  }\r\n  return goog.object.containsValue(col, val);\r\n};\r\n\r\n\r\n/**\r\n * Whether the collection is empty.\r\n * @param {Object} col The collection-like object.\r\n * @return {boolean} True if empty.\r\n */\r\ngoog.structs.isEmpty = function(col) {\r\n  if (col.isEmpty && typeof col.isEmpty == 'function') {\r\n    return col.isEmpty();\r\n  }\r\n\r\n  // We do not use goog.string.isEmptyOrWhitespace because here we treat the\r\n  // string as\r\n  // collection and as such even whitespace matters\r\n\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.isEmpty(/** @type {!Array<?>} */ (col));\r\n  }\r\n  return goog.object.isEmpty(col);\r\n};\r\n\r\n\r\n/**\r\n * Removes all the elements from the collection.\r\n * @param {Object} col The collection-like object.\r\n */\r\ngoog.structs.clear = function(col) {\r\n  // NOTE(arv): This should not contain strings because strings are immutable\r\n  if (col.clear && typeof col.clear == 'function') {\r\n    col.clear();\r\n  } else if (goog.isArrayLike(col)) {\r\n    goog.array.clear(/** @type {IArrayLike<?>} */ (col));\r\n  } else {\r\n    goog.object.clear(col);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for each value in a collection. The function takes\r\n * three arguments; the value, the key and the collection.\r\n *\r\n * @param {S} col The collection-like object.\r\n * @param {function(this:T,?,?,S):?} f The function to call for every value.\r\n *     This function takes\r\n *     3 arguments (the value, the key or undefined if the collection has no\r\n *     notion of keys, and the collection) and the return value is irrelevant.\r\n * @param {T=} opt_obj The object to be used as the value of 'this'\r\n *     within `f`.\r\n * @template T,S\r\n * @deprecated Use a more specific method, e.g. goog.array.forEach,\r\n *     goog.object.forEach, or for-of.\r\n */\r\ngoog.structs.forEach = function(col, f, opt_obj) {\r\n  if (col.forEach && typeof col.forEach == 'function') {\r\n    col.forEach(f, opt_obj);\r\n  } else if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    goog.array.forEach(/** @type {!Array<?>} */ (col), f, opt_obj);\r\n  } else {\r\n    var keys = goog.structs.getKeys(col);\r\n    var values = goog.structs.getValues(col);\r\n    var l = values.length;\r\n    for (var i = 0; i < l; i++) {\r\n      f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for every value in the collection. When a call returns true,\r\n * adds the value to a new collection (Array is returned by default).\r\n *\r\n * @param {S} col The collection-like object.\r\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\r\n *     value. This function takes\r\n *     3 arguments (the value, the key or undefined if the collection has no\r\n *     notion of keys, and the collection) and should return a Boolean. If the\r\n *     return value is true the value is added to the result collection. If it\r\n *     is false the value is not included.\r\n * @param {T=} opt_obj The object to be used as the value of 'this'\r\n *     within `f`.\r\n * @return {!Object|!Array<?>} A new collection where the passed values are\r\n *     present. If col is a key-less collection an array is returned.  If col\r\n *     has keys and values a plain old JS object is returned.\r\n * @template T,S\r\n */\r\ngoog.structs.filter = function(col, f, opt_obj) {\r\n  if (typeof col.filter == 'function') {\r\n    return col.filter(f, opt_obj);\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.filter(/** @type {!Array<?>} */ (col), f, opt_obj);\r\n  }\r\n\r\n  var rv;\r\n  var keys = goog.structs.getKeys(col);\r\n  var values = goog.structs.getValues(col);\r\n  var l = values.length;\r\n  if (keys) {\r\n    rv = {};\r\n    for (var i = 0; i < l; i++) {\r\n      if (f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col)) {\r\n        rv[keys[i]] = values[i];\r\n      }\r\n    }\r\n  } else {\r\n    // We should not use goog.array.filter here since we want to make sure that\r\n    // the index is undefined as well as make sure that col is passed to the\r\n    // function.\r\n    rv = [];\r\n    for (var i = 0; i < l; i++) {\r\n      if (f.call(opt_obj, values[i], undefined, col)) {\r\n        rv.push(values[i]);\r\n      }\r\n    }\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Calls a function for every value in the collection and adds the result into a\r\n * new collection (defaults to creating a new Array).\r\n *\r\n * @param {S} col The collection-like object.\r\n * @param {function(this:T,?,?,S):V} f The function to call for every value.\r\n *     This function takes 3 arguments (the value, the key or undefined if the\r\n *     collection has no notion of keys, and the collection) and should return\r\n *     something. The result will be used as the value in the new collection.\r\n * @param {T=} opt_obj  The object to be used as the value of 'this'\r\n *     within `f`.\r\n * @return {!Object<V>|!Array<V>} A new collection with the new values.  If\r\n *     col is a key-less collection an array is returned.  If col has keys and\r\n *     values a plain old JS object is returned.\r\n * @template T,S,V\r\n */\r\ngoog.structs.map = function(col, f, opt_obj) {\r\n  if (typeof col.map == 'function') {\r\n    return col.map(f, opt_obj);\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.map(/** @type {!Array<?>} */ (col), f, opt_obj);\r\n  }\r\n\r\n  var rv;\r\n  var keys = goog.structs.getKeys(col);\r\n  var values = goog.structs.getValues(col);\r\n  var l = values.length;\r\n  if (keys) {\r\n    rv = {};\r\n    for (var i = 0; i < l; i++) {\r\n      rv[keys[i]] = f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col);\r\n    }\r\n  } else {\r\n    // We should not use goog.array.map here since we want to make sure that\r\n    // the index is undefined as well as make sure that col is passed to the\r\n    // function.\r\n    rv = [];\r\n    for (var i = 0; i < l; i++) {\r\n      rv[i] = f.call(/** @type {?} */ (opt_obj), values[i], undefined, col);\r\n    }\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Calls f for each value in a collection. If any call returns true this returns\r\n * true (without checking the rest). If all returns false this returns false.\r\n *\r\n * @param {S} col The collection-like object.\r\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\r\n *     value. This function takes 3 arguments (the value, the key or undefined\r\n *     if the collection has no notion of keys, and the collection) and should\r\n *     return a boolean.\r\n * @param {T=} opt_obj  The object to be used as the value of 'this'\r\n *     within `f`.\r\n * @return {boolean} True if any value passes the test.\r\n * @template T,S\r\n */\r\ngoog.structs.some = function(col, f, opt_obj) {\r\n  if (typeof col.some == 'function') {\r\n    return col.some(f, opt_obj);\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.some(/** @type {!Array<?>} */ (col), f, opt_obj);\r\n  }\r\n  var keys = goog.structs.getKeys(col);\r\n  var values = goog.structs.getValues(col);\r\n  var l = values.length;\r\n  for (var i = 0; i < l; i++) {\r\n    if (f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Calls f for each value in a collection. If all calls return true this return\r\n * true this returns true. If any returns false this returns false at this point\r\n *  and does not continue to check the remaining values.\r\n *\r\n * @param {S} col The collection-like object.\r\n * @param {function(this:T,?,?,S):boolean} f The function to call for every\r\n *     value. This function takes 3 arguments (the value, the key or\r\n *     undefined if the collection has no notion of keys, and the collection)\r\n *     and should return a boolean.\r\n * @param {T=} opt_obj  The object to be used as the value of 'this'\r\n *     within `f`.\r\n * @return {boolean} True if all key-value pairs pass the test.\r\n * @template T,S\r\n */\r\ngoog.structs.every = function(col, f, opt_obj) {\r\n  if (typeof col.every == 'function') {\r\n    return col.every(f, opt_obj);\r\n  }\r\n  if (goog.isArrayLike(col) || goog.isString(col)) {\r\n    return goog.array.every(/** @type {!Array<?>} */ (col), f, opt_obj);\r\n  }\r\n  var keys = goog.structs.getKeys(col);\r\n  var values = goog.structs.getValues(col);\r\n  var l = values.length;\r\n  for (var i = 0; i < l; i++) {\r\n    if (!f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Datastructure: Hash Map.\r\n *\r\n * @author arv@google.com (Erik Arvidsson)\r\n *\r\n * This file contains an implementation of a Map structure. It implements a lot\r\n * of the methods used in goog.structs so those functions work on hashes. This\r\n * is best suited for complex key types. For simple keys such as numbers and\r\n * strings consider using the lighter-weight utilities in goog.object.\r\n */\r\n\r\n\r\ngoog.provide('goog.structs.Map');\r\n\r\ngoog.require('goog.iter.Iterator');\r\ngoog.require('goog.iter.StopIteration');\r\n\r\n\r\n\r\n/**\r\n * Class for Hash Map datastructure.\r\n * @param {*=} opt_map Map or Object to initialize the map with.\r\n * @param {...*} var_args If 2 or more arguments are present then they\r\n *     will be used as key-value pairs.\r\n * @constructor\r\n * @template K, V\r\n * @deprecated This type is misleading: use ES6 Map instead.\r\n */\r\ngoog.structs.Map = function(opt_map, var_args) {\r\n\r\n  /**\r\n   * Underlying JS object used to implement the map.\r\n   * @private {!Object}\r\n   */\r\n  this.map_ = {};\r\n\r\n  /**\r\n   * An array of keys. This is necessary for two reasons:\r\n   *   1. Iterating the keys using for (var key in this.map_) allocates an\r\n   *      object for every key in IE which is really bad for IE6 GC perf.\r\n   *   2. Without a side data structure, we would need to escape all the keys\r\n   *      as that would be the only way we could tell during iteration if the\r\n   *      key was an internal key or a property of the object.\r\n   *\r\n   * This array can contain deleted keys so it's necessary to check the map\r\n   * as well to see if the key is still in the map (this doesn't require a\r\n   * memory allocation in IE).\r\n   * @private {!Array<string>}\r\n   */\r\n  this.keys_ = [];\r\n\r\n  /**\r\n   * The number of key value pairs in the map.\r\n   * @private {number}\r\n   */\r\n  this.count_ = 0;\r\n\r\n  /**\r\n   * Version used to detect changes while iterating.\r\n   * @private {number}\r\n   */\r\n  this.version_ = 0;\r\n\r\n  var argLength = arguments.length;\r\n\r\n  if (argLength > 1) {\r\n    if (argLength % 2) {\r\n      throw new Error('Uneven number of arguments');\r\n    }\r\n    for (var i = 0; i < argLength; i += 2) {\r\n      this.set(arguments[i], arguments[i + 1]);\r\n    }\r\n  } else if (opt_map) {\r\n    this.addAll(/** @type {!Object} */ (opt_map));\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @return {number} The number of key-value pairs in the map.\r\n */\r\ngoog.structs.Map.prototype.getCount = function() {\r\n  return this.count_;\r\n};\r\n\r\n\r\n/**\r\n * Returns the values of the map.\r\n * @return {!Array<V>} The values in the map.\r\n */\r\ngoog.structs.Map.prototype.getValues = function() {\r\n  this.cleanupKeysArray_();\r\n\r\n  var rv = [];\r\n  for (var i = 0; i < this.keys_.length; i++) {\r\n    var key = this.keys_[i];\r\n    rv.push(this.map_[key]);\r\n  }\r\n  return rv;\r\n};\r\n\r\n\r\n/**\r\n * Returns the keys of the map.\r\n * @return {!Array<string>} Array of string values.\r\n */\r\ngoog.structs.Map.prototype.getKeys = function() {\r\n  this.cleanupKeysArray_();\r\n  return /** @type {!Array<string>} */ (this.keys_.concat());\r\n};\r\n\r\n\r\n/**\r\n * Whether the map contains the given key.\r\n * @param {*} key The key to check for.\r\n * @return {boolean} Whether the map contains the key.\r\n */\r\ngoog.structs.Map.prototype.containsKey = function(key) {\r\n  return goog.structs.Map.hasKey_(this.map_, key);\r\n};\r\n\r\n\r\n/**\r\n * Whether the map contains the given value. This is O(n).\r\n * @param {V} val The value to check for.\r\n * @return {boolean} Whether the map contains the value.\r\n */\r\ngoog.structs.Map.prototype.containsValue = function(val) {\r\n  for (var i = 0; i < this.keys_.length; i++) {\r\n    var key = this.keys_[i];\r\n    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Whether this map is equal to the argument map.\r\n * @param {goog.structs.Map} otherMap The map against which to test equality.\r\n * @param {function(V, V): boolean=} opt_equalityFn Optional equality function\r\n *     to test equality of values. If not specified, this will test whether\r\n *     the values contained in each map are identical objects.\r\n * @return {boolean} Whether the maps are equal.\r\n */\r\ngoog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {\r\n  if (this === otherMap) {\r\n    return true;\r\n  }\r\n\r\n  if (this.count_ != otherMap.getCount()) {\r\n    return false;\r\n  }\r\n\r\n  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;\r\n\r\n  this.cleanupKeysArray_();\r\n  for (var key, i = 0; key = this.keys_[i]; i++) {\r\n    if (!equalityFn(this.get(key), otherMap.get(key))) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Default equality test for values.\r\n * @param {*} a The first value.\r\n * @param {*} b The second value.\r\n * @return {boolean} Whether a and b reference the same object.\r\n */\r\ngoog.structs.Map.defaultEquals = function(a, b) {\r\n  return a === b;\r\n};\r\n\r\n\r\n/**\r\n * @return {boolean} Whether the map is empty.\r\n */\r\ngoog.structs.Map.prototype.isEmpty = function() {\r\n  return this.count_ == 0;\r\n};\r\n\r\n\r\n/**\r\n * Removes all key-value pairs from the map.\r\n */\r\ngoog.structs.Map.prototype.clear = function() {\r\n  this.map_ = {};\r\n  this.keys_.length = 0;\r\n  this.count_ = 0;\r\n  this.version_ = 0;\r\n};\r\n\r\n\r\n/**\r\n * Removes a key-value pair based on the key. This is O(logN) amortized due to\r\n * updating the keys array whenever the count becomes half the size of the keys\r\n * in the keys array.\r\n * @param {*} key  The key to remove.\r\n * @return {boolean} Whether object was removed.\r\n */\r\ngoog.structs.Map.prototype.remove = function(key) {\r\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\r\n    delete this.map_[key];\r\n    this.count_--;\r\n    this.version_++;\r\n\r\n    // clean up the keys array if the threshold is hit\r\n    if (this.keys_.length > 2 * this.count_) {\r\n      this.cleanupKeysArray_();\r\n    }\r\n\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\n/**\r\n * Cleans up the temp keys array by removing entries that are no longer in the\r\n * map.\r\n * @private\r\n */\r\ngoog.structs.Map.prototype.cleanupKeysArray_ = function() {\r\n  if (this.count_ != this.keys_.length) {\r\n    // First remove keys that are no longer in the map.\r\n    var srcIndex = 0;\r\n    var destIndex = 0;\r\n    while (srcIndex < this.keys_.length) {\r\n      var key = this.keys_[srcIndex];\r\n      if (goog.structs.Map.hasKey_(this.map_, key)) {\r\n        this.keys_[destIndex++] = key;\r\n      }\r\n      srcIndex++;\r\n    }\r\n    this.keys_.length = destIndex;\r\n  }\r\n\r\n  if (this.count_ != this.keys_.length) {\r\n    // If the count still isn't correct, that means we have duplicates. This can\r\n    // happen when the same key is added and removed multiple times. Now we have\r\n    // to allocate one extra Object to remove the duplicates. This could have\r\n    // been done in the first pass, but in the common case, we can avoid\r\n    // allocating an extra object by only doing this when necessary.\r\n    var seen = {};\r\n    var srcIndex = 0;\r\n    var destIndex = 0;\r\n    while (srcIndex < this.keys_.length) {\r\n      var key = this.keys_[srcIndex];\r\n      if (!(goog.structs.Map.hasKey_(seen, key))) {\r\n        this.keys_[destIndex++] = key;\r\n        seen[key] = 1;\r\n      }\r\n      srcIndex++;\r\n    }\r\n    this.keys_.length = destIndex;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Returns the value for the given key.  If the key is not found and the default\r\n * value is not given this will return `undefined`.\r\n * @param {*} key The key to get the value for.\r\n * @param {DEFAULT=} opt_val The value to return if no item is found for the\r\n *     given key, defaults to undefined.\r\n * @return {V|DEFAULT} The value for the given key.\r\n * @template DEFAULT\r\n */\r\ngoog.structs.Map.prototype.get = function(key, opt_val) {\r\n  if (goog.structs.Map.hasKey_(this.map_, key)) {\r\n    return this.map_[key];\r\n  }\r\n  return opt_val;\r\n};\r\n\r\n\r\n/**\r\n * Adds a key-value pair to the map.\r\n * @param {*} key The key.\r\n * @param {V} value The value to add.\r\n * @return {*} Some subclasses return a value.\r\n */\r\ngoog.structs.Map.prototype.set = function(key, value) {\r\n  if (!(goog.structs.Map.hasKey_(this.map_, key))) {\r\n    this.count_++;\r\n    // TODO(johnlenz): This class lies, it claims to return an array of string\r\n    // keys, but instead returns the original object used.\r\n    this.keys_.push(/** @type {?} */ (key));\r\n    // Only change the version if we add a new key.\r\n    this.version_++;\r\n  }\r\n  this.map_[key] = value;\r\n};\r\n\r\n\r\n/**\r\n * Adds multiple key-value pairs from another goog.structs.Map or Object.\r\n * @param {?Object} map Object containing the data to add.\r\n */\r\ngoog.structs.Map.prototype.addAll = function(map) {\r\n  if (map instanceof goog.structs.Map) {\r\n    var keys = map.getKeys();\r\n    for (var i = 0; i < keys.length; i++) {\r\n      this.set(keys[i], map.get(keys[i]));\r\n    }\r\n  } else {\r\n    for (var key in map) {\r\n      this.set(key, map[key]);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls the given function on each entry in the map.\r\n * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f\r\n * @param {T=} opt_obj The value of \"this\" inside f.\r\n * @template T\r\n */\r\ngoog.structs.Map.prototype.forEach = function(f, opt_obj) {\r\n  var keys = this.getKeys();\r\n  for (var i = 0; i < keys.length; i++) {\r\n    var key = keys[i];\r\n    var value = this.get(key);\r\n    f.call(opt_obj, value, key, this);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clones a map and returns a new map.\r\n * @return {!goog.structs.Map} A new map with the same key-value pairs.\r\n */\r\ngoog.structs.Map.prototype.clone = function() {\r\n  return new goog.structs.Map(this);\r\n};\r\n\r\n\r\n/**\r\n * Returns a new map in which all the keys and values are interchanged\r\n * (keys become values and values become keys). If multiple keys map to the\r\n * same value, the chosen transposed value is implementation-dependent.\r\n *\r\n * It acts very similarly to {goog.object.transpose(Object)}.\r\n *\r\n * @return {!goog.structs.Map} The transposed map.\r\n */\r\ngoog.structs.Map.prototype.transpose = function() {\r\n  var transposed = new goog.structs.Map();\r\n  for (var i = 0; i < this.keys_.length; i++) {\r\n    var key = this.keys_[i];\r\n    var value = this.map_[key];\r\n    transposed.set(value, key);\r\n  }\r\n\r\n  return transposed;\r\n};\r\n\r\n\r\n/**\r\n * @return {!Object} Object representation of the map.\r\n */\r\ngoog.structs.Map.prototype.toObject = function() {\r\n  this.cleanupKeysArray_();\r\n  var obj = {};\r\n  for (var i = 0; i < this.keys_.length; i++) {\r\n    var key = this.keys_[i];\r\n    obj[key] = this.map_[key];\r\n  }\r\n  return obj;\r\n};\r\n\r\n\r\n/**\r\n * Returns an iterator that iterates over the keys in the map.  Removal of keys\r\n * while iterating might have undesired side effects.\r\n * @return {!goog.iter.Iterator} An iterator over the keys in the map.\r\n */\r\ngoog.structs.Map.prototype.getKeyIterator = function() {\r\n  return this.__iterator__(true);\r\n};\r\n\r\n\r\n/**\r\n * Returns an iterator that iterates over the values in the map.  Removal of\r\n * keys while iterating might have undesired side effects.\r\n * @return {!goog.iter.Iterator} An iterator over the values in the map.\r\n */\r\ngoog.structs.Map.prototype.getValueIterator = function() {\r\n  return this.__iterator__(false);\r\n};\r\n\r\n\r\n/**\r\n * Returns an iterator that iterates over the values or the keys in the map.\r\n * This throws an exception if the map was mutated since the iterator was\r\n * created.\r\n * @param {boolean=} opt_keys True to iterate over the keys. False to iterate\r\n *     over the values.  The default value is false.\r\n * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.\r\n */\r\ngoog.structs.Map.prototype.__iterator__ = function(opt_keys) {\r\n  // Clean up keys to minimize the risk of iterating over dead keys.\r\n  this.cleanupKeysArray_();\r\n\r\n  var i = 0;\r\n  var version = this.version_;\r\n  var selfObj = this;\r\n\r\n  var newIter = new goog.iter.Iterator;\r\n  newIter.next = function() {\r\n    if (version != selfObj.version_) {\r\n      throw new Error('The map has changed since the iterator was created');\r\n    }\r\n    if (i >= selfObj.keys_.length) {\r\n      throw goog.iter.StopIteration;\r\n    }\r\n    var key = selfObj.keys_[i++];\r\n    return opt_keys ? key : selfObj.map_[key];\r\n  };\r\n  return newIter;\r\n};\r\n\r\n\r\n/**\r\n * Safe way to test for hasOwnProperty.  It even allows testing for\r\n * 'hasOwnProperty'.\r\n * @param {!Object} obj The object to test for presence of the given key.\r\n * @param {*} key The key to check for.\r\n * @return {boolean} Whether the object has the key.\r\n * @private\r\n */\r\ngoog.structs.Map.hasKey_ = function(obj, key) {\r\n  return Object.prototype.hasOwnProperty.call(obj, key);\r\n};\r\n","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/**\r\n * @fileoverview Utilities for string manipulation.\r\n * @author arv@google.com (Erik Arvidsson)\r\n */\r\n\r\n\r\n/**\r\n * Namespace for string utilities\r\n */\r\ngoog.provide('goog.string');\r\ngoog.provide('goog.string.Unicode');\r\n\r\ngoog.require('goog.string.internal');\r\n\r\n\r\n/**\r\n * @define {boolean} Enables HTML escaping of lowercase letter \"e\" which helps\r\n * with detection of double-escaping as this letter is frequently used.\r\n */\r\ngoog.string.DETECT_DOUBLE_ESCAPING =\r\n    goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);\r\n\r\n\r\n/**\r\n * @define {boolean} Whether to force non-dom html unescaping.\r\n */\r\ngoog.string.FORCE_NON_DOM_HTML_UNESCAPING =\r\n    goog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);\r\n\r\n\r\n/**\r\n * Common Unicode string characters.\r\n * @enum {string}\r\n */\r\ngoog.string.Unicode = {\r\n  NBSP: '\\xa0'\r\n};\r\n\r\n\r\n/**\r\n * Fast prefix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} prefix A string to look for at the start of `str`.\r\n * @return {boolean} True if `str` begins with `prefix`.\r\n */\r\ngoog.string.startsWith = goog.string.internal.startsWith;\r\n\r\n\r\n/**\r\n * Fast suffix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} suffix A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` ends with `suffix`.\r\n */\r\ngoog.string.endsWith = goog.string.internal.endsWith;\r\n\r\n\r\n/**\r\n * Case-insensitive prefix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} prefix  A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` begins with `prefix` (ignoring\r\n *     case).\r\n */\r\ngoog.string.caseInsensitiveStartsWith =\r\n    goog.string.internal.caseInsensitiveStartsWith;\r\n\r\n\r\n/**\r\n * Case-insensitive suffix-checker.\r\n * @param {string} str The string to check.\r\n * @param {string} suffix A string to look for at the end of `str`.\r\n * @return {boolean} True if `str` ends with `suffix` (ignoring\r\n *     case).\r\n */\r\ngoog.string.caseInsensitiveEndsWith =\r\n    goog.string.internal.caseInsensitiveEndsWith;\r\n\r\n\r\n/**\r\n * Case-insensitive equality checker.\r\n * @param {string} str1 First string to check.\r\n * @param {string} str2 Second string to check.\r\n * @return {boolean} True if `str1` and `str2` are the same string,\r\n *     ignoring case.\r\n */\r\ngoog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals;\r\n\r\n\r\n/**\r\n * Does simple python-style string substitution.\r\n * subs(\"foo%s hot%s\", \"bar\", \"dog\") becomes \"foobar hotdog\".\r\n * @param {string} str The string containing the pattern.\r\n * @param {...*} var_args The items to substitute into the pattern.\r\n * @return {string} A copy of `str` in which each occurrence of\r\n *     {@code %s} has been replaced an argument from `var_args`.\r\n */\r\ngoog.string.subs = function(str, var_args) {\r\n  var splitParts = str.split('%s');\r\n  var returnString = '';\r\n\r\n  var subsArguments = Array.prototype.slice.call(arguments, 1);\r\n  while (subsArguments.length &&\r\n         // Replace up to the last split part. We are inserting in the\r\n         // positions between split parts.\r\n         splitParts.length > 1) {\r\n    returnString += splitParts.shift() + subsArguments.shift();\r\n  }\r\n\r\n  return returnString + splitParts.join('%s');  // Join unused '%s'\r\n};\r\n\r\n\r\n/**\r\n * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines\r\n * and tabs) to a single space, and strips leading and trailing whitespace.\r\n * @param {string} str Input string.\r\n * @return {string} A copy of `str` with collapsed whitespace.\r\n */\r\ngoog.string.collapseWhitespace = function(str) {\r\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\r\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\r\n  // include it in the regexp to enforce consistent cross-browser behavior.\r\n  return str.replace(/[\\s\\xa0]+/g, ' ').replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string is empty or contains only whitespaces.\r\n * @param {string} str The string to check.\r\n * @return {boolean} Whether `str` is empty or whitespace only.\r\n */\r\ngoog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace;\r\n\r\n\r\n/**\r\n * Checks if a string is empty.\r\n * @param {string} str The string to check.\r\n * @return {boolean} Whether `str` is empty.\r\n */\r\ngoog.string.isEmptyString = function(str) {\r\n  return str.length == 0;\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string is empty or contains only whitespaces.\r\n *\r\n * @param {string} str The string to check.\r\n * @return {boolean} Whether `str` is empty or whitespace only.\r\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\r\n */\r\ngoog.string.isEmpty = goog.string.isEmptyOrWhitespace;\r\n\r\n\r\n/**\r\n * Checks if a string is null, undefined, empty or contains only whitespaces.\r\n * @param {*} str The string to check.\r\n * @return {boolean} Whether `str` is null, undefined, empty, or\r\n *     whitespace only.\r\n * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))\r\n *     instead.\r\n */\r\ngoog.string.isEmptyOrWhitespaceSafe = function(str) {\r\n  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string is null, undefined, empty or contains only whitespaces.\r\n *\r\n * @param {*} str The string to check.\r\n * @return {boolean} Whether `str` is null, undefined, empty, or\r\n *     whitespace only.\r\n * @deprecated Use goog.string.isEmptyOrWhitespace instead.\r\n */\r\ngoog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;\r\n\r\n\r\n/**\r\n * Checks if a string is all breaking whitespace.\r\n * @param {string} str The string to check.\r\n * @return {boolean} Whether the string is all breaking whitespace.\r\n */\r\ngoog.string.isBreakingWhitespace = function(str) {\r\n  return !/[^\\t\\n\\r ]/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string contains all letters.\r\n * @param {string} str string to check.\r\n * @return {boolean} True if `str` consists entirely of letters.\r\n */\r\ngoog.string.isAlpha = function(str) {\r\n  return !/[^a-zA-Z]/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string contains only numbers.\r\n * @param {*} str string to check. If not a string, it will be\r\n *     casted to one.\r\n * @return {boolean} True if `str` is numeric.\r\n */\r\ngoog.string.isNumeric = function(str) {\r\n  return !/[^0-9]/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Checks if a string contains only numbers or letters.\r\n * @param {string} str string to check.\r\n * @return {boolean} True if `str` is alphanumeric.\r\n */\r\ngoog.string.isAlphaNumeric = function(str) {\r\n  return !/[^a-zA-Z0-9]/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Checks if a character is a space character.\r\n * @param {string} ch Character to check.\r\n * @return {boolean} True if `ch` is a space.\r\n */\r\ngoog.string.isSpace = function(ch) {\r\n  return ch == ' ';\r\n};\r\n\r\n\r\n/**\r\n * Checks if a character is a valid unicode character.\r\n * @param {string} ch Character to check.\r\n * @return {boolean} True if `ch` is a valid unicode character.\r\n */\r\ngoog.string.isUnicodeChar = function(ch) {\r\n  return ch.length == 1 && ch >= ' ' && ch <= '~' ||\r\n      ch >= '\\u0080' && ch <= '\\uFFFD';\r\n};\r\n\r\n\r\n/**\r\n * Takes a string and replaces newlines with a space. Multiple lines are\r\n * replaced with a single space.\r\n * @param {string} str The string from which to strip newlines.\r\n * @return {string} A copy of `str` stripped of newlines.\r\n */\r\ngoog.string.stripNewlines = function(str) {\r\n  return str.replace(/(\\r\\n|\\r|\\n)+/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Replaces Windows and Mac new lines with unix style: \\r or \\r\\n with \\n.\r\n * @param {string} str The string to in which to canonicalize newlines.\r\n * @return {string} `str` A copy of {@code} with canonicalized newlines.\r\n */\r\ngoog.string.canonicalizeNewlines = function(str) {\r\n  return str.replace(/(\\r\\n|\\r|\\n)/g, '\\n');\r\n};\r\n\r\n\r\n/**\r\n * Normalizes whitespace in a string, replacing all whitespace chars with\r\n * a space.\r\n * @param {string} str The string in which to normalize whitespace.\r\n * @return {string} A copy of `str` with all whitespace normalized.\r\n */\r\ngoog.string.normalizeWhitespace = function(str) {\r\n  return str.replace(/\\xa0|\\s/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Normalizes spaces in a string, replacing all consecutive spaces and tabs\r\n * with a single space. Replaces non-breaking space with a space.\r\n * @param {string} str The string in which to normalize spaces.\r\n * @return {string} A copy of `str` with all consecutive spaces and tabs\r\n *    replaced with a single space.\r\n */\r\ngoog.string.normalizeSpaces = function(str) {\r\n  return str.replace(/\\xa0|[ \\t]+/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Removes the breaking spaces from the left and right of the string and\r\n * collapses the sequences of breaking spaces in the middle into single spaces.\r\n * The original and the result strings render the same way in HTML.\r\n * @param {string} str A string in which to collapse spaces.\r\n * @return {string} Copy of the string with normalized breaking spaces.\r\n */\r\ngoog.string.collapseBreakingSpaces = function(str) {\r\n  return str.replace(/[\\t\\r\\n ]+/g, ' ')\r\n      .replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\r\n};\r\n\r\n\r\n/**\r\n * Trims white spaces to the left and right of a string.\r\n * @param {string} str The string to trim.\r\n * @return {string} A trimmed copy of `str`.\r\n */\r\ngoog.string.trim = goog.string.internal.trim;\r\n\r\n\r\n/**\r\n * Trims whitespaces at the left end of a string.\r\n * @param {string} str The string to left trim.\r\n * @return {string} A trimmed copy of `str`.\r\n */\r\ngoog.string.trimLeft = function(str) {\r\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\r\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\r\n  // include it in the regexp to enforce consistent cross-browser behavior.\r\n  return str.replace(/^[\\s\\xa0]+/, '');\r\n};\r\n\r\n\r\n/**\r\n * Trims whitespaces at the right end of a string.\r\n * @param {string} str The string to right trim.\r\n * @return {string} A trimmed copy of `str`.\r\n */\r\ngoog.string.trimRight = function(str) {\r\n  // Since IE doesn't include non-breaking-space (0xa0) in their \\s character\r\n  // class (as required by section 7.2 of the ECMAScript spec), we explicitly\r\n  // include it in the regexp to enforce consistent cross-browser behavior.\r\n  return str.replace(/[\\s\\xa0]+$/, '');\r\n};\r\n\r\n\r\n/**\r\n * A string comparator that ignores case.\r\n * -1 = str1 less than str2\r\n *  0 = str1 equals str2\r\n *  1 = str1 greater than str2\r\n *\r\n * @param {string} str1 The string to compare.\r\n * @param {string} str2 The string to compare `str1` to.\r\n * @return {number} The comparator result, as described above.\r\n */\r\ngoog.string.caseInsensitiveCompare =\r\n    goog.string.internal.caseInsensitiveCompare;\r\n\r\n\r\n/**\r\n * Compares two strings interpreting their numeric substrings as numbers.\r\n *\r\n * @param {string} str1 First string.\r\n * @param {string} str2 Second string.\r\n * @param {!RegExp} tokenizerRegExp Splits a string into substrings of\r\n *     non-negative integers, non-numeric characters and optionally fractional\r\n *     numbers starting with a decimal point.\r\n * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if\r\n *     str1 > str2.\r\n * @private\r\n */\r\ngoog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {\r\n  if (str1 == str2) {\r\n    return 0;\r\n  }\r\n  if (!str1) {\r\n    return -1;\r\n  }\r\n  if (!str2) {\r\n    return 1;\r\n  }\r\n\r\n  // Using match to split the entire string ahead of time turns out to be faster\r\n  // for most inputs than using RegExp.exec or iterating over each character.\r\n  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);\r\n  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);\r\n\r\n  var count = Math.min(tokens1.length, tokens2.length);\r\n\r\n  for (var i = 0; i < count; i++) {\r\n    var a = tokens1[i];\r\n    var b = tokens2[i];\r\n\r\n    // Compare pairs of tokens, returning if one token sorts before the other.\r\n    if (a != b) {\r\n      // Only if both tokens are integers is a special comparison required.\r\n      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').\r\n      var num1 = parseInt(a, 10);\r\n      if (!isNaN(num1)) {\r\n        var num2 = parseInt(b, 10);\r\n        if (!isNaN(num2) && num1 - num2) {\r\n          return num1 - num2;\r\n        }\r\n      }\r\n      return a < b ? -1 : 1;\r\n    }\r\n  }\r\n\r\n  // If one string is a substring of the other, the shorter string sorts first.\r\n  if (tokens1.length != tokens2.length) {\r\n    return tokens1.length - tokens2.length;\r\n  }\r\n\r\n  // The two strings must be equivalent except for case (perfect equality is\r\n  // tested at the head of the function.) Revert to default ASCII string\r\n  // comparison to stabilize the sort.\r\n  return str1 < str2 ? -1 : 1;\r\n};\r\n\r\n\r\n/**\r\n * String comparison function that handles non-negative integer numbers in a\r\n * way humans might expect. Using this function, the string 'File 2.jpg' sorts\r\n * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison\r\n * is mostly case-insensitive, though strings that are identical except for case\r\n * are sorted with the upper-case strings before lower-case.\r\n *\r\n * This comparison function is up to 50x slower than either the default or the\r\n * case-insensitive compare. It should not be used in time-critical code, but\r\n * should be fast enough to sort several hundred short strings (like filenames)\r\n * with a reasonable delay.\r\n *\r\n * @param {string} str1 The string to compare in a numerically sensitive way.\r\n * @param {string} str2 The string to compare `str1` to.\r\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\r\n *     0 if str1 > str2.\r\n */\r\ngoog.string.intAwareCompare = function(str1, str2) {\r\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\D+/g);\r\n};\r\n\r\n\r\n/**\r\n * String comparison function that handles non-negative integer and fractional\r\n * numbers in a way humans might expect. Using this function, the string\r\n * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent\r\n * to {@link goog.string.intAwareCompare} apart from the way how it interprets\r\n * dots.\r\n *\r\n * @param {string} str1 The string to compare in a numerically sensitive way.\r\n * @param {string} str2 The string to compare `str1` to.\r\n * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than\r\n *     0 if str1 > str2.\r\n */\r\ngoog.string.floatAwareCompare = function(str1, str2) {\r\n  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\.\\d+|\\D+/g);\r\n};\r\n\r\n\r\n/**\r\n * Alias for {@link goog.string.floatAwareCompare}.\r\n *\r\n * @param {string} str1\r\n * @param {string} str2\r\n * @return {number}\r\n */\r\ngoog.string.numerateCompare = goog.string.floatAwareCompare;\r\n\r\n\r\n/**\r\n * URL-encodes a string\r\n * @param {*} str The string to url-encode.\r\n * @return {string} An encoded copy of `str` that is safe for urls.\r\n *     Note that '#', ':', and other characters used to delimit portions\r\n *     of URLs *will* be encoded.\r\n */\r\ngoog.string.urlEncode = function(str) {\r\n  return encodeURIComponent(String(str));\r\n};\r\n\r\n\r\n/**\r\n * URL-decodes the string. We need to specially handle '+'s because\r\n * the javascript library doesn't convert them to spaces.\r\n * @param {string} str The string to url decode.\r\n * @return {string} The decoded `str`.\r\n */\r\ngoog.string.urlDecode = function(str) {\r\n  return decodeURIComponent(str.replace(/\\+/g, ' '));\r\n};\r\n\r\n\r\n/**\r\n * Converts \\n to <br>s or <br />s.\r\n * @param {string} str The string in which to convert newlines.\r\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\r\n * @return {string} A copy of `str` with converted newlines.\r\n */\r\ngoog.string.newLineToBr = goog.string.internal.newLineToBr;\r\n\r\n\r\n/**\r\n * Escapes double quote '\"' and single quote '\\'' characters in addition to\r\n * '&', '<', and '>' so that a string can be included in an HTML tag attribute\r\n * value within double or single quotes.\r\n *\r\n * It should be noted that > doesn't need to be escaped for the HTML or XML to\r\n * be valid, but it has been decided to escape it for consistency with other\r\n * implementations.\r\n *\r\n * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the\r\n * lowercase letter \"e\".\r\n *\r\n * NOTE(user):\r\n * HtmlEscape is often called during the generation of large blocks of HTML.\r\n * Using statics for the regular expressions and strings is an optimization\r\n * that can more than half the amount of time IE spends in this function for\r\n * large apps, since strings and regexes both contribute to GC allocations.\r\n *\r\n * Testing for the presence of a character before escaping increases the number\r\n * of function calls, but actually provides a speed increase for the average\r\n * case -- since the average case often doesn't require the escaping of all 4\r\n * characters and indexOf() is much cheaper than replace().\r\n * The worst case does suffer slightly from the additional calls, therefore the\r\n * opt_isLikelyToContainHtmlChars option has been included for situations\r\n * where all 4 HTML entities are very likely to be present and need escaping.\r\n *\r\n * Some benchmarks (times tended to fluctuate +-0.05ms):\r\n *                                     FireFox                     IE6\r\n * (no chars / average (mix of cases) / all 4 chars)\r\n * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80\r\n * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84\r\n * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85\r\n *\r\n * An additional advantage of checking if replace actually needs to be called\r\n * is a reduction in the number of object allocations, so as the size of the\r\n * application grows the difference between the various methods would increase.\r\n *\r\n * @param {string} str string to be escaped.\r\n * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see\r\n *     if the character needs replacing - use this option if you expect each of\r\n *     the characters to appear often. Leave false if you expect few html\r\n *     characters to occur in your strings, such as if you are escaping HTML.\r\n * @return {string} An escaped copy of `str`.\r\n */\r\ngoog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {\r\n  str = goog.string.internal.htmlEscape(str, opt_isLikelyToContainHtmlChars);\r\n  if (goog.string.DETECT_DOUBLE_ESCAPING) {\r\n    str = str.replace(goog.string.E_RE_, '&#101;');\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Regular expression that matches a lowercase letter \"e\", for use in escaping.\r\n * @const {!RegExp}\r\n * @private\r\n */\r\ngoog.string.E_RE_ = /e/g;\r\n\r\n\r\n/**\r\n * Unescapes an HTML string.\r\n *\r\n * @param {string} str The string to unescape.\r\n * @return {string} An unescaped copy of `str`.\r\n */\r\ngoog.string.unescapeEntities = function(str) {\r\n  if (goog.string.contains(str, '&')) {\r\n    // We are careful not to use a DOM if we do not have one or we explicitly\r\n    // requested non-DOM html unescaping.\r\n    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&\r\n        'document' in goog.global) {\r\n      return goog.string.unescapeEntitiesUsingDom_(str);\r\n    } else {\r\n      // Fall back on pure XML entities\r\n      return goog.string.unescapePureXmlEntities_(str);\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Unescapes a HTML string using the provided document.\r\n *\r\n * @param {string} str The string to unescape.\r\n * @param {!Document} document A document to use in escaping the string.\r\n * @return {string} An unescaped copy of `str`.\r\n */\r\ngoog.string.unescapeEntitiesWithDocument = function(str, document) {\r\n  if (goog.string.contains(str, '&')) {\r\n    return goog.string.unescapeEntitiesUsingDom_(str, document);\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric\r\n * entities. This function is XSS-safe and whitespace-preserving.\r\n * @private\r\n * @param {string} str The string to unescape.\r\n * @param {Document=} opt_document An optional document to use for creating\r\n *     elements. If this is not specified then the default window.document\r\n *     will be used.\r\n * @return {string} The unescaped `str` string.\r\n */\r\ngoog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {\r\n  /** @type {!Object<string, string>} */\r\n  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"'};\r\n  /** @type {!Element} */\r\n  var div;\r\n  if (opt_document) {\r\n    div = opt_document.createElement('div');\r\n  } else {\r\n    div = goog.global.document.createElement('div');\r\n  }\r\n  // Match as many valid entity characters as possible. If the actual entity\r\n  // happens to be shorter, it will still work as innerHTML will return the\r\n  // trailing characters unchanged. Since the entity characters do not include\r\n  // open angle bracket, there is no chance of XSS from the innerHTML use.\r\n  // Since no whitespace is passed to innerHTML, whitespace is preserved.\r\n  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {\r\n    // Check for cached entity.\r\n    var value = seen[s];\r\n    if (value) {\r\n      return value;\r\n    }\r\n    // Check for numeric entity.\r\n    if (entity.charAt(0) == '#') {\r\n      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.\r\n      var n = Number('0' + entity.substr(1));\r\n      if (!isNaN(n)) {\r\n        value = String.fromCharCode(n);\r\n      }\r\n    }\r\n    // Fall back to innerHTML otherwise.\r\n    if (!value) {\r\n      // Append a non-entity character to avoid a bug in Webkit that parses\r\n      // an invalid entity at the end of innerHTML text as the empty string.\r\n      div.innerHTML = s + ' ';\r\n      // Then remove the trailing character from the result.\r\n      value = div.firstChild.nodeValue.slice(0, -1);\r\n    }\r\n    // Cache and return.\r\n    return seen[s] = value;\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Unescapes XML entities.\r\n * @private\r\n * @param {string} str The string to unescape.\r\n * @return {string} An unescaped copy of `str`.\r\n */\r\ngoog.string.unescapePureXmlEntities_ = function(str) {\r\n  return str.replace(/&([^;]+);/g, function(s, entity) {\r\n    switch (entity) {\r\n      case 'amp':\r\n        return '&';\r\n      case 'lt':\r\n        return '<';\r\n      case 'gt':\r\n        return '>';\r\n      case 'quot':\r\n        return '\"';\r\n      default:\r\n        if (entity.charAt(0) == '#') {\r\n          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.\r\n          var n = Number('0' + entity.substr(1));\r\n          if (!isNaN(n)) {\r\n            return String.fromCharCode(n);\r\n          }\r\n        }\r\n        // For invalid entities we just return the entity\r\n        return s;\r\n    }\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Regular expression that matches an HTML entity.\r\n * See also HTML5: Tokenization / Tokenizing character references.\r\n * @private\r\n * @type {!RegExp}\r\n */\r\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\r\n\r\n\r\n/**\r\n * Do escaping of whitespace to preserve spatial formatting. We use character\r\n * entity #160 to make it safer for xml.\r\n * @param {string} str The string in which to escape whitespace.\r\n * @param {boolean=} opt_xml Whether to use XML compatible tags.\r\n * @return {string} An escaped copy of `str`.\r\n */\r\ngoog.string.whitespaceEscape = function(str, opt_xml) {\r\n  // This doesn't use goog.string.preserveSpaces for backwards compatibility.\r\n  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);\r\n};\r\n\r\n\r\n/**\r\n * Preserve spaces that would be otherwise collapsed in HTML by replacing them\r\n * with non-breaking space Unicode characters.\r\n * @param {string} str The string in which to preserve whitespace.\r\n * @return {string} A copy of `str` with preserved whitespace.\r\n */\r\ngoog.string.preserveSpaces = function(str) {\r\n  return str.replace(/(^|[\\n ]) /g, '$1' + goog.string.Unicode.NBSP);\r\n};\r\n\r\n\r\n/**\r\n * Strip quote characters around a string.  The second argument is a string of\r\n * characters to treat as quotes.  This can be a single character or a string of\r\n * multiple character and in that case each of those are treated as possible\r\n * quote characters. For example:\r\n *\r\n * <pre>\r\n * goog.string.stripQuotes('\"abc\"', '\"`') --> 'abc'\r\n * goog.string.stripQuotes('`abc`', '\"`') --> 'abc'\r\n * </pre>\r\n *\r\n * @param {string} str The string to strip.\r\n * @param {string} quoteChars The quote characters to strip.\r\n * @return {string} A copy of `str` without the quotes.\r\n */\r\ngoog.string.stripQuotes = function(str, quoteChars) {\r\n  var length = quoteChars.length;\r\n  for (var i = 0; i < length; i++) {\r\n    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);\r\n    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {\r\n      return str.substring(1, str.length - 1);\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Truncates a string to a certain length and adds '...' if necessary.  The\r\n * length also accounts for the ellipsis, so a maximum length of 10 and a string\r\n * 'Hello World!' produces 'Hello W...'.\r\n * @param {string} str The string to truncate.\r\n * @param {number} chars Max number of characters.\r\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\r\n *     characters from being cut off in the middle.\r\n * @return {string} The truncated `str` string.\r\n */\r\ngoog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {\r\n  if (opt_protectEscapedCharacters) {\r\n    str = goog.string.unescapeEntities(str);\r\n  }\r\n\r\n  if (str.length > chars) {\r\n    str = str.substring(0, chars - 3) + '...';\r\n  }\r\n\r\n  if (opt_protectEscapedCharacters) {\r\n    str = goog.string.htmlEscape(str);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Truncate a string in the middle, adding \"...\" if necessary,\r\n * and favoring the beginning of the string.\r\n * @param {string} str The string to truncate the middle of.\r\n * @param {number} chars Max number of characters.\r\n * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped\r\n *     characters from being cutoff in the middle.\r\n * @param {number=} opt_trailingChars Optional number of trailing characters to\r\n *     leave at the end of the string, instead of truncating as close to the\r\n *     middle as possible.\r\n * @return {string} A truncated copy of `str`.\r\n */\r\ngoog.string.truncateMiddle = function(\r\n    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {\r\n  if (opt_protectEscapedCharacters) {\r\n    str = goog.string.unescapeEntities(str);\r\n  }\r\n\r\n  if (opt_trailingChars && str.length > chars) {\r\n    if (opt_trailingChars > chars) {\r\n      opt_trailingChars = chars;\r\n    }\r\n    var endPoint = str.length - opt_trailingChars;\r\n    var startPoint = chars - opt_trailingChars;\r\n    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);\r\n  } else if (str.length > chars) {\r\n    // Favor the beginning of the string:\r\n    var half = Math.floor(chars / 2);\r\n    var endPos = str.length - half;\r\n    half += chars % 2;\r\n    str = str.substring(0, half) + '...' + str.substring(endPos);\r\n  }\r\n\r\n  if (opt_protectEscapedCharacters) {\r\n    str = goog.string.htmlEscape(str);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n\r\n/**\r\n * Special chars that need to be escaped for goog.string.quote.\r\n * @private {!Object<string, string>}\r\n */\r\ngoog.string.specialEscapeChars_ = {\r\n  '\\0': '\\\\0',\r\n  '\\b': '\\\\b',\r\n  '\\f': '\\\\f',\r\n  '\\n': '\\\\n',\r\n  '\\r': '\\\\r',\r\n  '\\t': '\\\\t',\r\n  '\\x0B': '\\\\x0B',  // '\\v' is not supported in JScript\r\n  '\"': '\\\\\"',\r\n  '\\\\': '\\\\\\\\',\r\n  // To support the use case of embedding quoted strings inside of script\r\n  // tags, we have to make sure HTML comments and opening/closing script tags do\r\n  // not appear in the resulting string. The specific strings that must be\r\n  // escaped are documented at:\r\n  // http://www.w3.org/TR/html51/semantics.html#restrictions-for-contents-of-script-elements\r\n  '<': '\\x3c'\r\n};\r\n\r\n\r\n/**\r\n * Character mappings used internally for goog.string.escapeChar.\r\n * @private {!Object<string, string>}\r\n */\r\ngoog.string.jsEscapeCache_ = {\r\n  '\\'': '\\\\\\''\r\n};\r\n\r\n\r\n/**\r\n * Encloses a string in double quotes and escapes characters so that the\r\n * string is a valid JS string. The resulting string is safe to embed in\r\n * `<script>` tags as \"<\" is escaped.\r\n * @param {string} s The string to quote.\r\n * @return {string} A copy of `s` surrounded by double quotes.\r\n */\r\ngoog.string.quote = function(s) {\r\n  s = String(s);\r\n  var sb = ['\"'];\r\n  for (var i = 0; i < s.length; i++) {\r\n    var ch = s.charAt(i);\r\n    var cc = ch.charCodeAt(0);\r\n    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||\r\n        ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));\r\n  }\r\n  sb.push('\"');\r\n  return sb.join('');\r\n};\r\n\r\n\r\n/**\r\n * Takes a string and returns the escaped string for that input string.\r\n * @param {string} str The string to escape.\r\n * @return {string} An escaped string representing `str`.\r\n */\r\ngoog.string.escapeString = function(str) {\r\n  var sb = [];\r\n  for (var i = 0; i < str.length; i++) {\r\n    sb[i] = goog.string.escapeChar(str.charAt(i));\r\n  }\r\n  return sb.join('');\r\n};\r\n\r\n\r\n/**\r\n * Takes a character and returns the escaped string for that character. For\r\n * example escapeChar(String.fromCharCode(15)) -> \"\\\\x0E\".\r\n * @param {string} c The character to escape.\r\n * @return {string} An escaped string representing `c`.\r\n */\r\ngoog.string.escapeChar = function(c) {\r\n  if (c in goog.string.jsEscapeCache_) {\r\n    return goog.string.jsEscapeCache_[c];\r\n  }\r\n\r\n  if (c in goog.string.specialEscapeChars_) {\r\n    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];\r\n  }\r\n\r\n  var rv = c;\r\n  var cc = c.charCodeAt(0);\r\n  if (cc > 31 && cc < 127) {\r\n    rv = c;\r\n  } else {\r\n    // tab is 9 but handled above\r\n    if (cc < 256) {\r\n      rv = '\\\\x';\r\n      if (cc < 16 || cc > 256) {\r\n        rv += '0';\r\n      }\r\n    } else {\r\n      rv = '\\\\u';\r\n      if (cc < 4096) {  // \\u1000\r\n        rv += '0';\r\n      }\r\n    }\r\n    rv += cc.toString(16).toUpperCase();\r\n  }\r\n\r\n  return goog.string.jsEscapeCache_[c] = rv;\r\n};\r\n\r\n\r\n/**\r\n * Determines whether a string contains a substring.\r\n * @param {string} str The string to search.\r\n * @param {string} subString The substring to search for.\r\n * @return {boolean} Whether `str` contains `subString`.\r\n */\r\ngoog.string.contains = goog.string.internal.contains;\r\n\r\n\r\n/**\r\n * Determines whether a string contains a substring, ignoring case.\r\n * @param {string} str The string to search.\r\n * @param {string} subString The substring to search for.\r\n * @return {boolean} Whether `str` contains `subString`.\r\n */\r\ngoog.string.caseInsensitiveContains =\r\n    goog.string.internal.caseInsensitiveContains;\r\n\r\n\r\n/**\r\n * Returns the non-overlapping occurrences of ss in s.\r\n * If either s or ss evalutes to false, then returns zero.\r\n * @param {string} s The string to look in.\r\n * @param {string} ss The string to look for.\r\n * @return {number} Number of occurrences of ss in s.\r\n */\r\ngoog.string.countOf = function(s, ss) {\r\n  return s && ss ? s.split(ss).length - 1 : 0;\r\n};\r\n\r\n\r\n/**\r\n * Removes a substring of a specified length at a specific\r\n * index in a string.\r\n * @param {string} s The base string from which to remove.\r\n * @param {number} index The index at which to remove the substring.\r\n * @param {number} stringLength The length of the substring to remove.\r\n * @return {string} A copy of `s` with the substring removed or the full\r\n *     string if nothing is removed or the input is invalid.\r\n */\r\ngoog.string.removeAt = function(s, index, stringLength) {\r\n  var resultStr = s;\r\n  // If the index is greater or equal to 0 then remove substring\r\n  if (index >= 0 && index < s.length && stringLength > 0) {\r\n    resultStr = s.substr(0, index) +\r\n        s.substr(index + stringLength, s.length - index - stringLength);\r\n  }\r\n  return resultStr;\r\n};\r\n\r\n\r\n/**\r\n * Removes the first occurrence of a substring from a string.\r\n * @param {string} str The base string from which to remove.\r\n * @param {string} substr The string to remove.\r\n * @return {string} A copy of `str` with `substr` removed or the\r\n *     full string if nothing is removed.\r\n */\r\ngoog.string.remove = function(str, substr) {\r\n  return str.replace(substr, '');\r\n};\r\n\r\n\r\n/**\r\n *  Removes all occurrences of a substring from a string.\r\n *  @param {string} s The base string from which to remove.\r\n *  @param {string} ss The string to remove.\r\n *  @return {string} A copy of `s` with `ss` removed or the full\r\n *      string if nothing is removed.\r\n */\r\ngoog.string.removeAll = function(s, ss) {\r\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\r\n  return s.replace(re, '');\r\n};\r\n\r\n\r\n/**\r\n *  Replaces all occurrences of a substring of a string with a new substring.\r\n *  @param {string} s The base string from which to remove.\r\n *  @param {string} ss The string to replace.\r\n *  @param {string} replacement The replacement string.\r\n *  @return {string} A copy of `s` with `ss` replaced by\r\n *      `replacement` or the original string if nothing is replaced.\r\n */\r\ngoog.string.replaceAll = function(s, ss, replacement) {\r\n  var re = new RegExp(goog.string.regExpEscape(ss), 'g');\r\n  return s.replace(re, replacement.replace(/\\$/g, '$$$$'));\r\n};\r\n\r\n\r\n/**\r\n * Escapes characters in the string that are not safe to use in a RegExp.\r\n * @param {*} s The string to escape. If not a string, it will be casted\r\n *     to one.\r\n * @return {string} A RegExp safe, escaped copy of `s`.\r\n */\r\ngoog.string.regExpEscape = function(s) {\r\n  return String(s)\r\n      .replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\r\n      .replace(/\\x08/g, '\\\\x08');\r\n};\r\n\r\n\r\n/**\r\n * Repeats a string n times.\r\n * @param {string} string The string to repeat.\r\n * @param {number} length The number of times to repeat.\r\n * @return {string} A string containing `length` repetitions of\r\n *     `string`.\r\n */\r\ngoog.string.repeat = (String.prototype.repeat) ? function(string, length) {\r\n  // The native method is over 100 times faster than the alternative.\r\n  return string.repeat(length);\r\n} : function(string, length) {\r\n  return new Array(length + 1).join(string);\r\n};\r\n\r\n\r\n/**\r\n * Pads number to given length and optionally rounds it to a given precision.\r\n * For example:\r\n * <pre>padNumber(1.25, 2, 3) -> '01.250'\r\n * padNumber(1.25, 2) -> '01.25'\r\n * padNumber(1.25, 2, 1) -> '01.3'\r\n * padNumber(1.25, 0) -> '1.25'</pre>\r\n *\r\n * @param {number} num The number to pad.\r\n * @param {number} length The desired length.\r\n * @param {number=} opt_precision The desired precision.\r\n * @return {string} `num` as a string with the given options.\r\n */\r\ngoog.string.padNumber = function(num, length, opt_precision) {\r\n  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);\r\n  var index = s.indexOf('.');\r\n  if (index == -1) {\r\n    index = s.length;\r\n  }\r\n  return goog.string.repeat('0', Math.max(0, length - index)) + s;\r\n};\r\n\r\n\r\n/**\r\n * Returns a string representation of the given object, with\r\n * null and undefined being returned as the empty string.\r\n *\r\n * @param {*} obj The object to convert.\r\n * @return {string} A string representation of the `obj`.\r\n */\r\ngoog.string.makeSafe = function(obj) {\r\n  return obj == null ? '' : String(obj);\r\n};\r\n\r\n\r\n/**\r\n * Concatenates string expressions. This is useful\r\n * since some browsers are very inefficient when it comes to using plus to\r\n * concat strings. Be careful when using null and undefined here since\r\n * these will not be included in the result. If you need to represent these\r\n * be sure to cast the argument to a String first.\r\n * For example:\r\n * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'\r\n * buildString(null, undefined) -> ''\r\n * </pre>\r\n * @param {...*} var_args A list of strings to concatenate. If not a string,\r\n *     it will be casted to one.\r\n * @return {string} The concatenation of `var_args`.\r\n */\r\ngoog.string.buildString = function(var_args) {\r\n  return Array.prototype.join.call(arguments, '');\r\n};\r\n\r\n\r\n/**\r\n * Returns a string with at least 64-bits of randomness.\r\n *\r\n * Doesn't trust JavaScript's random function entirely. Uses a combination of\r\n * random and current timestamp, and then encodes the string in base-36 to\r\n * make it shorter.\r\n *\r\n * @return {string} A random string, e.g. sn1s7vb4gcic.\r\n */\r\ngoog.string.getRandomString = function() {\r\n  var x = 2147483648;\r\n  return Math.floor(Math.random() * x).toString(36) +\r\n      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);\r\n};\r\n\r\n\r\n/**\r\n * Compares two version numbers.\r\n *\r\n * @param {string|number} version1 Version of first item.\r\n * @param {string|number} version2 Version of second item.\r\n *\r\n * @return {number}  1 if `version1` is higher.\r\n *                   0 if arguments are equal.\r\n *                  -1 if `version2` is higher.\r\n */\r\ngoog.string.compareVersions = goog.string.internal.compareVersions;\r\n\r\n\r\n/**\r\n * String hash function similar to java.lang.String.hashCode().\r\n * The hash code for a string is computed as\r\n * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\r\n * where s[i] is the ith character of the string and n is the length of\r\n * the string. We mod the result to make it between 0 (inclusive) and 2^32\r\n * (exclusive).\r\n * @param {string} str A string.\r\n * @return {number} Hash value for `str`, between 0 (inclusive) and 2^32\r\n *  (exclusive). The empty string returns 0.\r\n */\r\ngoog.string.hashCode = function(str) {\r\n  var result = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Normalize to 4 byte range, 0 ... 2^32.\r\n    result = (31 * result + str.charCodeAt(i)) >>> 0;\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * The most recent unique ID. |0 is equivalent to Math.floor in this case.\r\n * @type {number}\r\n * @private\r\n */\r\ngoog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;\r\n\r\n\r\n/**\r\n * Generates and returns a string which is unique in the current document.\r\n * This is useful, for example, to create unique IDs for DOM elements.\r\n * @return {string} A unique id.\r\n */\r\ngoog.string.createUniqueString = function() {\r\n  return 'goog_' + goog.string.uniqueStringCounter_++;\r\n};\r\n\r\n\r\n/**\r\n * Converts the supplied string to a number, which may be Infinity or NaN.\r\n * This function strips whitespace: (toNumber(' 123') === 123)\r\n * This function accepts scientific notation: (toNumber('1e1') === 10)\r\n *\r\n * This is better than JavaScript's built-in conversions because, sadly:\r\n *     (Number(' ') === 0) and (parseFloat('123a') === 123)\r\n *\r\n * @param {string} str The string to convert.\r\n * @return {number} The number the supplied string represents, or NaN.\r\n */\r\ngoog.string.toNumber = function(str) {\r\n  var num = Number(str);\r\n  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {\r\n    return NaN;\r\n  }\r\n  return num;\r\n};\r\n\r\n\r\n/**\r\n * Returns whether the given string is lower camel case (e.g. \"isFooBar\").\r\n *\r\n * Note that this assumes the string is entirely letters.\r\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\r\n *\r\n * @param {string} str String to test.\r\n * @return {boolean} Whether the string is lower camel case.\r\n */\r\ngoog.string.isLowerCamelCase = function(str) {\r\n  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Returns whether the given string is upper camel case (e.g. \"FooBarBaz\").\r\n *\r\n * Note that this assumes the string is entirely letters.\r\n * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms\r\n *\r\n * @param {string} str String to test.\r\n * @return {boolean} Whether the string is upper camel case.\r\n */\r\ngoog.string.isUpperCamelCase = function(str) {\r\n  return /^([A-Z][a-z]*)+$/.test(str);\r\n};\r\n\r\n\r\n/**\r\n * Converts a string from selector-case to camelCase (e.g. from\r\n * \"multi-part-string\" to \"multiPartString\"), useful for converting\r\n * CSS selectors and HTML dataset keys to their equivalent JS properties.\r\n * @param {string} str The string in selector-case form.\r\n * @return {string} The string in camelCase form.\r\n */\r\ngoog.string.toCamelCase = function(str) {\r\n  return String(str).replace(/\\-([a-z])/g, function(all, match) {\r\n    return match.toUpperCase();\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Converts a string from camelCase to selector-case (e.g. from\r\n * \"multiPartString\" to \"multi-part-string\"), useful for converting JS\r\n * style and dataset properties to equivalent CSS selectors and HTML keys.\r\n * @param {string} str The string in camelCase form.\r\n *